Disassembly Listing for msd_basic
Generated From:
C:/Users/jsiek/Documents/Spring_2017/ENGR498/capture/SeniorDesign/msd_basic/firmware/msd_basic.X/dist/pic32mz_ef_curiosity/debug/msd_basic.X.debug.elf
Mar 28, 2017 4:56:12 PM

---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/timer.c  --
1:                   #include "timer.h"
2:                   
3:                   void initTimer3(){ //5msec timer
4:                       T3CONbits.TON = 0;
9D014E98  3C02BF84   LUI V0, -16508
9D014E9C  94430400   LHU V1, 1024(V0)
9D014EA0  7C037BC4   INS V1, ZERO, 15, 1
9D014EA4  A4430400   SH V1, 1024(V0)
5:                       TMR3 = 0x0000;
9D014EA8  3C03BF84   LUI V1, -16508
9D014EAC  AC600410   SW ZERO, 1040(V1)
6:                       PR3 = 62499;
9D014EB0  3404F423   ORI A0, ZERO, -3037
9D014EB4  3C03BF84   LUI V1, -16508
9D014EB8  AC640420   SW A0, 1056(V1)
7:                       T3CONbits.TCKPS = 0b011; //divide 100Mhz -> 12.5MHz
9D014EBC  94430400   LHU V1, 1024(V0)
9D014EC0  24040003   ADDIU A0, ZERO, 3
9D014EC4  7C833104   INS V1, A0, 4, 3
9D014EC8  A4430400   SH V1, 1024(V0)
8:                       IFS0bits.T3IF = 0;
9D014ECC  3C02BF81   LUI V0, -16511
9D014ED0  8C430040   LW V1, 64(V0)
9D014ED4  7C037384   INS V1, ZERO, 14, 1
9D014ED8  AC430040   SW V1, 64(V0)
9:                       IEC0bits.T3IE = 1; //enable interrupt
9D014EDC  3C02BF81   LUI V0, -16511
9D014EE0  8C4300C0   LW V1, 192(V0)
9D014EE4  24040001   ADDIU A0, ZERO, 1
9D014EE8  7C837384   INS V1, A0, 14, 1
9D014EEC  AC4300C0   SW V1, 192(V0)
10:                      /*Interrupt Priority and Subpriority for this interrupt vector is set within system_init.c*/
11:                      
12:                      TRISEbits.TRISE1 = 0; //for timer test
9D014EF0  3C02BF86   LUI V0, -16506
9D014EF4  94430410   LHU V1, 1040(V0)
9D014EF8  7C030844   INS V1, ZERO, 1, 1
9D014EFC  A4430410   SH V1, 1040(V0)
13:                      ODCEbits.ODCE1 = 0;
9D014F00  3C02BF86   LUI V0, -16506
9D014F04  94430440   LHU V1, 1088(V0)
9D014F08  7C030844   INS V1, ZERO, 1, 1
9D014F0C  A4430440   SH V1, 1088(V0)
14:                      LATEbits.LATE1 = 0;
9D014F10  3C02BF86   LUI V0, -16506
15:                  }
16:                  
17:                  void initTimer4(){ //msec
18:                      T4CONbits.TON = 0;
9D016084  3C02BF84   LUI V0, -16508
9D016088  94430600   LHU V1, 1536(V0)
9D01608C  7C037BC4   INS V1, ZERO, 15, 1
9D016090  A4430600   SH V1, 1536(V0)
19:                      TMR4 = 0x0000;
9D016094  3C03BF84   LUI V1, -16508
9D016098  AC600610   SW ZERO, 1552(V1)
20:                      PR4 = 49999;
9D01609C  3404C34F   ORI A0, ZERO, -15537
9D0160A0  3C03BF84   LUI V1, -16508
9D0160A4  AC640620   SW A0, 1568(V1)
21:                      T4CONbits.TCKPS = 1; //100 MHz -> 50 MHz
9D0160A8  94430600   LHU V1, 1536(V0)
9D0160AC  24040001   ADDIU A0, ZERO, 1
9D0160B0  7C833104   INS V1, A0, 4, 3
9D0160B4  A4430600   SH V1, 1536(V0)
22:                      IFS0bits.T4IF = 0;
9D0160B8  3C02BF81   LUI V0, -16511
9D0160BC  8C430040   LW V1, 64(V0)
9D0160C0  7C039CC4   INS V1, ZERO, 19, 1
9D0160C4  AC430040   SW V1, 64(V0)
23:                      IEC0bits.T4IE = 1; //enable interrupt
9D0160C8  3C02BF81   LUI V0, -16511
24:                      /*Interrupt Priorities and Subpriorities for this interrupt vector are set within system_init.c*/
25:                  }
26:                  
27:                  void initTimer5(){ //ADC trigger timer (sample timer): 55.55us
28:                      T5CONbits.TON = 0;
9D016190  3C02BF84   LUI V0, -16508
9D016194  94430800   LHU V1, 2048(V0)
9D016198  7C037BC4   INS V1, ZERO, 15, 1
9D01619C  A4430800   SH V1, 2048(V0)
29:                      TMR5 = 0x0000;
9D0161A0  3C03BF84   LUI V1, -16508
9D0161A4  AC600810   SW ZERO, 2064(V1)
30:                      PR5 = 5554;
9D0161A8  240415B2   ADDIU A0, ZERO, 5554
9D0161AC  3C03BF84   LUI V1, -16508
9D0161B0  AC640820   SW A0, 2080(V1)
31:                      T5CONbits.TCKPS = 0; //100 MHz
9D0161B4  94430800   LHU V1, 2048(V0)
9D0161B8  7C033104   INS V1, ZERO, 4, 3
9D0161BC  A4430800   SH V1, 2048(V0)
32:                      IFS0bits.T5IF = 0;
9D0161C0  3C02BF81   LUI V0, -16511
9D0161C4  8C430040   LW V1, 64(V0)
9D0161C8  7C03C604   INS V1, ZERO, 24, 1
9D0161CC  AC430040   SW V1, 64(V0)
33:                      IEC0bits.T5IE = 0;
9D0161D0  3C02BF81   LUI V0, -16511
34:                  }
35:                  
36:                  void timer3ON(){
37:                      T3CONbits.TON = 1;
9D0171A0  3C02BF84   LUI V0, -16508
38:                  }
39:                  void timer3OFF(){
40:                      T3CONbits.TON = 0;
9D017238  3C02BF84   LUI V0, -16508
41:                  }
42:                  void timer4ON(){
43:                      T4CONbits.TON = 1;
44:                  }
45:                  void timer4OFF(){
46:                      T4CONbits.TON = 0;
00000000  00000000   NOP
47:                  }
48:                  void timer5ON(){
49:                      T5CONbits.TON = 1;
9D0171BC  3C02BF84   LUI V0, -16508
50:                  }
51:                  void timer5OFF(){
52:                      T5CONbits.TON = 0;
9D017250  3C02BF84   LUI V0, -16508
53:                  }
54:                  
55:                  void delay5ms(){
56:                      T3CONbits.TON = 1;
00000000  00000000   NOP
57:                      while(IFS0bits.T3IF == 0){}
00000014  00000000   NOP
58:                      T3CONbits.TON = 0;
00000028  00000000   NOP
59:                      IFS0bits.T3IF = 0;
00000034  00000000   NOP
60:                  }
61:                  
62:                  void testTimer3(){
00000000  00000000   NOP
63:                      LATESET = 0x0002;
0000000C  00000000   NOP
64:                      delay5ms();
00000018  00000000   NOP
65:                      LATGINV = 0x0002;
00000020  00000000   NOP
66:                      delay5ms();
00000028  00000000   NOP
67:                  }
00000030  00000000   NOP
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/system_tasks.c
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       system_tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled state
9:                       machines.
10:                  
11:                    Description:
12:                      This file contains source code necessary to maintain system's polled state
13:                      machines.  It implements the "SYS_Tasks" function that calls the individual
14:                      "Tasks" functions for all polled MPLAB Harmony modules in the system.
15:                  
16:                    Remarks:
17:                      This file requires access to the systemObjects global data structure that
18:                      contains the object handles to all MPLAB Harmony module objects executing
19:                      polled in the system.  These handles are passed into the individual module
20:                      "Tasks" functions to identify the instance of the module to maintain.
21:                   *******************************************************************************/
22:                  
23:                  // DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: Included Files
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: System "Tasks" Routine
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  /*******************************************************************************
65:                    Function:
66:                      void SYS_Tasks ( void )
67:                  
68:                    Remarks:
69:                      See prototype in system/common/sys_module.h.
70:                  */
71:                  
72:                  void SYS_Tasks ( void )
73:                  {
9D0165D0  27BDFFE8   ADDIU SP, SP, -24
9D0165D4  AFBF0014   SW RA, 20(SP)
9D0165D8  AFB00010   SW S0, 16(SP)
74:                      /* Maintain system services */
75:                      SYS_DEVCON_Tasks(sysObj.sysDevcon);
9D0165DC  3C108000   LUI S0, -32768
9D0165E0  0F405CE0   JAL SYS_DEVCON_Tasks
9D0165E4  8E040A9C   LW A0, 2716(S0)
76:                      /* Maintain the file system state machine. */
77:                      SYS_FS_Tasks();
9D0165E8  0F405C29   JAL SYS_FS_Tasks
9D0165EC  26100A9C   ADDIU S0, S0, 2716
78:                      /* SYS_TMR Device layer tasks routine */ 
79:                      SYS_TMR_Tasks(sysObj.sysTmr);
9D0165F0  0F4026E9   JAL SYS_TMR_Tasks
9D0165F4  8E040004   LW A0, 4(S0)
80:                  
81:                      /* Maintain Device Drivers */
82:                  
83:                      /* Maintain Middleware & Other Libraries */
84:                  
85:                   
86:                          /* USBHS Driver Task Routine */ 
87:                           DRV_USBHS_Tasks(sysObj.drvUSBObject);
9D0165F8  0F40379E   JAL DRV_USBHS_Tasks
9D0165FC  8E04000C   LW A0, 12(S0)
88:                           
89:                   
90:                          /* USB Host layer task routine.*/
91:                          USB_HOST_Tasks(sysObj.usbHostObject0);
9D016600  0F403B35   JAL USB_HOST_Tasks
9D016604  8E040010   LW A0, 16(S0)
92:                  
93:                  }
9D016608  8FBF0014   LW RA, 20(SP)
94:                  
95:                  
96:                  /*******************************************************************************
97:                   End of File
98:                   */
99:                  
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/system_interrupt.c
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     File Name:
5:                       system_interrupt.c
6:                   
7:                     Summary:
8:                       Raw ISR definitions.
9:                   
10:                    Description:
11:                      This file contains a definitions of the raw ISRs required to support the
12:                      interrupt sub-system.
13:                  
14:                    Summary:
15:                      This file contains source code for the interrupt vector functions in the
16:                      system.
17:                  
18:                    Description:
19:                      This file contains source code for the interrupt vector functions in the
20:                      system.  It implements the system and part specific vector "stub" functions
21:                      from which the individual "Tasks" functions are called for any modules
22:                      executing interrupt-driven in the MPLAB Harmony system.
23:                  
24:                    Remarks:
25:                      This file requires access to the systemObjects global data structure that
26:                      contains the object handles to all MPLAB Harmony module objects executing
27:                      interrupt-driven in the system.  These handles are passed into the individual
28:                      module "Tasks" functions to identify the instance of the module to maintain.
29:                   *******************************************************************************/
30:                  
31:                  // DOM-IGNORE-BEGIN
32:                  /*******************************************************************************
33:                  Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
34:                  
35:                  Microchip licenses to you the right to use, modify, copy and distribute
36:                  Software only when embedded on a Microchip microcontroller or digital signal
37:                  controller that is integrated into your product or third party product
38:                  (pursuant to the sublicense terms in the accompanying license agreement).
39:                  
40:                  You should refer to the license agreement accompanying this Software for
41:                  additional information regarding your rights and obligations.
42:                  
43:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
44:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
45:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
46:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
47:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
48:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
49:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
50:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
51:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
52:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
53:                   *******************************************************************************/
54:                  // DOM-IGNORE-END
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  
62:                  #include <xc.h>
63:                  #include <sys/attribs.h>
64:                  #include "app.h"
65:                  #include "system_definitions.h"
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: System Interrupt Vector Functions
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                      
74:                  void __ISR(_TIMER_2_VECTOR, IPL4AUTO) IntHandlerDrvTmrInstance0(void)
75:                  {
9D00C528  415DE800   RDPGPR SP, SP
9D00C52C  401B7000   MFC0 K1, EPC
9D00C530  401A6002   MFC0 K0, SRSCtl
9D00C534  27BDFED0   ADDIU SP, SP, -304
9D00C538  AFBB012C   SW K1, 300(SP)
9D00C53C  401B6000   MFC0 K1, Status
9D00C540  AFBA0124   SW K0, 292(SP)
9D00C544  AFBB0128   SW K1, 296(SP)
9D00C548  7C1B7844   INS K1, ZERO, 1, 15
9D00C54C  377B1000   ORI K1, K1, 4096
9D00C550  409B6000   MTC0 K1, Status
9D00C554  AFA30018   SW V1, 24(SP)
9D00C558  AFA20014   SW V0, 20(SP)
9D00C55C  8FA30124   LW V1, 292(SP)
9D00C560  3063000F   ANDI V1, V1, 15
9D00C564  14600011   BNE V1, ZERO, 0x9D00C5AC
9D00C568  00000000   NOP
9D00C56C  AFBF0054   SW RA, 84(SP)
9D00C570  AFB90050   SW T9, 80(SP)
9D00C574  AFB8004C   SW T8, 76(SP)
9D00C578  AFAF0048   SW T7, 72(SP)
9D00C57C  AFAE0044   SW T6, 68(SP)
9D00C580  AFAD0040   SW T5, 64(SP)
9D00C584  AFAC003C   SW T4, 60(SP)
9D00C588  AFAB0038   SW T3, 56(SP)
9D00C58C  AFAA0034   SW T2, 52(SP)
9D00C590  AFA90030   SW T1, 48(SP)
9D00C594  AFA8002C   SW T0, 44(SP)
9D00C598  AFA70028   SW A3, 40(SP)
9D00C59C  AFA60024   SW A2, 36(SP)
9D00C5A0  AFA50020   SW A1, 32(SP)
9D00C5A4  AFA4001C   SW A0, 28(SP)
9D00C5A8  AFA10010   SW AT, 16(SP)
9D00C5AC  F7B300F0   SDC1 F19, 240(SP)
9D00C5B0  F7B200E8   SDC1 F18, 232(SP)
9D00C5B4  F7B100E0   SDC1 F17, 224(SP)
9D00C5B8  F7B000D8   SDC1 F16, 216(SP)
9D00C5BC  F7AF00D0   SDC1 F15, 208(SP)
9D00C5C0  F7AE00C8   SDC1 F14, 200(SP)
9D00C5C4  F7AD00C0   SDC1 F13, 192(SP)
9D00C5C8  F7AC00B8   SDC1 F12, 184(SP)
9D00C5CC  F7AB00B0   SDC1 F11, 176(SP)
9D00C5D0  F7AA00A8   SDC1 F10, 168(SP)
9D00C5D4  F7A900A0   SDC1 F9, 160(SP)
9D00C5D8  F7A80098   SDC1 F8, 152(SP)
9D00C5DC  F7A70090   SDC1 F7, 144(SP)
9D00C5E0  F7A60088   SDC1 F6, 136(SP)
9D00C5E4  F7A50080   SDC1 F5, 128(SP)
9D00C5E8  F7A40078   SDC1 F4, 120(SP)
9D00C5EC  F7A30070   SDC1 F3, 112(SP)
9D00C5F0  F7A20068   SDC1 F2, 104(SP)
9D00C5F4  F7A10060   SDC1 F1, 96(SP)
9D00C5F8  F7A00058   SDC1 F0, 88(SP)
9D00C5FC  00001012   MFLO V0
9D00C600  AFA2011C   SW V0, 284(SP)
9D00C604  00001810   MFHI V1
9D00C608  AFA30118   SW V1, 280(SP)
9D00C60C  00201012   MFLO V0
9D00C610  AFA20114   SW V0, 276(SP)
9D00C614  00201810   MFHI V1
9D00C618  AFA30110   SW V1, 272(SP)
9D00C61C  00401012   MFLO V0
9D00C620  AFA2010C   SW V0, 268(SP)
9D00C624  00401810   MFHI V1
9D00C628  AFA30108   SW V1, 264(SP)
9D00C62C  00601012   MFLO V0
9D00C630  AFA20104   SW V0, 260(SP)
9D00C634  00601810   MFHI V1
9D00C638  AFA30100   SW V1, 256(SP)
9D00C63C  7C3F1CB8   RDDSP V1, 0x3F
9D00C640  AFA3000C   SW V1, 12(SP)
9D00C644  4442F800   CFC1 V0, F31
9D00C648  AFA200FC   SW V0, 252(SP)
76:                      DRV_TMR_Tasks(sysObj.drvTmr0);
9D00C64C  3C028000   LUI V0, -32768
9D00C650  0F404E24   JAL DRV_TMR_Tasks
9D00C654  8C440AA4   LW A0, 2724(V0)
77:                  }
9D00C658  8FA200FC   LW V0, 252(SP)
78:                    
79:                  void __ISR( _USB_VECTOR , IPL4AUTO)_IntHandler_USB_stub ( void )
80:                  {
9D00C77C  415DE800   RDPGPR SP, SP
9D00C780  401B7000   MFC0 K1, EPC
9D00C784  401A6002   MFC0 K0, SRSCtl
9D00C788  27BDFED0   ADDIU SP, SP, -304
9D00C78C  AFBB012C   SW K1, 300(SP)
9D00C790  401B6000   MFC0 K1, Status
9D00C794  AFBA0124   SW K0, 292(SP)
9D00C798  AFBB0128   SW K1, 296(SP)
9D00C79C  7C1B7844   INS K1, ZERO, 1, 15
9D00C7A0  377B1000   ORI K1, K1, 4096
9D00C7A4  409B6000   MTC0 K1, Status
9D00C7A8  AFA30018   SW V1, 24(SP)
9D00C7AC  AFA20014   SW V0, 20(SP)
9D00C7B0  8FA30124   LW V1, 292(SP)
9D00C7B4  3063000F   ANDI V1, V1, 15
9D00C7B8  14600011   BNE V1, ZERO, 0x9D00C800
9D00C7BC  00000000   NOP
9D00C7C0  AFBF0054   SW RA, 84(SP)
9D00C7C4  AFB90050   SW T9, 80(SP)
9D00C7C8  AFB8004C   SW T8, 76(SP)
9D00C7CC  AFAF0048   SW T7, 72(SP)
9D00C7D0  AFAE0044   SW T6, 68(SP)
9D00C7D4  AFAD0040   SW T5, 64(SP)
9D00C7D8  AFAC003C   SW T4, 60(SP)
9D00C7DC  AFAB0038   SW T3, 56(SP)
9D00C7E0  AFAA0034   SW T2, 52(SP)
9D00C7E4  AFA90030   SW T1, 48(SP)
9D00C7E8  AFA8002C   SW T0, 44(SP)
9D00C7EC  AFA70028   SW A3, 40(SP)
9D00C7F0  AFA60024   SW A2, 36(SP)
9D00C7F4  AFA50020   SW A1, 32(SP)
9D00C7F8  AFA4001C   SW A0, 28(SP)
9D00C7FC  AFA10010   SW AT, 16(SP)
9D00C800  F7B300F0   SDC1 F19, 240(SP)
9D00C804  F7B200E8   SDC1 F18, 232(SP)
9D00C808  F7B100E0   SDC1 F17, 224(SP)
9D00C80C  F7B000D8   SDC1 F16, 216(SP)
9D00C810  F7AF00D0   SDC1 F15, 208(SP)
9D00C814  F7AE00C8   SDC1 F14, 200(SP)
9D00C818  F7AD00C0   SDC1 F13, 192(SP)
9D00C81C  F7AC00B8   SDC1 F12, 184(SP)
9D00C820  F7AB00B0   SDC1 F11, 176(SP)
9D00C824  F7AA00A8   SDC1 F10, 168(SP)
9D00C828  F7A900A0   SDC1 F9, 160(SP)
9D00C82C  F7A80098   SDC1 F8, 152(SP)
9D00C830  F7A70090   SDC1 F7, 144(SP)
9D00C834  F7A60088   SDC1 F6, 136(SP)
9D00C838  F7A50080   SDC1 F5, 128(SP)
9D00C83C  F7A40078   SDC1 F4, 120(SP)
9D00C840  F7A30070   SDC1 F3, 112(SP)
9D00C844  F7A20068   SDC1 F2, 104(SP)
9D00C848  F7A10060   SDC1 F1, 96(SP)
9D00C84C  F7A00058   SDC1 F0, 88(SP)
9D00C850  00001012   MFLO V0
9D00C854  AFA2011C   SW V0, 284(SP)
9D00C858  00001810   MFHI V1
9D00C85C  AFA30118   SW V1, 280(SP)
9D00C860  00201012   MFLO V0
9D00C864  AFA20114   SW V0, 276(SP)
9D00C868  00201810   MFHI V1
9D00C86C  AFA30110   SW V1, 272(SP)
9D00C870  00401012   MFLO V0
9D00C874  AFA2010C   SW V0, 268(SP)
9D00C878  00401810   MFHI V1
9D00C87C  AFA30108   SW V1, 264(SP)
9D00C880  00601012   MFLO V0
9D00C884  AFA20104   SW V0, 260(SP)
9D00C888  00601810   MFHI V1
9D00C88C  AFA30100   SW V1, 256(SP)
9D00C890  7C3F1CB8   RDDSP V1, 0x3F
9D00C894  AFA3000C   SW V1, 12(SP)
9D00C898  4442F800   CFC1 V0, F31
9D00C89C  AFA200FC   SW V0, 252(SP)
81:                      DRV_USBHS_Tasks_ISR(sysObj.drvUSBObject);
9D00C8A0  3C028000   LUI V0, -32768
9D00C8A4  0F4054B9   JAL DRV_USBHS_Tasks_ISR
9D00C8A8  8C440AA8   LW A0, 2728(V0)
82:                  }
9D00C8AC  8FA200FC   LW V0, 252(SP)
83:                  
84:                  void __ISR ( _USB_DMA_VECTOR, IPL4AUTO)  _IntHandlerUSBInstance0_USBDMA ( void )
85:                  {
9D00C9D0  415DE800   RDPGPR SP, SP
9D00C9D4  401B7000   MFC0 K1, EPC
9D00C9D8  401A6002   MFC0 K0, SRSCtl
9D00C9DC  27BDFED0   ADDIU SP, SP, -304
9D00C9E0  AFBB012C   SW K1, 300(SP)
9D00C9E4  401B6000   MFC0 K1, Status
9D00C9E8  AFBA0124   SW K0, 292(SP)
9D00C9EC  AFBB0128   SW K1, 296(SP)
9D00C9F0  7C1B7844   INS K1, ZERO, 1, 15
9D00C9F4  377B1000   ORI K1, K1, 4096
9D00C9F8  409B6000   MTC0 K1, Status
9D00C9FC  AFA30018   SW V1, 24(SP)
9D00CA00  AFA20014   SW V0, 20(SP)
9D00CA04  8FA30124   LW V1, 292(SP)
9D00CA08  3063000F   ANDI V1, V1, 15
9D00CA0C  14600011   BNE V1, ZERO, 0x9D00CA54
9D00CA10  00000000   NOP
9D00CA14  AFBF0054   SW RA, 84(SP)
9D00CA18  AFB90050   SW T9, 80(SP)
9D00CA1C  AFB8004C   SW T8, 76(SP)
9D00CA20  AFAF0048   SW T7, 72(SP)
9D00CA24  AFAE0044   SW T6, 68(SP)
9D00CA28  AFAD0040   SW T5, 64(SP)
9D00CA2C  AFAC003C   SW T4, 60(SP)
9D00CA30  AFAB0038   SW T3, 56(SP)
9D00CA34  AFAA0034   SW T2, 52(SP)
9D00CA38  AFA90030   SW T1, 48(SP)
9D00CA3C  AFA8002C   SW T0, 44(SP)
9D00CA40  AFA70028   SW A3, 40(SP)
9D00CA44  AFA60024   SW A2, 36(SP)
9D00CA48  AFA50020   SW A1, 32(SP)
9D00CA4C  AFA4001C   SW A0, 28(SP)
9D00CA50  AFA10010   SW AT, 16(SP)
9D00CA54  F7B300F0   SDC1 F19, 240(SP)
9D00CA58  F7B200E8   SDC1 F18, 232(SP)
9D00CA5C  F7B100E0   SDC1 F17, 224(SP)
9D00CA60  F7B000D8   SDC1 F16, 216(SP)
9D00CA64  F7AF00D0   SDC1 F15, 208(SP)
9D00CA68  F7AE00C8   SDC1 F14, 200(SP)
9D00CA6C  F7AD00C0   SDC1 F13, 192(SP)
9D00CA70  F7AC00B8   SDC1 F12, 184(SP)
9D00CA74  F7AB00B0   SDC1 F11, 176(SP)
9D00CA78  F7AA00A8   SDC1 F10, 168(SP)
9D00CA7C  F7A900A0   SDC1 F9, 160(SP)
9D00CA80  F7A80098   SDC1 F8, 152(SP)
9D00CA84  F7A70090   SDC1 F7, 144(SP)
9D00CA88  F7A60088   SDC1 F6, 136(SP)
9D00CA8C  F7A50080   SDC1 F5, 128(SP)
9D00CA90  F7A40078   SDC1 F4, 120(SP)
9D00CA94  F7A30070   SDC1 F3, 112(SP)
9D00CA98  F7A20068   SDC1 F2, 104(SP)
9D00CA9C  F7A10060   SDC1 F1, 96(SP)
9D00CAA0  F7A00058   SDC1 F0, 88(SP)
9D00CAA4  00001012   MFLO V0
9D00CAA8  AFA2011C   SW V0, 284(SP)
9D00CAAC  00001810   MFHI V1
9D00CAB0  AFA30118   SW V1, 280(SP)
9D00CAB4  00201012   MFLO V0
9D00CAB8  AFA20114   SW V0, 276(SP)
9D00CABC  00201810   MFHI V1
9D00CAC0  AFA30110   SW V1, 272(SP)
9D00CAC4  00401012   MFLO V0
9D00CAC8  AFA2010C   SW V0, 268(SP)
9D00CACC  00401810   MFHI V1
9D00CAD0  AFA30108   SW V1, 264(SP)
9D00CAD4  00601012   MFLO V0
9D00CAD8  AFA20104   SW V0, 260(SP)
9D00CADC  00601810   MFHI V1
9D00CAE0  AFA30100   SW V1, 256(SP)
9D00CAE4  7C3F1CB8   RDDSP V1, 0x3F
9D00CAE8  AFA3000C   SW V1, 12(SP)
9D00CAEC  4442F800   CFC1 V0, F31
9D00CAF0  AFA200FC   SW V0, 252(SP)
86:                      DRV_USBHS_Tasks_ISR_USBDMA(sysObj.drvUSBObject);
9D00CAF4  3C028000   LUI V0, -32768
9D00CAF8  0F4054DA   JAL DRV_USBHS_Tasks_ISR_USBDMA
9D00CAFC  8C440AA8   LW A0, 2728(V0)
87:                  }
9D00CB00  8FA200FC   LW V0, 252(SP)
88:                  
89:                  void __ISR( _TIMER_3_VECTOR, IPL6AUTO) _IntHandlerDebounceTimer(void) { //debouncetimer
9D00B47C  415DE800   RDPGPR SP, SP
9D00B480  401B7000   MFC0 K1, EPC
9D00B484  401A6002   MFC0 K0, SRSCtl
9D00B488  27BDFED0   ADDIU SP, SP, -304
9D00B48C  AFBB012C   SW K1, 300(SP)
9D00B490  401B6000   MFC0 K1, Status
9D00B494  AFBA0124   SW K0, 292(SP)
9D00B498  AFBB0128   SW K1, 296(SP)
9D00B49C  7C1B7844   INS K1, ZERO, 1, 15
9D00B4A0  377B1800   ORI K1, K1, 6144
9D00B4A4  409B6000   MTC0 K1, Status
9D00B4A8  AFA30018   SW V1, 24(SP)
9D00B4AC  AFA20014   SW V0, 20(SP)
9D00B4B0  8FA30124   LW V1, 292(SP)
9D00B4B4  3063000F   ANDI V1, V1, 15
9D00B4B8  14600011   BNE V1, ZERO, 0x9D00B500
9D00B4BC  00000000   NOP
9D00B4C0  AFBF0054   SW RA, 84(SP)
9D00B4C4  AFB90050   SW T9, 80(SP)
9D00B4C8  AFB8004C   SW T8, 76(SP)
9D00B4CC  AFAF0048   SW T7, 72(SP)
9D00B4D0  AFAE0044   SW T6, 68(SP)
9D00B4D4  AFAD0040   SW T5, 64(SP)
9D00B4D8  AFAC003C   SW T4, 60(SP)
9D00B4DC  AFAB0038   SW T3, 56(SP)
9D00B4E0  AFAA0034   SW T2, 52(SP)
9D00B4E4  AFA90030   SW T1, 48(SP)
9D00B4E8  AFA8002C   SW T0, 44(SP)
9D00B4EC  AFA70028   SW A3, 40(SP)
9D00B4F0  AFA60024   SW A2, 36(SP)
9D00B4F4  AFA50020   SW A1, 32(SP)
9D00B4F8  AFA4001C   SW A0, 28(SP)
9D00B4FC  AFA10010   SW AT, 16(SP)
9D00B500  F7B300F0   SDC1 F19, 240(SP)
9D00B504  F7B200E8   SDC1 F18, 232(SP)
9D00B508  F7B100E0   SDC1 F17, 224(SP)
9D00B50C  F7B000D8   SDC1 F16, 216(SP)
9D00B510  F7AF00D0   SDC1 F15, 208(SP)
9D00B514  F7AE00C8   SDC1 F14, 200(SP)
9D00B518  F7AD00C0   SDC1 F13, 192(SP)
9D00B51C  F7AC00B8   SDC1 F12, 184(SP)
9D00B520  F7AB00B0   SDC1 F11, 176(SP)
9D00B524  F7AA00A8   SDC1 F10, 168(SP)
9D00B528  F7A900A0   SDC1 F9, 160(SP)
9D00B52C  F7A80098   SDC1 F8, 152(SP)
9D00B530  F7A70090   SDC1 F7, 144(SP)
9D00B534  F7A60088   SDC1 F6, 136(SP)
9D00B538  F7A50080   SDC1 F5, 128(SP)
9D00B53C  F7A40078   SDC1 F4, 120(SP)
9D00B540  F7A30070   SDC1 F3, 112(SP)
9D00B544  F7A20068   SDC1 F2, 104(SP)
9D00B548  F7A10060   SDC1 F1, 96(SP)
9D00B54C  F7A00058   SDC1 F0, 88(SP)
9D00B550  00001012   MFLO V0
9D00B554  AFA2011C   SW V0, 284(SP)
9D00B558  00001810   MFHI V1
9D00B55C  AFA30118   SW V1, 280(SP)
9D00B560  00201012   MFLO V0
9D00B564  AFA20114   SW V0, 276(SP)
9D00B568  00201810   MFHI V1
9D00B56C  AFA30110   SW V1, 272(SP)
9D00B570  00401012   MFLO V0
9D00B574  AFA2010C   SW V0, 268(SP)
9D00B578  00401810   MFHI V1
9D00B57C  AFA30108   SW V1, 264(SP)
9D00B580  00601012   MFLO V0
9D00B584  AFA20104   SW V0, 260(SP)
9D00B588  00601810   MFHI V1
9D00B58C  AFA30100   SW V1, 256(SP)
9D00B590  7C3F1CB8   RDDSP V1, 0x3F
9D00B594  AFA3000C   SW V1, 12(SP)
9D00B598  4442F800   CFC1 V0, F31
9D00B59C  AFA200FC   SW V0, 252(SP)
90:                      IFS0bits.T3IF = 0;
9D00B5A0  3C02BF81   LUI V0, -16511
9D00B5A4  8C430040   LW V1, 64(V0)
9D00B5A8  7C037384   INS V1, ZERO, 14, 1
9D00B5AC  AC430040   SW V1, 64(V0)
91:                      timer3OFF();
9D00B5B0  0F405C8E   JAL timer3OFF
9D00B5B4  00000000   NOP
92:                      setDebounced();
9D00B5B8  0F405CBB   JAL setDebounced
9D00B5BC  00000000   NOP
93:                      togglePress();
9D00B5C0  0F405C88   JAL togglePress
9D00B5C4  00000000   NOP
94:                      TMR3 = 0x0000;
9D00B5C8  3C02BF84   LUI V0, -16508
9D00B5CC  AC400410   SW ZERO, 1040(V0)
95:                  }
9D00B5D0  8FA200FC   LW V0, 252(SP)
96:                  
97:                  void __ISR(_CHANGE_NOTICE_G_VECTOR, IPL1AUTO) _CNInterrupt(void) {
9D00B95C  415DE800   RDPGPR SP, SP
9D00B960  401B7000   MFC0 K1, EPC
9D00B964  401A6002   MFC0 K0, SRSCtl
9D00B968  27BDFED0   ADDIU SP, SP, -304
9D00B96C  AFBB012C   SW K1, 300(SP)
9D00B970  401B6000   MFC0 K1, Status
9D00B974  AFBA0124   SW K0, 292(SP)
9D00B978  AFBB0128   SW K1, 296(SP)
9D00B97C  7C1B7844   INS K1, ZERO, 1, 15
9D00B980  377B0400   ORI K1, K1, 1024
9D00B984  409B6000   MTC0 K1, Status
9D00B988  AFA30018   SW V1, 24(SP)
9D00B98C  AFA20014   SW V0, 20(SP)
9D00B990  8FA30124   LW V1, 292(SP)
9D00B994  3063000F   ANDI V1, V1, 15
9D00B998  14600011   BNE V1, ZERO, 0x9D00B9E0
9D00B99C  00000000   NOP
9D00B9A0  AFBF0054   SW RA, 84(SP)
9D00B9A4  AFB90050   SW T9, 80(SP)
9D00B9A8  AFB8004C   SW T8, 76(SP)
9D00B9AC  AFAF0048   SW T7, 72(SP)
9D00B9B0  AFAE0044   SW T6, 68(SP)
9D00B9B4  AFAD0040   SW T5, 64(SP)
9D00B9B8  AFAC003C   SW T4, 60(SP)
9D00B9BC  AFAB0038   SW T3, 56(SP)
9D00B9C0  AFAA0034   SW T2, 52(SP)
9D00B9C4  AFA90030   SW T1, 48(SP)
9D00B9C8  AFA8002C   SW T0, 44(SP)
9D00B9CC  AFA70028   SW A3, 40(SP)
9D00B9D0  AFA60024   SW A2, 36(SP)
9D00B9D4  AFA50020   SW A1, 32(SP)
9D00B9D8  AFA4001C   SW A0, 28(SP)
9D00B9DC  AFA10010   SW AT, 16(SP)
9D00B9E0  F7B300F0   SDC1 F19, 240(SP)
9D00B9E4  F7B200E8   SDC1 F18, 232(SP)
9D00B9E8  F7B100E0   SDC1 F17, 224(SP)
9D00B9EC  F7B000D8   SDC1 F16, 216(SP)
9D00B9F0  F7AF00D0   SDC1 F15, 208(SP)
9D00B9F4  F7AE00C8   SDC1 F14, 200(SP)
9D00B9F8  F7AD00C0   SDC1 F13, 192(SP)
9D00B9FC  F7AC00B8   SDC1 F12, 184(SP)
9D00BA00  F7AB00B0   SDC1 F11, 176(SP)
9D00BA04  F7AA00A8   SDC1 F10, 168(SP)
9D00BA08  F7A900A0   SDC1 F9, 160(SP)
9D00BA0C  F7A80098   SDC1 F8, 152(SP)
9D00BA10  F7A70090   SDC1 F7, 144(SP)
9D00BA14  F7A60088   SDC1 F6, 136(SP)
9D00BA18  F7A50080   SDC1 F5, 128(SP)
9D00BA1C  F7A40078   SDC1 F4, 120(SP)
9D00BA20  F7A30070   SDC1 F3, 112(SP)
9D00BA24  F7A20068   SDC1 F2, 104(SP)
9D00BA28  F7A10060   SDC1 F1, 96(SP)
9D00BA2C  F7A00058   SDC1 F0, 88(SP)
9D00BA30  00001012   MFLO V0
9D00BA34  AFA2011C   SW V0, 284(SP)
9D00BA38  00001810   MFHI V1
9D00BA3C  AFA30118   SW V1, 280(SP)
9D00BA40  00201012   MFLO V0
9D00BA44  AFA20114   SW V0, 276(SP)
9D00BA48  00201810   MFHI V1
9D00BA4C  AFA30110   SW V1, 272(SP)
9D00BA50  00401012   MFLO V0
9D00BA54  AFA2010C   SW V0, 268(SP)
9D00BA58  00401810   MFHI V1
9D00BA5C  AFA30108   SW V1, 264(SP)
9D00BA60  00601012   MFLO V0
9D00BA64  AFA20104   SW V0, 260(SP)
9D00BA68  00601810   MFHI V1
9D00BA6C  AFA30100   SW V1, 256(SP)
9D00BA70  7C3F1CB8   RDDSP V1, 0x3F
9D00BA74  AFA3000C   SW V1, 12(SP)
9D00BA78  4442F800   CFC1 V0, F31
9D00BA7C  AFA200FC   SW V0, 252(SP)
98:                      int dummy = PORTG;
9D00BA80  3C02BF86   LUI V0, -16506
9D00BA84  8C420620   LW V0, 1568(V0)
99:                      IFS3bits.CNGIF = 0;
9D00BA88  3C02BF81   LUI V0, -16511
9D00BA8C  8C430070   LW V1, 112(V0)
9D00BA90  7C03E704   INS V1, ZERO, 28, 1
9D00BA94  AC430070   SW V1, 112(V0)
100:                     timer3ON(); //delay for debounce
9D00BA98  0F405C68   JAL timer3ON
9D00BA9C  00000000   NOP
101:                 }
9D00BAA0  8FA200FC   LW V0, 252(SP)
102:                 
103:                 void __ISR( _TIMER_4_VECTOR, IPL1AUTO) _IntHandlerTmr4(void) { //older test
9D014E08  415DE800   RDPGPR SP, SP
9D014E0C  401B7000   MFC0 K1, EPC
9D014E10  401A6002   MFC0 K0, SRSCtl
9D014E14  27BDFFE8   ADDIU SP, SP, -24
9D014E18  AFBB0014   SW K1, 20(SP)
9D014E1C  401B6000   MFC0 K1, Status
9D014E20  AFBA000C   SW K0, 12(SP)
9D014E24  AFBB0010   SW K1, 16(SP)
9D014E28  7C1B7844   INS K1, ZERO, 1, 15
9D014E2C  377B0400   ORI K1, K1, 1024
9D014E30  409B6000   MTC0 K1, Status
9D014E34  AFA30004   SW V1, 4(SP)
9D014E38  AFA20000   SW V0, 0(SP)
104:                     IFS0bits.T4IF = 0;
9D014E3C  3C02BF81   LUI V0, -16511
9D014E40  8C430040   LW V1, 64(V0)
9D014E44  7C039CC4   INS V1, ZERO, 19, 1
9D014E48  AC430040   SW V1, 64(V0)
105:                     //incTimeStamp(); 
106:                     //addSample();
107:                     TMR4 = 0x0000;
9D014E4C  3C02BF84   LUI V0, -16508
9D014E50  AC400610   SW ZERO, 1552(V0)
108:                 }
9D014E54  8FA2000C   LW V0, 12(SP)
109:                 
110:                 //void __ISR( _TIMER_5_VECTOR, IPL1AUTO) _IntHandlerTmr5(void) {
111:                 //    IFS0bits.T5IF = 0;
112:                 //    TMR5 = 0x0000;
113:                 //}
114:                 
115:                 //void __ISR( _ADC_FIFO_VECTOR, IPL7AUTO) _IntHandlerADCFIFO(void){
116:                 //    //addSampleFromFIFO();
117:                 //}
118:                 
119:                 //void __ISR( _ADC_VECTOR, IPL6AUTO) _IntHandlerADCGlobal(void){
120:                 //    if(ADCDSTAT1bits.ARDY2 && ADCDSTAT1bits.ARDY3){ //these probably won't be ready at the same time...
121:                 //        addSample();
122:                 //        IFS1 = 0; //flags CANNOT be cleared until after data has been read
123:                 //    }
124:                 //}
125:                 
126:                 //void __attribute__ ((interrupt(IPL4SRS))) _DefaultInterrupt(void){
127:                 //    
128:                 //}
129:                 
130:                 //void __ISR( _ADC_DATA1_VECTOR, IPL6AUTO) _IntHandlerADCData1(void){
131:                 //    IFS1bits.ADCD1IF = 0; //pull global adc flag down
132:                 //    if(ADCDSTAT1bits.ARDY1 && ADCDSTAT1bits.ARDY2 && ADCDSTAT1bits.ARDY3 && ADCDSTAT1bits.ARDY4){ //these probably won't be ready at the same time...
133:                 //        addSample();
134:                 //    }
135:                 //    else{
136:                 //        error();
137:                 //    }
138:                 //}
139:                 //void __ISR( _ADC_DATA2_VECTOR, IPL6AUTO) _IntHandlerADCData2(void){
140:                 //    if(ADCDSTAT1bits.ARDY2 && ADCDSTAT1bits.ARDY3){ //these probably won't be ready at the same time...
141:                 //        addSample();
142:                 //        IFS1 = 0; //flags CANNOT be cleared until after data has been read
143:                 //    }
144:                 //}
145:                 //
146:                 //void __ISR( _ADC_DATA3_VECTOR, IPL6AUTO) _IntHandlerADCData3(void){
147:                 //    if(ADCDSTAT1bits.ARDY2 && ADCDSTAT1bits.ARDY3){ //these probably won't be ready at the same time...
148:                 //        addSample();
149:                 //        IFS1 = 0; //flags CANNOT be cleared until after data has been read
150:                 //    }
151:                 //}
152:                 //void __ISR( _ADC_DATA4_VECTOR, IPL6AUTO) _IntHandlerADCData4(void){
153:                 //    IFS1bits.ADCD4IF = 0; //pull global adc flag down
154:                 //    if(ADCDSTAT1bits.ARDY1 && ADCDSTAT1bits.ARDY2 && ADCDSTAT1bits.ARDY3 && ADCDSTAT1bits.ARDY4){ //these probably won't be ready at the same time...
155:                 //        addSample();
156:                 //    }
157:                 //    else{
158:                 //        error();
159:                 //    }
160:                 //}
161:                 /*******************************************************************************
162:                  End of File
163:                 */
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/system_init.c
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       system_init.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits, 
13:                      and allocates any necessary global system resources, such as the 
14:                      sysObj structure that contains the object handles to all the MPLAB Harmony 
15:                      module objects in the system.
16:                   *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system_config.h"
50:                  #include "system_definitions.h"
51:                  
52:                  
53:                  // ****************************************************************************
54:                  // ****************************************************************************
55:                  // Section: Configuration Bits
56:                  // ****************************************************************************
57:                  // ****************************************************************************
58:                  // <editor-fold defaultstate="collapsed" desc="Configuration Bits">
59:                  
60:                  /*** DEVCFG0 ***/
61:                  
62:                  #pragma config DEBUG =      OFF
63:                  #pragma config JTAGEN =     OFF
64:                  #pragma config ICESEL =     ICS_PGx2
65:                  #pragma config TRCEN =      OFF
66:                  #pragma config BOOTISA =    MIPS32
67:                  #pragma config FECCCON =    OFF_UNLOCKED
68:                  #pragma config FSLEEP =     OFF
69:                  #pragma config DBGPER =     PG_ALL
70:                  #pragma config SMCLR =      MCLR_NORM
71:                  #pragma config SOSCGAIN =   GAIN_LEVEL_3
72:                  #pragma config SOSCBOOST =  ON
73:                  #pragma config POSCGAIN =   GAIN_LEVEL_3
74:                  #pragma config POSCBOOST =  ON
75:                  #pragma config EJTAGBEN =   NORMAL
76:                  #pragma config CP =         OFF
77:                  
78:                  /*** DEVCFG1 ***/
79:                  
80:                  #pragma config FNOSC =      SPLL
81:                  #pragma config DMTINTV =    WIN_127_128
82:                  #pragma config FSOSCEN =    OFF
83:                  #pragma config IESO =       OFF
84:                  #pragma config POSCMOD =    EC
85:                  #pragma config OSCIOFNC =   OFF
86:                  #pragma config FCKSM =      CSECME
87:                  #pragma config WDTPS =      PS1048576
88:                  #pragma config WDTSPGM =    STOP
89:                  #pragma config FWDTEN =     OFF
90:                  #pragma config WINDIS =     NORMAL
91:                  #pragma config FWDTWINSZ =  WINSZ_25
92:                  #pragma config DMTCNT =     DMT31
93:                  #pragma config FDMTEN =     OFF
94:                  /*** DEVCFG2 ***/
95:                  
96:                  #pragma config FPLLIDIV =   DIV_3
97:                  #pragma config FPLLRNG =    RANGE_5_10_MHZ
98:                  #pragma config FPLLICLK =   PLL_POSC
99:                  #pragma config FPLLMULT =   MUL_50
100:                 #pragma config FPLLODIV =   DIV_2
101:                 #pragma config UPLLFSEL =   FREQ_24MHZ
102:                 /*** DEVCFG3 ***/
103:                 
104:                 #pragma config USERID =     0xffff
105:                 #pragma config FMIIEN =     OFF
106:                 #pragma config FETHIO =     ON
107:                 #pragma config PGL1WAY =    ON
108:                 #pragma config PMDL1WAY =   ON
109:                 #pragma config IOL1WAY =    ON
110:                 #pragma config FUSBIDIO =   ON
111:                 
112:                 /*** BF1SEQ0 ***/
113:                 
114:                 #pragma config TSEQ =       0x0000
115:                 #pragma config CSEQ =       0xffff
116:                 // </editor-fold>
117:                 
118:                 // *****************************************************************************
119:                 // *****************************************************************************
120:                 // Section: Driver Initialization Data
121:                 // *****************************************************************************
122:                 // *****************************************************************************
123:                 // <editor-fold defaultstate="collapsed" desc="DRV_Timer Initialization Data">
124:                 /*** TMR Driver Initialization Data ***/
125:                 
126:                 const DRV_TMR_INIT drvTmr0InitData =
127:                 {
128:                     .moduleInit.sys.powerState = DRV_TMR_POWER_STATE_IDX0,
129:                     .tmrId = DRV_TMR_PERIPHERAL_ID_IDX0,
130:                     .clockSource = DRV_TMR_CLOCK_SOURCE_IDX0, 
131:                     .prescale = DRV_TMR_PRESCALE_IDX0,
132:                     .mode = DRV_TMR_OPERATION_MODE_IDX0,
133:                     .interruptSource = DRV_TMR_INTERRUPT_SOURCE_IDX0,
134:                     .asyncWriteEnable = false,
135:                 };
136:                 // </editor-fold>
137:                 
138:                 // *****************************************************************************
139:                 // *****************************************************************************
140:                 // Section: System Data
141:                 // *****************************************************************************
142:                 // *****************************************************************************
143:                 
144:                 /* Structure to hold the object handles for the modules in the system. */
145:                 SYSTEM_OBJECTS sysObj;
146:                 
147:                 // *****************************************************************************
148:                 // *****************************************************************************
149:                 // Section: Module Initialization Data
150:                 // *****************************************************************************
151:                 // *****************************************************************************
152:                 //<editor-fold defaultstate="collapsed" desc="SYS_DEVCON Initialization Data">
153:                 /*******************************************************************************
154:                   Device Control System Service Initialization Data
155:                 */
156:                 
157:                 const SYS_DEVCON_INIT sysDevconInit =
158:                 {
159:                     .moduleInit = {0},
160:                 };
161:                 
162:                 // </editor-fold>
163:                 // <editor-fold defaultstate="collapsed" desc="SYS_FS Initialization Data">
164:                 /*** File System Initialization Data ***/
165:                 
166:                 
167:                 const SYS_FS_MEDIA_MOUNT_DATA sysfsMountTable[SYS_FS_VOLUME_NUMBER] = 
168:                 {
169:                     
170:                     {
171:                 		.mountName = SYS_FS_MEDIA_IDX0_MOUNT_NAME_VOLUME_IDX0,
172:                 		.devName   = SYS_FS_MEDIA_IDX0_DEVICE_NAME_VOLUME_IDX0, 
173:                 		.mediaType = SYS_FS_MEDIA_TYPE_IDX0,
174:                 		.fsType   = SYS_FS_TYPE_IDX0   
175:                     },
176:                     
177:                 
178:                 
179:                 
180:                      
181:                 };
182:                 
183:                 
184:                 
185:                 
186:                 const SYS_FS_REGISTRATION_TABLE sysFSInit [ SYS_FS_MAX_FILE_SYSTEM_TYPE ] =
187:                 {
188:                     {
189:                         .nativeFileSystemType = FAT,
190:                         .nativeFileSystemFunctions = &FatFsFunctions
191:                     }
192:                 };
193:                 // </editor-fold>
194:                 // <editor-fold defaultstate="collapsed" desc="SYS_TMR Initialization Data">
195:                 /*** TMR Service Initialization Data ***/
196:                 const SYS_TMR_INIT sysTmrInitData =
197:                 {
198:                     .moduleInit = {SYS_MODULE_POWER_RUN_FULL},
199:                     .drvIndex = DRV_TMR_INDEX_0,
200:                     .tmrFreq = 1000, 
201:                 };
202:                 // </editor-fold>
203:                 
204:                 // *****************************************************************************
205:                 // *****************************************************************************
206:                 // Section: Library/Stack Initialization Data
207:                 // *****************************************************************************
208:                 // *****************************************************************************
209:                 // <editor-fold defaultstate="collapsed" desc="USB Host Initialization Data"> 
210:                 
211:                 /****************************************************
212:                  * Endpoint Table needed by the controller driver .
213:                  ****************************************************/
214:                 
215:                 
216:                 
217:                 DRV_USBHS_INIT drvUSBHSInit = 
218:                 {
219:                     .moduleInit = {SYS_MODULE_POWER_RUN_FULL},
220:                     .interruptSource = INT_SOURCE_USB_1,
221:                     .interruptSourceUSBDma = INT_SOURCE_USB_1_DMA,
222:                     .operationMode = DRV_USBHS_OPMODE_HOST,
223:                     .operationSpeed = USB_SPEED_HIGH,
224:                     .portIndication = NULL,
225:                     .portPowerEnable = BSP_USBVBUSPowerEnable,
226:                     .portOverCurrentDetect = BSP_USBVBUSSwitchOverCurrentDetect,
227:                     .rootHubAvailableCurrent = 500,
228:                     .stopInIdle = false,
229:                     .suspendInSleep = false,
230:                     .usbID = USBHS_ID_0
231:                     
232:                 };
233:                 
234:                 
235:                 
236:                 const USB_HOST_TPL_ENTRY USBTPList[ 1 ] =
237:                 {
238:                 	
239:                     TPL_INTERFACE_CLASS_SUBCLASS_PROTOCOL(0x08, 0x06, 0x50, NULL,  USB_HOST_MSD_INTERFACE) ,
240:                 
241:                 
242:                 
243:                 
244:                 
245:                 
246:                 };
247:                 
248:                 
249:                 const USB_HOST_HCD hcdTable = 
250:                 {
251:                     .drvIndex = DRV_USBHS_INDEX_0,
252:                     .hcdInterface = DRV_USBHS_HOST_INTERFACE
253:                 };
254:                 
255:                 const USB_HOST_INIT usbHostInitData = 
256:                 {
257:                     .nTPLEntries = 1 ,
258:                     .tplList = (USB_HOST_TPL_ENTRY *)USBTPList,
259:                     .hostControllerDrivers = (USB_HOST_HCD *)&hcdTable
260:                     
261:                 };
262:                 
263:                 
264:                 
265:                 // </editor-fold>
266:                 
267:                 // *****************************************************************************
268:                 // *****************************************************************************
269:                 // Section: Static Initialization Functions
270:                 // *****************************************************************************
271:                 // *****************************************************************************
272:                 
273:                 
274:                 // *****************************************************************************
275:                 // *****************************************************************************
276:                 // Section: System Initialization
277:                 // *****************************************************************************
278:                 // *****************************************************************************
279:                 
280:                 /*******************************************************************************
281:                   Function:
282:                     void SYS_Initialize ( void *data )
283:                 
284:                   Summary:
285:                     Initializes the board, services, drivers, application and other modules.
286:                 
287:                   Remarks:
288:                     See prototype in system/common/sys_module.h.
289:                  */
290:                 
291:                 void SYS_Initialize ( void* data )
292:                 {
9D00CC24  27BDFFD0   ADDIU SP, SP, -48
9D00CC28  AFBF002C   SW RA, 44(SP)
9D00CC2C  AFB50028   SW S5, 40(SP)
9D00CC30  AFB40024   SW S4, 36(SP)
9D00CC34  AFB30020   SW S3, 32(SP)
9D00CC38  AFB2001C   SW S2, 28(SP)
9D00CC3C  AFB10018   SW S1, 24(SP)
9D00CC40  AFB00014   SW S0, 20(SP)
293:                     /* Core Processor Initialization */
294:                     SYS_CLK_Initialize( NULL );
9D00CC44  0F400004   JAL SYS_CLK_Initialize
9D00CC48  00002021   ADDU A0, ZERO, ZERO
295:                     sysObj.sysDevcon = SYS_DEVCON_Initialize(SYS_DEVCON_INDEX_0, (SYS_MODULE_INIT*)&sysDevconInit);
9D00CC4C  00002021   ADDU A0, ZERO, ZERO
9D00CC50  3C059D01   LUI A1, -25343
9D00CC54  0F405C9A   JAL SYS_DEVCON_Initialize
9D00CC58  24A55450   ADDIU A1, A1, 21584
9D00CC5C  3C118000   LUI S1, -32768
296:                     SYS_DEVCON_PerformanceConfig(SYS_CLK_SystemFrequencyGet()); //200MHz
9D00CC60  0F405CC2   JAL SYS_CLK_SystemFrequencyGet
9D00CC64  AE220A9C   SW V0, 2716(S1)
9D00CC68  0F4048A0   JAL SYS_DEVCON_PerformanceConfig
9D00CC6C  00402021   ADDU A0, V0, ZERO
297:                     SYS_PORTS_Initialize();
9D00CC70  0F404037   JAL SYS_PORTS_Initialize
9D00CC74  26310A9C   ADDIU S1, S1, 2716
298:                     /* Board Support Package Initialization */
299:                     BSP_Initialize();        
9D00CC78  0F400044   JAL BSP_Initialize
9D00CC7C  3C10BF81   LUI S0, -16511
300:                 
301:                     /* Initialize Drivers */
302:                     
303:                     //configureADCs();
304:                 
305:                     sysObj.drvTmr0 = DRV_TMR_Initialize(DRV_TMR_INDEX_0, (SYS_MODULE_INIT *)&drvTmr0InitData);
9D00CC80  00002021   ADDU A0, ZERO, ZERO
9D00CC84  3C059D01   LUI A1, -25343
9D00CC88  0F403B9F   JAL DRV_TMR_Initialize
9D00CC8C  24A55454   ADDIU A1, A1, 21588
9D00CC90  AE220008   SW V0, 8(S1)
306:                 
307:                     SYS_INT_VectorPrioritySet(INT_VECTOR_T2, INT_PRIORITY_LEVEL4);
308:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_T2, INT_SUBPRIORITY_LEVEL0);
309:                     
310:                     SYS_INT_VectorPrioritySet(INT_VECTOR_CHANGE_NOTICE_G, INT_PRIORITY_LEVEL1);
311:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_CHANGE_NOTICE_G, INT_SUBPRIORITY_LEVEL0);
312:                     
313:                     SYS_INT_VectorPrioritySet(INT_VECTOR_T3, INT_PRIORITY_LEVEL6);
314:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_T3, INT_SUBPRIORITY_LEVEL0);
315:                     
316:                     SYS_INT_VectorPrioritySet(INT_VECTOR_T4, INT_PRIORITY_LEVEL1);
317:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_T4, INT_SUBPRIORITY_LEVEL0);
318:                     
319:                 //    SYS_INT_VectorPrioritySet(INT_VECTOR_T5, INT_PRIORITY_LEVEL1);
320:                 //    SYS_INT_VectorSubprioritySet(INT_VECTOR_T5, INT_SUBPRIORITY_LEVEL0);
321:                     
322:                 //    SYS_INT_VectorPrioritySet(_ADC_FIFO_VECTOR, INT_PRIORITY_LEVEL7);
323:                 //    SYS_INT_VectorSubprioritySet(_ADC_FIFO_VECTOR, INT_SUBPRIORITY_LEVEL0);
324:                     
325:                 //    SYS_INT_VectorPrioritySet(INT_VECTOR_ADC1, INT_PRIORITY_LEVEL6);
326:                 //    SYS_INT_VectorSubprioritySet(INT_VECTOR_ADC1, INT_SUBPRIORITY_LEVEL0);
327:                     
328:                 //    SYS_INT_VectorPrioritySet(INT_VECTOR_ADC1_DATA1, INT_PRIORITY_LEVEL6);
329:                 //    SYS_INT_VectorSubprioritySet(INT_VECTOR_ADC1_DATA1, INT_SUBPRIORITY_LEVEL0);
330:                 //    
331:                 //    SYS_INT_VectorPrioritySet(INT_VECTOR_ADC1_DATA2, INT_PRIORITY_LEVEL6);
332:                 //    SYS_INT_VectorSubprioritySet(INT_VECTOR_ADC1_DATA2, INT_SUBPRIORITY_LEVEL0);
333:                 //    
334:                 //    SYS_INT_VectorPrioritySet(INT_VECTOR_ADC1_DATA3, INT_PRIORITY_LEVEL6);
335:                 //    SYS_INT_VectorSubprioritySet(INT_VECTOR_ADC1_DATA3, INT_SUBPRIORITY_LEVEL0);
336:                 //    
337:                 //    SYS_INT_VectorPrioritySet(INT_VECTOR_ADC1_DATA4, INT_PRIORITY_LEVEL6);
338:                 //    SYS_INT_VectorSubprioritySet(INT_VECTOR_ADC1_DATA4, INT_SUBPRIORITY_LEVEL0);
339:                  
340:                  
341:                     /* Initialize System Services */
342:                 
343:                     /*** File System Service Initialization Code ***/
344:                     SYS_FS_Initialize( (const void *) sysFSInit );
9D00CD80  3C049D01   LUI A0, -25343
9D00CD84  0F4053CA   JAL SYS_FS_Initialize
9D00CD88  2484541C   ADDIU A0, A0, 21532
345:                 
346:                     /*** Interrupt Service Initialization Code ***/
347:                     SYS_INT_Initialize();
9D00CD8C  0F405CA4   JAL SYS_INT_Initialize
9D00CD90  00000000   NOP
348:                 
349:                     /*** TMR Service Initialization Code ***/
350:                     sysObj.sysTmr  = SYS_TMR_Initialize(SYS_TMR_INDEX_0, (const SYS_MODULE_INIT  * const)&sysTmrInitData);
9D00CD94  00002021   ADDU A0, ZERO, ZERO
9D00CD98  3C059D01   LUI A1, -25343
9D00CD9C  0F404DF0   JAL SYS_TMR_Initialize
9D00CDA0  24A55414   ADDIU A1, A1, 21524
9D00CDA4  AE220004   SW V0, 4(S1)
351:                   
352:                     /* Initialize Middleware */
353:                 
354:                 
355:                 
356:                 
357:                     sysObj.usbHostObject0 = USB_HOST_Initialize ((SYS_MODULE_INIT *)& usbHostInitData );
9D00CDA8  3C049D01   LUI A0, -25343
9D00CDAC  0F404790   JAL USB_HOST_Initialize
9D00CDB0  248453EC   ADDIU A0, A0, 21484
9D00CDB4  AE220010   SW V0, 16(S1)
358:                     sysObj.drvUSBObject = DRV_USBHS_Initialize (DRV_USBHS_INDEX_0, (SYS_MODULE_INIT *) &drvUSBHSInit);
9D00CDB8  00002021   ADDU A0, ZERO, ZERO
9D00CDBC  3C058001   LUI A1, -32767
9D00CDC0  0F404A87   JAL DRV_USBHS_Initialize
9D00CDC4  24A54E7C   ADDIU A1, A1, 20092
9D00CDC8  AE22000C   SW V0, 12(S1)
359:                     
360:                 	SYS_INT_VectorPrioritySet(INT_VECTOR_USB1, INT_PRIORITY_LEVEL4);
361:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_USB1, INT_SUBPRIORITY_LEVEL0);
362:                 
363:                     /* Set the priority of the USB DMA Interrupt */
364:                     SYS_INT_VectorPrioritySet(INT_VECTOR_USB1_DMA, INT_PRIORITY_LEVEL4);
365:                     /* Set Sub-priority of the USB DMA Interrupt */
366:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_USB1_DMA, INT_SUBPRIORITY_LEVEL0);
367:                         
368:                     
369:                 
370:                 
371:                     /* Enable Global Interrupts */
372:                     SYS_INT_Enable();
373:                 }
9D00CE34  8FBF002C   LW RA, 44(SP)
374:                 
375:                 
376:                 /*******************************************************************************
377:                  End of File
378:                 */
379:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/system_exceptions.c
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       system_exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the deafult _weak_ exception 
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occured.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  
45:                  #include <xc.h>                 /* Defines special funciton registers, CP0 regs  */
46:                  #include "system_config.h"
47:                  #include "system_definitions.h"
48:                  #include "system/debug/sys_debug.h"
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data Definitions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /*******************************************************************************
58:                    Exception Reason Data
59:                    
60:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
61:                    
62:                    Remarks:
63:                      These global static items are used instead of local variables in the 
64:                      _general_exception_handler function because the stack may not be available
65:                      if an exception has occured.
66:                  */
67:                  
68:                  /* Code identifying the cause of the exception (CP0 Cause register). */
69:                  static unsigned int _excep_code;
70:                  
71:                  /* Address of instruction that caused the exception. */
72:                  static unsigned int _excep_addr;
73:                  
74:                  /* Pointer to the string describing the cause of the exception. */
75:                  static char *_cause_str;
76:                  
77:                  /* Array identifying the cause (indexed by _exception_code). */
78:                  static char *cause[] = 
79:                  {
80:                      "Interrupt",
81:                      "Undefined",
82:                      "Undefined",
83:                      "Undefined",
84:                      "Load/fetch address error",
85:                      "Store address error",
86:                      "Instruction bus error",
87:                      "Data bus error",
88:                      "Syscall",
89:                      "Breakpoint",
90:                      "Reserved instruction",
91:                      "Coprocessor unusable",
92:                      "Arithmetic overflow",
93:                      "Trap",
94:                      "Reserved",
95:                      "Reserved",
96:                      "Reserved",
97:                      "Reserved",
98:                      "Reserved"
99:                  };
100:                 
101:                 // </editor-fold>
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Exception Handling
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void _general_exception_handler ( void )
113:                 
114:                   Summary:
115:                     Overrides the XC32 _weak_ _generic_exception_handler.
116:                     
117:                   Description:
118:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
119:                 
120:                   Remarks:
121:                     Refer to the XC32 User's Guide for additional information.
122:                  */
123:                 
124:                 void _general_exception_handler ( void )
125:                 {
9D016874  27BDFFF8   ADDIU SP, SP, -8
9D016878  AFBF0004   SW RA, 4(SP)
126:                     /* Mask off Mask of the ExcCode Field from the Cause Register
127:                     Refer to the MIPs Software User's manual */
128:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D01687C  40026800   MFC0 V0, Cause
9D016880  7C422080   EXT V0, V0, 2, 5
9D016884  AF828068   SW V0, -32664(GP)
129:                     _excep_addr = _CP0_GET_EPC();
9D016888  40027000   MFC0 V0, EPC
9D01688C  AF828064   SW V0, -32668(GP)
130:                     _cause_str  = cause[_excep_code];
9D016890  8F828068   LW V0, -32664(GP)
9D016894  00021080   SLL V0, V0, 2
9D016898  3C039D01   LUI V1, -25343
9D01689C  24631A94   ADDIU V1, V1, 6804
9D0168A0  7C62100A   LWX V0, V0(V1)
9D0168A4  AF828060   SW V0, -32672(GP)
131:                 
132:                     SYS_DEBUG_PRINT(SYS_ERROR_ERROR, "\nGeneral Exception %s (cause=%d, addr=%x).\n", 
133:                                     _cause_str, _excep_code, _excep_addr);
134:                 
135:                     while (1)
136:                     {
137:                         SYS_DEBUG_BreakPoint();
9D0168A8  7000003F   SDBBP 0
138:                     }
139:                 }
140:                 
141:                 
142:                 void _simple_tlb_refill_exception_handler(void){
143:                     while (1)
144:                     {
145:                         SYS_DEBUG_BreakPoint();
9D017344  7000003F   SDBBP 0
146:                     }
147:                 }
148:                 void _cache_err_exception_handler(void){
149:                     while (1)
150:                     {
151:                         SYS_DEBUG_BreakPoint();
9D017350  7000003F   SDBBP 0
152:                     }
153:                 }
154:                 void _nmi_handler (void){
155:                     while (1)
156:                     {
157:                         SYS_DEBUG_BreakPoint();
9D01735C  7000003F   SDBBP 0
158:                     }
159:                 }
160:                 /*******************************************************************************
161:                  End of File
162:                 */
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/usb/src/dynamic/usb_host_scsi.c
1:                   /*******************************************************************************
2:                     USB Host SCSI Driver Implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_host_scsi.c
9:                   
10:                    Summary:
11:                      This file contains implementations of both private and public functions
12:                      of the USB Host MSD SCSI client driver.
13:                  
14:                    Description:
15:                      This file contains the USB Host MSD SCSI client driver implementation. This
16:                      file should be included in the project if USB MSD devices are to be
17:                      supported.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute Software
25:                  only when embedded on a Microchip microcontroller or digital  signal  controller
26:                  that is integrated into your product or third party  product  (pursuant  to  the
27:                  sub-license terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
33:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
37:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
39:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
40:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  #include "usb/usb_host_msd.h"
46:                  #include "usb/usb_host_scsi.h"
47:                  #include "usb/scsi.h"
48:                  #include "usb/src/usb_host_scsi_local.h"
49:                  #include "system/fs/sys_fs_media_manager.h"
50:                  #include "system/debug/sys_debug.h"
51:                  
52:                  /******************************************************
53:                   * USB HOST MSD SCSI Instance object. One for each LUN
54:                   ******************************************************/
55:                  
56:                  USB_HOST_SCSI_INSTANCE_OBJ gUSBHostSCSIObj[USB_HOST_MSD_LUN_NUMBERS];
57:                  
58:                  /******************************************************
59:                   * USB HOST MSD SCSI buffers needed for SCSI operation
60:                   ******************************************************/
61:                  
62:                  uint8_t gUSBSCSIBuffer[USB_HOST_MSD_LUN_NUMBERS][256] __attribute__((coherent)) __attribute__((aligned(16)));
63:                  
64:                  /*****************************************************
65:                   * USB HOST SCSI Attach Listeners.
66:                   *****************************************************/
67:                  USB_HOST_SCSI_ATTACH_LISTENER_OBJ gUSBHostSCSIAttachListener[USB_HOST_SCSI_ATTACH_LISTENERS_NUMBER];
68:                  
69:                  /*****************************************************
70:                   * Media functions table that is exported to the
71:                   * file system. Structure is defined by the file
72:                   * system.
73:                   *****************************************************/
74:                  SYS_FS_MEDIA_FUNCTIONS gUSBHostMSDSCSIMediaFunctions =
75:                  {
76:                      .mediaStatusGet     = USB_HOST_SCSI_MediaStatusGet,
77:                      .mediaGeometryGet   = USB_HOST_SCSI_MediaGeometryGet,
78:                      .sectorRead         = USB_HOST_SCSI_SectorRead,
79:                      .sectorWrite        = USB_HOST_SCSI_SectorWrite,
80:                      .eventHandlerset    = USB_HOST_SCSI_EventHandlerSet,
81:                      .open               = USB_HOST_SCSI_Open,
82:                      .close              = USB_HOST_SCSI_Close,
83:                      .tasks              = USB_HOST_SCSI_TransferTasks
84:                  };
85:                  
86:                  /****************************************************
87:                   * If the USB_HOST_SCSI_ERROR_CALLBACK option is set
88:                   * to true, then this declares a callback function.
89:                   ****************************************************/
90:                  _USB_HOST_SCSI_ERROR_CALLBACK_DECLARE
91:                  
92:                  // ******************************************************************************
93:                  // ******************************************************************************
94:                  // Local Functions
95:                  // ******************************************************************************
96:                  // ******************************************************************************
97:                  
98:                  // *****************************************************************************
99:                  /* Function:
100:                     void * _USB_HOST_SCSI_TimerCallback
101:                     (
102:                        uint32_t context,
103:                        uint32_t currtick
104:                     )
105:                 
106:                   Summary:
107:                     Function is called when the SYS_TMR_CallbackSingle expires.
108:                 
109:                   Description:
110:                     Function is called when the SYS_TMR_CallbackSingle expires.
111:                 
112:                   Remarks:
113:                     This is a local function and should not be called directly by the
114:                     application.
115:                 */    
116:                 
117:                 void _USB_HOST_SCSI_TimerCallback(uint32_t context, uint32_t currtick)
118:                 {
119:                     /* The handle is actually a pointer to the SCSI object */
120:                     USB_HOST_SCSI_INSTANCE_OBJ * scsiObj = ((USB_HOST_SCSI_INSTANCE_OBJ *)(context));
121:                     scsiObj->timerExpired = true;
9D017338  24020001   ADDIU V0, ZERO, 1
122:                 }
123:                 
124:                 // ******************************************************************************
125:                 /* Function:
126:                     void _USB_HOST_SCSI_Transfer 
127:                     (
128:                         USB_HOST_SCSI_HANDLE scsiHandle,
129:                         USB_HOST_MSD_TRANSFER_HANDLE * transferHandle,
130:                         uint32_t startSector
131:                         uint32_t nSectors
132:                         void * buffer
133:                         USB_HOST_MSD_TRANSFER_DIRECTION direction
134:                     )
135:                 
136:                   Summary:
137:                     This function performs a block read or block write.
138:                 
139:                   Description:
140:                     This function performs a block read or block write.
141:                 
142:                   Remarks:
143:                     This is a local function and should not be called directly by the
144:                     application.
145:                 */
146:                 
147:                 void _USB_HOST_SCSI_Transfer 
148:                 (
149:                     USB_HOST_SCSI_HANDLE scsiHandle,
150:                     USB_HOST_MSD_TRANSFER_HANDLE * transferHandle,
151:                     uint32_t startSector,
152:                     uint32_t nSectors,
153:                     void * buffer,
154:                     USB_HOST_MSD_TRANSFER_DIRECTION direction
155:                 )
156:                 {
9D00F1BC  27BDFFC8   ADDIU SP, SP, -56
9D00F1C0  AFBF0034   SW RA, 52(SP)
9D00F1C4  AFB10030   SW S1, 48(SP)
9D00F1C8  AFB0002C   SW S0, 44(SP)
9D00F1CC  00808021   ADDU S0, A0, ZERO
157:                     USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
158:                     USB_HOST_SCSI_COMMAND_OBJ * commandObj;
159:                     USB_HOST_MSD_RESULT result;
160:                     USB_HOST_MSD_TRANSFER_HANDLE temp, * commandHandle;
161:                 
162:                     /* If the transfer handle parameter is NULL, we set up a local variable to
163:                      * temporarily store the transfer handle */
164:                 
165:                     if(transferHandle == NULL)
166:                     {
167:                         commandHandle = &temp;
9D00F1D0  27B10020   ADDIU S1, SP, 32
168:                     }
169:                     else
170:                     {
171:                         commandHandle = transferHandle;
172:                     }
173:                 
174:                     /* Validate the handle */
175:                     if((scsiHandle == USB_HOST_SCSI_HANDLE_INVALID) || (scsiHandle == 0))
9D00F1D4  2482FFFF   ADDIU V0, A0, -1
9D00F1D8  2C42FFFE   SLTIU V0, V0, -2
9D00F1DC  14400004   BNE V0, ZERO, 0x9D00F1F0
9D00F1E0  00A5880B   MOVN S1, A1, A1
176:                     {
177:                         *commandHandle = SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
9D00F1E4  2402FFFF   ADDIU V0, ZERO, -1
9D00F1E8  0B403CD0   J 0x9D00F340
9D00F1EC  AE220000   SW V0, 0(S1)
178:                     }
179:                     else
180:                     {
181:                         /* The handle is actually a pointer to the SCSI object */
182:                         scsiObj = (USB_HOST_SCSI_INSTANCE_OBJ *)(scsiHandle);
183:                 
184:                         if((scsiObj->inUse) && (scsiObj->state == USB_HOST_SCSI_STATE_READY) &&
9D00F1F0  90820000   LBU V0, 0(A0)
9D00F1F4  1040004D   BEQ V0, ZERO, 0x9D00F32C
9D00F1F8  2402FFFF   ADDIU V0, ZERO, -1
9D00F1FC  8C830008   LW V1, 8(A0)
9D00F200  24020008   ADDIU V0, ZERO, 8
9D00F204  14620049   BNE V1, V0, 0x9D00F32C
9D00F208  2402FFFF   ADDIU V0, ZERO, -1
9D00F20C  9082001C   LBU V0, 28(A0)
9D00F210  14400046   BNE V0, ZERO, 0x9D00F32C
9D00F214  2402FFFF   ADDIU V0, ZERO, -1
185:                                 (!scsiObj->commandObj.inUse) && (scsiObj->isMediaReady))
9D00F218  908200CD   LBU V0, 205(A0)
9D00F21C  10400043   BEQ V0, ZERO, 0x9D00F32C
9D00F220  2402FFFF   ADDIU V0, ZERO, -1
186:                         {
187:                 
188:                             /* Check if the media is write protected */
189:                             if((direction == USB_HOST_MSD_TRANSFER_DIRECTION_HOST_TO_DEVICE) && (scsiObj->isWriteProtected))
9D00F224  8FA2004C   LW V0, 76(SP)
9D00F228  14400007   BNE V0, ZERO, 0x9D00F248
9D00F22C  24020001   ADDIU V0, ZERO, 1
9D00F230  908200CC   LBU V0, 204(A0)
9D00F234  1040003F   BEQ V0, ZERO, 0x9D00F334
9D00F238  24020001   ADDIU V0, ZERO, 1
190:                             {
191:                                 *commandHandle = SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
9D00F23C  2402FFFF   ADDIU V0, ZERO, -1
9D00F240  0B403CD0   J 0x9D00F340
9D00F244  AE220000   SW V0, 0(S1)
192:                             }
193:                             else
194:                             {
195:                                 /* This means the SCSI instance is valid and the command object is
196:                                  * available. Start by grabbing the command object */
197:                 
198:                                 scsiObj->commandObj.inUse = true;
9D00F248  A082001C   SB V0, 28(A0)
9D00F334  A082001C   SB V0, 28(A0)
199:                                 commandObj = &scsiObj->commandObj;
9D00F24C  2483001C   ADDIU V1, A0, 28
9D00F338  0B403C9C   J 0x9D00F270
9D00F33C  2483001C   ADDIU V1, A0, 28
200:                 
201:                                 /* Set up the command based on direction */
202:                                 if(direction == USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST)
9D00F250  24020080   ADDIU V0, ZERO, 128
9D00F254  8FA4004C   LW A0, 76(SP)
9D00F258  14820006   BNE A0, V0, 0x9D00F274
9D00F25C  2402002A   ADDIU V0, ZERO, 42
203:                                 {
204:                                     commandObj->cdb[0] = USB_HOST_SCSI_READ10_COMMAND;
9D00F260  24020028   ADDIU V0, ZERO, 40
9D00F264  A202001D   SB V0, 29(S0)
9D00F268  0B403CA0   J 0x9D00F280
9D00F26C  A200001E   SB ZERO, 30(S0)
205:                                     commandObj->cdb[1] = 0x00;
206:                                 }
207:                                 else
208:                                 {
209:                                     commandObj->cdb[0] = USB_HOST_SCSI_WRITE10_COMMAND;
9D00F270  2402002A   ADDIU V0, ZERO, 42
9D00F274  A202001D   SB V0, 29(S0)
210:                 
211:                                     /* Set the FUA bit in the command so that the media will
212:                                      * the completed the command only when the data has been 
213:                                      * written to the media. */
214:                                     commandObj->cdb[1] = 0x04;
9D00F278  24020004   ADDIU V0, ZERO, 4
9D00F27C  A202001E   SB V0, 30(S0)
215:                                 }
216:                 
217:                                 /* Set up the sector address */
218:                                 commandObj->cdb[2] = (uint8_t)(startSector >> 24);
9D00F280  00061602   SRL V0, A2, 24
9D00F284  A202001F   SB V0, 31(S0)
219:                                 commandObj->cdb[3] = (uint8_t)(startSector >> 16);
9D00F288  00061402   SRL V0, A2, 16
9D00F28C  A2020020   SB V0, 32(S0)
220:                                 commandObj->cdb[4] = (uint8_t)(startSector >> 8);
9D00F290  00061202   SRL V0, A2, 8
9D00F294  A2020021   SB V0, 33(S0)
221:                                 commandObj->cdb[5] = (uint8_t)(startSector);
9D00F298  A2060022   SB A2, 34(S0)
222:                 
223:                                 /* The number of sectors to read or write */
224:                                 commandObj->cdb[6] = 0x00;
9D00F29C  A2000023   SB ZERO, 35(S0)
225:                                 commandObj->cdb[7] = (uint8_t)(nSectors >> 8);
9D00F2A0  00071202   SRL V0, A3, 8
9D00F2A4  A2020024   SB V0, 36(S0)
226:                                 commandObj->cdb[8] = (uint8_t)(nSectors);
9D00F2A8  A2070025   SB A3, 37(S0)
227:                                 commandObj->cdb[9] = 0x00;
9D00F2AC  A2000026   SB ZERO, 38(S0)
228:                 
229:                                 /* Initialize the command handle */
230:                                 *commandHandle = (SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE)(commandObj);
9D00F2B0  AE230000   SW V1, 0(S1)
231:                 
232:                                 /* Make sure the transfer state is set to a know value */
233:                                 scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_IDLE;
9D00F2B4  AE00000C   SW ZERO, 12(S0)
234:                 
235:                                 /* Set the command delay to 0 */
236:                                 scsiObj->nCommandFailureTestUnitReadyAttempts = 0;
9D00F2B8  AE0000D0   SW ZERO, 208(S0)
237:                 
238:                                 /* Initialize the other members of the command object. These
239:                                  * would be needed if an error has occurred and the block
240:                                  * command needs to retried. */
241:                 
242:                                 scsiObj->commandObj.nSectors = nSectors;
9D00F2BC  AE07003C   SW A3, 60(S0)
243:                                 scsiObj->commandObj.direction = direction;
9D00F2C0  8FA2004C   LW V0, 76(SP)
9D00F2C4  AE020040   SW V0, 64(S0)
244:                                 scsiObj->commandObj.buffer = buffer;
9D00F2C8  8FA40048   LW A0, 72(SP)
9D00F2CC  AE040038   SW A0, 56(S0)
245:                 
246:                                 /* Schedule the transfer */
247:                                 result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, 
9D00F2D0  8E040018   LW A0, 24(S0)
9D00F2D8  AFA70010   SW A3, 16(SP)
9D00F2DC  AFA20014   SW V0, 20(SP)
9D00F2E0  3C029D01   LUI V0, -25343
9D00F2E4  24424B24   ADDIU V0, V0, 19236
9D00F2E8  AFA20018   SW V0, 24(SP)
9D00F2EC  AFB0001C   SW S0, 28(SP)
9D00F2F0  2605001D   ADDIU A1, S0, 29
9D00F2F4  2406000A   ADDIU A2, ZERO, 10
9D00F2F8  0F403ACA   JAL USB_HOST_MSD_Transfer
9D00F2FC  8FA70048   LW A3, 72(SP)
248:                                         scsiObj->commandObj.cdb, 0x0A, buffer , (nSectors << 9) /* The left shift multiplies by 512 */, 
9D00F2D4  00073A40   SLL A3, A3, 9
249:                                         direction, _USB_HOST_SCSI_BlockTransferCallback, (uintptr_t)(scsiObj));
250:                 
251:                                 if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D00F300  24030003   ADDIU V1, ZERO, 3
9D00F304  1043000E   BEQ V0, V1, 0x9D00F340
9D00F308  24030005   ADDIU V1, ZERO, 5
252:                                 {
253:                                     /* This means the transfer was scheduled. We dont have to do
254:                                      * anything. */
255:                                 }
256:                                 else if(result == USB_HOST_MSD_RESULT_BUSY)
9D00F30C  14430004   BNE V0, V1, 0x9D00F320
9D00F310  2402FFFF   ADDIU V0, ZERO, -1
257:                                 {
258:                                     /* The transfer could not be scheduled because the MSD
259:                                      * driver is busy completing another transfer. We let the
260:                                      * SCSI transfer tasks continue to try scheduling the
261:                                      * transfer. The caller will still get a valid command
262:                                      * handle */
263:                 
264:                                     scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_BLOCK_COMMAND_RETRY;
9D00F314  24020007   ADDIU V0, ZERO, 7
9D00F318  0B403CD0   J 0x9D00F340
9D00F31C  AE02000C   SW V0, 12(S0)
265:                                     _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiHandle, USB_HOST_SCSI_ERROR_CODE_BOT_REQUEST_DEFERRED);
266:                                 }
267:                                 else 
268:                                 {
269:                                     /* The request failed. Return the command object continue
270:                                      * and return an invalid handle */
271:                 
272:                                     SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host SCSI: Could not schedule BOT transfer");
273:                                     *commandHandle = SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
9D00F320  AE220000   SW V0, 0(S1)
274:                                     commandObj->inUse = false;
9D00F324  0B403CD0   J 0x9D00F340
9D00F328  A200001C   SB ZERO, 28(S0)
275:                                 }
276:                             }
277:                         }
278:                         else
279:                         {
280:                             /* The SCSI instance is not ready */
281:                             SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host SCSI: SCSI Instance is not ready");
282:                             *commandHandle = SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
9D00F32C  0B403CD0   J 0x9D00F340
9D00F330  AE220000   SW V0, 0(S1)
283:                             _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiHandle, USB_HOST_SCSI_ERROR_CODE_INSTANCE_BUSY);
284:                         }
285:                     }
286:                 }
9D00F340  8FBF0034   LW RA, 52(SP)
287:                 
288:                 // ******************************************************************************
289:                 /* Function:
290:                     void _USB_HOST_SCSI_CommandCallback 
291:                     (
292:                         USB_HOST_MSD_LUN_HANDLE lunHandle,
293:                         USB_HOST_MSD_TRANSFER_HANDLE transferHandle,
294:                         USB_HOST_MSD_RESULT result,
295:                         size_t size,
296:                         uintptr_t context
297:                     )
298:                 
299:                   Summary:
300:                     This function is called when a SCSI command related MSD transfer has
301:                     completed.
302:                 
303:                   Description:
304:                     This function is called when a SCSI command related MSD transfer has
305:                     completed.
306:                 
307:                   Remarks:
308:                     This is a local function and should not be called directly by the
309:                     application.
310:                 */
311:                 
312:                 void _USB_HOST_SCSI_CommandCallback 
313:                 (
314:                     USB_HOST_MSD_LUN_HANDLE lunHandle,
315:                     USB_HOST_MSD_TRANSFER_HANDLE transferHandle,
316:                     USB_HOST_MSD_RESULT result,
317:                     size_t size,
318:                     uintptr_t context
319:                 )
320:                 {
9D017168  8FA20010   LW V0, 16(SP)
321:                     USB_HOST_SCSI_COMMAND_OBJ * commandObj;
322:                 
323:                     /* The context for this callback is the pointer to the command object
324:                      * related to the callback. */
325:                     commandObj = (USB_HOST_SCSI_COMMAND_OBJ *)(context);
326:                 
327:                     /* The processed size */
328:                     commandObj->size = size;
9D01716C  AC470018   SW A3, 24(V0)
329:                 
330:                     /* The result of the command */
331:                     commandObj->result = result;
9D017170  AC460014   SW A2, 20(V0)
332:                     
333:                     /* Let the main state machine know that the command is completed */
334:                     commandObj->commandCompleted = true;
9D017174  24030001   ADDIU V1, ZERO, 1
9D017178  A0430011   SB V1, 17(V0)
335:                 
336:                     /* Release the command object */
337:                     commandObj->inUse = false;
9D01717C  03E00008   JR RA
338:                 }
339:                 
340:                 // ******************************************************************************
341:                 /* Function:
342:                     void _USB_HOST_SCSI_BlockTransferCallback 
343:                     (
344:                         USB_HOST_MSD_LUN_HANDLE lunHandle,
345:                         USB_HOST_MSD_TRANSFER_HANDLE transferHandle,
346:                         USB_HOST_MSD_RESULT result,
347:                         size_t size,
348:                         uintptr_t context
349:                     )
350:                 
351:                   Summary:
352:                     This function is called when a MSD SCSI Block transfer has completed.
353:                 
354:                   Description:
355:                     This function is called when a MSD SCSI Block transfer has completed.
356:                 
357:                   Remarks:
358:                     This is a local function and should not be called directly by the
359:                     application.
360:                 */
361:                 
362:                 void _USB_HOST_SCSI_BlockTransferCallback 
363:                 (
364:                     USB_HOST_MSD_LUN_HANDLE lunHandle,
365:                     USB_HOST_MSD_TRANSFER_HANDLE transferHandle,
366:                     USB_HOST_MSD_RESULT result,
367:                     size_t size,
368:                     uintptr_t context
369:                 )
370:                 {
9D014B24  27BDFFE0   ADDIU SP, SP, -32
9D014B28  AFBF001C   SW RA, 28(SP)
9D014B2C  AFB20018   SW S2, 24(SP)
9D014B30  AFB10014   SW S1, 20(SP)
9D014B34  AFB00010   SW S0, 16(SP)
9D014B38  00C08821   ADDU S1, A2, ZERO
371:                     int scsiObjIndex;
372:                     USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
373:                     USB_HOST_SCSI_COMMAND_OBJ * commandObj;
374:                 
375:                     /* Get the SCSI object index from the lunHandle */
376:                     scsiObjIndex = _USB_HOST_SCSI_LUNHandleToSCSIInstance(lunHandle);
9D014B3C  0F405B53   JAL _USB_HOST_SCSI_LUNHandleToSCSIInstance
9D014B40  00E09021   ADDU S2, A3, ZERO
377:                 
378:                     /* Get the pointer to the SCSI object */
379:                     scsiObj = &gUSBHostSCSIObj[scsiObjIndex];
9D014B44  00021940   SLL V1, V0, 5
9D014B48  00021200   SLL V0, V0, 8
9D014B4C  00431023   SUBU V0, V0, V1
9D014B50  3C108000   LUI S0, -32768
9D014B54  261009BC   ADDIU S0, S0, 2492
9D014B58  02028021   ADDU S0, S0, V0
380:                 
381:                     /* Pointer to the command object */
382:                     commandObj = &scsiObj->commandObj;
383:                 
384:                     /* The processed size */
385:                     commandObj->size = size;
9D014B5C  AE120034   SW S2, 52(S0)
386:                 
387:                     /* The result of the command */
388:                     commandObj->result = result;
9D014B60  AE110030   SW S1, 48(S0)
389:                 
390:                     /* Let the main state machine know that the command is completed */
391:                     commandObj->commandCompleted = true;
9D014B64  24020001   ADDIU V0, ZERO, 1
9D014B68  A202002D   SB V0, 45(S0)
392:                 
393:                     if((result == USB_HOST_MSD_RESULT_SUCCESS) || (result == USB_HOST_MSD_RESULT_COMMAND_PASSED))
9D014B6C  24020003   ADDIU V0, ZERO, 3
9D014B70  52220004   BEQL S1, V0, 0x9D014B84
9D014B74  8E0200C0   LW V0, 192(S0)
9D014B78  16200009   BNE S1, ZERO, 0x9D014BA0
9D014B7C  24020001   ADDIU V0, ZERO, 1
394:                     {
395:                         /* If there is an event handler registered, then call the event handler
396:                          * */
397:                         if(scsiObj->eventHandler != NULL)
9D014B80  8E0200C0   LW V0, 192(S0)
9D014B84  10400004   BEQ V0, ZERO, 0x9D014B98
9D014B88  00002021   ADDU A0, ZERO, ZERO
398:                         {
399:                             /* Generate the event */
400:                             (scsiObj->eventHandler)(USB_HOST_SCSI_EVENT_COMMAND_COMPLETE, (USB_HOST_SCSI_COMMAND_HANDLE)(commandObj), scsiObj->context);
9D014B8C  2605001C   ADDIU A1, S0, 28
9D014B90  0040F809   JALR V0
9D014B94  8E0600C4   LW A2, 196(S0)
401:                         }
402:                         
403:                         /* Return the command object */
404:                         commandObj->inUse = false;
9D014B98  0B4052E9   J 0x9D014BA4
9D014B9C  A200001C   SB ZERO, 28(S0)
405:                     }
406:                     else
407:                     {
408:                         /* The command failed. Transfer control to the transfer state machine to
409:                          * find out why */
410:                 
411:                         scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_REQUEST_SENSE;
9D014BA0  AE02000C   SW V0, 12(S0)
412:                     }
413:                 }
9D014BA4  8FBF001C   LW RA, 28(SP)
414:                 
415:                 // ******************************************************************************
416:                 /* Function:
417:                     void _USB_HOST_SCSI_TestUnitReadyCommand 
418:                     (
419:                         uint8_t * scsiCommand
420:                     )
421:                 
422:                   Summary:
423:                     Sets up the Test Unit Ready command.
424:                 
425:                   Description:
426:                     This function sets up the Test Unit Ready Command.
427:                 
428:                   Remarks:
429:                     This is a local function and should not be called directly by the
430:                     application.
431:                 */
432:                 
433:                 void _USB_HOST_SCSI_TestUnitReadyCommand (uint8_t * scsiCommand )
434:                 {
435:                     /* Set up the Test Unit Ready command */
436:                     scsiCommand[0] = SCSI_TEST_UNIT_READY;
9D017184  A0800000   SB ZERO, 0(A0)
437:                     scsiCommand[1] = 0x00;
9D017188  A0800001   SB ZERO, 1(A0)
438:                     scsiCommand[2] = 0x00;
9D01718C  A0800002   SB ZERO, 2(A0)
439:                     scsiCommand[3] = 0x00;
9D017190  A0800003   SB ZERO, 3(A0)
440:                     scsiCommand[4] = 0x00;
9D017194  A0800004   SB ZERO, 4(A0)
441:                     scsiCommand[5] = 0x00;
9D017198  03E00008   JR RA
442:                 
443:                 }
444:                 
445:                 // ******************************************************************************
446:                 /* Function:
447:                     void _USB_HOST_SCSI_RequestSenseCommand 
448:                     (
449:                         uint8_t * scsiCommand
450:                     )
451:                 
452:                   Summary:
453:                     Sets up the Request Sense command.
454:                 
455:                   Description:
456:                     This function sets up the Request Sense Command.
457:                 
458:                   Remarks:
459:                     This is a local function and should not be called directly by the
460:                     application.
461:                 */
462:                 
463:                 void _USB_HOST_SCSI_RequestSenseCommand (uint8_t * scsiCommand )
464:                 {
465:                     /* Set up the Request Sense Command */
466:                     scsiCommand[0] = SCSI_REQUEST_SENSE;
9D016FA4  24020003   ADDIU V0, ZERO, 3
9D016FA8  A0820000   SB V0, 0(A0)
467:                     scsiCommand[1] = 0x00;
9D016FAC  A0800001   SB ZERO, 1(A0)
468:                     scsiCommand[2] = 0x00;
9D016FB0  A0800002   SB ZERO, 2(A0)
469:                     scsiCommand[3] = 0x00;
9D016FB4  A0800003   SB ZERO, 3(A0)
470:                     scsiCommand[4] = 0xFF;
9D016FB8  2402FFFF   ADDIU V0, ZERO, -1
9D016FBC  A0820004   SB V0, 4(A0)
471:                     scsiCommand[5] = 0x00;
9D016FC0  03E00008   JR RA
472:                 }
473:                 
474:                 // ******************************************************************************
475:                 /* Function:
476:                     void _USB_HOST_SCSI_ReadCapacityCommand
477:                     (
478:                         uint8_t * scsiCommand
479:                     )
480:                 
481:                   Summary:
482:                     Sets up the Read Capacity Command.
483:                 
484:                   Description:
485:                     This function sets up the Read Capacity Command.
486:                 
487:                   Remarks:
488:                     This is a local function and should not be called directly by the
489:                     application.
490:                 */
491:                 
492:                 void _USB_HOST_SCSI_ReadCapacityCommand (uint8_t * scsiCommand )
493:                 {
494:                     /* Set up the Read Capacity Command */
495:                     scsiCommand[0] = SCSI_READ_CAPACITY;
9D016B84  24020025   ADDIU V0, ZERO, 37
9D016B88  A0820000   SB V0, 0(A0)
496:                     scsiCommand[1] = 0x00;
9D016B8C  A0800001   SB ZERO, 1(A0)
497:                     scsiCommand[2] = 0x00;
9D016B90  A0800002   SB ZERO, 2(A0)
498:                     scsiCommand[3] = 0x00;
9D016B94  A0800003   SB ZERO, 3(A0)
499:                     scsiCommand[4] = 0x00;
9D016B98  A0800004   SB ZERO, 4(A0)
500:                     scsiCommand[5] = 0x00;
9D016B9C  A0800005   SB ZERO, 5(A0)
501:                     scsiCommand[6] = 0x00;
9D016BA0  A0800006   SB ZERO, 6(A0)
502:                     scsiCommand[7] = 0x00;
9D016BA4  A0800007   SB ZERO, 7(A0)
503:                     scsiCommand[8] = 0x00;
9D016BA8  A0800008   SB ZERO, 8(A0)
504:                     scsiCommand[9] = 0x00;
9D016BAC  03E00008   JR RA
505:                 }
506:                 
507:                 // ******************************************************************************
508:                 /* Function:
509:                     void _USB_HOST_SCSI_InquiryResponseCommand 
510:                     (
511:                         uint8_t * scsiCommand
512:                     )
513:                 
514:                   Summary:
515:                     Sets up the SCSI Inquiry Response command.
516:                 
517:                   Description:
518:                     This function sets up the SCSI Inquiry Response Command.
519:                 
520:                   Remarks:
521:                     This is a local function and should not be called directly by the
522:                     application.
523:                 */
524:                 
525:                 void _USB_HOST_SCSI_InquiryResponseCommand (uint8_t * scsiCommand )
526:                 {
527:                     /* Set up the SCSI Inquiry command */
528:                     scsiCommand[0] = SCSI_INQUIRY;
9D016FC8  24020012   ADDIU V0, ZERO, 18
9D016FCC  A0820000   SB V0, 0(A0)
529:                     scsiCommand[1] = 0x00;
9D016FD0  A0800001   SB ZERO, 1(A0)
530:                     scsiCommand[2] = 0x00;
9D016FD4  A0800002   SB ZERO, 2(A0)
531:                     scsiCommand[3] = 0x00;
9D016FD8  A0800003   SB ZERO, 3(A0)
532:                     scsiCommand[4] = 0x24;
9D016FDC  24020024   ADDIU V0, ZERO, 36
9D016FE0  A0820004   SB V0, 4(A0)
533:                     scsiCommand[5] = 0x00;
9D016FE4  03E00008   JR RA
534:                 }
535:                 
536:                 // ******************************************************************************
537:                 /* Function:
538:                     void _USB_HOST_SCSI_ModeSense
539:                     (
540:                         uint8_t * scsiCommand
541:                     )
542:                 
543:                   Summary:
544:                     Sets up the SCSI Mode Sense command.
545:                 
546:                   Description:
547:                     This function sets up the SCSI Mode Sense Command.
548:                 
549:                   Remarks:
550:                     This is a local function and should not be called directly by the
551:                     application.
552:                 */
553:                 
554:                 void _USB_HOST_SCSI_ModeSense (uint8_t * scsiCommand )
555:                 {
556:                     /* Set up the Read Format Capacity Command's CDB. */
557:                     scsiCommand[0] = SCSI_MODE_SENSE;
9D016D20  2402001A   ADDIU V0, ZERO, 26
9D016D24  A0820000   SB V0, 0(A0)
558:                     scsiCommand[1] = 0x00;
9D016D28  A0800001   SB ZERO, 1(A0)
559:                     scsiCommand[2] = 0x1C;
9D016D2C  2402001C   ADDIU V0, ZERO, 28
9D016D30  A0820002   SB V0, 2(A0)
560:                     scsiCommand[3] = 0x00;
9D016D34  A0800003   SB ZERO, 3(A0)
561:                     scsiCommand[4] = 192;
9D016D38  2402FFC0   ADDIU V0, ZERO, -64
9D016D3C  A0820004   SB V0, 4(A0)
562:                     scsiCommand[5] = 0x00;
9D016D40  A0800005   SB ZERO, 5(A0)
563:                     scsiCommand[9] = 0x00;
9D016D44  03E00008   JR RA
564:                 }
565:                 
566:                 // ******************************************************************************
567:                 /* Function:
568:                     int _USB_HOST_SCSI_LUNHandleToSCSIInstance 
569:                     (
570:                         USB_HOST_MSD_LUN_HANDLE lunHandle
571:                     )
572:                 
573:                   Summary:
574:                     This function maps a LUN Handle to the SCSI instance.
575:                 
576:                   Description:
577:                     This function maps a LUN Handle to the SCSI instance. It returns the index
578:                     of the SCSI object. It will return -1 if the object is not found.
579:                 
580:                   Remarks:
581:                     This is a local function and should not be called directly by the
582:                     application.
583:                 */
584:                 
585:                 int _USB_HOST_SCSI_LUNHandleToSCSIInstance
586:                 (
587:                     USB_HOST_MSD_LUN_HANDLE lunHandle
588:                 )
589:                 {
590:                     int iterator;
591:                     int result = -1;
592:                     
593:                     for(iterator = 0;iterator < USB_HOST_MSD_LUN_NUMBERS; iterator ++)
594:                     {
595:                         if(gUSBHostSCSIObj[iterator].inUse)
9D016D4C  3C038000   LUI V1, -32768
9D016D50  906309BC   LBU V1, 2492(V1)
9D016D54  10600006   BEQ V1, ZERO, 0x9D016D70
9D016D58  2402FFFF   ADDIU V0, ZERO, -1
596:                         {
597:                             if(gUSBHostSCSIObj[iterator].lunHandle == lunHandle)
9D016D5C  3C028000   LUI V0, -32768
9D016D60  8C4209D4   LW V0, 2516(V0)
9D016D64  00441026   XOR V0, V0, A0
9D016D68  0002102B   SLTU V0, ZERO, V0
9D016D6C  00021023   SUBU V0, ZERO, V0
598:                             {
599:                                 /* Got a match */
600:                                 result = iterator;
601:                                 break;
602:                             }
603:                         }
604:                     }
605:                 
606:                     return(result);
607:                 }
9D016D70  03E00008   JR RA
608:                 
609:                 // ******************************************************************************
610:                 /* Function:
611:                     void USB_HOST_SCSI_Initialize (USB_HOST_MSD_LUN_HANDLE lunHandle)
612:                 
613:                   Summary:
614:                     This function is called by the MSD Host Client Driver for detected LUN.
615:                 
616:                   Description:
617:                     This function is called by the MSD Host Client Driver for detected LUN. The
618:                     function will then register this LUN as drive with the file system media
619:                     manager, thus allowing the media manager to access this drive.
620:                 
621:                   Remarks:
622:                     The application will never need to call this function. This function is
623:                     always called the USB Host MSD Client Driver.
624:                 */
625:                 
626:                 void USB_HOST_SCSI_Initialize(USB_HOST_MSD_LUN_HANDLE lunHandle)
627:                 {
9D015680  27BDFFE0   ADDIU SP, SP, -32
9D015684  AFBF001C   SW RA, 28(SP)
9D015688  AFB20018   SW S2, 24(SP)
9D01568C  AFB10014   SW S1, 20(SP)
9D015690  AFB00010   SW S0, 16(SP)
9D015694  00808021   ADDU S0, A0, ZERO
628:                     int iterator;
629:                     USB_HOST_SCSI_INSTANCE_OBJ * scsiObj = NULL;
630:                 
631:                     /* Search for a free SCSI object */
632:                     for(iterator = 0; iterator < USB_HOST_MSD_LUN_NUMBERS; iterator ++)
633:                     {
634:                         if(!gUSBHostSCSIObj[iterator].inUse)
9D015670  3C028000   LUI V0, -32768
9D015674  904209BC   LBU V0, 2492(V0)
9D015678  1440001B   BNE V0, ZERO, 0x9D0156E8
9D01567C  00002821   ADDU A1, ZERO, ZERO
635:                         {
636:                             scsiObj = &gUSBHostSCSIObj[iterator];
637:                 
638:                             /* Clear this object */
639:                             memset(scsiObj, 0, sizeof(USB_HOST_SCSI_INSTANCE_OBJ));
9D015698  3C128000   LUI S2, -32768
9D01569C  265109BC   ADDIU S1, S2, 2492
9D0156A0  02202021   ADDU A0, S1, ZERO
9D0156A4  0F405189   JAL memset
9D0156A8  240600E0   ADDIU A2, ZERO, 224
640:                 
641:                             /* Setup the rest of the object members whose initial values are
642:                              * non-zero. */
643:                             scsiObj->inUse = true;
9D0156AC  24020001   ADDIU V0, ZERO, 1
9D0156B0  A24209BC   SB V0, 2492(S2)
644:                             scsiObj->lunHandle = lunHandle;
9D0156B4  AE300018   SW S0, 24(S1)
645:                             scsiObj->buffer = &gUSBSCSIBuffer[iterator][0];
9D0156B8  3C02A001   LUI V0, -24575
9D0156BC  24424AA0   ADDIU V0, V0, 19104
9D0156C0  AE2200C8   SW V0, 200(S1)
646:                             scsiObj->state = USB_HOST_SCSI_STATE_INQUIRY_RESPONSE;
9D0156C4  24020001   ADDIU V0, ZERO, 1
9D0156C8  AE220008   SW V0, 8(S1)
647:                             scsiObj->fsHandle = SYS_FS_MEDIA_HANDLE_INVALID;
9D0156CC  2402FFFF   ADDIU V0, ZERO, -1
9D0156D0  AE220004   SW V0, 4(S1)
648:                             break;
649:                         }
650:                     }
651:                 
652:                     if(iterator >= USB_HOST_MSD_LUN_NUMBERS)
653:                     {
654:                         /* This means a SCSI instance object could not be allocated. We call the
655:                          * Error callback function if this is defined. */
656:                 
657:                         _USB_HOST_SCSI_ERROR_CALLBACK(lunHandle, USB_HOST_SCSI_ERROR_CODE_INSUFFICIENT_INSTANCES);
658:                     }
659:                 }
9D0156D4  8FBF001C   LW RA, 28(SP)
660:                 
661:                 // ******************************************************************************
662:                 /* Function:
663:                     void USB_HOST_SCSI_DeInitialize (USB_HOST_MSD_LUN_HANDLE lunHandle)
664:                 
665:                   Summary:
666:                     This function is called by the MSD Host Client Driver for detached LUN.
667:                 
668:                   Description:
669:                     This function is called by the MSD Host Client Driver for detached LUN. The
670:                     function will then de-register this LUN from the file system media manager.
671:                 
672:                   Remarks:
673:                     The application will never need to call this function. This function is
674:                     always called the USB Host MSD Client Driver.
675:                 */
676:                 
677:                 void USB_HOST_SCSI_Deinitialize(USB_HOST_MSD_LUN_HANDLE lunHandle)
678:                 {
9D014954  27BDFFE8   ADDIU SP, SP, -24
9D014958  AFBF0014   SW RA, 20(SP)
679:                     USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
680:                     int scsiObjIndex;
681:                 
682:                     /* Find the SCSI object that owns this LUN */
683:                     scsiObjIndex = _USB_HOST_SCSI_LUNHandleToSCSIInstance(lunHandle);
9D01495C  0F405B53   JAL _USB_HOST_SCSI_LUNHandleToSCSIInstance
9D014960  AFB00010   SW S0, 16(SP)
684:                 
685:                     if(scsiObjIndex >= 0)
9D014964  0440001E   BLTZ V0, 0x9D0149E0
9D014968  00021940   SLL V1, V0, 5
686:                     {
687:                         /* Valid index. Get the pointer to the SCSI object */
688:                         scsiObj = &gUSBHostSCSIObj[scsiObjIndex];
9D01496C  00021200   SLL V0, V0, 8
9D014970  00431023   SUBU V0, V0, V1
9D014974  3C108000   LUI S0, -32768
9D014978  261009BC   ADDIU S0, S0, 2492
9D01497C  02028021   ADDU S0, S0, V0
689:                         
690:                         /* Here we check if a SCSI transfer was in progress. It is possible that
691:                          * SCSI driver would have received a request from the file system but
692:                          * the device got detached before the SCSI driver could submit this 
693:                          * request to the MSD Host Client driver. In such a case, the IRP would
694:                          * not be scheduled and hence the SCSI driver would not get a transfer
695:                          * failure callback when the underlying pipes are closed. The SCSI
696:                          * command object in such case would still indicate that a command was
697:                          * requested by the file system. In such a case we should let the file
698:                          * system know that command has failed */
699:                         
700:                         if(scsiObj->commandObj.inUse)
9D014980  9202001C   LBU V0, 28(S0)
9D014984  10400007   BEQ V0, ZERO, 0x9D0149A4
9D014988  8E0200C0   LW V0, 192(S0)
701:                         {
702:                             /* This means a command was requested */
703:                             
704:                             if(scsiObj->eventHandler != NULL)
9D01498C  1040000A   BEQ V0, ZERO, 0x9D0149B8
9D014990  24040001   ADDIU A0, ZERO, 1
705:                             {
706:                                 /* Generate the error event */
707:                                 (scsiObj->eventHandler)(USB_HOST_SCSI_EVENT_COMMAND_ERROR, (USB_HOST_SCSI_COMMAND_HANDLE)(&scsiObj->commandObj), scsiObj->context);
9D014994  2605001C   ADDIU A1, S0, 28
9D014998  0040F809   JALR V0
9D01499C  8E0600C4   LW A2, 196(S0)
708:                             }
709:                         }
710:                         
711:                         if(scsiObj->eventHandler != NULL)
9D0149A0  8E0200C0   LW V0, 192(S0)
9D0149A4  10400004   BEQ V0, ZERO, 0x9D0149B8
9D0149A8  24040002   ADDIU A0, ZERO, 2
712:                         {
713:                             /* Let the client know that device has been detached. */
714:                             scsiObj->eventHandler(USB_HOST_SCSI_EVENT_DETACH, USB_HOST_SCSI_COMMAND_HANDLE_INVALID, scsiObj->context);
9D0149AC  2405FFFF   ADDIU A1, ZERO, -1
9D0149B0  0040F809   JALR V0
9D0149B4  8E0600C4   LW A2, 196(S0)
715:                         }
716:                 
717:                         /* De-register from the file system */
718:                         if(scsiObj->fsHandle != SYS_FS_MEDIA_HANDLE_INVALID)
9D0149B8  8E040004   LW A0, 4(S0)
9D0149BC  2402FFFF   ADDIU V0, ZERO, -1
9D0149C0  50820006   BEQL A0, V0, 0x9D0149DC
9D0149C4  AE000008   SW ZERO, 8(S0)
719:                         {
720:                             /* It may be possible that this specific LUN may have not registered
721:                              * with the file system. Hence the check. */
722:                             _USB_HOST_SCSI_FILE_SYSTEM_DEREGISTER(scsiObj->fsHandle);
9D0149C8  0F405C76   JAL SYS_FS_MEDIA_MANAGER_DeRegister
9D0149CC  00000000   NOP
723:                             scsiObj->fsHandle = SYS_FS_MEDIA_HANDLE_INVALID;
9D0149D0  2402FFFF   ADDIU V0, ZERO, -1
9D0149D4  AE020004   SW V0, 4(S0)
724:                         }
725:                 
726:                         /* Set the state to not ready */
727:                         scsiObj->state = USB_HOST_SCSI_STATE_NOT_READY;
9D0149D8  AE000008   SW ZERO, 8(S0)
728:                 
729:                         /* Release this object back */
730:                         scsiObj->inUse = false;
9D0149DC  A2000000   SB ZERO, 0(S0)
731:                     }
732:                 }
9D0149E0  8FBF0014   LW RA, 20(SP)
733:                 
734:                 // ******************************************************************************
735:                 /* Function:
736:                     void _USB_HOST_SCSI_TasksByIndex (int scsiIndex)
737:                 
738:                   Summary:
739:                     This function is called by the USB_HOST_SCSI_Tasks to update the driver
740:                     state machine.
741:                 
742:                   Description:
743:                     This function is called by the USB_HOST_SCSI_Tasks to update the driver
744:                     state machine.
745:                 
746:                   Remarks:
747:                     This is local function and should not be called by the application.
748:                 */
749:                 
750:                 void _USB_HOST_SCSI_TasksByIndex(int scsiObjIndex)
751:                 {
9D005098  27BDFFD0   ADDIU SP, SP, -48
9D00509C  AFBF002C   SW RA, 44(SP)
9D0050A0  AFB10028   SW S1, 40(SP)
9D0050A4  AFB00024   SW S0, 36(SP)
752:                     USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
753:                     USB_HOST_MSD_RESULT result;
754:                     SCSI_SENSE_DATA * requestSenseResponse;
755:                     int attachListenerIndex = 0;
756:                 
757:                     scsiObj = &gUSBHostSCSIObj[scsiObjIndex];
9D0050A8  00041140   SLL V0, A0, 5
9D0050AC  00048200   SLL S0, A0, 8
9D0050B0  02021023   SUBU V0, S0, V0
9D0050B4  3C108000   LUI S0, -32768
9D0050B8  261009BC   ADDIU S0, S0, 2492
9D0050BC  02028021   ADDU S0, S0, V0
758:                 
759:                     switch(scsiObj->state)
9D0050C0  8E020008   LW V0, 8(S0)
9D0050C4  2C42000F   SLTIU V0, V0, 15
9D0050C8  10400152   BEQ V0, ZERO, 0x9D005614
9D0050CC  00802821   ADDU A1, A0, ZERO
9D0050D0  8E030008   LW V1, 8(S0)
9D0050D4  00031880   SLL V1, V1, 2
9D0050D8  3C029D00   LUI V0, -25344
9D0050DC  244250EC   ADDIU V0, V0, 20716
9D0050E0  7C43100A   LWX V0, V1(V0)
9D0050E4  00400008   JR V0
9D0050E8  00000000   NOP
760:                     {
761:                         case USB_HOST_SCSI_STATE_NOT_READY:
762:                             /* We are not ready to do anything yet */
763:                             break;
764:                 
765:                         case USB_HOST_SCSI_STATE_INQUIRY_RESPONSE:
766:                 
767:                             /* We get the SCSI Enquiry response. Although there isn't much
768:                              * that we can do with this data */
769:                             _USB_HOST_SCSI_InquiryResponseCommand(scsiObj->taskCommandObj.cdb);
9D005128  26110045   ADDIU S1, S0, 69
9D00512C  0F405BF2   JAL _USB_HOST_SCSI_InquiryResponseCommand
9D005130  02202021   ADDU A0, S1, ZERO
770:                 
771:                             /* The commandCompleted flag will be updated in the callback.
772:                              * Update the state and send the command.   */
773:                             scsiObj->taskCommandObj.inUse = true;
9D005134  24020001   ADDIU V0, ZERO, 1
9D005138  A2020044   SB V0, 68(S0)
774:                             scsiObj->taskCommandObj.commandCompleted = false;
9D00513C  A2000055   SB ZERO, 85(S0)
775:                 
776:                             result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, 
9D005140  8E040018   LW A0, 24(S0)
9D005144  8E0700C8   LW A3, 200(S0)
9D005148  24020024   ADDIU V0, ZERO, 36
9D00514C  AFA20010   SW V0, 16(SP)
9D005150  24020080   ADDIU V0, ZERO, 128
9D005154  AFA20014   SW V0, 20(SP)
9D005158  3C029D01   LUI V0, -25343
9D00515C  24427168   ADDIU V0, V0, 29032
9D005160  AFA20018   SW V0, 24(SP)
9D005168  AFA2001C   SW V0, 28(SP)
9D00516C  02202821   ADDU A1, S1, ZERO
9D005170  0F403ACA   JAL USB_HOST_MSD_Transfer
9D005174  24060006   ADDIU A2, ZERO, 6
777:                                     scsiObj->taskCommandObj.cdb, 6, scsiObj->buffer, 36, 
778:                                     USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST,
779:                                     _USB_HOST_SCSI_CommandCallback, (uintptr_t)(&scsiObj->taskCommandObj));
9D005164  26020044   ADDIU V0, S0, 68
780:                 
781:                             if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D005178  24030003   ADDIU V1, ZERO, 3
9D00517C  14430126   BNE V0, V1, 0x9D005618
9D005180  8FBF002C   LW RA, 44(SP)
782:                             {
783:                                 scsiObj->state = USB_HOST_SCSI_STATE_WAIT_INQUIRY_RESPONSE;
9D005184  24020002   ADDIU V0, ZERO, 2
9D005188  0B401585   J 0x9D005614
9D00518C  AE020008   SW V0, 8(S0)
784:                             }
785:                 
786:                             break;
787:                 
788:                         case USB_HOST_SCSI_STATE_WAIT_INQUIRY_RESPONSE:
789:                 
790:                             /* Here we wait for the Inquiry Response */
791:                             if(scsiObj->taskCommandObj.commandCompleted)
9D005190  92020055   LBU V0, 85(S0)
9D005194  10400120   BEQ V0, ZERO, 0x9D005618
9D005198  8FBF002C   LW RA, 44(SP)
792:                             {
793:                                 /* This means the command has completed. We can launch the
794:                                  * next command which is the Read Capacities command
795:                                  * */
796:                                 SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Inquiry Response Successful", scsiObjIndex);
797:                                 scsiObj->state = USB_HOST_SCSI_STATE_READ_CAPACITY;
9D00519C  24020003   ADDIU V0, ZERO, 3
9D0051A0  0B401585   J 0x9D005614
9D0051A4  AE020008   SW V0, 8(S0)
798:                             }
799:                             break;
800:                 
801:                         case USB_HOST_SCSI_STATE_READ_CAPACITY:
802:                 
803:                             /* Here we send the read capacity command */
804:                             _USB_HOST_SCSI_ReadCapacityCommand(scsiObj->taskCommandObj.cdb);
9D0051A8  26110045   ADDIU S1, S0, 69
9D0051AC  0F405AE1   JAL _USB_HOST_SCSI_ReadCapacityCommand
9D0051B0  02202021   ADDU A0, S1, ZERO
805:                 
806:                             /* The commandCompleted flag will be updated in the callback.
807:                              * Update the state and send the command.   */
808:                             scsiObj->taskCommandObj.inUse = true;
9D0051B4  24020001   ADDIU V0, ZERO, 1
9D0051B8  A2020044   SB V0, 68(S0)
809:                             scsiObj->taskCommandObj.commandCompleted = false;
9D0051BC  A2000055   SB ZERO, 85(S0)
810:                 
811:                             result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, 
9D0051C0  8E040018   LW A0, 24(S0)
9D0051C4  8E0700C8   LW A3, 200(S0)
9D0051C8  24020008   ADDIU V0, ZERO, 8
9D0051CC  AFA20010   SW V0, 16(SP)
9D0051D0  24020080   ADDIU V0, ZERO, 128
9D0051D4  AFA20014   SW V0, 20(SP)
9D0051D8  3C029D01   LUI V0, -25343
9D0051DC  24427168   ADDIU V0, V0, 29032
9D0051E0  AFA20018   SW V0, 24(SP)
9D0051E8  AFA2001C   SW V0, 28(SP)
9D0051EC  02202821   ADDU A1, S1, ZERO
9D0051F0  0F403ACA   JAL USB_HOST_MSD_Transfer
9D0051F4  2406000A   ADDIU A2, ZERO, 10
812:                                     scsiObj->taskCommandObj.cdb, 0xA, scsiObj->buffer, 0x8 , 
813:                                     USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST,
814:                                     _USB_HOST_SCSI_CommandCallback, (uintptr_t)(&scsiObj->taskCommandObj));
9D0051E4  26020044   ADDIU V0, S0, 68
815:                 
816:                             if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D0051F8  24030003   ADDIU V1, ZERO, 3
9D0051FC  14430106   BNE V0, V1, 0x9D005618
9D005200  8FBF002C   LW RA, 44(SP)
817:                             {
818:                                 /* Go to the next state only if the request was placed
819:                                  * successfully. */
820:                                 scsiObj->state = USB_HOST_SCSI_STATE_WAIT_READ_CAPACITY;
9D005204  24020004   ADDIU V0, ZERO, 4
9D005208  0B401585   J 0x9D005614
9D00520C  AE020008   SW V0, 8(S0)
821:                             }
822:                 
823:                             break;
824:                 
825:                         case USB_HOST_SCSI_STATE_WAIT_READ_CAPACITY:
826:                 
827:                             /* Here we wait for the read capacity to complete */
828:                             if(scsiObj->taskCommandObj.commandCompleted)
9D005210  92020055   LBU V0, 85(S0)
9D005214  1040002F   BEQ V0, ZERO, 0x9D0052D4
9D005218  00000000   NOP
829:                             {
830:                                 if(scsiObj->taskCommandObj.result == USB_HOST_MSD_RESULT_COMMAND_PASSED)
9D00521C  8E020058   LW V0, 88(S0)
9D005220  14400028   BNE V0, ZERO, 0x9D0052C4
9D005224  24020003   ADDIU V0, ZERO, 3
831:                                 {
832:                                     /* We have the capacity information. Update the geometry
833:                                      * object */
834:                 
835:                                     uint8_t * buffer = scsiObj->buffer;
9D005228  8E0200C8   LW V0, 200(S0)
836:                 
837:                                     /* The read and write will be blocking */
838:                                     scsiObj->mediaGeometry.mediaProperty = (SYS_FS_MEDIA_WRITE_IS_BLOCKING|SYS_FS_MEDIA_READ_IS_BLOCKING);
9D00522C  24030018   ADDIU V1, ZERO, 24
9D005230  AE030094   SW V1, 148(S0)
839:                 
840:                                     /* There is one read, write and erase region */
841:                                     scsiObj->mediaGeometry.numReadRegions = 1;
9D005234  24030001   ADDIU V1, ZERO, 1
9D005238  AE030098   SW V1, 152(S0)
842:                                     scsiObj->mediaGeometry.numWriteRegions = 1;
9D00523C  AE03009C   SW V1, 156(S0)
843:                                     scsiObj->mediaGeometry.numEraseRegions = 1;
9D005240  AE0300A0   SW V1, 160(S0)
844:                 
845:                                     /* The size of the read region and size of the read block */
846:                                     scsiObj->mediaRegionGeometry[0].blockSize = (buffer[7])|(buffer[6] << 8)|(buffer[5]<<16)| (buffer[4] << 24);
9D005244  90440006   LBU A0, 6(V0)
9D005248  00042200   SLL A0, A0, 8
9D00524C  90430005   LBU V1, 5(V0)
9D005250  00031C00   SLL V1, V1, 16
9D005254  00832025   OR A0, A0, V1
9D005258  90430007   LBU V1, 7(V0)
9D00525C  00832025   OR A0, A0, V1
9D005260  90430004   LBU V1, 4(V0)
9D005264  00031E00   SLL V1, V1, 24
9D005268  00831825   OR V1, A0, V1
9D00526C  AE0300A8   SW V1, 168(S0)
847:                                     scsiObj->mediaRegionGeometry[0].numBlocks = ((buffer[3])|(buffer[2] << 8)|(buffer[1]<<16)| (buffer[0] << 24)) + 1;
9D005270  90450002   LBU A1, 2(V0)
9D005274  00052A00   SLL A1, A1, 8
9D005278  90440001   LBU A0, 1(V0)
9D00527C  00042400   SLL A0, A0, 16
9D005280  00A42825   OR A1, A1, A0
9D005284  90440003   LBU A0, 3(V0)
9D005288  00A42025   OR A0, A1, A0
9D00528C  90420000   LBU V0, 0(V0)
9D005290  00021600   SLL V0, V0, 24
9D005294  00821025   OR V0, A0, V0
9D005298  24420001   ADDIU V0, V0, 1
9D00529C  AE0200AC   SW V0, 172(S0)
848:                 
849:                                     /* The size of the write region and size of the read block */
850:                                     scsiObj->mediaRegionGeometry[1].blockSize = scsiObj->mediaRegionGeometry[0].blockSize;
9D0052A0  AE0300B0   SW V1, 176(S0)
851:                                     scsiObj->mediaRegionGeometry[1].numBlocks = scsiObj->mediaRegionGeometry[0].numBlocks;
9D0052A4  AE0200B4   SW V0, 180(S0)
852:                 
853:                                     /* The size of the erase region and size of the read block */
854:                                     scsiObj->mediaRegionGeometry[2].blockSize = scsiObj->mediaRegionGeometry[0].blockSize;
9D0052A8  AE0300B8   SW V1, 184(S0)
855:                                     scsiObj->mediaRegionGeometry[2].numBlocks = scsiObj->mediaRegionGeometry[0].numBlocks;
9D0052AC  AE0200BC   SW V0, 188(S0)
856:                 
857:                                     /* Adding the region specific geometry table */
858:                                     scsiObj->mediaGeometry.geometryTable = scsiObj->mediaRegionGeometry;
9D0052B0  260200A8   ADDIU V0, S0, 168
9D0052B4  AE0200A4   SW V0, 164(S0)
859:                                     SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Read Capacity Successful", scsiObjIndex);
860:                                     SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Capacity is %d blocks", scsiObjIndex, scsiObj->mediaRegionGeometry[1].numBlocks);
861:                 
862:                                     /* Now we can check if the device is write protected.
863:                                      * */
864:                                     scsiObj->state = USB_HOST_SCSI_STATE_MODE_SENSE;
9D0052B8  24020005   ADDIU V0, ZERO, 5
9D0052BC  0B401585   J 0x9D005614
9D0052C0  AE020008   SW V0, 8(S0)
865:                                 }
866:                                 else
867:                                 {
868:                                     /* The Read capacity command failed. We must do a
869:                                      * Request sense to see why */
870:                 
871:                                     SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host SCSI: SCSI Instance %d Read Capacity Failed. Requesting Sense Data", scsiObjIndex);
872:                                     scsiObj->failedCommandState = USB_HOST_SCSI_STATE_READ_CAPACITY;
9D0052C4  AE020014   SW V0, 20(S0)
873:                                     scsiObj->state = USB_HOST_SCSI_STATE_REQUEST_SENSE;
9D0052C8  24020009   ADDIU V0, ZERO, 9
9D0052CC  0B401585   J 0x9D005614
9D0052D0  AE020008   SW V0, 8(S0)
874:                                     _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_READ_CAPACITY_FAILED);
875:                                 }
876:                             }
877:                             else
878:                             {
879:                                 /* We must run the Transfer Error tasks while we are waiting
880:                                  * for the transfer to complete. */                   
881:                                 USB_HOST_MSD_TransferErrorTasks(scsiObj->lunHandle);
9D0052D4  0F402234   JAL USB_HOST_MSD_TransferErrorTasks
9D0052D8  8E040018   LW A0, 24(S0)
882:                             }
883:                 
884:                             break;
885:                 
886:                         case USB_HOST_SCSI_STATE_MODE_SENSE:
887:                 
888:                             /* In this state we send the mode sense command to find out if
889:                              * the device is write protected */
890:                 
891:                             _USB_HOST_SCSI_ModeSense(scsiObj->taskCommandObj.cdb);
9D0052E4  26110045   ADDIU S1, S0, 69
9D0052E8  0F405B48   JAL _USB_HOST_SCSI_ModeSense
9D0052EC  02202021   ADDU A0, S1, ZERO
892:                 
893:                             /* The commandCompleted flag will be updated in the callback.
894:                              * Update the state and send the command.   */
895:                             scsiObj->taskCommandObj.inUse = true;
9D0052F0  24020001   ADDIU V0, ZERO, 1
9D0052F4  A2020044   SB V0, 68(S0)
896:                             scsiObj->taskCommandObj.commandCompleted = false;
9D0052F8  A2000055   SB ZERO, 85(S0)
897:                 
898:                             result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, 
9D0052FC  8E040018   LW A0, 24(S0)
9D005300  8E0700C8   LW A3, 200(S0)
9D005304  240200C0   ADDIU V0, ZERO, 192
9D005308  AFA20010   SW V0, 16(SP)
9D00530C  24020080   ADDIU V0, ZERO, 128
9D005310  AFA20014   SW V0, 20(SP)
9D005314  3C029D01   LUI V0, -25343
9D005318  24427168   ADDIU V0, V0, 29032
9D00531C  AFA20018   SW V0, 24(SP)
9D005324  AFA2001C   SW V0, 28(SP)
9D005328  02202821   ADDU A1, S1, ZERO
9D00532C  0F403ACA   JAL USB_HOST_MSD_Transfer
9D005330  24060006   ADDIU A2, ZERO, 6
899:                                     scsiObj->taskCommandObj.cdb, 0x06, scsiObj->buffer, 192 , 
900:                                     USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST,
901:                                     _USB_HOST_SCSI_CommandCallback, (uintptr_t)(&scsiObj->taskCommandObj));
9D005320  26020044   ADDIU V0, S0, 68
902:                 
903:                             if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D005334  24030003   ADDIU V1, ZERO, 3
9D005338  144300B7   BNE V0, V1, 0x9D005618
9D00533C  8FBF002C   LW RA, 44(SP)
904:                             {
905:                                 /* Go to the next state only if the request was placed
906:                                  * successfully. */
907:                                 scsiObj->state = USB_HOST_SCSI_STATE_WAIT_MODE_SENSE;
9D005340  24020006   ADDIU V0, ZERO, 6
9D005344  0B401585   J 0x9D005614
9D005348  AE020008   SW V0, 8(S0)
908:                             }
909:                 
910:                             break;
911:                 
912:                         case USB_HOST_SCSI_STATE_WAIT_MODE_SENSE:
913:                 
914:                             /* Here we are waiting for the mode sense request to complete */
915:                 
916:                             if(scsiObj->taskCommandObj.commandCompleted)
9D00534C  92020055   LBU V0, 85(S0)
9D005350  10400011   BEQ V0, ZERO, 0x9D005398
9D005354  00000000   NOP
917:                             {
918:                                 if(scsiObj->taskCommandObj.result == USB_HOST_MSD_RESULT_COMMAND_PASSED)
9D005358  8E020058   LW V0, 88(S0)
9D00535C  1440000A   BNE V0, ZERO, 0x9D005388
9D005360  24020005   ADDIU V0, ZERO, 5
919:                                 {
920:                                     /* Check if the device is write protected. This will be
921:                                      * indicated by bit 7 of the third byte in the mode
922:                                      * sense response. */
923:                                     if(scsiObj->buffer[2] & 0x80)
9D005364  8E0200C8   LW V0, 200(S0)
9D005368  80420002   LB V0, 2(V0)
9D00536C  04430003   BGEZL V0, 0x9D00537C
9D005370  A20000CC   SB ZERO, 204(S0)
924:                                     {
925:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Mode Sense Passed. Media is write protected.", scsiObjIndex);
926:                                         scsiObj->isWriteProtected = true;
9D005374  24020001   ADDIU V0, ZERO, 1
9D005378  A20200CC   SB V0, 204(S0)
927:                                     }
928:                                     else
929:                                     {
930:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Mode Sense Passed. Media is not write protected.", scsiObjIndex);
931:                                         scsiObj->isWriteProtected = false;
932:                                     }
933:                 
934:                                     /* We are done with the Mode Sense command are now ready
935:                                      * to move to the ready state */
936:                                     scsiObj->state = USB_HOST_SCSI_STATE_MODE_SENSE_DONE;
9D00537C  24020007   ADDIU V0, ZERO, 7
9D005380  0B401585   J 0x9D005614
9D005384  AE020008   SW V0, 8(S0)
937:                                 }
938:                                 else
939:                                 {
940:                                     /* The mode sense command failed. Use the Request Sense
941:                                      * state to find out why */
942:                                     SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Mode Sense Failed. Requesting Sense Data.", scsiObjIndex);
943:                                     scsiObj->failedCommandState = USB_HOST_SCSI_STATE_MODE_SENSE;
9D005388  AE020014   SW V0, 20(S0)
944:                                     scsiObj->state = USB_HOST_SCSI_STATE_REQUEST_SENSE;
9D00538C  24020009   ADDIU V0, ZERO, 9
9D005390  0B401585   J 0x9D005614
9D005394  AE020008   SW V0, 8(S0)
945:                                     _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_MODE_SENSE_FAILED);
946:                                 }
947:                             }
948:                             else
949:                             {
950:                                 /* We must run the Transfer Error tasks while we are waiting
951:                                  * for the transfer to complete. */                   
952:                                 USB_HOST_MSD_TransferErrorTasks(scsiObj->lunHandle);
9D005398  0F402234   JAL USB_HOST_MSD_TransferErrorTasks
9D00539C  8E040018   LW A0, 24(S0)
953:                             }
954:                 
955:                             break;
956:                 
957:                         case USB_HOST_SCSI_STATE_MODE_SENSE_DONE:
958:                 
959:                             /* This state is prior to get the ready state. In this state, we
960:                              * register the media with the file system, initialize the state
961:                              * of the detach state machine to start checking for detach. */
962:                 
963:                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d is ready for block commands", scsiObjIndex);
964:                             scsiObj->fsHandle = _USB_HOST_SCSI_FILE_SYSTEM_REGISTER((SYS_MODULE_OBJ)(scsiObj->lunHandle), 
9D0053A8  8E040018   LW A0, 24(S0)
9D0053AC  30A5FFFF   ANDI A1, A1, -1
9D0053B0  3C068001   LUI A2, -32767
9D0053B4  24C64E4C   ADDIU A2, A2, 20044
9D0053B8  0F4057AC   JAL SYS_FS_MEDIA_MANAGER_Register
9D0053BC  24070001   ADDIU A3, ZERO, 1
9D0053C0  AE020004   SW V0, 4(S0)
965:                                     scsiObjIndex, &gUSBHostMSDSCSIMediaFunctions, SYS_FS_MEDIA_TYPE_MSD);
966:                             
967:                             for (attachListenerIndex = 0; attachListenerIndex < USB_HOST_SCSI_ATTACH_LISTENERS_NUMBER; attachListenerIndex ++)
968:                             {
969:                                 /* If there are any attach listeners registered, then call 
970:                                  * each of these listeners */
971:                                 if(gUSBHostSCSIAttachListener[attachListenerIndex].inUse)
972:                                 {
973:                                     gUSBHostSCSIAttachListener[attachListenerIndex].eventHandler((USB_HOST_SCSI_OBJ)(scsiObjIndex), 
974:                                             gUSBHostSCSIAttachListener[attachListenerIndex].context);
975:                                 }
976:                             }
977:                             
978:                             scsiObj->state = USB_HOST_SCSI_STATE_READY;
9D0053C4  24020008   ADDIU V0, ZERO, 8
9D0053C8  AE020008   SW V0, 8(S0)
979:                             scsiObj->detachTaskState = USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_SEND;
9D0053CC  24020001   ADDIU V0, ZERO, 1
9D0053D0  AE020010   SW V0, 16(S0)
980:                 
981:                             /* Indicate that the media is ready to accept block
982:                              * transfer commands. Reset the detach time out. */
983:                             scsiObj->isMediaReady = true;
9D0053D4  A20200CD   SB V0, 205(S0)
984:                             scsiObj->detachTimeOut = 0;
985:                             break;
9D0053D8  0B401585   J 0x9D005614
9D0053DC  AE0000DC   SW ZERO, 220(S0)
986:                 
987:                         case USB_HOST_SCSI_STATE_READY:
988:                 
989:                             /* In this state the driver checks periodically if the media is
990:                              * ready. This is needed for cases where the media is a card reader.
991:                              * The card reader would always be plugged in but the card itself
992:                              * could be plugged in and out. The driver uses the SCSI test unit
993:                              * ready command to check if the card is responding. When running in
994:                              * a RTOS, this check could block on the MSD BOT transfer object
995:                              * which may be in use by a SCSI client thread. Another possible
996:                              * case that could occur is when a media error has occurred. In such
997:                              * a case, the driver will de-register the media from the file
998:                              * system and will return to a state where it tries to bring up the
999:                              * card again */
1000:                
1001:                            if(scsiObj->isMediaError)
9D0053E0  920200CE   LBU V0, 206(S0)
9D0053E4  1040000E   BEQ V0, ZERO, 0x9D005420
9D0053E8  00000000   NOP
1002:                            {
1003:                                /* This means that some tpye of media error has occurred. We
1004:                                 * deregister the media from the file system and then try to
1005:                                 * bring up the media again. */
1006:                                SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host SCSI: SCSI Instance %d Media Error has occurred", scsiObjIndex);
1007:                                
1008:                                /* Send the detach event to all client event handlers */
1009:                                if(scsiObj->eventHandler != NULL)
9D0053EC  8E0200C0   LW V0, 192(S0)
9D0053F0  10400004   BEQ V0, ZERO, 0x9D005404
9D0053F4  2405FFFF   ADDIU A1, ZERO, -1
1010:                                {
1011:                                    /* Let the client know that device has been detached. */
1012:                                    scsiObj->eventHandler(USB_HOST_SCSI_EVENT_DETACH, USB_HOST_SCSI_COMMAND_HANDLE_INVALID, scsiObj->context);
9D0053F8  24040002   ADDIU A0, ZERO, 2
9D0053FC  0040F809   JALR V0
9D005400  8E0600C4   LW A2, 196(S0)
1013:                                }
1014:                                
1015:                                _USB_HOST_SCSI_FILE_SYSTEM_DEREGISTER(scsiObj->fsHandle);
9D005404  0F405C76   JAL SYS_FS_MEDIA_MANAGER_DeRegister
9D005408  8E040004   LW A0, 4(S0)
1016:                                    
1017:                                scsiObj->fsHandle = SYS_FS_MEDIA_HANDLE_INVALID;
9D00540C  2402FFFF   ADDIU V0, ZERO, -1
9D005410  AE020004   SW V0, 4(S0)
1018:                                scsiObj->state = USB_HOST_SCSI_STATE_INQUIRY_RESPONSE;
9D005414  24020001   ADDIU V0, ZERO, 1
9D005418  0B401585   J 0x9D005614
9D00541C  AE020008   SW V0, 8(S0)
1019:                            }
1020:                            else
1021:                            {
1022:                                /* Continue to check if the media is present */
1023:                                _USB_HOST_SCSI_DetachDetectTasks(scsiObjIndex);
9D005420  0F403905   JAL _USB_HOST_SCSI_DetachDetectTasks
9D005424  00000000   NOP
1024:                            }
1025:                
1026:                            break;
1027:                
1028:                        case USB_HOST_SCSI_STATE_REQUEST_SENSE:
1029:                
1030:                            /* In this state, we send the request sense command */
1031:                
1032:                            _USB_HOST_SCSI_RequestSenseCommand(scsiObj->taskCommandObj.cdb);
9D005430  26110045   ADDIU S1, S0, 69
9D005434  0F405BE9   JAL _USB_HOST_SCSI_RequestSenseCommand
9D005438  02202021   ADDU A0, S1, ZERO
1033:                
1034:                            /* The commandCompleted flag will be updated in the callback.
1035:                             * Update the state and send the command.   */
1036:                            scsiObj->taskCommandObj.inUse = true;
9D00543C  24020001   ADDIU V0, ZERO, 1
9D005440  A2020044   SB V0, 68(S0)
1037:                            scsiObj->taskCommandObj.commandCompleted = false;
9D005444  A2000055   SB ZERO, 85(S0)
1038:                
1039:                            /* Send the command */
1040:                            result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, 
9D005448  8E040018   LW A0, 24(S0)
9D00544C  8E0700C8   LW A3, 200(S0)
9D005450  24020012   ADDIU V0, ZERO, 18
9D005454  AFA20010   SW V0, 16(SP)
9D005458  24020080   ADDIU V0, ZERO, 128
9D00545C  AFA20014   SW V0, 20(SP)
9D005460  3C029D01   LUI V0, -25343
9D005464  24427168   ADDIU V0, V0, 29032
9D005468  AFA20018   SW V0, 24(SP)
9D005470  AFA2001C   SW V0, 28(SP)
9D005474  02202821   ADDU A1, S1, ZERO
9D005478  0F403ACA   JAL USB_HOST_MSD_Transfer
9D00547C  24060006   ADDIU A2, ZERO, 6
1041:                                    scsiObj->taskCommandObj.cdb, 0x6, scsiObj->buffer, 18 , 
1042:                                    USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST,
1043:                                    _USB_HOST_SCSI_CommandCallback, (uintptr_t)(&scsiObj->taskCommandObj));
9D00546C  26020044   ADDIU V0, S0, 68
1044:                
1045:                            if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D005480  24030003   ADDIU V1, ZERO, 3
9D005484  14430064   BNE V0, V1, 0x9D005618
9D005488  8FBF002C   LW RA, 44(SP)
1046:                            {
1047:                                /* Go to the next state only if the request was placed
1048:                                 * successfully. */
1049:                                scsiObj->state = USB_HOST_SCSI_STATE_WAIT_REQUEST_SENSE;
9D00548C  2402000A   ADDIU V0, ZERO, 10
9D005490  0B401585   J 0x9D005614
9D005494  AE020008   SW V0, 8(S0)
1050:                            }
1051:                
1052:                            break;
1053:                
1054:                        case USB_HOST_SCSI_STATE_WAIT_REQUEST_SENSE:
1055:                
1056:                            /* In this state we wait for the command to complete */
1057:                
1058:                            if(scsiObj->taskCommandObj.commandCompleted)
9D005498  92020055   LBU V0, 85(S0)
9D00549C  1040001F   BEQ V0, ZERO, 0x9D00551C
9D0054A0  00000000   NOP
1059:                            {
1060:                                if(scsiObj->taskCommandObj.result == USB_HOST_MSD_RESULT_COMMAND_PASSED)
9D0054A4  8E020058   LW V0, 88(S0)
9D0054A8  14400019   BNE V0, ZERO, 0x9D005510
9D0054AC  24020005   ADDIU V0, ZERO, 5
1061:                                {
1062:                                    /* Check the sense data */
1063:                                    requestSenseResponse = (SCSI_SENSE_DATA *)(scsiObj->buffer);
1064:                
1065:                                    if(scsiObj->failedCommandState == USB_HOST_SCSI_STATE_MODE_SENSE)
9D0054B0  8E030014   LW V1, 20(S0)
9D0054B4  14620005   BNE V1, V0, 0x9D0054CC
9D0054B8  8E0400C8   LW A0, 200(S0)
1066:                                    {
1067:                                        /* This means the device does not support the mode sense
1068:                                         * command. That is okay. We assume that device is not
1069:                                         * write protected. Because the mode sense command
1070:                                         * occurs after the read capacity command, at this point
1071:                                         * we have all the data needed for the file system to
1072:                                         * open the device. */
1073:                
1074:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Sense Key Mode Sense not supported.", scsiObjIndex);
1075:                                        scsiObj->isWriteProtected = false;
9D0054BC  A20000CC   SB ZERO, 204(S0)
1076:                                        scsiObj->state = USB_HOST_SCSI_STATE_MODE_SENSE_DONE;
9D0054C0  24020007   ADDIU V0, ZERO, 7
9D0054C4  0B401585   J 0x9D005614
9D0054C8  AE020008   SW V0, 8(S0)
1077:                                    }
1078:                                    else if((requestSenseResponse->SenseKey == SCSI_SENSE_UNIT_ATTENTION) ||
9D0054CC  90820002   LBU V0, 2(A0)
9D0054D0  3043000F   ANDI V1, V0, 15
9D0054D4  24040006   ADDIU A0, ZERO, 6
9D0054D8  10640003   BEQ V1, A0, 0x9D0054E8
9D0054DC  3042000D   ANDI V0, V0, 13
1079:                                            (requestSenseResponse->SenseKey == SCSI_SENSE_NOT_READY) ||
9D0054E0  14400004   BNE V0, ZERO, 0x9D0054F4
9D0054E4  24020003   ADDIU V0, ZERO, 3
1080:                                            (requestSenseResponse->SenseKey == SCSI_SENSE_NO_SENSE))
1081:                                    {
1082:                                        /* This means something has changed or is changing on
1083:                                         * the device. Wait for the unit to be ready.  The
1084:                                         * Transcend card reader reports no sense on the flash
1085:                                         * reader when no media is inserted. */
1086:                
1087:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Sense Key Unit Not Ready.", scsiObjIndex);
1088:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Check if Unit is Ready.", scsiObjIndex);
1089:                                        scsiObj->state = USB_HOST_SCSI_STATE_TEST_UNIT_READY;
9D0054E8  2402000D   ADDIU V0, ZERO, 13
9D0054EC  0B401585   J 0x9D005614
9D0054F0  AE020008   SW V0, 8(S0)
1090:                                        _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_REQUEST_SENSE_TEST_UNIT_READY);
1091:                                    }
1092:                                    else if(requestSenseResponse->SenseKey == SCSI_SENSE_MEDIUM_ERROR)
9D0054F4  14620048   BNE V1, V0, 0x9D005618
9D0054F8  8FBF002C   LW RA, 44(SP)
1093:                                    {
1094:                                        /* This could mean there is something terribly wrong
1095:                                         * with the device. We let the ready state catch this
1096:                                         * error. */
1097:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Sense Key Medium Error.", scsiObjIndex);
1098:                                        scsiObj->isMediaError = true;
9D0054FC  24020001   ADDIU V0, ZERO, 1
9D005500  A20200CE   SB V0, 206(S0)
1099:                                        scsiObj->state = USB_HOST_SCSI_STATE_READY;
9D005504  24020008   ADDIU V0, ZERO, 8
9D005508  0B401585   J 0x9D005614
9D00550C  AE020008   SW V0, 8(S0)
1100:                                        _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_REQUEST_SENSE_MEDIUM_ERROR);
1101:                                    }
1102:                                }
1103:                                else
1104:                                {
1105:                                    /* The SCSI Request Sense command must pass */
1106:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Sense Command failed!", scsiObjIndex);
1107:                                    scsiObj->state = USB_HOST_SCSI_STATE_ERROR;
9D005510  2402FFFF   ADDIU V0, ZERO, -1
9D005514  0B401585   J 0x9D005614
9D005518  AE020008   SW V0, 8(S0)
1108:                                    _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_REQUEST_SENSE_FAILURE);
1109:                                }
1110:                            }
1111:                            else
1112:                            {
1113:                                USB_HOST_MSD_TransferErrorTasks(scsiObj->lunHandle);
9D00551C  0F402234   JAL USB_HOST_MSD_TransferErrorTasks
9D005520  8E040018   LW A0, 24(S0)
1114:                            }
1115:                
1116:                            break;
1117:                
1118:                        case USB_HOST_SCSI_STATE_TEST_UNIT_READY_DELAY_START:
1119:                
1120:                            /* In this state we start a delay before launching the Test Unit
1121:                             * Ready command */
1122:                
1123:                            scsiObj->timerExpired = false;
9D00552C  A20000D8   SB ZERO, 216(S0)
1124:                            scsiObj->commandDelayHandle = SYS_TMR_CallbackSingle( USB_HOST_SCSI_DETACH_TEST_UNIT_READY_INTERVAL, 
9D005530  24040064   ADDIU A0, ZERO, 100
9D005534  02002821   ADDU A1, S0, ZERO
9D005538  3C069D01   LUI A2, -25343
9D00553C  0F405C4C   JAL SYS_TMR_CallbackSingle
9D005540  24C67338   ADDIU A2, A2, 29496
1125:                                    (uintptr_t )scsiObj, _USB_HOST_SCSI_TimerCallback);
1126:                            
1127:                            if (scsiObj->commandDelayHandle != SYS_TMR_HANDLE_INVALID)
9D005544  2403FFFF   ADDIU V1, ZERO, -1
9D005548  10430032   BEQ V0, V1, 0x9D005614
9D00554C  AE0200D4   SW V0, 212(S0)
1128:                            {
1129:                                /* The delay has started. Now wait for the delay to complete
1130:                                 * */
1131:                
1132:                                scsiObj->state = USB_HOST_SCSI_STATE_TEST_UNIT_READY_DELAY_WAIT;
9D005550  2402000C   ADDIU V0, ZERO, 12
9D005554  0B401585   J 0x9D005614
9D005558  AE020008   SW V0, 8(S0)
1133:                            }
1134:                            else
1135:                            {
1136:                                /* Continue to stay in this state till the delay could be
1137:                                 * scheduled */
1138:                            }
1139:                            break;
1140:                
1141:                        case USB_HOST_SCSI_STATE_TEST_UNIT_READY_DELAY_WAIT:
1142:                
1143:                            /* Check if the delay has completed */
1144:                
1145:                            if(scsiObj->timerExpired)
9D00555C  920200D8   LBU V0, 216(S0)
9D005560  1040002D   BEQ V0, ZERO, 0x9D005618
9D005564  8FBF002C   LW RA, 44(SP)
1146:                            {
1147:                                /* Delay has completed. Send the test unit ready command */
1148:                                scsiObj->state = USB_HOST_SCSI_STATE_TEST_UNIT_READY;
9D005568  2402000D   ADDIU V0, ZERO, 13
9D00556C  AE020008   SW V0, 8(S0)
1149:                                scsiObj->commandDelayHandle = SYS_TMR_HANDLE_INVALID ;
9D005570  2402FFFF   ADDIU V0, ZERO, -1
9D005574  0B401585   J 0x9D005614
9D005578  AE0200D4   SW V0, 212(S0)
1150:                                
1151:                            }
1152:                            else
1153:                            {
1154:                                /* Stay in this state. Continue to check if the delay has
1155:                                 * completed */
1156:                            }
1157:                            break;
1158:                
1159:                        case USB_HOST_SCSI_STATE_TEST_UNIT_READY:
1160:                
1161:                            /* In this state the driver will check if the device is ready.
1162:                             * Grab the command object. Populate the command block with
1163:                             * command */
1164:                            
1165:                            _USB_HOST_SCSI_TestUnitReadyCommand(scsiObj->taskCommandObj.cdb);
9D00557C  26110045   ADDIU S1, S0, 69
9D005580  0F405C61   JAL _USB_HOST_SCSI_TestUnitReadyCommand
9D005584  02202021   ADDU A0, S1, ZERO
1166:                
1167:                            /* Send the command. The commandCompleted flag will be update in
1168:                             * the event handler  */
1169:                            
1170:                            scsiObj->taskCommandObj.inUse = true;
9D005588  24020001   ADDIU V0, ZERO, 1
9D00558C  A2020044   SB V0, 68(S0)
1171:                            scsiObj->taskCommandObj.commandCompleted = false;
9D005590  A2000055   SB ZERO, 85(S0)
1172:                
1173:                            result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, scsiObj->taskCommandObj.cdb, 6, NULL, 0, 
9D005594  8E040018   LW A0, 24(S0)
9D005598  AFA00010   SW ZERO, 16(SP)
9D00559C  24020080   ADDIU V0, ZERO, 128
9D0055A0  AFA20014   SW V0, 20(SP)
9D0055A4  3C029D01   LUI V0, -25343
9D0055A8  24427168   ADDIU V0, V0, 29032
9D0055AC  AFA20018   SW V0, 24(SP)
9D0055B4  AFA2001C   SW V0, 28(SP)
9D0055B8  02202821   ADDU A1, S1, ZERO
9D0055BC  24060006   ADDIU A2, ZERO, 6
9D0055C0  0F403ACA   JAL USB_HOST_MSD_Transfer
9D0055C4  00003821   ADDU A3, ZERO, ZERO
1174:                                    USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST, _USB_HOST_SCSI_CommandCallback, 
1175:                                    (uintptr_t)(&scsiObj->taskCommandObj));
9D0055B0  26020044   ADDIU V0, S0, 68
1176:                
1177:                            if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D0055C8  24030003   ADDIU V1, ZERO, 3
9D0055CC  14430012   BNE V0, V1, 0x9D005618
9D0055D0  8FBF002C   LW RA, 44(SP)
1178:                            {
1179:                                /* The request was scheduled successfully. Wait for the
1180:                                 * request to complete */
1181:                
1182:                                scsiObj->state = USB_HOST_SCSI_STATE_WAIT_TEST_UNIT_READY;
9D0055D4  2402000E   ADDIU V0, ZERO, 14
9D0055D8  0B401585   J 0x9D005614
9D0055DC  AE020008   SW V0, 8(S0)
1183:                            }
1184:                
1185:                            break;
1186:                
1187:                        case USB_HOST_SCSI_STATE_WAIT_TEST_UNIT_READY:
1188:                
1189:                            /* Here we are waiting for the test unit command to complete */
1190:                
1191:                            if(scsiObj->taskCommandObj.commandCompleted)
9D0055E0  92020055   LBU V0, 85(S0)
9D0055E4  10400009   BEQ V0, ZERO, 0x9D00560C
9D0055E8  00000000   NOP
1192:                            {
1193:                                /* The status of the test unit ready command can be read
1194:                                 * from the CSW */
1195:                
1196:                                if(scsiObj->taskCommandObj.result == USB_HOST_MSD_RESULT_COMMAND_PASSED)
9D0055EC  8E020058   LW V0, 88(S0)
9D0055F0  14400004   BNE V0, ZERO, 0x9D005604
9D0055F4  2402000B   ADDIU V0, ZERO, 11
1197:                                {
1198:                                    /* The test unit ready command must have been called
1199:                                     * because some command failed. Try the command again */
1200:                                    scsiObj->state = scsiObj->failedCommandState;
9D0055F8  8E020014   LW V0, 20(S0)
9D0055FC  0B401585   J 0x9D005614
9D005600  AE020008   SW V0, 8(S0)
1201:                                }
1202:                                else
1203:                                {
1204:                                    scsiObj->state = USB_HOST_SCSI_STATE_TEST_UNIT_READY_DELAY_START;
9D005604  0B401585   J 0x9D005614
9D005608  AE020008   SW V0, 8(S0)
1205:                                }
1206:                            }
1207:                            else
1208:                            {
1209:                                /* Continue to run the transfer error tasks while waiting
1210:                                 * for the transfer to complete */
1211:                                USB_HOST_MSD_TransferErrorTasks(scsiObj->lunHandle);
9D00560C  0F402234   JAL USB_HOST_MSD_TransferErrorTasks
9D005610  8E040018   LW A0, 24(S0)
1212:                            }
1213:                
1214:                            break;
1215:                
1216:                        case USB_HOST_SCSI_STATE_ERROR:
1217:                
1218:                            /* We are in the state because a media error has occurred. There
1219:                             * is really nothing to be done here. The media is assumed
1220:                             * un-usable and should be un-plugged. */
1221:                            break;
1222:                
1223:                        default:
1224:                            break;
1225:                    }
1226:                }
9D0052DC  0B401586   J 0x9D005618
9D0052E0  8FBF002C   LW RA, 44(SP)
9D0053A0  0B401586   J 0x9D005618
9D0053A4  8FBF002C   LW RA, 44(SP)
9D005428  0B401586   J 0x9D005618
9D00542C  8FBF002C   LW RA, 44(SP)
9D005524  0B401586   J 0x9D005618
9D005528  8FBF002C   LW RA, 44(SP)
9D005614  8FBF002C   LW RA, 44(SP)
1227:                
1228:                // ******************************************************************************
1229:                /* Function:
1230:                    void USB_HOST_SCSI_Tasks (USB_HOST_MSD_LUN_HANDLE lunHandle)
1231:                
1232:                  Summary:
1233:                    This function is called by the MSD Host Client Driver to update the driver
1234:                    state machine.
1235:                
1236:                  Description:
1237:                    This function is called by the MSD Host Client Driver to update the driver
1238:                    state machine.
1239:                
1240:                  Remarks:
1241:                    The application will never need to call this function. This function is
1242:                    always called the USB Host MSD Client Driver.
1243:                */
1244:                
1245:                void USB_HOST_SCSI_Tasks(USB_HOST_MSD_LUN_HANDLE lunHandle)
1246:                {
9D016D78  27BDFFE8   ADDIU SP, SP, -24
9D016D7C  AFBF0014   SW RA, 20(SP)
1247:                    int scsiObjIndex;
1248:                
1249:                    /* Find the SCSI object that own this LUN */
1250:                    scsiObjIndex = _USB_HOST_SCSI_LUNHandleToSCSIInstance(lunHandle);
9D016D80  0F405B53   JAL _USB_HOST_SCSI_LUNHandleToSCSIInstance
9D016D84  00000000   NOP
1251:                
1252:                    if(scsiObjIndex >= 0)
9D016D88  04400004   BLTZ V0, 0x9D016D9C
9D016D8C  8FBF0014   LW RA, 20(SP)
1253:                    {
1254:                        _USB_HOST_SCSI_TasksByIndex(scsiObjIndex);
9D016D90  0F401426   JAL _USB_HOST_SCSI_TasksByIndex
9D016D94  00402021   ADDU A0, V0, ZERO
1255:                    }
1256:                }
9D016D98  8FBF0014   LW RA, 20(SP)
1257:                
1258:                // ******************************************************************************
1259:                /* Function:
1260:                    USB_HOST_SCSI_HANDLE USB_HOST_SCSI_Open 
1261:                    (
1262:                        const SYS_MODULE_INDEX index, 
1263:                        const DRV_IO_INTENT intent
1264:                    );
1265:                
1266:                  Summary:
1267:                    This function will open the specified instance of the SCSI driver.
1268:                
1269:                  Description:
1270:                    This function will open the specified instance of the SCSI driver. The
1271:                    handle will allow the client to read and write data to the SCSI device.
1272:                
1273:                  Remarks:
1274:                    This function is typically called by the file system media manager.
1275:                */
1276:                
1277:                USB_HOST_SCSI_HANDLE USB_HOST_SCSI_Open 
1278:                (
1279:                    SYS_MODULE_INDEX index, 
1280:                    DRV_IO_INTENT intent
1281:                )
1282:                {
9D016834  3084FFFF   ANDI A0, A0, -1
1283:                    USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
1284:                    USB_HOST_SCSI_HANDLE result;
1285:                
1286:                    if(index >= USB_HOST_MSD_LUN_NUMBERS)
9D016838  1480000C   BNE A0, ZERO, 0x9D01686C
9D01683C  2402FFFF   ADDIU V0, ZERO, -1
1287:                    {
1288:                        /* Invalid driver index */
1289:                        result = USB_HOST_SCSI_HANDLE_INVALID;
1290:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host SCSI: Invalid LUN index in USB_HOST_SCSI_Open().");
1291:                    }
1292:                    else
1293:                    {
1294:                        scsiObj = &gUSBHostSCSIObj[index];
1295:                        if((scsiObj->inUse) && (scsiObj->state == USB_HOST_SCSI_STATE_READY))
9D016840  3C028000   LUI V0, -32768
9D016844  904309BC   LBU V1, 2492(V0)
9D016848  10600008   BEQ V1, ZERO, 0x9D01686C
9D01684C  2402FFFF   ADDIU V0, ZERO, -1
9D016850  3C028000   LUI V0, -32768
9D016854  8C4409C4   LW A0, 2500(V0)
9D016858  24030008   ADDIU V1, ZERO, 8
9D01685C  14830003   BNE A0, V1, 0x9D01686C
9D016860  2402FFFF   ADDIU V0, ZERO, -1
1296:                        {
1297:                            /* This means this object is ready for use */
1298:                            result = (USB_HOST_SCSI_HANDLE)(scsiObj);
9D016864  3C028000   LUI V0, -32768
9D016868  244209BC   ADDIU V0, V0, 2492
1299:                        }
1300:                        else
1301:                        {
1302:                            /* Not ready to be opened */
1303:                            _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)index, USB_HOST_SCSI_ERROR_CODE_OPEN_FAIL_ON_BUSY);
1304:                            result = USB_HOST_SCSI_HANDLE_INVALID;
1305:                        }
1306:                    }
1307:                
1308:                    return(result);
1309:                }
9D01686C  03E00008   JR RA
1310:                
1311:                // ******************************************************************************
1312:                /* Function:
1313:                    USB_HOST_SCSI_HANDLE USB_HOST_SCSI_Close 
1314:                    (
1315:                        USB_HOST_SCSI_HANDLE scsiHandle
1316:                    );
1317:                
1318:                  Summary:
1319:                    This function will close the specified instance of the SCSI driver.
1320:                
1321:                  Description:
1322:                    This function will close the specified instance of the SCSI driver. The
1323:                    handle in scsiHandle will not be valid any more. The driver must be opened
1324:                    once again.
1325:                
1326:                  Remarks:
1327:                    This function is typically called by the file system media manager.
1328:                */
1329:                
1330:                void USB_HOST_SCSI_Close 
1331:                (
1332:                    USB_HOST_SCSI_HANDLE scsiHandle
1333:                )
1334:                {
9D0173B8  03E00008   JR RA
1335:                    /* This function is not implemented in this release of the driver */
1336:                }
1337:                
1338:                // ******************************************************************************
1339:                /* Function:
1340:                    bool USB_HOST_SCSI_MediaStatusGet 
1341:                    (
1342:                        USB_HOST_SCSI_HANDLE scsiHandle
1343:                    );
1344:                
1345:                  Summary:
1346:                    This function will return true if the SCSI media is attached and ready to
1347:                    use.
1348:                
1349:                  Description:
1350:                    This function will return true if the SCSI media is attached and ready to
1351:                    use.
1352:                
1353:                  Remarks:
1354:                    This function is typically called by the file system media manager.
1355:                */
1356:                
1357:                bool USB_HOST_SCSI_MediaStatusGet 
1358:                (
1359:                    USB_HOST_SCSI_HANDLE scsiHandle
1360:                )
1361:                {
1362:                    USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
1363:                    bool result = false;
1364:                
1365:                    /* Validate the SCSI handle */
1366:                    if((USB_HOST_SCSI_HANDLE_INVALID != scsiHandle) &&
9D016B54  2483FFFF   ADDIU V1, A0, -1
9D016B58  2C63FFFE   SLTIU V1, V1, -2
9D016B5C  10600007   BEQ V1, ZERO, 0x9D016B7C
9D016B60  00001021   ADDU V0, ZERO, ZERO
1367:                            (0 != scsiHandle))
1368:                    {
1369:                        /* The handle is actually a pointer to the SCSI object */
1370:                        scsiObj = (USB_HOST_SCSI_INSTANCE_OBJ *)scsiHandle;
1371:                
1372:                        if((scsiObj->inUse) && (scsiObj->state == USB_HOST_SCSI_STATE_READY) && (scsiObj->isMediaReady))
9D016B64  90830000   LBU V1, 0(A0)
9D016B68  10600004   BEQ V1, ZERO, 0x9D016B7C
9D016B6C  24030008   ADDIU V1, ZERO, 8
9D016B70  8C850008   LW A1, 8(A0)
9D016B74  50A30001   BEQL A1, V1, 0x9D016B7C
9D016B78  908200CD   LBU V0, 205(A0)
1373:                        {
1374:                            /* Device is attached and ready to use */
1375:                            result = true;
1376:                        }
1377:                    }
1378:                
1379:                    return(result);
1380:                }
9D016B7C  03E00008   JR RA
1381:                
1382:                // ******************************************************************************
1383:                /* Function:
1384:                    void USB_HOST_SCSI_SectorRead 
1385:                    (
1386:                        USB_HOST_SCSI_HANDLE scsiHandle,
1387:                        SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle,
1388:                        void * buffer,
1389:                        uint32_t blockStart,
1390:                        uint32_t nBlock
1391:                    );
1392:                
1393:                  Summary:
1394:                    Performs a block read operation.
1395:                
1396:                  Description:
1397:                    This function will perform a block read operation. The operation will not
1398:                    complete when the function returns. Instead a handle to the operation will
1399:                    be returned in commandHandle and driver will generate an event when the
1400:                    operation has completed. The command handle will be returned along with the
1401:                    event. The data will be stored in buffer. Data will be read from the
1402:                    blockStart block and nBlock buffers will be read.
1403:                
1404:                  Remarks:
1405:                    This function is typically called by the file system media manager.
1406:                */
1407:                
1408:                void USB_HOST_SCSI_SectorRead 
1409:                (
1410:                    USB_HOST_SCSI_HANDLE scsiHandle,
1411:                    SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle,
1412:                    void * buffer,
1413:                    uint32_t blockStart,
1414:                    uint32_t nBlock
1415:                )
1416:                {
9D016CF4  27BDFFE0   ADDIU SP, SP, -32
9D016CF8  AFBF001C   SW RA, 28(SP)
1417:                     /* Perform a read transfer */
1418:                    _USB_HOST_SCSI_Transfer(scsiHandle, commandHandle, blockStart, nBlock, buffer, USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST);
9D016CFC  AFA60010   SW A2, 16(SP)
9D016D00  24020080   ADDIU V0, ZERO, 128
9D016D04  AFA20014   SW V0, 20(SP)
9D016D08  00E03021   ADDU A2, A3, ZERO
9D016D0C  0F403C6F   JAL _USB_HOST_SCSI_Transfer
9D016D10  8FA70030   LW A3, 48(SP)
1419:                }
9D016D14  8FBF001C   LW RA, 28(SP)
1420:                
1421:                // ******************************************************************************
1422:                /* Function:
1423:                    void USB_HOST_SCSI_SectorWrite 
1424:                    (
1425:                        USB_HOST_SCSI_HANDLE scsiHandle,
1426:                        SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle,
1427:                        void * buffer,
1428:                        uint32_t blockStart,
1429:                        uint32_t nBlock
1430:                    );
1431:                
1432:                  Summary:
1433:                    Performs a block write operation.
1434:                
1435:                  Description:
1436:                    This function will perform a block write operation. The operation will not
1437:                    complete when the function returns. Instead a handle to the operation will
1438:                    be returned in commandHandle and driver will generate an event when the
1439:                    operation has completed. The command handle will be returned along with the
1440:                    event. The data to be written is specified by buffer. Data will be written
1441:                    to the blockStart block and nBlock buffers will be written.
1442:                
1443:                  Remarks:
1444:                    This function is typically called by the file system media manager.
1445:                */
1446:                
1447:                void USB_HOST_SCSI_SectorWrite 
1448:                (
1449:                    USB_HOST_SCSI_HANDLE scsiHandle,
1450:                    SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE * commandHandle,
1451:                    void * buffer,
1452:                    uint32_t blockStart,
1453:                    uint32_t nBlock
1454:                )
1455:                {
9D016EE8  27BDFFE0   ADDIU SP, SP, -32
9D016EEC  AFBF001C   SW RA, 28(SP)
1456:                    /* Perform a write transfer */
1457:                    _USB_HOST_SCSI_Transfer(scsiHandle, commandHandle, blockStart, nBlock, buffer, USB_HOST_MSD_TRANSFER_DIRECTION_HOST_TO_DEVICE);
9D016EF0  AFA60010   SW A2, 16(SP)
9D016EF4  AFA00014   SW ZERO, 20(SP)
9D016EF8  00E03021   ADDU A2, A3, ZERO
9D016EFC  0F403C6F   JAL _USB_HOST_SCSI_Transfer
9D016F00  8FA70030   LW A3, 48(SP)
1458:                }
9D016F04  8FBF001C   LW RA, 28(SP)
1459:                
1460:                // ******************************************************************************
1461:                /* Function:
1462:                    void USB_HOST_SCSI_EventHandlerSet 
1463:                    (
1464:                        USB_HOST_SCSI_HANDLE scsiHandle,
1465:                        const void * eventHandler,
1466:                        const uintptr_t context
1467:                    );
1468:                
1469:                  Summary:
1470:                    Registers an event handler with media driver.
1471:                
1472:                  Description:
1473:                    This function will register an event handler with the SCSI driver. When read
1474:                    or a write command has completed, the SCSI driver will call this function
1475:                    with the relevant event. The context parameter will returned with this
1476:                    event.
1477:                
1478:                  Remarks:
1479:                    This function is typically called by the file system media manager.
1480:                */
1481:                
1482:                void USB_HOST_SCSI_EventHandlerSet 
1483:                (
1484:                    USB_HOST_SCSI_HANDLE scsiHandle,
1485:                    const void * eventHandler,
1486:                    const uintptr_t context
1487:                )
1488:                {
1489:                    USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
1490:                
1491:                    if((scsiHandle != USB_HOST_SCSI_HANDLE_INVALID) && (scsiHandle != 0))
9D016CC8  2482FFFF   ADDIU V0, A0, -1
9D016CCC  2C42FFFE   SLTIU V0, V0, -2
9D016CD0  10400006   BEQ V0, ZERO, 0x9D016CEC
9D016CD4  00000000   NOP
1492:                    {
1493:                        /* Set the event handler and the context */
1494:                        scsiObj = (USB_HOST_SCSI_INSTANCE_OBJ *)(scsiHandle);
1495:                        if(scsiObj->inUse)
9D016CD8  90820000   LBU V0, 0(A0)
9D016CDC  10400003   BEQ V0, ZERO, 0x9D016CEC
9D016CE0  00000000   NOP
1496:                        {
1497:                            /* Only if the object is valid */
1498:                            scsiObj->eventHandler = eventHandler;
9D016CE4  AC8500C0   SW A1, 192(A0)
1499:                            scsiObj->context = context;
9D016CE8  AC8600C4   SW A2, 196(A0)
1500:                        }
1501:                    }
1502:                }
1503:                
1504:                // ******************************************************************************
1505:                /* Function:
1506:                    SYS_FS_MEDIA_GEOMETRY * USB_HOST_SCSI_MediaGeometryGet 
1507:                    (
1508:                        USB_HOST_SCSI_HANDLE scsiHandle
1509:                    );
1510:                
1511:                  Summary:
1512:                    Return the media geometry of this media.
1513:                
1514:                  Description:
1515:                    This function will return the media geometry of this media. 
1516:                
1517:                  Remarks:
1518:                    This function is typically called by the file system media manager.
1519:                */
1520:                
1521:                SYS_FS_MEDIA_GEOMETRY * USB_HOST_SCSI_MediaGeometryGet 
1522:                (
1523:                    USB_HOST_SCSI_HANDLE scsiHandle
1524:                )
1525:                {
1526:                    USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
1527:                    SYS_FS_MEDIA_GEOMETRY * result;
1528:                
1529:                    result = NULL;
9D016720  03E00008   JR RA
9D016724  00001021   ADDU V0, ZERO, ZERO
1530:                    if((scsiHandle != USB_HOST_SCSI_HANDLE_INVALID) && (scsiHandle != 0))
9D0166EC  2482FFFF   ADDIU V0, A0, -1
9D0166F0  2C42FFFE   SLTIU V0, V0, -2
9D0166F4  1040000A   BEQ V0, ZERO, 0x9D016720
9D0166F8  00000000   NOP
1531:                    {
1532:                        /* Set the event handler and the context */
1533:                        scsiObj = (USB_HOST_SCSI_INSTANCE_OBJ *)(scsiHandle);
1534:                        if((scsiObj->inUse) && (scsiObj->state == USB_HOST_SCSI_STATE_READY))
9D0166FC  90820000   LBU V0, 0(A0)
9D016700  10400009   BEQ V0, ZERO, 0x9D016728
9D016704  00000000   NOP
9D016708  8C820008   LW V0, 8(A0)
1535:                        {
1536:                            /* Only if the object is valid */
1537:                            result = &scsiObj->mediaGeometry;
9D01670C  24840094   ADDIU A0, A0, 148
9D016710  38420008   XORI V0, V0, 8
9D016714  0002200B   MOVN A0, ZERO, V0
9D016718  03E00008   JR RA
9D01671C  00801021   ADDU V0, A0, ZERO
1538:                        }
1539:                    }
1540:                    
1541:                    return(result);
1542:                }
9D016728  03E00008   JR RA
1543:                
1544:                // ******************************************************************************
1545:                /* Function:
1546:                    void _USB_HOST_SCSI_DetachDetectTasks(int scsiObjIndex)
1547:                
1548:                  Summary:
1549:                    This function is called periodically by the USB_HOST_SCSI_Tasks() function
1550:                    to check if the media is still attached.
1551:                
1552:                  Description:
1553:                    This function is called periodically by the USB_HOST_SCSI_Tasks() function
1554:                    to check if the media is still attached. It uses the Test Unit ready command
1555:                    to check if the media responding. If the media is not responding the
1556:                    function moves the main state machine to initial state.
1557:                
1558:                  Remarks:
1559:                    None.
1560:                */
1561:                
1562:                void _USB_HOST_SCSI_DetachDetectTasks(int scsiObjIndex)
1563:                {
9D00E414  27BDFFD0   ADDIU SP, SP, -48
9D00E418  AFBF002C   SW RA, 44(SP)
9D00E41C  AFB10028   SW S1, 40(SP)
9D00E420  AFB00024   SW S0, 36(SP)
1564:                    USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
1565:                    USB_HOST_MSD_RESULT result;
1566:                
1567:                    scsiObj = &gUSBHostSCSIObj[scsiObjIndex];
9D00E424  00041140   SLL V0, A0, 5
9D00E428  00042200   SLL A0, A0, 8
9D00E42C  00822023   SUBU A0, A0, V0
9D00E430  3C108000   LUI S0, -32768
9D00E434  261009BC   ADDIU S0, S0, 2492
9D00E438  02048021   ADDU S0, S0, A0
1568:                
1569:                    switch(scsiObj->detachTaskState)
9D00E43C  8E020010   LW V0, 16(S0)
9D00E440  24030002   ADDIU V1, ZERO, 2
9D00E444  1043002B   BEQ V0, V1, 0x9D00E4F4
9D00E448  2C430003   SLTIU V1, V0, 3
9D00E44C  10600006   BEQ V1, ZERO, 0x9D00E468
9D00E450  24030003   ADDIU V1, ZERO, 3
9D00E454  24030001   ADDIU V1, ZERO, 1
9D00E458  10430009   BEQ V0, V1, 0x9D00E480
9D00E45C  26110045   ADDIU S1, S0, 69
9D00E468  10430048   BEQ V0, V1, 0x9D00E58C
9D00E46C  24030004   ADDIU V1, ZERO, 4
9D00E470  50430052   BEQL V0, V1, 0x9D00E5BC
9D00E474  920200D8   LBU V0, 216(S0)
1570:                    {
1571:                        case USB_HOST_SCSI_DETACH_TASK_STATE_IDLE:
1572:                
1573:                            /* Nothing to be done in this state */
1574:                            break;
1575:                
1576:                        case USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_SEND:
1577:                
1578:                            /* In this state, the driver prepares and send the Test Unit
1579:                             * ready command */
1580:                            _USB_HOST_SCSI_TestUnitReadyCommand(scsiObj->taskCommandObj.cdb);
9D00E480  0F405C61   JAL _USB_HOST_SCSI_TestUnitReadyCommand
9D00E484  02202021   ADDU A0, S1, ZERO
1581:                
1582:                            /* Send the command. The commandCompleted flag will be update in
1583:                             * the event handler  */
1584:                            scsiObj->taskCommandObj.inUse = true;
9D00E488  24020001   ADDIU V0, ZERO, 1
9D00E48C  A2020044   SB V0, 68(S0)
1585:                            scsiObj->taskCommandObj.commandCompleted = false;
9D00E490  A2000055   SB ZERO, 85(S0)
1586:                
1587:                            result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, 
9D00E494  8E040018   LW A0, 24(S0)
9D00E498  AFA00010   SW ZERO, 16(SP)
9D00E49C  24020080   ADDIU V0, ZERO, 128
9D00E4A0  AFA20014   SW V0, 20(SP)
9D00E4A4  3C029D01   LUI V0, -25343
9D00E4A8  24427168   ADDIU V0, V0, 29032
9D00E4AC  AFA20018   SW V0, 24(SP)
9D00E4B4  AFA2001C   SW V0, 28(SP)
9D00E4B8  02202821   ADDU A1, S1, ZERO
9D00E4BC  24060006   ADDIU A2, ZERO, 6
9D00E4C0  0F403ACA   JAL USB_HOST_MSD_Transfer
9D00E4C4  00003821   ADDU A3, ZERO, ZERO
1588:                                    scsiObj->taskCommandObj.cdb, 6, NULL, 0, 
1589:                                    USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST,
1590:                                    _USB_HOST_SCSI_CommandCallback, (uintptr_t)(&scsiObj->taskCommandObj));
9D00E4B0  26020044   ADDIU V0, S0, 68
1591:                
1592:                            if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D00E4C8  24030003   ADDIU V1, ZERO, 3
9D00E4CC  14430004   BNE V0, V1, 0x9D00E4E0
9D00E4D0  24030005   ADDIU V1, ZERO, 5
1593:                            {
1594:                                /* The request was scheduled successfully. Wait for the
1595:                                 * request to complete */
1596:                
1597:                                scsiObj->detachTaskState = USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_WAIT;
9D00E4D4  24020002   ADDIU V0, ZERO, 2
9D00E4D8  0B403974   J 0x9D00E5D0
9D00E4DC  AE020010   SW V0, 16(S0)
1598:                                _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_IDLE_TEST_UNIT_READY);
1599:                            }
1600:                            else if(result == USB_HOST_MSD_RESULT_BUSY)
9D00E4E0  1443003C   BNE V0, V1, 0x9D00E5D4
9D00E4E4  8FBF002C   LW RA, 44(SP)
1601:                            {
1602:                                /* If MSD is busy then we should really retry this after some time
1603:                                 * */
1604:                                scsiObj->detachTaskState = USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_DELAY;
9D00E4E8  24020003   ADDIU V0, ZERO, 3
9D00E4EC  0B403974   J 0x9D00E5D0
9D00E4F0  AE020010   SW V0, 16(S0)
1605:                            }
1606:                
1607:                
1608:                            break;
1609:                
1610:                        case USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_WAIT:
1611:                
1612:                            /* Here we are waiting for the test unit command to complete */
1613:                
1614:                            if(scsiObj->taskCommandObj.commandCompleted)
9D00E4F4  92020055   LBU V0, 85(S0)
9D00E4F8  10400020   BEQ V0, ZERO, 0x9D00E57C
9D00E4FC  00000000   NOP
1615:                            {
1616:                                /* The status of the test unit ready command can be read
1617:                                 * from the CSW */
1618:                
1619:                                if(scsiObj->taskCommandObj.result == USB_HOST_MSD_RESULT_COMMAND_PASSED)
9D00E500  8E020058   LW V0, 88(S0)
9D00E504  54400007   BNEL V0, ZERO, 0x9D00E524
9D00E508  A20000CD   SB ZERO, 205(S0)
1620:                                {
1621:                                    /* Indicate that media is ready and reset the
1622:                                     * detachTimeOut counter */
1623:                                    scsiObj->isMediaReady = true;
9D00E50C  24020001   ADDIU V0, ZERO, 1
9D00E510  A20200CD   SB V0, 205(S0)
1624:                                    scsiObj->detachTimeOut = 0;
9D00E514  AE0000DC   SW ZERO, 220(S0)
1625:                                    scsiObj->detachTaskState = USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_DELAY;
9D00E518  24020003   ADDIU V0, ZERO, 3
9D00E51C  0B403974   J 0x9D00E5D0
9D00E520  AE020010   SW V0, 16(S0)
1626:                                }
1627:                                else
1628:                                {
1629:                                    /* The test unit ready command failed. Increment the detach count */
1630:                                    scsiObj->isMediaReady = false;
1631:                                    scsiObj->detachTimeOut += USB_HOST_SCSI_DETACH_TEST_UNIT_READY_INTERVAL;
9D00E524  8E0200DC   LW V0, 220(S0)
9D00E528  24420064   ADDIU V0, V0, 100
9D00E52C  AE0200DC   SW V0, 220(S0)
1632:                                    if(scsiObj->detachTimeOut >= USB_HOST_SCSI_DETACH_TIME_OUT)
9D00E530  2C4201F4   SLTIU V0, V0, 500
9D00E534  1440000F   BNE V0, ZERO, 0x9D00E574
9D00E538  24020003   ADDIU V0, ZERO, 3
1633:                                    {
1634:                                        /* This means that the media has most probably
1635:                                         * detached. Deregister the media from the file
1636:                                         * system and then try re-start the media bring up
1637:                                         * process. */
1638:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host SCSI: SCSI Instance %d Media was detached", scsiObjIndex);
1639:                                        
1640:                                        if(scsiObj->eventHandler != NULL)
9D00E53C  8E0200C0   LW V0, 192(S0)
9D00E540  10400004   BEQ V0, ZERO, 0x9D00E554
9D00E544  24040002   ADDIU A0, ZERO, 2
1641:                                        {
1642:                                            /* Let the client know that device has been detached. */
1643:                                            scsiObj->eventHandler(USB_HOST_SCSI_EVENT_DETACH, USB_HOST_SCSI_COMMAND_HANDLE_INVALID, scsiObj->context);
9D00E548  2405FFFF   ADDIU A1, ZERO, -1
9D00E54C  0040F809   JALR V0
9D00E550  8E0600C4   LW A2, 196(S0)
1644:                                        }
1645:                                        
1646:                                        _USB_HOST_SCSI_FILE_SYSTEM_DEREGISTER(scsiObj->fsHandle);
9D00E554  0F405C76   JAL SYS_FS_MEDIA_MANAGER_DeRegister
9D00E558  8E040004   LW A0, 4(S0)
1647:                                        scsiObj->fsHandle = SYS_FS_MEDIA_HANDLE_INVALID;
9D00E55C  2402FFFF   ADDIU V0, ZERO, -1
9D00E560  AE020004   SW V0, 4(S0)
1648:                                        scsiObj->state = USB_HOST_SCSI_STATE_INQUIRY_RESPONSE;
9D00E564  24020001   ADDIU V0, ZERO, 1
9D00E568  AE020008   SW V0, 8(S0)
9D00E56C  0B403974   J 0x9D00E5D0
9D00E570  AE000010   SW ZERO, 16(S0)
1649:                                        scsiObj->detachTaskState = USB_HOST_SCSI_DETACH_TASK_STATE_IDLE;
1650:                                        _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_DETACH_TIME_OUT);
1651:                                    }
1652:                                    else
1653:                                    {
1654:                                        /* We need to keep sending the test unit ready.
1655:                                         * Start the delay and then send the command again
1656:                                         * */
1657:                                        scsiObj->detachTaskState = USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_DELAY;
9D00E574  0B403974   J 0x9D00E5D0
9D00E578  AE020010   SW V0, 16(S0)
1658:                                    }
1659:                                }
1660:                            }
1661:                            else
1662:                            {
1663:                                /* Continue to run the transfer error tasks while waiting
1664:                                 * for the transfer to complete */
1665:                                USB_HOST_MSD_TransferErrorTasks(scsiObj->lunHandle);
9D00E57C  0F402234   JAL USB_HOST_MSD_TransferErrorTasks
9D00E580  8E040018   LW A0, 24(S0)
1666:                            }
1667:                
1668:                            break;
1669:                
1670:                        case USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_DELAY:
1671:                            /* In this state we start a delay before launching the Test Unit
1672:                             * Ready command */
1673:                            scsiObj->timerExpired = false;
9D00E58C  A20000D8   SB ZERO, 216(S0)
1674:                            scsiObj->commandDelayHandle = SYS_TMR_CallbackSingle( USB_HOST_SCSI_DETACH_TEST_UNIT_READY_INTERVAL, (uintptr_t )scsiObj, _USB_HOST_SCSI_TimerCallback );
9D00E590  24040064   ADDIU A0, ZERO, 100
9D00E594  02002821   ADDU A1, S0, ZERO
9D00E598  3C069D01   LUI A2, -25343
9D00E59C  0F405C4C   JAL SYS_TMR_CallbackSingle
9D00E5A0  24C67338   ADDIU A2, A2, 29496
1675:                            if (scsiObj->commandDelayHandle != SYS_TMR_HANDLE_INVALID)
9D00E5A4  2403FFFF   ADDIU V1, ZERO, -1
9D00E5A8  10430009   BEQ V0, V1, 0x9D00E5D0
9D00E5AC  AE0200D4   SW V0, 212(S0)
1676:                            {
1677:                                /* The delay has started. Now wait for the delay to complete
1678:                                 * */
1679:                
1680:                                scsiObj->detachTaskState = USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_DELAY_WAIT;
9D00E5B0  24020004   ADDIU V0, ZERO, 4
9D00E5B4  0B403974   J 0x9D00E5D0
9D00E5B8  AE020010   SW V0, 16(S0)
1681:                            }
1682:                            else
1683:                            {
1684:                                /* Continue to stay in this state till the delay could be
1685:                                 * scheduled */
1686:                            }
1687:                            break;
1688:                
1689:                        case USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_DELAY_WAIT:
1690:                            /* Check if the delay has completed */
1691:                
1692:                            if(scsiObj->timerExpired )
9D00E5BC  10400004   BEQ V0, ZERO, 0x9D00E5D0
9D00E5C0  24020001   ADDIU V0, ZERO, 1
1693:                            {
1694:                                /* Delay has completed. Send the test unit ready command */
1695:                                scsiObj->detachTaskState = USB_HOST_SCSI_DETACH_TASK_STATE_TEST_UNIT_READY_SEND;
9D00E5C4  AE020010   SW V0, 16(S0)
1696:                                scsiObj->commandDelayHandle = SYS_TMR_HANDLE_INVALID ;
9D00E5C8  2402FFFF   ADDIU V0, ZERO, -1
9D00E5CC  AE0200D4   SW V0, 212(S0)
1697:                               
1698:                            }
1699:                            else
1700:                            {
1701:                                /* Stay in this state. Continue to check if the delay has
1702:                                 * completed */
1703:                            }
1704:                            break;
1705:                
1706:                        default:
1707:                            break;
1708:                    }
1709:                }
9D00E460  0B403975   J 0x9D00E5D4
9D00E464  8FBF002C   LW RA, 44(SP)
9D00E478  0B403975   J 0x9D00E5D4
9D00E47C  8FBF002C   LW RA, 44(SP)
9D00E584  0B403975   J 0x9D00E5D4
9D00E588  8FBF002C   LW RA, 44(SP)
9D00E5D0  8FBF002C   LW RA, 44(SP)
1710:                
1711:                USB_HOST_MSD_LUN_HANDLE USB_HOST_SCSI_MSDLUNHandleGet(USB_HOST_SCSI_OBJ scsiObj)
1712:                {
1713:                    /* This function return the MSD LUN Handle associated with this SCSI object */
1714:                    USB_HOST_MSD_LUN_HANDLE result = USB_HOST_MSD_LUN_HANDLE_INVALID;
1715:                    int scsiObjIndex = (int)scsiObj;
1716:                    
1717:                    if(gUSBHostSCSIObj[scsiObjIndex].inUse)
00000000  00000000   NOP
1718:                    {
1719:                        result = gUSBHostSCSIObj[scsiObjIndex].lunHandle;
00000020  00000000   NOP
1720:                    }
1721:                            
1722:                    return(result);
1723:                    
1724:                }
0000003C  00000000   NOP
1725:                
1726:                // ******************************************************************************
1727:                /* Function:
1728:                    void USB_HOST_SCSI_TransferTasks (USB_HOST_MSD_LUN_HANDLE lunHandle)
1729:                
1730:                  Summary:
1731:                    This function is should be called periodically by the client that has opened
1732:                    the logical unit.
1733:                
1734:                  Description:
1735:                    This function is should be called periodically by the client that has opened
1736:                    the logical unit. It should be called when the client is waiting for read or
1737:                    This function maintains the read/write command state machine.  write command
1738:                    to complete.
1739:                
1740:                  Remarks:
1741:                    None.
1742:                */
1743:                
1744:                void USB_HOST_SCSI_TransferTasks(USB_HOST_MSD_LUN_HANDLE lunHandle)
1745:                {
9D009EA4  27BDFFD0   ADDIU SP, SP, -48
9D009EA8  AFBF002C   SW RA, 44(SP)
9D009EAC  AFB10028   SW S1, 40(SP)
9D009EB0  AFB00024   SW S0, 36(SP)
1746:                    int scsiObjIndex;
1747:                    USB_HOST_SCSI_INSTANCE_OBJ * scsiObj;
1748:                    USB_HOST_MSD_RESULT result;
1749:                    SCSI_SENSE_DATA * requestSenseResponse;
1750:                    USB_HOST_SCSI_COMMAND_OBJ * commandObj;
1751:                    bool doEventCallback = false;
9D00A14C  00001021   ADDU V0, ZERO, ZERO
1752:                    int iterator;
1753:                
1754:                    /* Run the MSD transfer error tasks. This will update the BOT transfer error
1755:                     * state machine */
1756:                    USB_HOST_MSD_TransferErrorTasks(lunHandle);    
9D009EB4  0F402234   JAL USB_HOST_MSD_TransferErrorTasks
9D009EB8  00808021   ADDU S0, A0, ZERO
1757:                
1758:                    /* Run the SCSI tasks for all the LUNs. This is only needed when the
1759:                     * application is running in Bare-metal mode. */
1760:                    
1761:                    for(iterator = 0; iterator < USB_HOST_MSD_LUN_NUMBERS; iterator++)
1762:                    {
1763:                        if(gUSBHostSCSIObj[iterator].inUse)
9D009EBC  3C028000   LUI V0, -32768
9D009EC0  904209BC   LBU V0, 2492(V0)
9D009EC4  10400003   BEQ V0, ZERO, 0x9D009ED4
9D009EC8  00000000   NOP
1764:                        {
1765:                            /* Run the task routine for all objects that are valid */
1766:                            _USB_HOST_SCSI_TasksByIndex(iterator);
9D009ECC  0F401426   JAL _USB_HOST_SCSI_TasksByIndex
9D009ED0  00002021   ADDU A0, ZERO, ZERO
1767:                        }
1768:                    }
1769:                
1770:                    /* Find the SCSI object that own this LUN */
1771:                    scsiObjIndex = _USB_HOST_SCSI_LUNHandleToSCSIInstance(lunHandle);
9D009ED4  0F405B53   JAL _USB_HOST_SCSI_LUNHandleToSCSIInstance
9D009ED8  02002021   ADDU A0, S0, ZERO
1772:                
1773:                    if(scsiObjIndex >= 0)
9D009EDC  044000A6   BLTZ V0, 0x9D00A178
9D009EE0  00021940   SLL V1, V0, 5
1774:                    {
1775:                        scsiObj = &gUSBHostSCSIObj[scsiObjIndex];
9D009EE4  00021200   SLL V0, V0, 8
9D009EE8  00431023   SUBU V0, V0, V1
9D009EEC  3C108000   LUI S0, -32768
9D009EF0  261009BC   ADDIU S0, S0, 2492
9D009EF4  02028021   ADDU S0, S0, V0
1776:                        commandObj = &scsiObj->commandObj;
1777:                
1778:                        switch(scsiObj->transferTaskState)
9D009EF8  8E02000C   LW V0, 12(S0)
9D009EFC  2C420008   SLTIU V0, V0, 8
9D009F00  10400092   BEQ V0, ZERO, 0x9D00A14C
9D009F04  3C029D01   LUI V0, -25343
9D009F08  8E03000C   LW V1, 12(S0)
9D009F0C  00031880   SLL V1, V1, 2
9D009F10  24429F20   ADDIU V0, V0, -24800
9D009F14  7C43100A   LWX V0, V1(V0)
9D009F18  00400008   JR V0
9D009F1C  00000000   NOP
1779:                        {
1780:                            case USB_HOST_SCSI_TRANSFER_STATE_IDLE:
1781:                
1782:                                /* In this state we don't have anything to do. */
1783:                                break;
1784:                
1785:                            case USB_HOST_SCSI_TRANSFER_STATE_REQUEST_SENSE:
1786:                
1787:                                /* We get into this state when a block command (READ10 or WRITE
1788:                                 * 10) has failed. We have to find out why. Note that we are not
1789:                                 * using the commandObj command object for these commands.
1790:                                 * commandObj will still contain the original command requested
1791:                                 * by the client. This will be needed just in case we need to
1792:                                 * retry the command. */
1793:                
1794:                                _USB_HOST_SCSI_RequestSenseCommand(scsiObj->transferErrorCommandObj.cdb);
9D009F40  2611006D   ADDIU S1, S0, 109
9D009F44  0F405BE9   JAL _USB_HOST_SCSI_RequestSenseCommand
9D009F48  02202021   ADDU A0, S1, ZERO
1795:                
1796:                                /* The commandCompleted flag will be updated in the callback.
1797:                                 * Update the state and send the command.   */
1798:                                scsiObj->transferErrorCommandObj.inUse = true;
9D009F4C  24020001   ADDIU V0, ZERO, 1
9D009F50  A202006C   SB V0, 108(S0)
1799:                                scsiObj->transferErrorCommandObj.commandCompleted = false;
9D009F54  A200007D   SB ZERO, 125(S0)
1800:                
1801:                                /* Send the command */
1802:                                result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, 
9D009F58  8E040018   LW A0, 24(S0)
9D009F5C  8E0700C8   LW A3, 200(S0)
9D009F60  24020012   ADDIU V0, ZERO, 18
9D009F64  AFA20010   SW V0, 16(SP)
9D009F68  24020080   ADDIU V0, ZERO, 128
9D009F6C  AFA20014   SW V0, 20(SP)
9D009F70  3C029D01   LUI V0, -25343
9D009F74  24427168   ADDIU V0, V0, 29032
9D009F78  AFA20018   SW V0, 24(SP)
9D009F80  AFA2001C   SW V0, 28(SP)
9D009F84  02202821   ADDU A1, S1, ZERO
9D009F88  0F403ACA   JAL USB_HOST_MSD_Transfer
9D009F8C  24060006   ADDIU A2, ZERO, 6
1803:                                        scsiObj->transferErrorCommandObj.cdb, 0x6, scsiObj->buffer, 18 , 
1804:                                        USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST,
1805:                                        _USB_HOST_SCSI_CommandCallback, (uintptr_t)(&scsiObj->transferErrorCommandObj));
9D009F7C  2602006C   ADDIU V0, S0, 108
1806:                
1807:                                if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D009F90  24030003   ADDIU V1, ZERO, 3
9D009F94  14430004   BNE V0, V1, 0x9D009FA8
9D009F98  2403FFFD   ADDIU V1, ZERO, -3
1808:                                {
1809:                                    /* Go to the next state only if the request was placed
1810:                                     * successfully. */
1811:                                    scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_WAIT_REQUEST_SENSE;
9D009F9C  24020002   ADDIU V0, ZERO, 2
9D009FA0  0B40285E   J 0x9D00A178
9D009FA4  AE02000C   SW V0, 12(S0)
1812:                                }
1813:                                else if(result == USB_HOST_MSD_RESULT_FAILURE  ||
9D009FA8  00431024   AND V0, V0, V1
9D009FAC  24030004   ADDIU V1, ZERO, 4
9D009FB0  14430072   BNE V0, V1, 0x9D00A17C
9D009FB4  8FBF002C   LW RA, 44(SP)
9D009FB8  0B402857   J 0x9D00A15C
9D009FBC  8E0200C0   LW V0, 192(S0)
1814:                                        result == USB_HOST_MSD_RESULT_LUN_HANDLE_INVALID)
1815:                                {
1816:                                    /* These errors return due to a bad handle, invalid parameter, and so on;
1817:                                       things that no amount of spinning and retrying will fix.  In this case
1818:                                       just set the callback and get out. */
1819:                                    doEventCallback = true;
1820:                                }
1821:                
1822:                
1823:                                break;
1824:                
1825:                            case USB_HOST_SCSI_TRANSFER_STATE_WAIT_REQUEST_SENSE:
1826:                
1827:                                /* Here we check if the request sense command has completed */
1828:                
1829:                                if(scsiObj->transferErrorCommandObj.commandCompleted)
9D009FC0  9202007D   LBU V0, 125(S0)
9D009FC4  1040006D   BEQ V0, ZERO, 0x9D00A17C
9D009FC8  8FBF002C   LW RA, 44(SP)
1830:                                {
1831:                                    if(scsiObj->transferErrorCommandObj.result == USB_HOST_MSD_RESULT_COMMAND_PASSED)
9D009FCC  8E020080   LW V0, 128(S0)
9D009FD0  1440006B   BNE V0, ZERO, 0x9D00A180
9D009FD4  8FB10028   LW S1, 40(SP)
1832:                                    {
1833:                                        /* Check the sense data */
1834:                                        requestSenseResponse = (SCSI_SENSE_DATA *)(scsiObj->buffer);
9D009FD8  8E0300C8   LW V1, 200(S0)
1835:                
1836:                                        if(requestSenseResponse->SenseKey == SCSI_SENSE_NOT_READY)
9D009FDC  90620002   LBU V0, 2(V1)
9D009FE0  3042000F   ANDI V0, V0, 15
9D009FE4  24040002   ADDIU A0, ZERO, 2
9D009FE8  14440004   BNE V0, A0, 0x9D009FFC
9D009FEC  24040006   ADDIU A0, ZERO, 6
1837:                                        {
1838:                                            /* This means the unit is not ready to serve the
1839:                                             * command. We have to send the Test Unit ready
1840:                                             * command to check when the unit becomes ready */
1841:                 
1842:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Block command failed on Unit not ready.", scsiObjIndex);
1843:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Testing if unit is ready.", scsiObjIndex);
1844:                                            scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_TEST_UNIT_READY;
9D009FF0  24020003   ADDIU V0, ZERO, 3
9D009FF4  0B40285E   J 0x9D00A178
9D009FF8  AE02000C   SW V0, 12(S0)
1845:                                            _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_READ_WRITE_TEST_UNIT_READY);
1846:                                        }
1847:                                        else if((requestSenseResponse->SenseKey == SCSI_SENSE_UNIT_ATTENTION) &&
9D009FFC  14440007   BNE V0, A0, 0x9D00A01C
9D00A000  24040003   ADDIU A0, ZERO, 3
9D00A004  9064000C   LBU A0, 12(V1)
9D00A008  2402003A   ADDIU V0, ZERO, 58
9D00A00C  54820008   BNEL A0, V0, 0x9D00A030
9D00A010  9062000D   LBU V0, 13(V1)
1848:                                                (requestSenseResponse->ASC == SCSI_ASC_MEDIUM_NOT_PRESENT))
1849:                                        {
1850:                                            /* This could probably mean that the medium was
1851:                                             * detached. We set the isMediaReady flag to false
1852:                                             * and then let the main SCSI state machine continue
1853:                                             * to check if the media is ready. We should also
1854:                                             * let the client know that block command has
1855:                                             * failed. */
1856:                
1857:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Block command failed on Media not present.", scsiObjIndex);
1858:                                            _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_READ_WRITE_MEDIUM_NOT_PRESENT);
1859:                                            scsiObj->isMediaReady = false;
1860:                                            doEventCallback = true;
9D00A014  0B402856   J 0x9D00A158
9D00A018  A20000CD   SB ZERO, 205(S0)
1861:                                        }
1862:                                        else if(requestSenseResponse->SenseKey == SCSI_SENSE_MEDIUM_ERROR)
9D00A01C  54440004   BNEL V0, A0, 0x9D00A030
9D00A020  9062000D   LBU V0, 13(V1)
1863:                                        {
1864:                                            /* This means there was an error on the medium */
1865:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Block command failed on Media Error.", scsiObjIndex);
1866:                                            _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_READ_WRITE_MEDIUM_ERROR);
1867:                                            scsiObj->isMediaError = true;
9D00A024  24020001   ADDIU V0, ZERO, 1
9D00A028  0B402856   J 0x9D00A158
9D00A02C  A20200CE   SB V0, 206(S0)
9D00A030  0B402854   J 0x9D00A150
9D00A034  2C420001   SLTIU V0, V0, 1
1868:                                            doEventCallback = true;
1869:                                        }
1870:                                        else if(requestSenseResponse->ASCQ == SCSI_ASCQ_WRITE_PROTECTED)
1871:                                        {
1872:                                            /* This means the medium is Write protected */
1873:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Block command failed on Media Write Protect Error.", scsiObjIndex);
1874:                                            doEventCallback = true;
1875:                                            _USB_HOST_SCSI_ERROR_CALLBACK((uintptr_t)scsiObjIndex, USB_HOST_SCSI_ERROR_CODE_MEDIA_WRITE_PROTECTED);
1876:                                        }
1877:                                    }
1878:                
1879:                                }
1880:                
1881:                                break;
1882:                
1883:                            case USB_HOST_SCSI_TRANSFER_STATE_TEST_UNIT_READY:
1884:                
1885:                                /* We get into this state if a SCSI block command failed and the
1886:                                 * request sense returned a sense code an media not ready. In
1887:                                 * this state we will periodically send the Test Unit ready
1888:                                 * command. */
1889:                
1890:                                _USB_HOST_SCSI_TestUnitReadyCommand(scsiObj->transferErrorCommandObj.cdb);
9D00A038  2611006D   ADDIU S1, S0, 109
9D00A03C  0F405C61   JAL _USB_HOST_SCSI_TestUnitReadyCommand
9D00A040  02202021   ADDU A0, S1, ZERO
1891:                
1892:                                /* Send the command. The commandCompleted flag will be update in
1893:                                 * the event handler  */
1894:                                scsiObj->transferErrorCommandObj.inUse = true;
9D00A044  24020001   ADDIU V0, ZERO, 1
9D00A048  A202006C   SB V0, 108(S0)
1895:                                scsiObj->transferErrorCommandObj.commandCompleted = false;
9D00A04C  A200007D   SB ZERO, 125(S0)
1896:                
1897:                                result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, 
9D00A050  8E040018   LW A0, 24(S0)
9D00A054  AFA00010   SW ZERO, 16(SP)
9D00A058  24020080   ADDIU V0, ZERO, 128
9D00A05C  AFA20014   SW V0, 20(SP)
9D00A060  3C029D01   LUI V0, -25343
9D00A064  24427168   ADDIU V0, V0, 29032
9D00A068  AFA20018   SW V0, 24(SP)
9D00A070  AFA2001C   SW V0, 28(SP)
9D00A074  02202821   ADDU A1, S1, ZERO
9D00A078  24060006   ADDIU A2, ZERO, 6
9D00A07C  0F403ACA   JAL USB_HOST_MSD_Transfer
9D00A080  00003821   ADDU A3, ZERO, ZERO
1898:                                        scsiObj->transferErrorCommandObj.cdb, 6, NULL, 0, 
1899:                                        USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST,
1900:                                        _USB_HOST_SCSI_CommandCallback, (uintptr_t)(&scsiObj->transferErrorCommandObj));
9D00A06C  2602006C   ADDIU V0, S0, 108
1901:                
1902:                                if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D00A084  24030003   ADDIU V1, ZERO, 3
9D00A088  14430004   BNE V0, V1, 0x9D00A09C
9D00A08C  2403FFFD   ADDIU V1, ZERO, -3
1903:                                {
1904:                                    /* The request was scheduled successfully. Wait for the
1905:                                     * request to complete */
1906:                
1907:                                    scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_WAIT_TEST_UNIT_READY;
9D00A090  24020004   ADDIU V0, ZERO, 4
9D00A094  0B40285E   J 0x9D00A178
9D00A098  AE02000C   SW V0, 12(S0)
1908:                                }
1909:                                
1910:                                else if(result == USB_HOST_MSD_RESULT_FAILURE  ||
9D00A09C  00431024   AND V0, V0, V1
9D00A0A0  24030004   ADDIU V1, ZERO, 4
9D00A0A4  14430035   BNE V0, V1, 0x9D00A17C
9D00A0A8  8FBF002C   LW RA, 44(SP)
9D00A0AC  0B402857   J 0x9D00A15C
9D00A0B0  8E0200C0   LW V0, 192(S0)
1911:                                        result == USB_HOST_MSD_RESULT_LUN_HANDLE_INVALID)
1912:                                {
1913:                                    /* The USB_HOST_MSD_Transfer may fail here if the device was
1914:                                     * disconnected or if some fatal error has occurred on the
1915:                                     * bus. In such a case, we must stop the transfer. */
1916:                
1917:                                    doEventCallback = true;
1918:                                }
1919:                
1920:                
1921:                                break;
1922:                
1923:                            case USB_HOST_SCSI_TRANSFER_STATE_WAIT_TEST_UNIT_READY:
1924:                
1925:                                /* Here we are waiting for the test unit command to complete */
1926:                
1927:                                if(scsiObj->transferErrorCommandObj.commandCompleted)
9D00A0B4  9202007D   LBU V0, 125(S0)
9D00A0B8  10400030   BEQ V0, ZERO, 0x9D00A17C
9D00A0BC  8FBF002C   LW RA, 44(SP)
1928:                                {
1929:                                    /* The status of the test unit ready command can be read
1930:                                     * from the CSW */
1931:                
1932:                                    if(scsiObj->transferErrorCommandObj.result == USB_HOST_MSD_RESULT_COMMAND_PASSED)
9D00A0C0  8E020080   LW V0, 128(S0)
9D00A0C4  54400004   BNEL V0, ZERO, 0x9D00A0D8
9D00A0C8  8E0200D0   LW V0, 208(S0)
1933:                                    {
1934:                                        /* This means the unit is ready. The block command
1935:                                         * should be re-tried. */
1936:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Test Unit is ready. Retrying block command.", scsiObjIndex);
1937:                                        scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_BLOCK_COMMAND_RETRY;
9D00A0CC  24020007   ADDIU V0, ZERO, 7
9D00A0D0  0B40285E   J 0x9D00A178
9D00A0D4  AE02000C   SW V0, 12(S0)
1938:                                    }
1939:                                    else
1940:                                    {
1941:                                        /* The test unit ready failed.  Before trying, we check
1942:                                         * how many time we have tried this already. If this has
1943:                                         * exceeded the retry count, then we fail the transfer.
1944:                                         * */
1945:                
1946:                                        if(scsiObj->nCommandFailureTestUnitReadyAttempts >= USB_HOST_SCSI_COMMAND_FAILURE_TEST_UNIT_READY_NUMBER)
9D00A0D8  2C430064   SLTIU V1, V0, 100
9D00A0DC  5060001F   BEQL V1, ZERO, 0x9D00A15C
9D00A0E0  8E0200C0   LW V0, 192(S0)
1947:                                        {
1948:                                            /* This means we have exceeded the re-try the count
1949:                                             * */
1950:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host SCSI: SCSI Instance %d Test Unit retry count exceeded. Failing the block command.", scsiObjIndex);
1951:                                            doEventCallback = true;
1952:                                        }
1953:                                        else
1954:                                        {
1955:                                            /* Increment the delay and try again */
1956:                                            scsiObj->nCommandFailureTestUnitReadyAttempts ++;
9D00A0E4  24420001   ADDIU V0, V0, 1
9D00A0E8  AE0200D0   SW V0, 208(S0)
1957:                                            scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_TEST_UNIT_READY;
9D00A0EC  24020003   ADDIU V0, ZERO, 3
9D00A0F0  0B40285E   J 0x9D00A178
9D00A0F4  AE02000C   SW V0, 12(S0)
1958:                                        }
1959:                                    }
1960:                                }
1961:                
1962:                                break;
1963:                
1964:                            case USB_HOST_SCSI_TRANSFER_STATE_BLOCK_COMMAND_RETRY:
1965:                
1966:                                /* In this state, we retry the block command that caused the
1967:                                 * failure in the first place. The block command parameter are a
1968:                                 * part of the command object */
1969:                
1970:                                result = USB_HOST_MSD_Transfer(scsiObj->lunHandle, 
9D00A0F8  8E040018   LW A0, 24(S0)
9D00A0FC  8E070038   LW A3, 56(S0)
9D00A100  8E02003C   LW V0, 60(S0)
9D00A104  00021240   SLL V0, V0, 9
9D00A108  AFA20010   SW V0, 16(SP)
9D00A10C  8E020040   LW V0, 64(S0)
9D00A110  AFA20014   SW V0, 20(SP)
9D00A114  3C029D01   LUI V0, -25343
9D00A118  24424B24   ADDIU V0, V0, 19236
9D00A11C  AFA20018   SW V0, 24(SP)
9D00A120  AFB0001C   SW S0, 28(SP)
9D00A124  2605001D   ADDIU A1, S0, 29
9D00A128  0F403ACA   JAL USB_HOST_MSD_Transfer
9D00A12C  2406000A   ADDIU A2, ZERO, 10
1971:                                        scsiObj->commandObj.cdb, 0x0A, scsiObj->commandObj.buffer , (scsiObj->commandObj.nSectors << 9) /* The left shift multiplies by 512 */, 
1972:                                        scsiObj->commandObj.direction, _USB_HOST_SCSI_BlockTransferCallback, (uintptr_t)(scsiObj));
1973:                
1974:                                /* Update the transfer handle */
1975:                                if(result == USB_HOST_MSD_RESULT_SUCCESS)
9D00A130  24030003   ADDIU V1, ZERO, 3
9D00A134  54430003   BNEL V0, V1, 0x9D00A144
9D00A138  38420004   XORI V0, V0, 4
9D00A13C  0B40285E   J 0x9D00A178
9D00A140  AE00000C   SW ZERO, 12(S0)
9D00A144  0B402854   J 0x9D00A150
9D00A148  2C420001   SLTIU V0, V0, 1
1976:                                {
1977:                                    /* This means we can return the transfer task state to idle
1978:                                     * */
1979:                                    scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_IDLE; 
1980:                                }
1981:                                else if (result == USB_HOST_MSD_RESULT_BUSY)
1982:                                {
1983:                                    /* Continue to try sending this command */
1984:                                }
1985:                                else if(result == USB_HOST_MSD_RESULT_FAILURE)
1986:                                {
1987:                                    /* An unknown failure has occurred. We should terminate the
1988:                                     * transfer. We should let the client know that transfer
1989:                                     * has failed. The transfer error tasks routine must return
1990:                                     * back to not doing anything. */
1991:                
1992:                                    doEventCallback = true;
1993:                
1994:                                }
1995:                
1996:                                break;
1997:                
1998:                            default:
1999:                                break;
2000:                        }
2001:                
2002:                        if(doEventCallback)
9D00A150  1040000A   BEQ V0, ZERO, 0x9D00A17C
9D00A154  8FBF002C   LW RA, 44(SP)
2003:                        {
2004:                            /* We should let the client know that transfer has failed.
2005:                             * The transfer error tasks routine must return back to not
2006:                             * doing anything. */
2007:                            if(scsiObj->eventHandler != NULL)
9D00A158  8E0200C0   LW V0, 192(S0)
9D00A15C  10400004   BEQ V0, ZERO, 0x9D00A170
9D00A160  24040001   ADDIU A0, ZERO, 1
2008:                            {
2009:                                /* Generate the event */
2010:                                (scsiObj->eventHandler)(USB_HOST_SCSI_EVENT_COMMAND_ERROR, 
9D00A164  2605001C   ADDIU A1, S0, 28
9D00A168  0040F809   JALR V0
9D00A16C  8E0600C4   LW A2, 196(S0)
2011:                                                        (USB_HOST_SCSI_COMMAND_HANDLE)(commandObj), 
2012:                                                        scsiObj->context);
2013:                            }
2014:                            
2015:                            /* Release the command object and reset the transfer state machine since 
2016:                               the command failed. */
2017:                            scsiObj->commandObj.inUse = false;
9D00A170  A200001C   SB ZERO, 28(S0)
2018:                            scsiObj->transferTaskState = USB_HOST_SCSI_TRANSFER_STATE_IDLE;
9D00A174  AE00000C   SW ZERO, 12(S0)
2019:                        }    
2020:                    }
2021:                }
9D00A178  8FBF002C   LW RA, 44(SP)
2022:                
2023:                // ****************************************************************************
2024:                /* Function:
2025:                    USB_HOST_SCSI_RESULT USB_HOST_SCSI_AttachEventHandlerSet
2026:                    (
2027:                        USB_HOST_SCSI_ATTACH_EVENT_HANDLER eventHandler,
2028:                        uintptr_t context
2029:                    );
2030:                           
2031:                  Summary:
2032:                    This function will set an attach event handler.
2033:                
2034:                  Description:
2035:                    This function will set an attach event handler. The attach event handler
2036:                    will be called when a Mass Storage Device that supports a SCSI command set
2037:                    is attached. The context will be returned in the event handler. 
2038:                    This function should be called before the bus has been enabled.
2039:                
2040:                  Remarks:
2041:                    Refer to usb_host_scsi.h for usage information.
2042:                */
2043:                
2044:                USB_HOST_SCSI_RESULT USB_HOST_SCSI_AttachEventHandlerSet
2045:                (
2046:                    USB_HOST_SCSI_ATTACH_EVENT_HANDLER eventHandler,
2047:                    uintptr_t context
2048:                )
2049:                {
2050:                    int iterator;
2051:                
2052:                    USB_HOST_SCSI_RESULT result = USB_HOST_SCSI_RESULT_FAILURE;
2053:                    USB_HOST_SCSI_ATTACH_LISTENER_OBJ * attachListener;
2054:                    
2055:                    if(eventHandler == NULL)
00000000  00000000   NOP
2056:                    {
2057:                        result = USB_HOST_SCSI_RESULT_PARAMETER_INVALID;
2058:                    }
2059:                    else
2060:                    {
2061:                        /* Search for free listener object */
2062:                        for(iterator = 0; iterator < USB_HOST_SCSI_ATTACH_LISTENERS_NUMBER; iterator ++)
2063:                        {
2064:                            if(!gUSBHostSCSIAttachListener[iterator].inUse)
2065:                            {
2066:                                /* Found a free object */
2067:                                attachListener = &gUSBHostSCSIAttachListener[iterator];
2068:                                attachListener->inUse = true;
2069:                                attachListener->eventHandler = eventHandler;
2070:                                attachListener->context = context;
2071:                                result = USB_HOST_SCSI_RESULT_SUCCESS;
2072:                                break;
2073:                            }
2074:                        }
2075:                    }
2076:                
2077:                    return(result);
2078:                }
00000004  00000000   NOP
2079:                
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/usb/src/dynamic/usb_host_msd.c
1:                   /*******************************************************************************
2:                     USB Mass Storage Client Driver Implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_host_msd.c
9:                   
10:                    Summary:
11:                      This file contains implementations of both private and public functions
12:                      of the USB Host MSD client driver.
13:                  
14:                    Description:
15:                      This file contains the USB host MSD client driver implementation. This file 
16:                      should be included in the project if USB MSD devices are to be supported.
17:                  *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute Software
24:                  only when embedded on a Microchip microcontroller or digital  signal  controller
25:                  that is integrated into your product or third party  product  (pursuant  to  the
26:                  sub license terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
32:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
36:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
38:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
39:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  #include "usb/usb_host_msd.h"
51:                  #include "usb/src/usb_host_msd_local.h"
52:                  #include "usb/usb_host_client_driver.h"
53:                  #include "system/debug/sys_debug.h"
54:                  #include "usb/usb_host_scsi.h"
55:                  #include <p32xxxx.h>
56:                  
57:                  /*************************************************
58:                   * Driver interface that is provide to the 
59:                   * host layer.
60:                   *************************************************/
61:                  
62:                  USB_HOST_CLIENT_DRIVER gUSBHostMSDClientDriver = 
63:                  {
64:                      .initialize = _USB_HOST_MSD_Initialize,
65:                      .deinitialize = _USB_HOST_MSD_Deinitialize,
66:                      .reinitialize = _USB_HOST_MSD_Reinitialize,
67:                      .interfaceAssign = _USB_HOST_MSD_InterfaceAssign,
68:                      .interfaceRelease = _USB_HOST_MSD_InterfaceRelease,
69:                      .interfaceEventHandler = _USB_HOST_MSD_InterfaceEventHandler,
70:                      .interfaceTasks = _USB_HOST_MSD_InterfaceTasks,
71:                      .deviceEventHandler = NULL,
72:                      .deviceAssign = NULL,
73:                      .deviceEventHandler = NULL,
74:                      .deviceRelease = NULL
75:                           
76:                  };
77:                  
78:                  /**************************************************
79:                   * If the error callback function has been enabled
80:                   * then declare it here.
81:                   **************************************************/
82:                  _USB_HOST_MSD_ERROR_CALLBACK_DECLARE
83:                  
84:                  /**************************************************
85:                   * Global array of MSD Instance Objects. Each for
86:                   * one MSD device attached.
87:                   ***************************************************/
88:                  USB_HOST_MSD_INSTANCE  gUSBHostMSDInstance[USB_HOST_MSD_INSTANCES_NUMBER];
89:                  
90:                  /***********************************************
91:                   * CBW and CSW structure needed by for the MSD
92:                   * function driver instance.
93:                   ***********************************************/
94:                  uint8_t gUSBHostMSDCBW[USB_HOST_MSD_INSTANCES_NUMBER][32] __attribute__((coherent)) __attribute__((aligned(16)));
95:                  uint8_t gUSBHostMSDCSW[USB_HOST_MSD_INSTANCES_NUMBER][16] __attribute__((coherent)) __attribute__((aligned(16)));
96:                  
97:                  // *****************************************************************************
98:                  // *****************************************************************************
99:                  // USB Host MSD Local Functions
100:                 // *****************************************************************************
101:                 // *****************************************************************************
102:                 
103:                 // *****************************************************************************
104:                 /* Function:
105:                    void _USB_HOST_MSD_TransferTasks
106:                    (
107:                         uintptr msdInstanceIndex,
108:                         USB_HOST_RESULT result,
109:                         size_t size
110:                    );
111:                 
112:                   Summary:
113:                     This function is called when a transfer event has occurred. This updates the
114:                     transfer state of an ongoing MSD transfer.
115:                 
116:                   Description:
117:                     This function is called when a transfer event has occurred. This updates the
118:                     transfer state of an ongoing MSD transfer.
119:                 
120:                   Remarks:
121:                     This is a local function and should not be called directly by the
122:                     application.
123:                 */
124:                 
125:                 void _USB_HOST_MSD_TransferTasks
126:                 (
127:                     uintptr_t msdInstanceIndex,
128:                     USB_HOST_RESULT result,
129:                     size_t size
130:                 )
131:                 {
9D00A46C  27BDFFD8   ADDIU SP, SP, -40
9D00A470  AFBF0024   SW RA, 36(SP)
9D00A474  AFB00020   SW S0, 32(SP)
132:                     USB_HOST_TRANSFER_HANDLE transferHandle;
133:                     USB_HOST_MSD_RESULT msdResult;
134:                     USB_HOST_PIPE_HANDLE pipeHandle;
135:                     USB_MSD_CSW * msdCSW;
136:                     size_t processedBytes = 0;
9D00A568  00003821   ADDU A3, ZERO, ZERO
9D00A5EC  00003821   ADDU A3, ZERO, ZERO
137:                     USB_HOST_MSD_TRANSFER_OBJ * transferObj;
138:                     bool transferIsDone = false;
139:                     USB_HOST_MSD_INSTANCE * msdInstanceInfo = &gUSBHostMSDInstance[msdInstanceIndex];
9D00A478  00041080   SLL V0, A0, 2
9D00A47C  00048140   SLL S0, A0, 5
9D00A480  02021023   SUBU V0, S0, V0
9D00A484  00441021   ADDU V0, V0, A0
9D00A488  00021080   SLL V0, V0, 2
9D00A48C  3C108000   LUI S0, -32768
9D00A490  26100948   ADDIU S0, S0, 2376
9D00A494  02028021   ADDU S0, S0, V0
140:                 
141:                     if(msdInstanceInfo->msdState == USB_HOST_MSD_STATE_READY)
9D00A498  8E030018   LW V1, 24(S0)
9D00A49C  24020003   ADDIU V0, ZERO, 3
9D00A4A0  546200A7   BNEL V1, V0, 0x9D00A740
9D00A4A4  8FBF0024   LW RA, 36(SP)
142:                     {
143:                         /* This means this transfer event is related to a regular BOT transfer
144:                          * */
145:                 
146:                         transferObj = &msdInstanceInfo->transferObj;
147:                 
148:                         switch(msdInstanceInfo->transferState)
9D00A4A8  8E020054   LW V0, 84(S0)
9D00A4AC  24030002   ADDIU V1, ZERO, 2
9D00A4B0  10430030   BEQ V0, V1, 0x9D00A574
9D00A4B4  24030003   ADDIU V1, ZERO, 3
9D00A4B8  1043004F   BEQ V0, V1, 0x9D00A5F8
9D00A4BC  24030001   ADDIU V1, ZERO, 1
9D00A4C0  5443009F   BNEL V0, V1, 0x9D00A740
9D00A4C4  8FBF0024   LW RA, 36(SP)
149:                         {
150:                             case USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_CBW:
151:                 
152:                                 /* This means the CBW stage has completed */
153:                                 if(result == USB_HOST_RESULT_SUCCESS)
9D00A4C8  24020001   ADDIU V0, ZERO, 1
9D00A4CC  14A2001C   BNE A1, V0, 0x9D00A540
9D00A4D0  2402FF9F   ADDIU V0, ZERO, -97
154:                                 {
155:                                     /* Check if the command needs a data stage */
156:                                     if(transferObj->size > 0)
9D00A4D4  8E07003C   LW A3, 60(S0)
9D00A4D8  10E0000E   BEQ A3, ZERO, 0x9D00A514
9D00A4DC  24020080   ADDIU V0, ZERO, 128
157:                                     {
158:                                         /* Data stage is needed. Find out the direction */
159:                                         if(transferObj->transferDirection == USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST)
9D00A4E0  8E030040   LW V1, 64(S0)
9D00A4E4  54620002   BNEL V1, V0, 0x9D00A4F0
9D00A4E8  8E020028   LW V0, 40(S0)
9D00A4EC  8E020024   LW V0, 36(S0)
160:                                         {
161:                                             /* We need the in pipe */
162:                                             pipeHandle = msdInstanceInfo->bulkInPipeHandle;
163:                                         }
164:                                         else
165:                                         {
166:                                             /* Else we need the out pipe */
167:                                             pipeHandle = msdInstanceInfo->bulkOutPipeHandle;
168:                                         }
169:                 
170:                                         /* Update the state to indicate that we are waiting for data
171:                                          * */
172:                                         msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_DATA;
9D00A4F0  24030002   ADDIU V1, ZERO, 2
9D00A4F4  AE030054   SW V1, 84(S0)
173:                 
174:                                         /* Send the transfer */
175:                                         USB_HOST_DeviceTransfer(pipeHandle, &transferHandle, transferObj->buffer, transferObj->size,msdInstanceIndex);
9D00A4F8  8E06004C   LW A2, 76(S0)
9D00A4FC  AFA40010   SW A0, 16(SP)
9D00A500  00402021   ADDU A0, V0, ZERO
9D00A504  0F4035A6   JAL USB_HOST_DeviceTransfer
9D00A508  27A50018   ADDIU A1, SP, 24
9D00A50C  0B4029D0   J 0x9D00A740
9D00A510  8FBF0024   LW RA, 36(SP)
176:                                     }
177:                                     else
178:                                     {
179:                                         /* Data stage is not needed. We can launch CSW */
180:                                         msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_CSW;
9D00A514  24020003   ADDIU V0, ZERO, 3
9D00A518  AE020054   SW V0, 84(S0)
181:                 
182:                                         /* Note that we are not checking for return value here
183:                                          * because we are in an interrupt context. If the function
184:                                          * fails here, there isn't much that we can do. */
185:                                         USB_HOST_DeviceTransfer(msdInstanceInfo->bulkInPipeHandle, &transferHandle, msdInstanceInfo->msdCSW, 13, msdInstanceIndex);
9D00A51C  8E020024   LW V0, 36(S0)
9D00A520  8E060008   LW A2, 8(S0)
9D00A524  AFA40010   SW A0, 16(SP)
9D00A528  00402021   ADDU A0, V0, ZERO
9D00A52C  27A50018   ADDIU A1, SP, 24
9D00A530  0F4035A6   JAL USB_HOST_DeviceTransfer
9D00A534  2407000D   ADDIU A3, ZERO, 13
186:                                     }
187:                                 }
188:                                 else if(result == USB_HOST_RESULT_REQUEST_STALLED)
9D00A540  14A20006   BNE A1, V0, 0x9D00A55C
9D00A544  24020006   ADDIU V0, ZERO, 6
189:                                 {
190:                                     /* The CBW was stalled. The specification is not clear on
191:                                      * what should be done in such a case. In this
192:                                      * implementation we will request reset recovery procedure.
193:                                      * Because the reset recovery cannot be completed in this
194:                                      * transfer event handler context, we defer this to the
195:                                      * transfer error tasks routine */
196:                 
197:                                     msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_RESET_RECOVERY;
9D00A548  24020001   ADDIU V0, ZERO, 1
9D00A54C  AE020058   SW V0, 88(S0)
198:                                     msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_ERROR;
9D00A550  2402FFFF   ADDIU V0, ZERO, -1
9D00A554  0B4029CF   J 0x9D00A73C
9D00A558  AE020054   SW V0, 84(S0)
199:                                     _USB_HOST_MSD_ERROR_CALLBACK(msdInstanceIndex, USB_HOST_MSD_ERROR_CODE_CBW_STALL_RESET_RECOVERY);
200:                                 }
201:                                 else 
202:                                 {
203:                                     /* An unknown failure occurred on the bus. We move this MSD
204:                                      * instance to an error state. We must let the client know
205:                                      * the transfer will not complete. */
206:                                     msdInstanceInfo->msdErrorCode = USB_HOST_MSD_ERROR_CODE_FAILED_BOT_TRANSFER;
9D00A55C  AE020070   SW V0, 112(S0)
207:                 
208:                                     msdInstanceInfo->msdState = USB_HOST_MSD_STATE_ERROR;
9D00A560  2402FFFF   ADDIU V0, ZERO, -1
9D00A564  AE020018   SW V0, 24(S0)
209:                                     transferIsDone = true;
210:                                     msdResult = USB_HOST_MSD_RESULT_FAILURE;
9D00A56C  0B4029CA   J 0x9D00A728
9D00A570  24060004   ADDIU A2, ZERO, 4
211:                                 }
212:                 
213:                                 break;
214:                 
215:                             case USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_DATA:
216:                 
217:                                 /* We were waiting for the data stage to complete */
218:                                 if (result == USB_HOST_RESULT_SUCCESS)
9D00A574  24020001   ADDIU V0, ZERO, 1
9D00A578  14A2000C   BNE A1, V0, 0x9D00A5AC
9D00A57C  2402FF9F   ADDIU V0, ZERO, -97
219:                                 {
220:                                     /* We got the data stage. Go to CSW stage */
221:                                     msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_CSW;
9D00A580  24020003   ADDIU V0, ZERO, 3
9D00A584  AE020054   SW V0, 84(S0)
222:                 
223:                                     /* Note that we are not checking for return value here
224:                                      * because we are in an interrupt context. If the function
225:                                      * fails here, there isn't much that we can do. */
226:                                     USB_HOST_DeviceTransfer(msdInstanceInfo->bulkInPipeHandle, &transferHandle, msdInstanceInfo->msdCSW, 13, msdInstanceIndex);
9D00A588  8E020024   LW V0, 36(S0)
9D00A58C  8E060008   LW A2, 8(S0)
9D00A590  AFA40010   SW A0, 16(SP)
9D00A594  00402021   ADDU A0, V0, ZERO
9D00A598  27A50018   ADDIU A1, SP, 24
9D00A59C  0F4035A6   JAL USB_HOST_DeviceTransfer
9D00A5A0  2407000D   ADDIU A3, ZERO, 13
9D00A5A4  0B4029D0   J 0x9D00A740
9D00A5A8  8FBF0024   LW RA, 36(SP)
227:                                 }
228:                                 else if(result == USB_HOST_RESULT_REQUEST_STALLED)
9D00A5AC  14A2000C   BNE A1, V0, 0x9D00A5E0
9D00A5B0  24020006   ADDIU V0, ZERO, 6
229:                                 {
230:                                     /* If the data stage of the BOT was stalled, sections 6.7.2
231:                                      * and 6.7.3 define the action to be taken. The rest of the
232:                                      * transfer must complete in the error tasks routine. */
233:                 
234:                                     if(transferObj->transferDirection == USB_HOST_MSD_TRANSFER_DIRECTION_DEVICE_TO_HOST)
9D00A5B4  8E030040   LW V1, 64(S0)
9D00A5B8  24020080   ADDIU V0, ZERO, 128
9D00A5BC  14620004   BNE V1, V0, 0x9D00A5D0
9D00A5C0  24020009   ADDIU V0, ZERO, 9
235:                                     {
236:                                         /* Clear the halt on the in pipe */
237:                                         msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_IN_PIPE_STALLED;
9D00A5C4  24020007   ADDIU V0, ZERO, 7
9D00A5C8  0B402975   J 0x9D00A5D4
9D00A5CC  AE020058   SW V0, 88(S0)
238:                                     }
239:                                     else
240:                                     {
241:                                         /* Clear the halt on the out pipe */
242:                                         msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_OUT_PIPE_STALLED;
9D00A5D0  AE020058   SW V0, 88(S0)
243:                                     }
244:                                     
245:                                     msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_ERROR;
9D00A5D4  2402FFFF   ADDIU V0, ZERO, -1
9D00A5D8  0B4029CF   J 0x9D00A73C
9D00A5DC  AE020054   SW V0, 84(S0)
246:                                 }
247:                                 else
248:                                 {
249:                                     /* End the command. This is an error that we cannot handle */
250:                                     msdInstanceInfo->msdErrorCode = USB_HOST_MSD_ERROR_CODE_FAILED_BOT_TRANSFER;
9D00A5E0  AE020070   SW V0, 112(S0)
251:                                     msdInstanceInfo->msdState = USB_HOST_MSD_STATE_ERROR;
9D00A5E4  2402FFFF   ADDIU V0, ZERO, -1
9D00A5E8  AE020018   SW V0, 24(S0)
252:                                     transferIsDone = true;
253:                                     msdResult = USB_HOST_MSD_RESULT_FAILURE;
9D00A5F0  0B4029CA   J 0x9D00A728
9D00A5F4  24060004   ADDIU A2, ZERO, 4
254:                                 }
255:                 
256:                                 break;
257:                 
258:                             case USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_CSW:
259:                                 /* This means the CSW has completed. Check if we have a valid
260:                                  * and meaningful CSW */
261:                 
262:                                 msdCSW = msdInstanceInfo->msdCSW;
263:                 
264:                                 if(result == USB_HOST_RESULT_SUCCESS) 
9D00A5F8  14A30033   BNE A1, V1, 0x9D00A6C8
9D00A5FC  8E020008   LW V0, 8(S0)
265:                                 { 
266:                                     if(msdInstanceInfo->transferErrorTaskState == USB_HOST_MSD_TRANSFER_ERROR_STATE_CSW_RETRY)
9D00A600  8E040058   LW A0, 88(S0)
9D00A604  2403000D   ADDIU V1, ZERO, 13
9D00A608  50830001   BEQL A0, V1, 0x9D00A610
9D00A60C  AE000058   SW ZERO, 88(S0)
267:                                     {
268:                                         /* This means this CSW was re-attempted after the
269:                                          * previous CSW attempt that was stalled. Clear
270:                                          * the transfer error task state to let the error
271:                                          * task know that nothing needs to be done now. */
272:                                         
273:                                         msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_NO_ERROR;
274:                                     }
275:                                     
276:                                     if ((msdCSW->dCSWSignature == USB_MSD_VALID_CSW_SIGNATURE) &&
9D00A610  88440003   LWL A0, 3(V0)
9D00A614  98440000   LWR A0, 0(V0)
9D00A618  3C035342   LUI V1, 21314
9D00A61C  24635355   ADDIU V1, V1, 21333
9D00A620  54830025   BNEL A0, V1, 0x9D00A6B8
9D00A624  2402FFFF   ADDIU V0, ZERO, -1
9D00A630  3C03DD13   LUI V1, -8941
9D00A634  246331DD   ADDIU V1, V1, 12765
9D00A638  5483001F   BNEL A0, V1, 0x9D00A6B8
9D00A63C  2402FFFF   ADDIU V0, ZERO, -1
277:                                             (msdCSW->dCSWTag == USB_MSD_VALID_CBW_TAG) && (size == 13))
9D00A628  88440007   LWL A0, 7(V0)
9D00A62C  98440004   LWR A0, 4(V0)
9D00A640  2403000D   ADDIU V1, ZERO, 13
9D00A644  54C3001C   BNEL A2, V1, 0x9D00A6B8
9D00A648  2402FFFF   ADDIU V0, ZERO, -1
278:                                     {
279:                                         /* This means the CSW is valid as defined in section
280:                                          * 6.3.1 of the BOT specification. Now we check if it is
281:                                          * meaningful.
282:                                          * */
283:                 
284:                                         if(((msdCSW->bCSWStatus == USB_MSD_CSW_STATUS_GOOD) || (msdCSW->bCSWStatus == USB_MSD_CSW_STATUS_FAIL)) &&
9D00A64C  9046000C   LBU A2, 12(V0)
9D00A650  2CC30002   SLTIU V1, A2, 2
9D00A654  5060000A   BEQL V1, ZERO, 0x9D00A680
9D00A658  24020002   ADDIU V0, ZERO, 2
9D00A670  00E3102B   SLTU V0, A3, V1
9D00A674  1040002C   BEQ V0, ZERO, 0x9D00A728
9D00A678  00E33823   SUBU A3, A3, V1
285:                                                 (msdCSW->dCSWDataResidue <= msdInstanceInfo->msdCBW->dCBWDataTransferLength))
9D00A65C  8843000B   LWL V1, 11(V0)
9D00A660  98430008   LWR V1, 8(V0)
9D00A664  8E020004   LW V0, 4(S0)
9D00A668  8847000B   LWL A3, 11(V0)
9D00A66C  98470008   LWR A3, 8(V0)
286:                                         {
287:                                             /* This means the CSW is meaningful. We must let the
288:                                              * MSD client know if the command has failed or
289:                                              * passed. This is know in the bCSWStatus of CSW. */
290:                                             processedBytes = msdInstanceInfo->msdCBW->dCBWDataTransferLength - msdCSW->dCSWDataResidue;
291:                                             transferIsDone = true;
292:                                             msdResult = msdCSW->bCSWStatus;
293:                                         }
294:                                         else if (msdCSW->bCSWStatus == USB_MSD_CSW_STATUS_PHASE_ERROR)
9D00A67C  24020002   ADDIU V0, ZERO, 2
9D00A680  14C20007   BNE A2, V0, 0x9D00A6A0
9D00A684  24020006   ADDIU V0, ZERO, 6
295:                                         {
296:                                             /* This means the CSW is valid but a phase error has
297:                                              * occurred. Reset recovery should be performed.
298:                                              * This is done in the transfer error tasks routine. */
299:                                             msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_ERROR;
9D00A688  2402FFFF   ADDIU V0, ZERO, -1
9D00A68C  AE020054   SW V0, 84(S0)
300:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_RESET_RECOVERY;
9D00A690  24020001   ADDIU V0, ZERO, 1
9D00A694  AE020058   SW V0, 88(S0)
9D00A698  0B4029CF   J 0x9D00A73C
9D00A69C  A202000C   SB V0, 12(S0)
301:                                             msdInstanceInfo->cswPhaseError = true;
302:                                             _USB_HOST_MSD_ERROR_CALLBACK(msdInstanceIndex, USB_HOST_MSD_ERROR_CODE_CSW_PHASE_ERROR);
303:                                         }
304:                                         else
305:                                         {
306:                                             /* The specification does not define how the host
307:                                              * must react in such a case. The specification
308:                                              * requires the device to return a valid and
309:                                              * meaningful. Because this is something we cannot
310:                                              * handle, we end the transfer and move the device
311:                                              * to error state. */
312:                 
313:                                             msdInstanceInfo->msdErrorCode = USB_HOST_MSD_ERROR_CODE_FAILED_BOT_TRANSFER;
9D00A6A0  AE020070   SW V0, 112(S0)
314:                                             msdInstanceInfo->msdState = USB_HOST_MSD_STATE_ERROR;
9D00A6A4  2402FFFF   ADDIU V0, ZERO, -1
9D00A6A8  AE020018   SW V0, 24(S0)
315:                                             transferIsDone = true;
316:                                             processedBytes = 0;
9D00A6AC  00003821   ADDU A3, ZERO, ZERO
317:                                             msdResult = USB_HOST_MSD_RESULT_FAILURE;
9D00A6B0  0B4029CA   J 0x9D00A728
9D00A6B4  24060004   ADDIU A2, ZERO, 4
318:                                         }
319:                                     }
320:                                     else
321:                                     {
322:                                         /* If the CSW is not valid, then Reset recovery must be
323:                                          * performed. See Figure 2 - Status transport flow in
324:                                          * the BOT specification. */
325:                 
326:                                         msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_ERROR;
9D00A6B8  AE020054   SW V0, 84(S0)
327:                                         msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_RESET_RECOVERY;
9D00A6BC  24020001   ADDIU V0, ZERO, 1
9D00A6C0  0B4029CF   J 0x9D00A73C
9D00A6C4  AE020058   SW V0, 88(S0)
328:                                     }
329:                                 }
330:                                 else if(result == USB_HOST_RESULT_REQUEST_STALLED)
9D00A6C8  2402FF9F   ADDIU V0, ZERO, -97
9D00A6CC  14A2000B   BNE A1, V0, 0x9D00A6FC
9D00A6D0  2402FFFF   ADDIU V0, ZERO, -1
331:                                 {
332:                                     /* We need to check if the this the first or the second time
333:                                      * the CSW got stalled. If the transfer error task state
334:                                      * machine is in a CSW retry state, then we know that this
335:                                      * is the second time. */
336:                 
337:                                     msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_ERROR;
9D00A6D4  AE020054   SW V0, 84(S0)
338:                                     if(msdInstanceInfo->transferErrorTaskState == USB_HOST_MSD_TRANSFER_ERROR_STATE_CSW_RETRY)
9D00A6D8  8E030058   LW V1, 88(S0)
9D00A6DC  2402000D   ADDIU V0, ZERO, 13
9D00A6E0  14620004   BNE V1, V0, 0x9D00A6F4
9D00A6E4  2402000B   ADDIU V0, ZERO, 11
339:                                     {
340:                                         /* This means the CSW was stalled once before and has
341:                                          * been stalled again. We should move to reset recovery.
342:                                          * */
343:                                         
344:                                         msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_RESET_RECOVERY;
9D00A6E8  24020001   ADDIU V0, ZERO, 1
9D00A6EC  0B4029CF   J 0x9D00A73C
9D00A6F0  AE020058   SW V0, 88(S0)
345:                                     }
346:                                     else
347:                                     {
348:                                         /* The CSW request got stalled ! Lets try to clear the IN
349:                                          * pipe stall condition. This is an transfer error condition
350:                                          * which must cleared in the transfer error tasks routine. */
351:                                         
352:                                         msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_CSW_STALLED;
9D00A6F4  0B4029CF   J 0x9D00A73C
9D00A6F8  AE020058   SW V0, 88(S0)
353:                                     }
354:                                 }
355:                                 else
356:                                 {
357:                                     /* Figure 2 of the BOT specification states that the host
358:                                      * should try to do an endpoint stall clear on bulk error.
359:                                      * */
360:                            
361:                                     msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_ERROR;
9D00A6FC  AE020054   SW V0, 84(S0)
362:                                     msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_CSW_STALLED;
9D00A700  2402000B   ADDIU V0, ZERO, 11
9D00A704  0B4029CF   J 0x9D00A73C
9D00A708  AE020058   SW V0, 88(S0)
363:                                     _USB_HOST_MSD_ERROR_CALLBACK(msdInstanceIndex, USB_HOST_MSD_ERROR_CODE_CSW_UNKNOWN_ERROR);
364:                                 }
365:                 
366:                                 break;
367:                 
368:                             default:
369:                                 break;
370:                         }
371:                 
372:                         if(transferIsDone)
373:                         {
374:                             if(msdInstanceInfo->transferObj.callback != NULL)
9D00A728  8E020030   LW V0, 48(S0)
9D00A72C  5440FFF7   BNEL V0, ZERO, 0x9D00A70C
9D00A730  8E040048   LW A0, 72(S0)
9D00A734  0B4029C8   J 0x9D00A720
9D00A738  A200002C   SB ZERO, 44(S0)
375:                             {
376:                                 /* Let the caller who initiated the command know that this is
377:                                  * done */
378:                                 msdInstanceInfo->transferObj.callback(msdInstanceInfo->transferObj.lunHandle,
9D00A70C  8E030044   LW V1, 68(S0)
9D00A710  AFA30010   SW V1, 16(SP)
9D00A714  0040F809   JALR V0
9D00A718  2605002C   ADDIU A1, S0, 44
379:                                         (USB_HOST_MSD_TRANSFER_HANDLE)(&msdInstanceInfo->transferObj), 
380:                                         msdResult, processedBytes, msdInstanceInfo->transferObj.context);
381:                             }
382:                 
383:                             /* Return the transfer object back */
384:                             msdInstanceInfo->transferObj.inUse = false;
9D00A71C  A200002C   SB ZERO, 44(S0)
385:                 
386:                             /* Make the transfer state ready for another transfer */
387:                             msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_READY;
9D00A720  0B4029CF   J 0x9D00A73C
9D00A724  AE000054   SW ZERO, 84(S0)
388:                         }
389:                     }
390:                 }
9D00A538  0B4029D0   J 0x9D00A740
9D00A53C  8FBF0024   LW RA, 36(SP)
9D00A73C  8FBF0024   LW RA, 36(SP)
391:                 
392:                 // *****************************************************************************
393:                 /* Function:
394:                    USB_HOST_MSD_RESULT _USB_HOST_MSD_HostResultToMSDResultMap
395:                    (
396:                         USB_HOST_RESULT result
397:                    )
398:                 
399:                   Summary:
400:                     Maps USB_HOST_RESULT to USB_HOST_MSD_RESULT.
401:                 
402:                   Description:
403:                     Maps USB_HOST_RESULT to USB_HOST_MSD_RESULT.
404:                 
405:                   Remarks:
406:                     This is a local function and should not be called directly by the
407:                     application.
408:                 */
409:                 
410:                 USB_HOST_MSD_RESULT _USB_HOST_MSD_HostResultToMSDResultMap
411:                 (
412:                     USB_HOST_RESULT result
413:                 )
414:                 {
415:                     USB_HOST_MSD_RESULT msdResult;
416:                 
417:                     switch(result)
9D0167F4  2402FF9F   ADDIU V0, ZERO, -97
9D0167F8  1082000C   BEQ A0, V0, 0x9D01682C
9D0167FC  00000000   NOP
9D016800  24020001   ADDIU V0, ZERO, 1
9D016804  10820007   BEQ A0, V0, 0x9D016824
9D016808  24030004   ADDIU V1, ZERO, 4
9D01680C  2402FF9C   ADDIU V0, ZERO, -100
418:                     {
419:                         case USB_HOST_RESULT_SUCCESS:
420:                             msdResult = USB_HOST_MSD_RESULT_SUCCESS;
9D016824  03E00008   JR RA
9D016828  24020003   ADDIU V0, ZERO, 3
421:                             break;
422:                         case USB_HOST_RESULT_FAILURE:
423:                             /* Note the fall through here. This is intentional */
424:                         case USB_HOST_RESULT_PARAMETER_INVALID:
425:                         case USB_HOST_RESULT_TRANSFER_ABORTED:
426:                         case USB_HOST_RESULT_PIPE_HANDLE_INVALID:
427:                             msdResult = USB_HOST_MSD_RESULT_FAILURE;
9D016810  00822026   XOR A0, A0, V0
9D016814  24050005   ADDIU A1, ZERO, 5
9D016818  00601021   ADDU V0, V1, ZERO
9D01681C  03E00008   JR RA
9D016820  00A4100A   MOVZ V0, A1, A0
428:                             break;
429:                         case USB_HOST_RESULT_REQUEST_BUSY:
430:                             msdResult = USB_HOST_MSD_RESULT_BUSY;
431:                             break;
432:                         case USB_HOST_RESULT_REQUEST_STALLED:
433:                             msdResult = USB_HOST_MSD_RESULT_COMMAND_STALLED;
434:                             break;
435:                         default:
436:                             msdResult = USB_HOST_MSD_RESULT_FAILURE;
437:                             break;
438:                     }
439:                 
440:                     return(msdResult);
441:                 }
9D01682C  03E00008   JR RA
442:                 
443:                 // *****************************************************************************
444:                 /* Function:
445:                    int_USB_HOST_MSD_InterfaceHandleToMSDInstance
446:                    ( 
447:                         USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
448:                    )
449:                 
450:                   Summary:
451:                     This function will return the MSD instance object that is associated with
452:                     this interface.
453:                 
454:                   Description:
455:                     This function will return the MSD instance object that is associated with
456:                     this interface.
457:                 
458:                   Remarks:
459:                     This is a local function and should not be called directly by the
460:                     application.
461:                 */
462:                 
463:                 int _USB_HOST_MSD_InterfaceHandleToMSDInstance
464:                 ( 
465:                     USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
466:                 )
467:                 {
468:                     int iterator;
469:                     int msdInstanceInfo = -1;
470:                 
471:                     /* Find the MSD Instance object that owns this interface */
472:                     for (iterator = 0; iterator < USB_HOST_MSD_INSTANCES_NUMBER; iterator ++)
473:                     {
474:                         if(gUSBHostMSDInstance[iterator].assigned)
9D016C9C  3C038000   LUI V1, -32768
9D016CA0  90630948   LBU V1, 2376(V1)
9D016CA4  10600006   BEQ V1, ZERO, 0x9D016CC0
9D016CA8  2402FFFF   ADDIU V0, ZERO, -1
475:                         {
476:                             if(gUSBHostMSDInstance[iterator].interfaceHandle == interfaceHandle)
9D016CAC  3C028000   LUI V0, -32768
9D016CB0  8C42095C   LW V0, 2396(V0)
9D016CB4  00441026   XOR V0, V0, A0
9D016CB8  0002102B   SLTU V0, ZERO, V0
9D016CBC  00021023   SUBU V0, ZERO, V0
477:                             {
478:                                 /* Found it */
479:                                 msdInstanceInfo = iterator;
480:                                 break;
481:                             }
482:                         }
483:                     }
484:                     return(msdInstanceInfo);
485:                 }
9D016CC0  03E00008   JR RA
486:                 
487:                 // *****************************************************************************
488:                 /* Function:
489:                    void _USB_HOST_MSD_InstanceRelease
490:                     (
491:                         USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
492:                     );
493:                 
494:                   Summary:
495:                     This function will release the device interface. It will close any open
496:                     pipes. It will de initialize any SCSI instances.
497:                 
498:                   Description:
499:                     This function will release the device interface. It will close any open
500:                     pipes. It will de initialize any SCSI instances.
501:                 
502:                   Remarks:
503:                     This is a local function and should not be called directly by the
504:                     application.
505:                 */
506:                 
507:                 void _USB_HOST_MSD_InstanceRelease
508:                 (
509:                     USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
510:                 )
511:                 {
9D013548  27BDFFE0   ADDIU SP, SP, -32
9D01354C  AFBF001C   SW RA, 28(SP)
9D013550  AFB20018   SW S2, 24(SP)
9D013554  AFB10014   SW S1, 20(SP)
9D013558  AFB00010   SW S0, 16(SP)
512:                     int msdInstanceIndex;
513:                     int iterator;
514:                     USB_HOST_MSD_INSTANCE * msdInstanceInfo;
515:                 
516:                     /* Find the MSD instance for this interface */
517:                     msdInstanceIndex = _USB_HOST_MSD_InterfaceHandleToMSDInstance(interfaceHandle);
9D01355C  0F405B27   JAL _USB_HOST_MSD_InterfaceHandleToMSDInstance
9D013560  00808021   ADDU S0, A0, ZERO
518:                 
519:                     if(msdInstanceIndex >= 0)
9D013564  04400027   BLTZ V0, 0x9D013604
9D013568  00409021   ADDU S2, V0, ZERO
520:                     {
521:                         /* Get the object pointer */
522:                         msdInstanceInfo = &(gUSBHostMSDInstance[msdInstanceIndex]);
9D01356C  00021080   SLL V0, V0, 2
9D013570  00121940   SLL V1, S2, 5
9D013574  00621023   SUBU V0, V1, V0
9D013578  00521021   ADDU V0, V0, S2
9D01357C  00021080   SLL V0, V0, 2
9D013580  3C118000   LUI S1, -32768
9D013584  26310948   ADDIU S1, S1, 2376
9D013588  02228821   ADDU S1, S1, V0
523:                 
524:                         /* Close any open pipes */
525:                         if(msdInstanceInfo->bulkOutPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D01358C  8E240028   LW A0, 40(S1)
9D013590  2403FFFF   ADDIU V1, ZERO, -1
9D013594  50830007   BEQL A0, V1, 0x9D0135B4
9D013598  8E240024   LW A0, 36(S1)
526:                         {
527:                             /* Close the pipe */
528:                             USB_HOST_DevicePipeClose(msdInstanceInfo->bulkOutPipeHandle);
9D01359C  0F4053ED   JAL USB_HOST_DevicePipeClose
9D0135A0  00000000   NOP
529:                             msdInstanceInfo->bulkOutPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D0135A4  2402FFFF   ADDIU V0, ZERO, -1
9D0135A8  AE220028   SW V0, 40(S1)
530:                         }
531:                 
532:                         if(msdInstanceInfo->bulkInPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D0135AC  8E240024   LW A0, 36(S1)
9D0135B0  2403FFFF   ADDIU V1, ZERO, -1
9D0135B4  10830005   BEQ A0, V1, 0x9D0135CC
9D0135B8  00000000   NOP
533:                         {
534:                             /* Close the pipe */
535:                             USB_HOST_DevicePipeClose(msdInstanceInfo->bulkInPipeHandle);
9D0135BC  0F4053ED   JAL USB_HOST_DevicePipeClose
9D0135C0  00000000   NOP
536:                             msdInstanceInfo->bulkInPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D0135C4  2402FFFF   ADDIU V0, ZERO, -1
9D0135C8  AE220024   SW V0, 36(S1)
537:                         }
538:                 
539:                         /* The interface is release after the pipes are closed. This will allow
540:                          * the IRP callback functions to be valid when the pipes are closed
541:                          * in the statement above. */
542:                 
543:                         USB_HOST_DeviceInterfaceRelease(interfaceHandle);
9D0135CC  0F40557C   JAL USB_HOST_DeviceInterfaceRelease
9D0135D0  02002021   ADDU A0, S0, ZERO
544:                 
545:                         /* Note that we are not checking the msdState before calling
546:                          * USB_HOST_SCSI_Deinitialize for this LUN. A valid concern could be
547:                          * that what if we are deinitialising on a LUN for which a initialize
548:                          * was never called.  The answer lies in how the
549:                          * USB_HOST_SCSI_Deinitialize function works.  It will check if the
550:                          * input LUN was assigned any SCSI instance. If not then it will not
551:                          * have any effect. The msdState cannot be qualified because we dont
552:                          * know in what state the device may have detached. */
553:                 
554:                         for(iterator = 0; iterator < msdInstanceInfo->logicalUnitNumber; iterator ++)
9D0135D4  9222001C   LBU V0, 28(S1)
9D0135D8  18400009   BLEZ V0, 0x9D013600
9D0135DC  00008021   ADDU S0, ZERO, ZERO
9D0135EC  26100001   ADDIU S0, S0, 1
9D0135F0  9223001C   LBU V1, 28(S1)
9D0135F4  0203182A   SLT V1, S0, V1
9D0135F8  5460FFFA   BNEL V1, ZERO, 0x9D0135E4
9D0135FC  00102200   SLL A0, S0, 8
555:                         {
556:                             USB_HOST_SCSI_Deinitialize(USB_HOST_MSD_LUNHandleGet(iterator, msdInstanceIndex));
9D0135E0  00102200   SLL A0, S0, 8
9D0135E4  0F405255   JAL USB_HOST_SCSI_Deinitialize
9D0135E8  00922025   OR A0, A0, S2
557:                         }
558:                 
559:                         msdInstanceInfo->assigned = false;
9D013600  A2200000   SB ZERO, 0(S1)
560:                     }
561:                 }
9D013604  8FBF001C   LW RA, 28(SP)
562:                 
563:                 // *****************************************************************************
564:                 /* Function:
565:                     void USB_HOST_MSD_TransferErrorTasks
566:                     (
567:                         USB_HOST_MSD_LUN_HANDLE lunHandle,
568:                     );
569:                 
570:                   Summary:
571:                     This function maintains the MSD transfer error handling state machine.
572:                 
573:                   Description:
574:                     This function maintains the MSD transfer error handling state machine. This
575:                     function should be called periodically after the USB_HOST_MSD_Transfer
576:                     function has been called to schedule a transfer. The function should be
577:                     called periodically at least till the transfer completion event has been
578:                     received. Calling this function while a BOT transfer is in progress allows
579:                     the MSD Host Client driver to perform BOT error handling in a non-blocking
580:                     manner.  
581:                 
582:                     Calling this function when there is no BOT transfer in progress will not
583:                     have any effect. In case of BOT error handling, calling this function will
584:                     eventually result in a BOT transfer event. It is not necessary to call this
585:                     function after this event has occurred (till the next BOT transfer has been
586:                     scheduled).
587:                 
588:                   Remarks:
589:                     While running in an RTOS application, this function should be called in the
590:                     same thread that requested the BOT Transfer.
591:                 */
592:                 
593:                 void USB_HOST_MSD_TransferErrorTasks
594:                 (
595:                     USB_HOST_MSD_LUN_HANDLE lunHandle
596:                 )
597:                 {
9D0088DC  27BDFFD8   ADDIU SP, SP, -40
9D0088E0  AFBF0024   SW RA, 36(SP)
9D0088E4  AFB00020   SW S0, 32(SP)
598:                     USB_HOST_MSD_RESULT msdResult = USB_HOST_MSD_RESULT_FAILURE;
599:                     bool transferIsDone = false;
600:                     USB_HOST_MSD_INSTANCE * msdInstanceInfo;
601:                     int msdInstanceIndex;
602:                     size_t processedBytes;
603:                     USB_HOST_TRANSFER_HANDLE transferHandle, requestHandle;
604:                 
605:                     if(USB_HOST_MSD_LUN_HANDLE_INVALID == lunHandle)
9D0088D0  2402FFFF   ADDIU V0, ZERO, -1
9D0088D4  108200D3   BEQ A0, V0, 0x9D008C24
9D0088D8  308600FF   ANDI A2, A0, 255
606:                     {
607:                         SYS_DEBUG_PRINT(SYS_ERROR_ERROR, "\r\nUSB Host MSD: LUN Handle %x in USB_HOST_MSD_Transfer is not valid.",lunHandle);
608:                     }
609:                     else
610:                     {
611:                         /* Get the MSD Instance Index from the LUN Handle */
612:                         msdInstanceIndex = USB_HOST_MSD_INDEX(lunHandle);
613:                 
614:                         /* Get the pointer to the MSD instance */
615:                         msdInstanceInfo = &gUSBHostMSDInstance[msdInstanceIndex];
9D0088E8  00061080   SLL V0, A2, 2
9D0088EC  00068140   SLL S0, A2, 5
9D0088F0  02021023   SUBU V0, S0, V0
9D0088F4  00461021   ADDU V0, V0, A2
9D0088F8  00021080   SLL V0, V0, 2
9D0088FC  3C108000   LUI S0, -32768
9D008900  26100948   ADDIU S0, S0, 2376
9D008904  02028021   ADDU S0, S0, V0
616:                 
617:                         if(!msdInstanceInfo->assigned)
9D008908  92020000   LBU V0, 0(S0)
9D00890C  104000C2   BEQ V0, ZERO, 0x9D008C18
9D008910  24020003   ADDIU V0, ZERO, 3
618:                         {
619:                             /* This object is not valid */
620:                             SYS_DEBUG_PRINT(SYS_ERROR_ERROR, "\r\nUSB Host MSD: MSD Instance %d in USB_HOST_MSD_TransferErrorTasks is not valid.", msdInstanceIndex);
621:                         }
622:                         else
623:                         {
624:                             if(msdInstanceInfo->msdState == USB_HOST_MSD_STATE_READY)
9D008914  8E030018   LW V1, 24(S0)
9D008918  546200C0   BNEL V1, V0, 0x9D008C1C
9D00891C  8FBF0024   LW RA, 36(SP)
625:                             {
626:                                 /* Check the error state of the transfer */
627:                                 switch(msdInstanceInfo->transferErrorTaskState)
9D008920  8E020058   LW V0, 88(S0)
9D008924  2C42000D   SLTIU V0, V0, 13
9D008928  104000BB   BEQ V0, ZERO, 0x9D008C18
9D00892C  3C029D01   LUI V0, -25343
9D008930  8E030058   LW V1, 88(S0)
9D008934  00031880   SLL V1, V1, 2
9D008938  24428948   ADDIU V0, V0, -30392
9D00893C  7C43100A   LWX V0, V1(V0)
9D008940  00400008   JR V0
9D008944  00000000   NOP
628:                                 {
629:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_NO_ERROR:
630:                 
631:                                         /* In this state there is no error. There is nothing for
632:                                          * this task routine to do. */
633:                                         break;
634:                 
635:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_RESET_RECOVERY:
636:                 
637:                                         /* In this state, driver must perform reset recovery as
638:                                          * described 5.3.4 of the BOT specification. The client
639:                                          * driver enters this state if the CBW was stalled
640:                                          * (behaviour not defined in the specification, CSW was
641:                                          * stalled twice, if the CSW was not valid or if an
642:                                          * phase error has occurred. */
643:                 
644:                                         /* Note that if we are in reset recovery, then the
645:                                          * amount of data processed will be ignored. We should
646:                                          * let the client know that no data was processed */
647:                                         processedBytes = 0;
648:                 
649:                                         /* Create the control transfer setup packet */
650:                                         _USB_HOST_MSD_ResetPacketCreate(&msdInstanceInfo->setupPacket, msdInstanceInfo->bInterfaceNumber);
9D00897C  92020050   LBU V0, 80(S0)
651:                                         msdInstanceInfo->controlTransferDone = false;
9D0089A8  A200005E   SB ZERO, 94(S0)
652:                 
653:                                         /* Try sending the control transfer */
654:                                         if(USB_HOST_DeviceControlTransfer(msdInstanceInfo->controlPipeHandle, &transferHandle,
9D0089AC  8E040020   LW A0, 32(S0)
9D0089B0  3C029D01   LUI V0, -25343
9D0089B4  24427208   ADDIU V0, V0, 29192
9D0089B8  AFA20010   SW V0, 16(SP)
9D0089BC  AFB00014   SW S0, 20(SP)
9D0089C0  27A50018   ADDIU A1, SP, 24
9D0089C4  2606005F   ADDIU A2, S0, 95
9D0089C8  0F4042A3   JAL USB_HOST_DeviceControlTransfer
9D0089CC  00003821   ADDU A3, ZERO, ZERO
9D0089D0  24030001   ADDIU V1, ZERO, 1
9D0089D4  14430091   BNE V0, V1, 0x9D008C1C
9D0089D8  8FBF0024   LW RA, 36(SP)
655:                                                     &msdInstanceInfo->setupPacket, NULL, _USB_HOST_MSD_ControlTransferCallback,
656:                                                     (uintptr_t)(msdInstanceInfo)) == USB_HOST_RESULT_SUCCESS)
657:                                         {
658:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_WAIT_MSD_RESET;
9D0089DC  24020002   ADDIU V0, ZERO, 2
9D0089E0  0B402306   J 0x9D008C18
9D0089E4  AE020058   SW V0, 88(S0)
659:                                         }
660:                                         else
661:                                         {
662:                                             /* If the control transfer could not be scheduled, then
663:                                              * we wait in the same state */
664:                                         }
665:                 
666:                                         break;
667:                 
668:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_WAIT_MSD_RESET:
669:                 
670:                                         /* Here we check if the control transfer has completed */
671:                                         if(msdInstanceInfo->controlTransferDone)
9D0089E8  9202005E   LBU V0, 94(S0)
9D0089EC  1040008B   BEQ V0, ZERO, 0x9D008C1C
9D0089F0  8FBF0024   LW RA, 36(SP)
672:                                         {
673:                                             /* This means the control transfer has completed */
674:                                             if(USB_HOST_RESULT_SUCCESS == msdInstanceInfo->controlTransferResult)
9D0089F4  8E030068   LW V1, 104(S0)
9D0089F8  24020001   ADDIU V0, ZERO, 1
9D0089FC  14620004   BNE V1, V0, 0x9D008A10
9D008A00  24020007   ADDIU V0, ZERO, 7
675:                                             {
676:                                                 /* The control transfer completed successfully */
677:                                                 SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d MSD Reset done.", msdInstanceIndex);
678:                                                 SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d clearing Halt on Bulk IN endpoint", msdInstanceIndex);
679:                                                 msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_CLEAR_FEATURE_IN;
9D008A04  24020003   ADDIU V0, ZERO, 3
9D008A08  0B402306   J 0x9D008C18
9D008A0C  AE020058   SW V0, 88(S0)
680:                                             }
681:                                             else
682:                                             {
683:                                                 /* We should not face errors with the MSD reset. We
684:                                                  * cannot handle such error. Place the device in
685:                                                  * error state */
686:                 
687:                                                 transferIsDone = true;
688:                                                 msdInstanceInfo->msdErrorCode = USB_HOST_MSD_ERROR_CODE_FAILED_RESET_RECOVERY;
9D008A10  AE020070   SW V0, 112(S0)
689:                                                 msdInstanceInfo->msdState = USB_HOST_MSD_STATE_ERROR;
9D008A14  2402FFFF   ADDIU V0, ZERO, -1
9D008A18  AE020018   SW V0, 24(S0)
690:                                                 msdResult = USB_HOST_MSD_RESULT_FAILURE;
9D008A1C  0B402301   J 0x9D008C04
9D008A20  24060004   ADDIU A2, ZERO, 4
691:                                             }
692:                                         }
693:                                         break;
694:                 
695:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_CLEAR_FEATURE_IN:
696:                 
697:                                         /* In this state, we send a clear halt to the IN
698:                                          * endpoint */
699:                 
700:                                         msdInstanceInfo->standardRequestDone = false;
9D008A24  A200005C   SB ZERO, 92(S0)
701:                                         if(USB_HOST_DevicePipeHaltClear(msdInstanceInfo->bulkInPipeHandle, &requestHandle, 
9D008A28  8E040024   LW A0, 36(S0)
9D008A2C  0F40434D   JAL USB_HOST_DevicePipeHaltClear
9D008A30  27A5001C   ADDIU A1, SP, 28
9D008A34  24030001   ADDIU V1, ZERO, 1
9D008A38  14430078   BNE V0, V1, 0x9D008C1C
9D008A3C  8FBF0024   LW RA, 36(SP)
702:                                                     (uintptr_t)(msdInstanceIndex)) == USB_HOST_RESULT_SUCCESS)
703:                                         {
704:                                             /* The request was accepted. Wait for completion */
705:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_CLEAR_FEATURE_IN_WAIT;
9D008A40  24020004   ADDIU V0, ZERO, 4
9D008A44  0B402306   J 0x9D008C18
9D008A48  AE020058   SW V0, 88(S0)
706:                                         }
707:                                         break;
708:                 
709:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_CLEAR_FEATURE_IN_WAIT:
710:                 
711:                                         /* Here we are waiting for the standard request to complete */
712:                                         if(msdInstanceInfo->standardRequestDone)
9D008A4C  9202005C   LBU V0, 92(S0)
9D008A50  10400072   BEQ V0, ZERO, 0x9D008C1C
9D008A54  8FBF0024   LW RA, 36(SP)
713:                                         {
714:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d MSD IN endpoint Clear Feature Done done.\r\n", msdInstanceIndex);
715:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d clearing Halt on Bulk Out endpoint\r\n", msdInstanceIndex);
716:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_CLEAR_FEATURE_OUT;
9D008A58  24020005   ADDIU V0, ZERO, 5
9D008A5C  0B402306   J 0x9D008C18
9D008A60  AE020058   SW V0, 88(S0)
717:                                         }
718:                                         break;
719:                 
720:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_CLEAR_FEATURE_OUT:
721:                 
722:                                         /* In this state, we send a clear halt to the OUT
723:                                          * endpoint */
724:                 
725:                                         msdInstanceInfo->standardRequestDone = false;
9D008A64  A200005C   SB ZERO, 92(S0)
726:                                         if(USB_HOST_DevicePipeHaltClear(msdInstanceInfo->bulkOutPipeHandle, &requestHandle, 
9D008A68  8E040028   LW A0, 40(S0)
9D008A6C  0F40434D   JAL USB_HOST_DevicePipeHaltClear
9D008A70  27A5001C   ADDIU A1, SP, 28
9D008A74  24030001   ADDIU V1, ZERO, 1
9D008A78  14430068   BNE V0, V1, 0x9D008C1C
9D008A7C  8FBF0024   LW RA, 36(SP)
727:                                                     (uintptr_t)(msdInstanceIndex)) == USB_HOST_RESULT_SUCCESS)
728:                                         {
729:                                             /* The request was accepted. Wait for completion */
730:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_CLEAR_FEATURE_OUT_WAIT;
9D008A80  24020006   ADDIU V0, ZERO, 6
9D008A84  0B402306   J 0x9D008C18
9D008A88  AE020058   SW V0, 88(S0)
731:                                         }
732:                                         break;
733:                 
734:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_RR_CLEAR_FEATURE_OUT_WAIT:
735:                 
736:                                         /* Here we are waiting for the standard request to complete */
737:                                         if(msdInstanceInfo->standardRequestDone)
9D008A8C  9202005C   LBU V0, 92(S0)
9D008A90  10400062   BEQ V0, ZERO, 0x9D008C1C
9D008A94  8FBF0024   LW RA, 36(SP)
738:                                         {
739:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d MSD OUT endpoint Clear Feature Done done.", msdInstanceIndex);
740:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d Ending Transfer.", msdInstanceIndex);
741:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_NO_ERROR;
9D008A98  AE000058   SW ZERO, 88(S0)
742:                                             transferIsDone = true;
743:                                             if(msdInstanceInfo->cswPhaseError)
9D008A9C  9206000C   LBU A2, 12(S0)
744:                                             {
745:                                                 /* This means we performed reset recovery
746:                                                  * because of a phase error */
747:                                                 msdResult = USB_HOST_MSD_RESULT_COMMAND_PHASE_ERROR;
748:                                             }
749:                                             else
750:                                             {
751:                                                 /* The CSW was not valid or we have dont know
752:                                                  * the reason for the failure */
753:                                                 msdResult = USB_HOST_MSD_RESULT_FAILURE;
9D008AA0  24020004   ADDIU V0, ZERO, 4
9D008AA4  24030002   ADDIU V1, ZERO, 2
9D008AA8  0066100B   MOVN V0, V1, A2
9D008AAC  0B402301   J 0x9D008C04
9D008AB0  00403021   ADDU A2, V0, ZERO
754:                                             }
755:                                         }
756:                                         break;
757:                 
758:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_IN_PIPE_STALLED:
759:                 
760:                                         /* This error can occur when the data stage of the BOT
761:                                          * has stalled. As sub-item 5 of 6.7.2 of the BOT
762:                                          * specification, we have clear the stall and then try
763:                                          * to get the CSW. */
764:                 
765:                                         msdInstanceInfo->standardRequestDone = false;
9D008AB4  A200005C   SB ZERO, 92(S0)
766:                                         if(USB_HOST_DevicePipeHaltClear(msdInstanceInfo->bulkInPipeHandle, &requestHandle, (uintptr_t)(msdInstanceIndex)) == USB_HOST_RESULT_SUCCESS)
9D008AB8  8E040024   LW A0, 36(S0)
9D008ABC  0F40434D   JAL USB_HOST_DevicePipeHaltClear
9D008AC0  27A5001C   ADDIU A1, SP, 28
9D008AC4  24030001   ADDIU V1, ZERO, 1
9D008AC8  14430054   BNE V0, V1, 0x9D008C1C
9D008ACC  8FBF0024   LW RA, 36(SP)
767:                                         {
768:                                             /* The request was accepted. Wait for completion */
769:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_IN_PIPE_STALLED_CLEAR_WAIT;
9D008AD0  24020008   ADDIU V0, ZERO, 8
9D008AD4  0B402306   J 0x9D008C18
9D008AD8  AE020058   SW V0, 88(S0)
770:                                         }
771:                                         break;
772:                 
773:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_IN_PIPE_STALLED_CLEAR_WAIT:
774:                 
775:                                         /* Here we are waiting for the standard request to complete */
776:                                         if(msdInstanceInfo->standardRequestDone)
9D008ADC  9202005C   LBU V0, 92(S0)
9D008AE0  5040004E   BEQL V0, ZERO, 0x9D008C1C
9D008AE4  8FBF0024   LW RA, 36(SP)
777:                                         {
778:                                             /* The request had completed. Now we try to get the
779:                                              * CSW. */
780:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d MSD IN endpoint Clear Feature Done.", msdInstanceIndex);
781:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d Trying to get CSW.", msdInstanceIndex);
782:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_NO_ERROR;
9D008AE8  AE000058   SW ZERO, 88(S0)
783:                 
784:                                             /* The CSW completion will be completed in the
785:                                              * transfer tasks. So we set the state of the
786:                                              * transfer tasks to indicate this. */
787:                                             msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_CSW;
9D008AEC  24020003   ADDIU V0, ZERO, 3
9D008AF0  AE020054   SW V0, 84(S0)
788:                 
789:                                             /* Launch the CSW */
790:                                             USB_HOST_DeviceTransfer(msdInstanceInfo->bulkInPipeHandle, &transferHandle, msdInstanceInfo->msdCSW, 13, msdInstanceIndex);
9D008AF4  8E040024   LW A0, 36(S0)
9D008AF8  8E020008   LW V0, 8(S0)
9D008AFC  AFA60010   SW A2, 16(SP)
9D008B00  27A50018   ADDIU A1, SP, 24
9D008B04  00403021   ADDU A2, V0, ZERO
9D008B08  0F4035A6   JAL USB_HOST_DeviceTransfer
9D008B0C  2407000D   ADDIU A3, ZERO, 13
791:                 
792:                                         }
793:                                         break;
794:                 
795:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_OUT_PIPE_STALLED:
796:                 
797:                                         /* This error can occur when the data stage of the BOT
798:                                          * has stalled. As sub-item 5 of 6.7.3 of the BOT
799:                                          * specification, we have clear the stall and then try
800:                                          * to get the CSW. */
801:                 
802:                                         msdInstanceInfo->standardRequestDone = false;
9D008B18  A200005C   SB ZERO, 92(S0)
803:                                         if(USB_HOST_DevicePipeHaltClear(msdInstanceInfo->bulkOutPipeHandle, &requestHandle, (uintptr_t)(msdInstanceIndex)) == USB_HOST_RESULT_SUCCESS)
9D008B1C  8E040028   LW A0, 40(S0)
9D008B20  0F40434D   JAL USB_HOST_DevicePipeHaltClear
9D008B24  27A5001C   ADDIU A1, SP, 28
9D008B28  24030001   ADDIU V1, ZERO, 1
9D008B2C  1443003B   BNE V0, V1, 0x9D008C1C
9D008B30  8FBF0024   LW RA, 36(SP)
804:                                         {
805:                                             /* The request was accepted. Wait for completion */
806:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_OUT_PIPE_STALLED_CLEAR_WAIT;
9D008B34  2402000A   ADDIU V0, ZERO, 10
9D008B38  0B402306   J 0x9D008C18
9D008B3C  AE020058   SW V0, 88(S0)
807:                                         }
808:                                         break;
809:                 
810:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_OUT_PIPE_STALLED_CLEAR_WAIT:
811:                 
812:                                         /* Here we are waiting for the standard request to complete */
813:                                         if(msdInstanceInfo->standardRequestDone)
9D008B40  9202005C   LBU V0, 92(S0)
9D008B44  50400035   BEQL V0, ZERO, 0x9D008C1C
9D008B48  8FBF0024   LW RA, 36(SP)
814:                                         {
815:                                             /* The request had completed. Now we try to get the
816:                                              * CSW. */
817:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d MSD OUT endpoint Clear Feature Done.", msdInstanceIndex);
818:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d Trying to get CSW.", msdInstanceIndex);
819:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_NO_ERROR;
9D008B4C  AE000058   SW ZERO, 88(S0)
820:                 
821:                                             /* The CSW completion will be completed in the
822:                                              * transfer tasks. So we set the state of the
823:                                              * transfer tasks to indicate this. */
824:                                             msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_CSW;
9D008B50  24020003   ADDIU V0, ZERO, 3
9D008B54  AE020054   SW V0, 84(S0)
825:                 
826:                                             /* Launch the CSW */
827:                                             USB_HOST_DeviceTransfer(msdInstanceInfo->bulkInPipeHandle, &transferHandle, msdInstanceInfo->msdCSW, 13, msdInstanceIndex);
9D008B58  8E040024   LW A0, 36(S0)
9D008B5C  8E020008   LW V0, 8(S0)
9D008B60  AFA60010   SW A2, 16(SP)
9D008B64  27A50018   ADDIU A1, SP, 24
9D008B68  00403021   ADDU A2, V0, ZERO
9D008B6C  0F4035A6   JAL USB_HOST_DeviceTransfer
9D008B70  2407000D   ADDIU A3, ZERO, 13
828:                 
829:                                         }
830:                                         break;
831:                 
832:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_CSW_STALLED:
833:                 
834:                                         /* This means a CSW request has stalled. Figure 2 of the
835:                                          * BOT specification specifies how this should be
836:                                          * handled */
837:                 
838:                                         msdInstanceInfo->standardRequestDone = false;
9D008B7C  A200005C   SB ZERO, 92(S0)
839:                                         if(USB_HOST_DevicePipeHaltClear(msdInstanceInfo->bulkInPipeHandle, &requestHandle, (uintptr_t)(msdInstanceIndex)) == USB_HOST_RESULT_SUCCESS)
9D008B80  8E040024   LW A0, 36(S0)
9D008B84  0F40434D   JAL USB_HOST_DevicePipeHaltClear
9D008B88  27A5001C   ADDIU A1, SP, 28
9D008B8C  24030001   ADDIU V1, ZERO, 1
9D008B90  14430022   BNE V0, V1, 0x9D008C1C
9D008B94  8FBF0024   LW RA, 36(SP)
840:                                         {
841:                                             /* The request was accepted. Wait for completion */
842:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_CSW_STALLED_IN_PIPE_CLEAR_WAIT;
9D008B98  2402000C   ADDIU V0, ZERO, 12
9D008B9C  0B402306   J 0x9D008C18
9D008BA0  AE020058   SW V0, 88(S0)
843:                                         }
844:                                         break;
845:                 
846:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_CSW_STALLED_IN_PIPE_CLEAR_WAIT:
847:                 
848:                                         /* In this state, we are waiting for clear feature
849:                                          * on the IN pipe to complete.
850:                                          * */
851:                 
852:                                         if(msdInstanceInfo->standardRequestDone)
9D008BA4  9202005C   LBU V0, 92(S0)
9D008BA8  5040001C   BEQL V0, ZERO, 0x9D008C1C
9D008BAC  8FBF0024   LW RA, 36(SP)
853:                                         {
854:                                             /* The request had completed. Now we try to get the
855:                                              * CSW again. */
856:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d CSW Stall Bulk IN endpoint Clear Feature Done.", msdInstanceIndex);
857:                                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d Trying to get CSW.", msdInstanceIndex);
858:                 
859:                                             /* The CSW completion will be completed in the
860:                                              * transfer tasks. So we set the state of the
861:                                              * transfer tasks to indicate this. */
862:                                             msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_CSW;
9D008BB0  24020003   ADDIU V0, ZERO, 3
9D008BB4  AE020054   SW V0, 84(S0)
863:                                             msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_CSW_RETRY;
9D008BB8  2402000D   ADDIU V0, ZERO, 13
9D008BBC  AE020058   SW V0, 88(S0)
864:                 
865:                                             /* Launch the CSW */
866:                                             USB_HOST_DeviceTransfer(msdInstanceInfo->bulkInPipeHandle, &transferHandle, msdInstanceInfo->msdCSW, 13, msdInstanceIndex);
9D008BC0  8E040024   LW A0, 36(S0)
9D008BC4  8E020008   LW V0, 8(S0)
9D008BC8  AFA60010   SW A2, 16(SP)
9D008BCC  27A50018   ADDIU A1, SP, 24
9D008BD0  00403021   ADDU A2, V0, ZERO
9D008BD4  0F4035A6   JAL USB_HOST_DeviceTransfer
9D008BD8  2407000D   ADDIU A3, ZERO, 13
867:                 
868:                                         }
869:                                         break;
870:                 
871:                                     case USB_HOST_MSD_TRANSFER_ERROR_STATE_CSW_RETRY:
872:                 
873:                                         /* We dont do any thing in this state. This is an
874:                                          * indication state only. The transfer tasks state
875:                                          * machine will check if the error tasks state machine
876:                                          * is in this state. If so it will know that this is the
877:                                          * second attempt at getting the CSW. */
878:                 
879:                                         break;
880:                 
881:                                     default:
882:                                         break;
883:                                 }
884:                 
885:                                 if(transferIsDone)
886:                                 {
887:                                     if(msdInstanceInfo->transferObj.callback != NULL)
9D008C04  8E030030   LW V1, 48(S0)
9D008C08  5460FFF6   BNEL V1, ZERO, 0x9D008BE4
9D008C0C  8E040048   LW A0, 72(S0)
9D008C10  0B4022FF   J 0x9D008BFC
9D008C14  A200002C   SB ZERO, 44(S0)
888:                                     {
889:                                         /* Let the caller who initiated the command know that this is
890:                                          * done */
891:                                         msdInstanceInfo->transferObj.callback(msdInstanceInfo->transferObj.lunHandle,
9D008BE4  8E020044   LW V0, 68(S0)
9D008BE8  AFA20010   SW V0, 16(SP)
9D008BEC  2605002C   ADDIU A1, S0, 44
9D008BF0  0060F809   JALR V1
9D008BF4  00003821   ADDU A3, ZERO, ZERO
892:                                                 (USB_HOST_MSD_TRANSFER_HANDLE)(&msdInstanceInfo->transferObj), 
893:                                                 msdResult, processedBytes, 
894:                                                 msdInstanceInfo->transferObj.context);
895:                                     }
896:                 
897:                                     /* Return the transfer object back */
898:                                     msdInstanceInfo->transferObj.inUse = false;
9D008BF8  A200002C   SB ZERO, 44(S0)
899:                 
900:                                     /* Make the transfer state ready for another transfer */
901:                                     msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_READY;
9D008BFC  0B402306   J 0x9D008C18
9D008C00  AE000054   SW ZERO, 84(S0)
902:                                 }
903:                             }
904:                         }
905:                     }
906:                 }
9D008B10  0B402307   J 0x9D008C1C
9D008B14  8FBF0024   LW RA, 36(SP)
9D008B74  0B402307   J 0x9D008C1C
9D008B78  8FBF0024   LW RA, 36(SP)
9D008BDC  0B402307   J 0x9D008C1C
9D008BE0  8FBF0024   LW RA, 36(SP)
9D008C18  8FBF0024   LW RA, 36(SP)
907:                 
908:                 // *****************************************************************************
909:                 /* Function:
910:                    void _USB_HOST_MSD_ControlTransferCallback
911:                     (
912:                         USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
913:                         USB_HOST_REQUEST_HANDLE requestHandle,
914:                         USB_HOST_RESULT result,
915:                         size_t size,
916:                         uintptr_t context
917:                     );
918:                 
919:                   Summary:
920:                     This function is called when a control transfer completes.
921:                 
922:                   Description:
923:                     This function is called when a control transfer completes.
924:                 
925:                   Remarks:
926:                     This is a local function and should not be called directly by the
927:                     application.
928:                 */
929:                 
930:                 void _USB_HOST_MSD_ControlTransferCallback
931:                 (
932:                     USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
933:                     USB_HOST_REQUEST_HANDLE requestHandle,
934:                     USB_HOST_RESULT result,
935:                     size_t size,
936:                     uintptr_t context
937:                 )
938:                 {
9D017208  8FA20010   LW V0, 16(SP)
939:                     USB_HOST_MSD_INSTANCE * msdInstanceInfo;
940:                     
941:                     /* The context will be a pointer to the MSD instance */
942:                     msdInstanceInfo = (USB_HOST_MSD_INSTANCE *)(context);
943:                     
944:                     /* Update the request object with the result */
945:                     msdInstanceInfo->controlTransferResult = result;
9D01720C  AC460068   SW A2, 104(V0)
946:                     msdInstanceInfo->controlTransferSize = size;
9D017210  AC47006C   SW A3, 108(V0)
947:                     msdInstanceInfo->controlTransferDone = true; 
9D017214  24030001   ADDIU V1, ZERO, 1
948:                 
949:                     return;
950:                 }
951:                 
952:                 // *****************************************************************************
953:                 /* Function:
954:                    void _USB_HOST_MSD_GetMaxLUNPacketCreate
955:                    ( 
956:                        USB_SETUP_PACKET * setupPacket,
957:                        uint8_t bInterfaceNumber
958:                    )
959:                 
960:                   Summary:
961:                     This function will create the Get MAX LUN
962:                 
963:                   Description:
964:                     This function will create the Get MAX LUN
965:                 
966:                   Remarks:
967:                     This is a local function and should not be called directly by the
968:                     application.
969:                 */
970:                 
971:                 void _USB_HOST_MSD_GetMaxLUNPacketCreate
972:                 (
973:                    USB_SETUP_PACKET * setupPacket,
974:                    uint8_t bInterfaceNumber
975:                 )
976:                 {
00000000  00000000   NOP
977:                     /* Fill setup packet. The Get MAX LUN is target to the interface */
978:                     setupPacket->bmRequestType  = ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_CLASS | USB_SETUP_RECIPIENT_INTERFACE );
9D00D108  2403FFA1   ADDIU V1, ZERO, -95
00000004  00000000   NOP
979:                 
980:                     /* Setup the other setup packet values */
981:                     setupPacket->bRequest =  USB_MSD_GET_MAX_LUN ;
9D00D110  2403FFFE   ADDIU V1, ZERO, -2
0000000C  00000000   NOP
982:                     setupPacket->wValue = 0x0000;
9D00D118  A2000061   SB ZERO, 97(S0)
00000014  00000000   NOP
983:                     setupPacket->wIndex = bInterfaceNumber;
9D00D120  A2020063   SB V0, 99(S0)
0000001C  00000000   NOP
984:                     setupPacket->wLength = 0x01;
9D00D128  24020001   ADDIU V0, ZERO, 1
00000024  00000000   NOP
985:                 }
986:                 
987:                 // *****************************************************************************
988:                 /* Function:
989:                    void _USB_HOST_MSD_ResetPacketCreate
990:                    ( 
991:                        USB_SETUP_PACKET * setupPacket,
992:                        uint8_t bInterfaceNumber
993:                    )
994:                 
995:                   Summary:
996:                     This function will create the Reset Packet.
997:                 
998:                   Description:
999:                     This function will create the Reset Packet.
1000:                
1001:                  Remarks:
1002:                    This is a local function and should not be called directly by the
1003:                    application.
1004:                */
1005:                
1006:                void _USB_HOST_MSD_ResetPacketCreate
1007:                ( 
1008:                   USB_SETUP_PACKET * setupPacket,
1009:                   uint8_t bInterfaceNumber
1010:                )
1011:                {
00000000  00000000   NOP
1012:                    /* Create the setup packet */
1013:                    setupPacket->bmRequestType  = ( USB_SETUP_DIRN_HOST_TO_DEVICE | USB_SETUP_TYPE_CLASS | USB_SETUP_RECIPIENT_INTERFACE ); 
9D008980  24030021   ADDIU V1, ZERO, 33
00000004  00000000   NOP
1014:                    setupPacket->bRequest =  USB_MSD_RESET ;
9D008988  2403FFFF   ADDIU V1, ZERO, -1
0000000C  00000000   NOP
1015:                    setupPacket->wValue = 0x0000;
9D008990  A2000061   SB ZERO, 97(S0)
00000014  00000000   NOP
1016:                    setupPacket->wIndex = bInterfaceNumber;
9D008998  A2020063   SB V0, 99(S0)
0000001C  00000000   NOP
1017:                    setupPacket->wLength = 0x00;
9D0089A0  A2000065   SB ZERO, 101(S0)
00000024  00000000   NOP
1018:                }
1019:                
1020:                // *****************************************************************************
1021:                /* Function:
1022:                    void _USB_HOST_MSD_Initialize(void * msdInitData)
1023:                
1024:                  Summary:
1025:                    This function is called when the Host Layer is initializing.
1026:                
1027:                  Description:
1028:                    This function is called when the Host Layer is initializing.
1029:                
1030:                  Remarks:
1031:                    This is a local function and should not be called directly by the
1032:                    application.
1033:                */
1034:                
1035:                void _USB_HOST_MSD_Initialize(void * msdInitData)
1036:                {
1037:                    /* Make sure all the pipe handles are invalid */
1038:                    
1039:                    int iterator;
1040:                    USB_HOST_MSD_INSTANCE * msdInstanceInfo;
1041:                    
1042:                    for (iterator = 0; iterator < USB_HOST_MSD_INSTANCES_NUMBER; iterator ++)
1043:                    {
1044:                        msdInstanceInfo = &gUSBHostMSDInstance[iterator];
1045:                        msdInstanceInfo->controlPipeHandle = USB_HOST_CONTROL_PIPE_HANDLE_INVALID;
9D0168B4  3C028000   LUI V0, -32768
9D0168B8  24420948   ADDIU V0, V0, 2376
9D0168BC  2403FFFF   ADDIU V1, ZERO, -1
9D0168C0  AC430020   SW V1, 32(V0)
1046:                        msdInstanceInfo->bulkInPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D0168C4  AC430024   SW V1, 36(V0)
1047:                        msdInstanceInfo->bulkOutPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D0168C8  AC430028   SW V1, 40(V0)
1048:                        msdInstanceInfo->msdCBW = (USB_MSD_CBW *)(&gUSBHostMSDCBW[iterator][0]);
9D0168CC  3C03A001   LUI V1, -24575
9D0168D0  24634F30   ADDIU V1, V1, 20272
9D0168D4  AC430004   SW V1, 4(V0)
1049:                        msdInstanceInfo->msdCSW = (USB_MSD_CSW *)(&gUSBHostMSDCSW[iterator][0]);
9D0168D8  3C03A001   LUI V1, -24575
9D0168DC  24634F50   ADDIU V1, V1, 20304
9D0168E0  AC430008   SW V1, 8(V0)
1050:                
1051:                        /* We create mutexes at initialization time. This way we dont have to
1052:                         * deal with having to delete the mutex when the interface is released.
1053:                         * A mutex should not be deleted in the interrupt context and the
1054:                         * interface release function could be called from an interrupt context.
1055:                         * */
1056:                
1057:                        if(OSAL_RESULT_TRUE != OSAL_MUTEX_Create(&(msdInstanceInfo->mutexMSDInstanceObject)))
1058:                        {
1059:                            /* The mutex could not be created. We cannot
1060:                             * continue with using the instance object. */
1061:                            SYS_DEBUG_PRINT(SYS_ERROR_FATAL, "\r\nUSB Host MSD: Could not create Mutex for MSD instance %d",iterator);
1062:                        }
1063:                    }
1064:                }
1065:                
1066:                // *****************************************************************************
1067:                /* Function:
1068:                    void _USB_HOST_MSD_Deinitialize(void)
1069:                
1070:                  Summary:
1071:                    This function is called when the Host Layer is deinitializing.
1072:                
1073:                  Description:
1074:                    This function is called when the Host Layer is deinitializing.
1075:                
1076:                  Remarks:
1077:                    This is a local function and should not be called directly by the
1078:                    application.
1079:                */
1080:                
1081:                void _USB_HOST_MSD_Deinitialize(void)
1082:                {
9D0173A8  03E00008   JR RA
1083:                    /* This function is not implemented in this release of the driver */
1084:                }
1085:                
1086:                // *****************************************************************************
1087:                /* Function:
1088:                    void _USB_HOST_MSD_Reinitialize(void)
1089:                
1090:                  Summary:
1091:                    This function is called when the Host Layer is reinitializing.
1092:                
1093:                  Description:
1094:                    This function is called when the Host Layer is reinitializing.
1095:                
1096:                  Remarks:
1097:                    This is a local function and should not be called directly by the
1098:                    application.
1099:                */
1100:                
1101:                void _USB_HOST_MSD_Reinitialize(void * msdInitData)
1102:                {
9D0173B0  03E00008   JR RA
1103:                    /* This function is not implemented in this release of the driver */
1104:                }
1105:                
1106:                // *****************************************************************************
1107:                /* Function:
1108:                    void _USB_HOST_MSD_InterfaceAssign 
1109:                    (
1110:                        USB_HOST_DEVICE_INTERFACE_HANDLE * interfaces,
1111:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
1112:                        size_t nInterfaces,
1113:                        uint8_t * descriptor
1114:                    )
1115:                
1116:                  Summary:
1117:                    This function is called when the Host Layer attaches this driver to an
1118:                    interface.
1119:                
1120:                  Description:
1121:                    This function is called when the Host Layer attaches this driver to an
1122:                    interface.
1123:                
1124:                  Remarks:
1125:                    This is a local function and should not be called directly by the
1126:                    application.
1127:                */
1128:                
1129:                void _USB_HOST_MSD_InterfaceAssign 
1130:                (
1131:                    USB_HOST_DEVICE_INTERFACE_HANDLE * interfaces,
1132:                    USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
1133:                    size_t nInterfaces,
1134:                    uint8_t * descriptor
1135:                )
1136:                {
9D00F678  27BDFFB8   ADDIU SP, SP, -72
9D00F67C  AFBF0044   SW RA, 68(SP)
9D00F680  AFB60040   SW S6, 64(SP)
9D00F684  AFB5003C   SW S5, 60(SP)
9D00F688  AFB40038   SW S4, 56(SP)
9D00F68C  AFB30034   SW S3, 52(SP)
9D00F690  AFB20030   SW S2, 48(SP)
9D00F694  AFB1002C   SW S1, 44(SP)
9D00F698  AFB00028   SW S0, 40(SP)
9D00F69C  00809021   ADDU S2, A0, ZERO
9D00F6A0  00A08821   ADDU S1, A1, ZERO
9D00F6A4  00E0A021   ADDU S4, A3, ZERO
1137:                    int driverIndex;
1138:                    USB_HOST_MSD_INSTANCE * msdInstanceInfo = NULL;
1139:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle;
1140:                    USB_HOST_ENDPOINT_DESCRIPTOR_QUERY endpointQuery;
1141:                    USB_ENDPOINT_DESCRIPTOR * endpointDescriptor;
1142:                    USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
1143:                    USB_HOST_PIPE_HANDLE controlPipeHandle, bulkInPipeHandle, bulkOutPipeHandle;
1144:                    bool result = false;
1145:                
1146:                    /* We first try to open a control pipe to the device. Also initialize the
1147:                     * local pipe handles  */
1148:                
1149:                    controlPipeHandle = USB_HOST_DeviceControlPipeOpen(deviceObjHandle);
9D00F6A8  0F405906   JAL USB_HOST_DeviceControlPipeOpen
9D00F6AC  00A02021   ADDU A0, A1, ZERO
9D00F6B0  00409821   ADDU S3, V0, ZERO
1150:                    bulkInPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
1151:                    bulkOutPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D00F7BC  2416FFFF   ADDIU S6, ZERO, -1
1152:                    interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(descriptor);
1153:                    interfaceHandle = interfaces[0];
1154:                
1155:                    if(controlPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D00F6B4  2402FFFF   ADDIU V0, ZERO, -1
9D00F6B8  1262003C   BEQ S3, V0, _USB_HOST_MSD_InterfaceAssign::_USB_HOST_MSD_InterfaceRelease
9D00F6BC  8E500000   LW S0, 0(S2)
1156:                    {
1157:                        /* The control pipe could be opened. Now we check if the interface
1158:                         * descriptors contain the endpoints needed to operate the device. We
1159:                         * first find the Bulk IN endpoint and then try to open a pipe. To do
1160:                         * this, a query must be setup first. */
1161:                
1162:                        USB_HOST_DeviceEndpointQueryContextClear(&endpointQuery);
9D00F6C0  0F405CB7   JAL USB_HOST_DeviceEndpointQueryContextClear
9D00F6C4  27A40010   ADDIU A0, SP, 16
1163:                        endpointQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_DIRECTION|USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE;
9D00F6C8  24020006   ADDIU V0, ZERO, 6
9D00F6CC  AFA2001C   SW V0, 28(SP)
1164:                        endpointQuery.direction  = USB_DATA_DIRECTION_DEVICE_TO_HOST;
9D00F6D0  24020001   ADDIU V0, ZERO, 1
9D00F6D4  AFA20018   SW V0, 24(SP)
1165:                        endpointQuery.transferType = USB_TRANSFER_TYPE_BULK;
9D00F6D8  24020002   ADDIU V0, ZERO, 2
9D00F6DC  AFA20014   SW V0, 20(SP)
1166:                
1167:                        /* Now find the endpoint */
1168:                        endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor, &endpointQuery);
9D00F6E0  02802021   ADDU A0, S4, ZERO
9D00F6E4  0F403F7E   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D00F6E8  27A50010   ADDIU A1, SP, 16
1169:                        if(endpointDescriptor != NULL)
9D00F6EC  1040002F   BEQ V0, ZERO, _USB_HOST_MSD_InterfaceAssign::_USB_HOST_MSD_InterfaceRelease
9D00F6F0  02002021   ADDU A0, S0, ZERO
1170:                        {
1171:                            /* We have found the IN bulk endpoint. Try opening a pipe on this 
1172:                             * endpoint */
1173:                
1174:                            bulkInPipeHandle = USB_HOST_DevicePipeOpen(interfaceHandle, endpointDescriptor->bEndpointAddress);
9D00F6F4  0F403523   JAL USB_HOST_DevicePipeOpen
9D00F6F8  90450002   LBU A1, 2(V0)
9D00F6FC  0040A821   ADDU S5, V0, ZERO
1175:                            if(bulkInPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D00F700  2402FFFF   ADDIU V0, ZERO, -1
9D00F704  12A20029   BEQ S5, V0, _USB_HOST_MSD_InterfaceAssign::_USB_HOST_MSD_InterfaceRelease
9D00F708  00000000   NOP
1176:                            {
1177:                                /* Now open the the bulk out pipe */
1178:                
1179:                                USB_HOST_DeviceEndpointQueryContextClear(&endpointQuery);
9D00F70C  0F405CB7   JAL USB_HOST_DeviceEndpointQueryContextClear
9D00F710  27A40010   ADDIU A0, SP, 16
1180:                                endpointQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_DIRECTION|USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE;
9D00F714  24020006   ADDIU V0, ZERO, 6
9D00F718  AFA2001C   SW V0, 28(SP)
1181:                                endpointQuery.direction  = USB_DATA_DIRECTION_HOST_TO_DEVICE;
9D00F71C  AFA00018   SW ZERO, 24(SP)
1182:                                endpointQuery.transferType = USB_TRANSFER_TYPE_BULK;
9D00F720  24020002   ADDIU V0, ZERO, 2
9D00F724  AFA20014   SW V0, 20(SP)
1183:                
1184:                                /* Now find the endpoint */
1185:                                endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor, &endpointQuery);
9D00F728  02802021   ADDU A0, S4, ZERO
9D00F72C  0F403F7E   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D00F730  27A50010   ADDIU A1, SP, 16
1186:                                if(endpointDescriptor != NULL)
9D00F734  10400021   BEQ V0, ZERO, 0x9D00F7BC
9D00F738  02002021   ADDU A0, S0, ZERO
1187:                                {
1188:                                    /* Found the bulk out endpoint. Now open the pipe */
1189:                                    bulkOutPipeHandle = USB_HOST_DevicePipeOpen(interfaceHandle, endpointDescriptor->bEndpointAddress);
9D00F73C  0F403523   JAL USB_HOST_DevicePipeOpen
9D00F740  90450002   LBU A1, 2(V0)
9D00F744  0040B021   ADDU S6, V0, ZERO
1190:                                    if(bulkOutPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D00F748  2402FFFF   ADDIU V0, ZERO, -1
9D00F74C  12C2001C   BEQ S6, V0, 0x9D00F7C0
9D00F750  3C028000   LUI V0, -32768
1191:                                    {
1192:                                        /* All pipes open. Now we search for a MSD Client
1193:                                         * driver instance object that can be assigned to
1194:                                         * this device */
1195:                                        for ( driverIndex = 0 ; driverIndex < USB_HOST_MSD_INSTANCES_NUMBER ; driverIndex++ )
1196:                                        {
1197:                                            if (!gUSBHostMSDInstance[driverIndex].assigned)
9D00F754  90420948   LBU V0, 2376(V0)
9D00F758  14400019   BNE V0, ZERO, 0x9D00F7C0
9D00F75C  3C028000   LUI V0, -32768
1198:                                            {
1199:                                                /* Found a free instance object. We
1200:                                                 * assing the pipe handles, the
1201:                                                 * interface handle and the device
1202:                                                 * object handle. */
1203:                
1204:                                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Host Instance %d Assigned.",driverIndex);
1205:                                                gUSBHostMSDInstance[driverIndex].assigned = true;
9D00F760  24030001   ADDIU V1, ZERO, 1
9D00F764  A0430948   SB V1, 2376(V0)
1206:                                                msdInstanceInfo = &gUSBHostMSDInstance[driverIndex];
1207:                                                msdInstanceInfo->transferObj.inUse = false;
9D00F768  24420948   ADDIU V0, V0, 2376
9D00F76C  A040002C   SB ZERO, 44(V0)
1208:                                                msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_READY;
9D00F770  AC400054   SW ZERO, 84(V0)
1209:                                                msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_NO_ERROR;
9D00F774  AC400058   SW ZERO, 88(V0)
1210:                                                msdInstanceInfo->msdState = USB_HOST_MSD_STATE_GET_MAX_LUN;
9D00F778  24030001   ADDIU V1, ZERO, 1
9D00F77C  AC430018   SW V1, 24(V0)
1211:                                                msdInstanceInfo->controlPipeHandle = controlPipeHandle;
9D00F780  AC530020   SW S3, 32(V0)
1212:                                                msdInstanceInfo->bulkInPipeHandle = bulkInPipeHandle;
9D00F784  AC550024   SW S5, 36(V0)
1213:                                                msdInstanceInfo->bulkOutPipeHandle = bulkOutPipeHandle;
9D00F788  AC560028   SW S6, 40(V0)
1214:                                                msdInstanceInfo->interfaceHandle = interfaces[0];
9D00F78C  8E430000   LW V1, 0(S2)
9D00F790  AC430014   SW V1, 20(V0)
1215:                                                msdInstanceInfo->deviceObjHandle = deviceObjHandle;
9D00F794  AC510010   SW S1, 16(V0)
1216:                                                interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(descriptor);
1217:                                                msdInstanceInfo->bInterfaceNumber = interfaceDescriptor->bInterfaceNumber;
9D00F798  92830002   LBU V1, 2(S4)
9D00F79C  0B403DF7   J 0x9D00F7DC
9D00F7A0  A0430050   SB V1, 80(V0)
1218:                                                result = true;
1219:                                                break;
1220:                                            }
1221:                                        }
1222:                                    }
1223:                                    else
1224:                                    {
1225:                                        /* If an error callback function is defined, then call it with the error
1226:                                         * code */
1227:                                        _USB_HOST_MSD_ERROR_CALLBACK(deviceObjHandle, USB_HOST_MSD_ERROR_CODE_FAILED_PIPE_OPEN);
1228:                
1229:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host MSD: Could not open Bulk OUT pipe.");
1230:                                    }
1231:                                }
1232:                                else
1233:                                {
1234:                                    /* If an error callback function is defined, then call it with the error
1235:                                     * code */
1236:                                    _USB_HOST_MSD_ERROR_CALLBACK(deviceObjHandle, USB_HOST_MSD_ERROR_CODE_NOT_FOUND_BULK_OUT_ENDPOINT);
1237:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host MSD: Could not find OUT endpoint in interface descriptor.");
1238:                                }
1239:                            }
1240:                            else
1241:                            {
1242:                                /* If an error callback function is defined, then call it with the error
1243:                                 * code */
1244:                                _USB_HOST_MSD_ERROR_CALLBACK(deviceObjHandle, USB_HOST_MSD_ERROR_CODE_FAILED_PIPE_OPEN);
1245:                                SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host MSD: Could not open Bulk IN pipe.");
1246:                            }
1247:                        }
1248:                        else
1249:                        {
1250:                            /* If an error callback function is defined, then call it with the error
1251:                             * code */
1252:                            _USB_HOST_MSD_ERROR_CALLBACK(deviceObjHandle, USB_HOST_MSD_ERROR_CODE_NOT_FOUND_BULK_IN_ENDPOINT);
1253:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host MSD: Could not find IN endpoint in interface descriptor.");
1254:                        }
1255:                    }
1256:                
1257:                    if (result == false)
1258:                    {
1259:                        /* Let the host know that this interface cannot be processed */
1260:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host MSD: Could not allocate MSD object.");
1261:                
1262:                        /* If an error callback function is defined, then call it with the error
1263:                         * code */
1264:                        _USB_HOST_MSD_ERROR_CALLBACK(deviceObjHandle, USB_HOST_MSD_ERROR_CODE_INSUFFICIENT_INSTANCES);
1265:                        
1266:                        /* Close any pipes that were opened */
1267:                        if(USB_HOST_PIPE_HANDLE_INVALID != bulkInPipeHandle)
1268:                        {
1269:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host MSD: Closing Bulk IN pipe.");
1270:                            USB_HOST_DevicePipeClose(bulkInPipeHandle);
9D00F7C0  0F4053ED   JAL USB_HOST_DevicePipeClose
9D00F7C4  02A02021   ADDU A0, S5, ZERO
1271:                        }
1272:                
1273:                        if(USB_HOST_PIPE_HANDLE_INVALID != bulkOutPipeHandle)
9D00F7C8  2402FFFF   ADDIU V0, ZERO, -1
9D00F7CC  16C2FFF5   BNE S6, V0, 0x9D00F7A4
9D00F7D0  00000000   NOP
9D00F7D4  0B403DEB   J _USB_HOST_MSD_InterfaceAssign::_USB_HOST_MSD_InterfaceRelease
9D00F7D8  00000000   NOP
1274:                        {
1275:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host MSD: Closing Bulk OUT pipe.");
1276:                            USB_HOST_DevicePipeClose(bulkOutPipeHandle);
9D00F7A4  0F4053ED   JAL USB_HOST_DevicePipeClose
9D00F7A8  02C02021   ADDU A0, S6, ZERO
1277:                        }
1278:                
1279:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host MSD: Releasing Interface.");
1280:                        _USB_HOST_MSD_InterfaceRelease(interfaceHandle);
1281:                    }
1282:                
1283:                    return;
1284:                }
9D00F7B4  0B403DF8   J 0x9D00F7E0
9D00F7B8  8FBF0044   LW RA, 68(SP)
9D00F7DC  8FBF0044   LW RA, 68(SP)
1285:                
1286:                // *****************************************************************************
1287:                /* Function:
1288:                    void USB_HOST_MSD_InterfaceRelease
1289:                    (
1290:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
1291:                    )
1292:                
1293:                  Summary:
1294:                    This function is called when the Host Layer detaches this driver from an
1295:                    interface.
1296:                
1297:                  Description:
1298:                    This function is called when the Host Layer detaches this driver from an
1299:                    interface.
1300:                
1301:                  Remarks:
1302:                    This is a local function and should not be called directly by the
1303:                    application.
1304:                */
1305:                
1306:                void _USB_HOST_MSD_InterfaceRelease
1307:                (
1308:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
1309:                )
1310:                {
9D01714C  27BDFFE8   ADDIU SP, SP, -24
9D017150  AFBF0014   SW RA, 20(SP)
1311:                    /* The device is detached or the configuration has changed. Shut down
1312:                     * everything for this interface */
1313:                    _USB_HOST_MSD_InstanceRelease(interfaceHandle);
9D00F7AC  0F404D52   JAL _USB_HOST_MSD_InstanceRelease
9D017154  0F404D52   JAL _USB_HOST_MSD_InstanceRelease
9D017158  00000000   NOP
1314:                }
9D01715C  8FBF0014   LW RA, 20(SP)
1315:                
1316:                // *****************************************************************************
1317:                /* Function:
1318:                    USB_HOST_DEVICE_INTERFACE_EVENT_RESPONSE _USB_HOST_MSD_InterfaceEventHandler
1319:                    (
1320:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
1321:                        USB_HOST_DEVICE_INTERFACE_EVENT event,
1322:                        void * eventData,
1323:                        uintptr_t context
1324:                    )
1325:                
1326:                  Summary:
1327:                    This function is called when the Host Layer generates interface level
1328:                    events. 
1329:                
1330:                  Description:
1331:                    This function is called when the Host Layer generates interface level
1332:                    events. 
1333:                
1334:                  Remarks:
1335:                    This is a local function and should not be called directly by the
1336:                    application.
1337:                */
1338:                
1339:                USB_HOST_DEVICE_INTERFACE_EVENT_RESPONSE _USB_HOST_MSD_InterfaceEventHandler
1340:                (
1341:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
1342:                    USB_HOST_DEVICE_INTERFACE_EVENT event,
1343:                    void * eventData,
1344:                    uintptr_t context
1345:                )
1346:                {
9D015AD0  AFBF0014   SW RA, 20(SP)
1347:                    USB_HOST_MSD_INSTANCE * msdInstanceInfo;
1348:                    USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE_DATA * transferCompleteEventData;
1349:                
1350:                    /* The context at the time of scheduling a transfer is the MSD Instance
1351:                     * Index */
1352:                
1353:                    msdInstanceInfo = &gUSBHostMSDInstance[context];
9D015AEC  00071940   SLL V1, A3, 5
9D015AF0  00621023   SUBU V0, V1, V0
9D015AF4  00473821   ADDU A3, V0, A3
9D015AF8  00071080   SLL V0, A3, 2
1354:                    
1355:                    switch(event)
9D015AB4  50A00006   BEQL A1, ZERO, 0x9D015AD0
9D015AB8  27BDFFE8   ADDIU SP, SP, -24
9D015ABC  24020002   ADDIU V0, ZERO, 2
9D015AC0  50A2000A   BEQL A1, V0, 0x9D015AEC
9D015AC4  00071080   SLL V0, A3, 2
1356:                    {
1357:                        case USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE:
1358:                    
1359:                            /* This means a transfer completed. Update the transfer state
1360:                             * machine. */
1361:                            transferCompleteEventData = (USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE_DATA *)(eventData);
1362:                            _USB_HOST_MSD_TransferTasks (context, transferCompleteEventData->result, transferCompleteEventData->length);
9D015AD4  00E02021   ADDU A0, A3, ZERO
9D015AD8  8CC50004   LW A1, 4(A2)
9D015ADC  0F40291B   JAL _USB_HOST_MSD_TransferTasks
9D015AE0  8CC60008   LW A2, 8(A2)
1363:                            break;
9D015AE4  0B4056C5   J 0x9D015B14
9D015AE8  00001021   ADDU V0, ZERO, ZERO
1364:                            
1365:                        case USB_HOST_DEVICE_INTERFACE_EVENT_SET_INTERFACE_COMPLETE:
1366:                            
1367:                            break;
1368:                            
1369:                        case USB_HOST_DEVICE_INTERFACE_EVENT_PIPE_HALT_CLEAR_COMPLETE:
1370:                            /* Let the main state machine know that the standard request is done
1371:                             * */
1372:                            msdInstanceInfo->standardRequestDone = true;
9D015AFC  3C078000   LUI A3, -32768
9D015B00  24E70948   ADDIU A3, A3, 2376
9D015B04  00E23821   ADDU A3, A3, V0
9D015B08  24020001   ADDIU V0, ZERO, 1
1373:                            break;
9D015B0C  0B4056B2   J 0x9D015AC8
9D015B10  A0E2005C   SB V0, 92(A3)
1374:                            
1375:                        default:
1376:                            break;
1377:                    }
1378:                
1379:                
1380:                    return(USB_HOST_DEVICE_INTERFACE_EVENT_RESPONSE_NONE);
1381:                }
9D015AC8  03E00008   JR RA
9D015ACC  00001021   ADDU V0, ZERO, ZERO
9D015B14  8FBF0014   LW RA, 20(SP)
1382:                
1383:                // *****************************************************************************
1384:                /* Function:
1385:                    void USB_HOST_MSD_InterfaceTasks
1386:                    (
1387:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
1388:                    )
1389:                
1390:                  Summary:
1391:                    This function is called by the Host Layer to update the state of this
1392:                    driver.
1393:                
1394:                  Description:
1395:                    This function is called by the Host Layer to update the state of this
1396:                    driver.
1397:                
1398:                  Remarks:
1399:                    This is a local function and should not be called directly by the
1400:                    application.
1401:                */
1402:                
1403:                void _USB_HOST_MSD_InterfaceTasks
1404:                (
1405:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
1406:                )
1407:                {
9D00D070  27BDFFC8   ADDIU SP, SP, -56
9D00D074  AFBF0034   SW RA, 52(SP)
9D00D078  AFB30030   SW S3, 48(SP)
9D00D07C  AFB2002C   SW S2, 44(SP)
9D00D080  AFB10028   SW S1, 40(SP)
1408:                    int msdInstanceIndex;
1409:                    bool interruptIsEnabled;
1410:                    int iterator;
1411:                    USB_HOST_MSD_INSTANCE * msdInstanceInfo;
1412:                    USB_HOST_TRANSFER_HANDLE  transferHandle;
1413:                     
1414:                    /* Get the MSD instance for this interface */
1415:                    msdInstanceIndex = _USB_HOST_MSD_InterfaceHandleToMSDInstance(interfaceHandle);
9D00D084  0F405B27   JAL _USB_HOST_MSD_InterfaceHandleToMSDInstance
9D00D088  AFB00024   SW S0, 36(SP)
1416:                
1417:                    if(msdInstanceIndex >= 0)
9D00D08C  04400075   BLTZ V0, 0x9D00D264
9D00D090  00409021   ADDU S2, V0, ZERO
1418:                    {
1419:                        msdInstanceInfo = &gUSBHostMSDInstance[msdInstanceIndex];
9D00D094  00021080   SLL V0, V0, 2
9D00D098  00121940   SLL V1, S2, 5
9D00D09C  00621023   SUBU V0, V1, V0
9D00D0A0  00521021   ADDU V0, V0, S2
9D00D0A4  00021080   SLL V0, V0, 2
9D00D0A8  3C108000   LUI S0, -32768
9D00D0AC  26100948   ADDIU S0, S0, 2376
9D00D0B0  02028021   ADDU S0, S0, V0
1420:                        
1421:                        switch(msdInstanceInfo->msdState)
9D00D0B4  8E020018   LW V0, 24(S0)
9D00D0B8  24030001   ADDIU V1, ZERO, 1
9D00D0BC  10430011   BEQ V0, V1, 0x9D00D104
9D00D0C0  28430002   SLTI V1, V0, 2
9D00D0C4  10600006   BEQ V1, ZERO, 0x9D00D0E0
9D00D0C8  24030002   ADDIU V1, ZERO, 2
9D00D0CC  2403FFFF   ADDIU V1, ZERO, -1
9D00D0D0  10430063   BEQ V0, V1, 0x9D00D260
9D00D0D4  2402FFFE   ADDIU V0, ZERO, -2
9D00D0E0  10430024   BEQ V0, V1, 0x9D00D174
9D00D0E4  24030003   ADDIU V1, ZERO, 3
9D00D0E8  1443005F   BNE V0, V1, 0x9D00D268
9D00D0EC  8FBF0034   LW RA, 52(SP)
1422:                        {
1423:                            case USB_HOST_MSD_STATE_NOT_READY:
1424:                
1425:                                /* This object is in the process of getting initialized. Dont do
1426:                                 * anything yet */
1427:                                break;
1428:                
1429:                            case USB_HOST_MSD_STATE_GET_MAX_LUN:
1430:                
1431:                                /* In this state we launch the Get Max LUN request. Create the
1432:                                 * Get Max LUN packet */
1433:                                _USB_HOST_MSD_GetMaxLUNPacketCreate(&msdInstanceInfo->setupPacket, msdInstanceInfo->bInterfaceNumber);
9D00D104  92020050   LBU V0, 80(S0)
1434:                
1435:                                /* Set the flag indicating we are waiting for the control
1436:                                 * request to complete */
1437:                                msdInstanceInfo->controlTransferDone = false;
9D00D134  A200005E   SB ZERO, 94(S0)
1438:                
1439:                                /* Launch the request. We give a pointer to the
1440:                                 * logicalUnitNumber member of the instance object. The received
1441:                                 * data should be stored there. */
1442:                
1443:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d Trying to send Get Max LUN Request.", msdInstanceIndex);
1444:                                
1445:                                if(USB_HOST_DeviceControlTransfer(msdInstanceInfo->controlPipeHandle, 
9D00D138  8E040020   LW A0, 32(S0)
9D00D13C  3C029D01   LUI V0, -25343
9D00D140  24427208   ADDIU V0, V0, 29192
9D00D144  AFA20010   SW V0, 16(SP)
9D00D148  AFB00014   SW S0, 20(SP)
9D00D14C  27A50018   ADDIU A1, SP, 24
9D00D150  2606005F   ADDIU A2, S0, 95
9D00D154  0F4042A3   JAL USB_HOST_DeviceControlTransfer
9D00D158  2607001C   ADDIU A3, S0, 28
9D00D15C  24030001   ADDIU V1, ZERO, 1
9D00D160  14430041   BNE V0, V1, 0x9D00D268
9D00D164  8FBF0034   LW RA, 52(SP)
1446:                                        &transferHandle,
1447:                                        &msdInstanceInfo->setupPacket, 
1448:                                        &msdInstanceInfo->logicalUnitNumber,
1449:                                        _USB_HOST_MSD_ControlTransferCallback,
1450:                                        (uintptr_t)(msdInstanceInfo)) == USB_HOST_RESULT_SUCCESS)
1451:                                {
1452:                                    /* Update state. We will wait for the Get Max LUN request to
1453:                                     * complete. */
1454:                                    msdInstanceInfo->msdState = USB_HOST_MSD_STATE_WAITING_GET_MAX_LUN;
9D00D168  24020002   ADDIU V0, ZERO, 2
9D00D16C  0B403499   J 0x9D00D264
9D00D170  AE020018   SW V0, 24(S0)
1455:                                }
1456:                                else
1457:                                {
1458:                                    /* Wait in the same state */
1459:                                }
1460:                
1461:                                break;
1462:                                
1463:                            case USB_HOST_MSD_STATE_WAITING_GET_MAX_LUN:
1464:                                
1465:                                /* Here we wait for the Get Max Lun to complete */
1466:                                if(msdInstanceInfo->controlTransferDone)
9D00D174  9202005E   LBU V0, 94(S0)
9D00D178  1040003A   BEQ V0, ZERO, 0x9D00D264
9D00D17C  2403FFA8   ADDIU V1, ZERO, -88
1467:                                {
1468:                                    /* This means the control transfer completed. Check the 
1469:                                     * result */
1470:                                    if(msdInstanceInfo->controlTransferResult == USB_HOST_RESULT_FAILURE)
9D00D180  8E020068   LW V0, 104(S0)
9D00D184  14430007   BNE V0, V1, 0x9D00D1A4
9D00D188  2403FF9F   ADDIU V1, ZERO, -97
1471:                                    {
1472:                                        /* This means an unknown error has occurred. For now we
1473:                                         * will move the client driver to an error state. The
1474:                                         * device will not be accessible in the error state. */
1475:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host MSD: MSD Instance %d Get Max LUN Request Unknown Failure.", msdInstanceIndex);
1476:                                        msdInstanceInfo->logicalUnitNumber = 0;
9D00D18C  A200001C   SB ZERO, 28(S0)
1477:                                        msdInstanceInfo->msdErrorCode = USB_HOST_MSD_ERROR_CODE_FAILED_GET_MAX_LUN;
9D00D190  24020005   ADDIU V0, ZERO, 5
9D00D194  AE020070   SW V0, 112(S0)
1478:                                        msdInstanceInfo->msdState = USB_HOST_MSD_STATE_ERROR;
9D00D198  2402FFFF   ADDIU V0, ZERO, -1
9D00D19C  0B403499   J 0x9D00D264
9D00D1A0  AE020018   SW V0, 24(S0)
1479:                                    }
1480:                                    else if(msdInstanceInfo->controlTransferResult == USB_HOST_RESULT_REQUEST_STALLED)
9D00D1A4  14430004   BNE V0, V1, 0x9D00D1B8
9D00D1A8  24030001   ADDIU V1, ZERO, 1
1481:                                    {
1482:                                        /* Device can stall the Get Max LUN request when it does
1483:                                         * not support multiple LUNs. We set the number of LUNs
1484:                                         * to 1 */
1485:                
1486:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d Get Max LUN Request was stalled. Setting LUNs to 1.", msdInstanceIndex);
1487:                                        msdInstanceInfo->logicalUnitNumber = 1;
9D00D1AC  24020001   ADDIU V0, ZERO, 1
9D00D1B0  0B403473   J 0x9D00D1CC
9D00D1B4  A202001C   SB V0, 28(S0)
1488:                                    }
1489:                                    else if (msdInstanceInfo->controlTransferResult == USB_HOST_RESULT_SUCCESS) 
9D00D1B8  14430008   BNE V0, V1, 0x9D00D1DC
9D00D1BC  00000000   NOP
1490:                                    {
1491:                                        /* The Get Max LUN request passed. logicalUnitNumber
1492:                                         * should contain the number of LUNs (which could be 0).
1493:                                         * */
1494:                
1495:                                        /* While the BOT specification (in section 3.2) states that
1496:                                         * the Get Max LUN request will return 0 if there are no
1497:                                         * LUNs associated with the device, device do return 0 if no
1498:                                         * LUNs are supported. We increment the LUN count by 1. */
1499:                
1500:                                        msdInstanceInfo->logicalUnitNumber ++;
9D00D1C0  9202001C   LBU V0, 28(S0)
9D00D1C4  24420001   ADDIU V0, V0, 1
9D00D1C8  A202001C   SB V0, 28(S0)
1501:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: Get Max LUN Request was passed. LUNs = %d.", msdInstanceInfo->logicalUnitNumber);
1502:                                    }
1503:                
1504:                                    if(msdInstanceInfo->msdState != USB_HOST_MSD_STATE_ERROR)
9D00D1CC  8E030018   LW V1, 24(S0)
9D00D1D0  2402FFFF   ADDIU V0, ZERO, -1
9D00D1D4  10620024   BEQ V1, V0, 0x9D00D268
9D00D1D8  8FBF0034   LW RA, 52(SP)
1505:                                    {
1506:                                        /* The process of initializing the SCSI instances for each
1507:                                         * LUN should not be interrupted, specially by a USB Detach
1508:                                         * interrupt. We make this process atomic. The
1509:                                         * USB_HOST_SCSI_Initialize function does not perform
1510:                                         * hardware access and is not a blocking function. So we are
1511:                                         * safe in that sense. */
1512:                
1513:                                        interruptIsEnabled = SYS_INT_Disable();
9D00D1DC  0F405C0B   JAL SYS_INT_Disable
9D00D1E0  00000000   NOP
9D00D1E4  00409821   ADDU S3, V0, ZERO
1514:                                        for (iterator = 0; iterator < msdInstanceInfo->logicalUnitNumber; iterator ++)
9D00D1E8  9202001C   LBU V0, 28(S0)
9D00D1EC  18400009   BLEZ V0, 0x9D00D214
9D00D1F0  00008821   ADDU S1, ZERO, ZERO
9D00D200  26310001   ADDIU S1, S1, 1
9D00D204  9203001C   LBU V1, 28(S0)
9D00D208  0223182A   SLT V1, S1, V1
9D00D20C  5460FFFA   BNEL V1, ZERO, 0x9D00D1F8
9D00D210  00112200   SLL A0, S1, 8
1515:                                        {
1516:                                            /* Initialize the SCSI driver for every LUN */
1517:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: Initializing SCSI for LUN %d.", iterator);
1518:                                            USB_HOST_SCSI_Initialize(USB_HOST_MSD_LUNHandleGet(iterator,msdInstanceIndex));
9D00D1F4  00112200   SLL A0, S1, 8
9D00D1F8  0F40559C   JAL USB_HOST_SCSI_Initialize
9D00D1FC  00922025   OR A0, A0, S2
1519:                                        }
1520:                
1521:                                        msdInstanceInfo->msdState = USB_HOST_MSD_STATE_READY;
9D00D214  24020003   ADDIU V0, ZERO, 3
1522:                
1523:                                        if(interruptIsEnabled)
9D00D218  12600012   BEQ S3, ZERO, 0x9D00D264
9D00D21C  AE020018   SW V0, 24(S0)
1524:                                        {
1525:                                            /* Re-enable the global interrupt */
1526:                                            SYS_INT_Enable();
1527:                                        }
1528:                
1529:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d is Ready.", msdInstanceIndex);
1530:                                    }
1531:                                    else
1532:                                    {
1533:                                        /* Get Max LUN failed. Note that the msdState becomes
1534:                                         * USB_HOST_MSD_STATE_ERROR in the Get Max LUN failure
1535:                                         * case. */
1536:                                    }
1537:                                }
1538:                                break;
1539:                
1540:                            case USB_HOST_MSD_STATE_READY:
1541:                                
1542:                                /* Device is in a ready state. BOT protocol can be supported now
1543:                                 * Run the SCSI task routines for each LUN. These task routines
1544:                                 * perform the SCSI commands required to make sure that the SCSI
1545:                                 * device is ready. */
1546:                                for (iterator = 0; iterator < (msdInstanceInfo->logicalUnitNumber); iterator ++)
9D00D0F0  9202001C   LBU V0, 28(S0)
9D00D0F4  1C400050   BGTZ V0, 0x9D00D238
9D00D0F8  00008821   ADDU S1, ZERO, ZERO
9D00D244  26310001   ADDIU S1, S1, 1
9D00D248  9202001C   LBU V0, 28(S0)
9D00D24C  0222102A   SLT V0, S1, V0
9D00D250  5440FFFA   BNEL V0, ZERO, 0x9D00D23C
9D00D254  00112200   SLL A0, S1, 8
9D00D258  0B40349A   J 0x9D00D268
9D00D25C  8FBF0034   LW RA, 52(SP)
1547:                                {
1548:                                    USB_HOST_SCSI_Tasks(USB_HOST_MSD_LUNHandleGet(iterator,msdInstanceIndex));
9D00D238  00112200   SLL A0, S1, 8
9D00D23C  0F405B5E   JAL USB_HOST_SCSI_Tasks
9D00D240  00922025   OR A0, A0, S2
1549:                                }
1550:                                break;
1551:                
1552:                            case USB_HOST_MSD_STATE_ERROR:
1553:                
1554:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d is entering error state", msdInstanceIndex);
1555:                                _USB_HOST_MSD_ERROR_CALLBACK(msdInstanceIndex, msdInstanceInfo->msdErrorCode); 
1556:                                msdInstanceInfo->msdState = USB_HOST_MSD_STATE_ERROR_HOLDING;
9D00D260  AE020018   SW V0, 24(S0)
1557:                                break;
1558:                
1559:                            case USB_HOST_MSD_STATE_ERROR_HOLDING:
1560:                                /* Device is in an error state. It must be unplugged. */
1561:                                break;
1562:                
1563:                            default:
1564:                                break;
1565:                        }
1566:                    }
1567:                }
9D00D0D8  0B40349A   J 0x9D00D268
9D00D0DC  8FBF0034   LW RA, 52(SP)
9D00D0FC  0B40349B   J 0x9D00D26C
9D00D100  8FB30030   LW S3, 48(SP)
9D00D230  0B40349A   J 0x9D00D268
9D00D234  8FBF0034   LW RA, 52(SP)
9D00D264  8FBF0034   LW RA, 52(SP)
1568:                
1569:                // *****************************************************************************
1570:                /* Function:
1571:                   USB_HOST_MSD_RESULT USB_HOST_MSD_Transfer
1572:                   (
1573:                       uint8_t * cdb,
1574:                       uint8_t cdbLength,
1575:                       void * data,
1576:                       size_t size,
1577:                       USB_HOST_MSD_TRANSFER_DIRECTION transferDirection,
1578:                       USB_HOST_MSD_TRANSFER_CALLBACK callback,
1579:                       uintptr_t context
1580:                   )
1581:                
1582:                  Summary:
1583:                    This function schedules a MSD BOT transfer.
1584:                
1585:                  Description:
1586:                    This function schedules a MSD BOT transfer. The command to be executed is
1587:                    specified in the cdb. This should be pointer to a 16 byte command descriptor
1588:                    block. The actual length of the command is specified by cdbLength. If there
1589:                    is data to be transferred, the pointer to the buffer is specified by data.
1590:                    The size of the buffer is specified in size. When the transfer completes,
1591:                    the callback function will be called. The context will be returned in the
1592:                    callback function.
1593:                
1594:                  Remarks:
1595:                    None.
1596:                */
1597:                
1598:                USB_HOST_MSD_RESULT USB_HOST_MSD_Transfer
1599:                (
1600:                    USB_HOST_MSD_LUN_HANDLE lunHandle,
1601:                    uint8_t * cdb,
1602:                    uint8_t cdbLength,
1603:                    void * data,
1604:                    size_t size,
1605:                    USB_HOST_MSD_TRANSFER_DIRECTION transferDirection,
1606:                    USB_HOST_MSD_TRANSFER_CALLBACK callback,
1607:                    uintptr_t context
1608:                )
1609:                {
9D00EB28  30C600FF   ANDI A2, A2, 255
9D00EBA4  27BDFFD8   ADDIU SP, SP, -40
9D00EBA8  AFBF0024   SW RA, 36(SP)
1610:                    USB_HOST_MSD_RESULT result;
1611:                    int iterator;
1612:                    USB_HOST_MSD_INSTANCE * msdInstanceInfo;
1613:                    int msdInstanceIndex;
1614:                    USB_HOST_RESULT hostResult;
1615:                    USB_HOST_TRANSFER_HANDLE transferHandle;
1616:                
1617:                    if(USB_HOST_MSD_LUN_HANDLE_INVALID == lunHandle)
9D00EB2C  2403FFFF   ADDIU V1, ZERO, -1
9D00EB30  10830066   BEQ A0, V1, 0x9D00ECCC
9D00EB34  24020006   ADDIU V0, ZERO, 6
1618:                    {
1619:                        SYS_DEBUG_MESSAGE(SYS_ERROR_ERROR, "\r\nUSB Host MSD: LUN Handle in USB_HOST_MSD_Transfer is not valid.");
1620:                        result = USB_HOST_MSD_RESULT_LUN_HANDLE_INVALID;
1621:                    }
1622:                    else
1623:                    {
1624:                        /* Get the MSD Instance Index from the LUN Handle */
1625:                        msdInstanceIndex = USB_HOST_MSD_INDEX(lunHandle);
9D00EB38  308300FF   ANDI V1, A0, 255
1626:                
1627:                        /* Get the pointer to the MSD instance */
1628:                        msdInstanceInfo = &gUSBHostMSDInstance[msdInstanceIndex];
9D00EB3C  00031080   SLL V0, V1, 2
9D00EB40  00034140   SLL T0, V1, 5
9D00EB44  01021023   SUBU V0, T0, V0
9D00EB48  00431021   ADDU V0, V0, V1
9D00EB4C  00021080   SLL V0, V0, 2
9D00EB50  3C088000   LUI T0, -32768
9D00EB54  25080948   ADDIU T0, T0, 2376
9D00EB58  01024021   ADDU T0, T0, V0
1629:                
1630:                        if(!msdInstanceInfo->assigned)
9D00EB5C  91090000   LBU T1, 0(T0)
9D00EB60  1120005A   BEQ T1, ZERO, 0x9D00ECCC
9D00EB64  24020004   ADDIU V0, ZERO, 4
1631:                        {
1632:                            /* This object is not valid */
1633:                            SYS_DEBUG_PRINT(SYS_ERROR_ERROR, "\r\nUSB Host MSD: MSD Instance %d in USB_HOST_MSD_Transfer is not valid.", msdInstanceIndex);
1634:                            result = USB_HOST_MSD_RESULT_FAILURE;
1635:                        }
1636:                        else
1637:                        {
1638:                            /* Try obtaining the mutex. In an RTOS application, the thread could
1639:                             * block at this point */
1640:                            
1641:                            if(OSAL_MUTEX_Lock(&(msdInstanceInfo->mutexMSDInstanceObject), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1642:                            {
1643:                                /* We got the mutex. Now check if the BOT transfer object is
1644:                                 * free and if the MSD state machine can accept transfer
1645:                                 * requests. */
1646:                
1647:                
1648:                                if((msdInstanceInfo->msdState == USB_HOST_MSD_STATE_READY) && 
9D00EB7C  8D090018   LW T1, 24(T0)
9D00EB80  24020003   ADDIU V0, ZERO, 3
9D00EB84  1522004D   BNE T1, V0, USB_HOST_MSD_Transfer::OSAL_MUTEX_Unlock
9D00EB88  24020001   ADDIU V0, ZERO, 1
9D00EB8C  9102002C   LBU V0, 44(T0)
9D00EB90  1440004A   BNE V0, ZERO, USB_HOST_MSD_Transfer::OSAL_MUTEX_Unlock
9D00EB94  24020001   ADDIU V0, ZERO, 1
1649:                                        (!msdInstanceInfo->transferObj.inUse) &&
9D00EB98  8D020054   LW V0, 84(T0)
9D00EB9C  14400047   BNE V0, ZERO, USB_HOST_MSD_Transfer::OSAL_MUTEX_Unlock
9D00EBA0  24020001   ADDIU V0, ZERO, 1
1650:                                        (msdInstanceInfo->transferState == USB_HOST_MSD_TRANSFER_STATE_READY))
1651:                                {
1652:                                    /* We can proceed with the request. Grab the transfer object */
1653:                                    msdInstanceInfo->transferObj.inUse = true;
9D00EBAC  A102002C   SB V0, 44(T0)
1654:                
1655:                                    /* We can release the mutex now */
1656:                                    OSAL_MUTEX_Unlock(&(msdInstanceInfo->mutexMSDInstanceObject));
1657:                                    
1658:                                    /* Setup the CBW */
1659:                                    msdInstanceInfo->msdCBW->dCBWSignature = USB_MSD_VALID_CBW_SIGNATURE;
9D00EBB4  8D020004   LW V0, 4(T0)
9D00EBB8  3C094342   LUI T1, 17218
9D00EBBC  25295355   ADDIU T1, T1, 21333
9D00EBC0  A8490003   SWL T1, 3(V0)
9D00EBC4  B8490000   SWR T1, 0(V0)
1660:                                    msdInstanceInfo->msdCBW->dCBWTag = USB_MSD_VALID_CBW_TAG;
9D00EBC8  8D020004   LW V0, 4(T0)
9D00EBCC  3C09DD13   LUI T1, -8941
9D00EBD0  252931DD   ADDIU T1, T1, 12765
9D00EBD4  A8490007   SWL T1, 7(V0)
9D00EBD8  B8490004   SWR T1, 4(V0)
1661:                                    msdInstanceInfo->msdCBW->bCBWCBLength = cdbLength;
9D00EBDC  8D020004   LW V0, 4(T0)
9D00EBE0  A046000E   SB A2, 14(V0)
1662:                                    msdInstanceInfo->msdCBW->dCBWDataTransferLength = size;
9D00EBE4  8D020004   LW V0, 4(T0)
9D00EBE8  8FA90038   LW T1, 56(SP)
9D00EBEC  A849000B   SWL T1, 11(V0)
9D00EBF0  B8490008   SWR T1, 8(V0)
1663:                                    msdInstanceInfo->msdCBW->bmCBWFlags.value = transferDirection;
9D00EBF4  8D020004   LW V0, 4(T0)
9D00EBF8  8FA9003C   LW T1, 60(SP)
9D00EBFC  A049000C   SB T1, 12(V0)
1664:                                    
1665:                                    /* Reset the phase error flag. This flag gets set is a phase
1666:                                     * error has occurred. */
1667:                                    msdInstanceInfo->cswPhaseError = false;
9D00EC00  A100000C   SB ZERO, 12(T0)
1668:                
1669:                                    msdInstanceInfo->msdCBW->bCBWLUN = USB_HOST_MSD_LUN(lunHandle);
9D00EC04  8D020004   LW V0, 4(T0)
9D00EC08  00044A02   SRL T1, A0, 8
9D00EC0C  A049000D   SB T1, 13(V0)
1670:                
1671:                                    /* Copy the cdb. It should be zero padded */
1672:                                    for(iterator = 0; iterator < 16; iterator ++)
9D00EC10  00001021   ADDU V0, ZERO, ZERO
9D00EC14  240A0010   ADDIU T2, ZERO, 16
9D00EC20  24420001   ADDIU V0, V0, 1
9D00EC24  144AFFFC   BNE V0, T2, 0x9D00EC18
9D00EC28  A120000F   SB ZERO, 15(T1)
1673:                                    {
1674:                                        /* Clear the command block */
1675:                                        msdInstanceInfo->msdCBW->CBWCB[iterator] = 0;
9D00EC18  8D090004   LW T1, 4(T0)
9D00EC1C  01224821   ADDU T1, T1, V0
1676:                                    }
1677:                
1678:                                    /* Now copy the command */
1679:                                    for(iterator = 0; iterator < cdbLength; iterator ++)
9D00EC2C  18C0000A   BLEZ A2, 0x9D00EC58
9D00EC30  00C05821   ADDU T3, A2, ZERO
9D00EC34  00001021   ADDU V0, ZERO, ZERO
9D00EC48  24420001   ADDIU V0, V0, 1
9D00EC4C  004B482A   SLT T1, V0, T3
9D00EC50  5520FFFA   BNEL T1, ZERO, 0x9D00EC3C
9D00EC54  8D090004   LW T1, 4(T0)
1680:                                    {
1681:                                        msdInstanceInfo->msdCBW->CBWCB[iterator] = cdb[iterator];
9D00EC38  8D090004   LW T1, 4(T0)
9D00EC3C  7CA2518A   LBUX T2, V0(A1)
9D00EC40  01224821   ADDU T1, T1, V0
9D00EC44  A12A000F   SB T2, 15(T1)
1682:                                    }
1683:                
1684:                                    /* Save the caller data in the transfer object */
1685:                                    msdInstanceInfo->transferObj.callback = callback;
9D00EC58  8FA20040   LW V0, 64(SP)
9D00EC5C  AD020030   SW V0, 48(T0)
1686:                                    msdInstanceInfo->transferObj.context = context;
9D00EC60  8FA20044   LW V0, 68(SP)
9D00EC64  AD020044   SW V0, 68(T0)
1687:                                    msdInstanceInfo->transferObj.size = size;
9D00EC68  8FA20038   LW V0, 56(SP)
9D00EC6C  AD02003C   SW V0, 60(T0)
1688:                                    msdInstanceInfo->transferObj.transferDirection = transferDirection;
9D00EC70  8FA9003C   LW T1, 60(SP)
9D00EC74  AD090040   SW T1, 64(T0)
1689:                                    msdInstanceInfo->transferObj.cdb = cdb;
9D00EC78  AD050034   SW A1, 52(T0)
1690:                                    msdInstanceInfo->transferObj.cdbLength = cdbLength;
9D00EC7C  A1060038   SB A2, 56(T0)
1691:                                    msdInstanceInfo->transferObj.lunHandle = lunHandle;
9D00EC80  AD040048   SW A0, 72(T0)
1692:                                    msdInstanceInfo->transferObj.buffer = data;
9D00EC84  AD07004C   SW A3, 76(T0)
1693:                
1694:                                    msdInstanceInfo->transferState = USB_HOST_MSD_TRANSFER_STATE_WAIT_FOR_CBW;
9D00EC88  24020001   ADDIU V0, ZERO, 1
9D00EC8C  AD020054   SW V0, 84(T0)
1695:                                    msdInstanceInfo->transferErrorTaskState = USB_HOST_MSD_TRANSFER_ERROR_STATE_NO_ERROR;
9D00EC90  AD000058   SW ZERO, 88(T0)
1696:                
1697:                                    /* CBW must go out on the bulk out pipe handle */
1698:                                    hostResult = USB_HOST_DeviceTransfer(msdInstanceInfo->bulkOutPipeHandle, &transferHandle, msdInstanceInfo->msdCBW, 31, (uintptr_t)(msdInstanceIndex));
9D00EC94  8D040028   LW A0, 40(T0)
9D00EC98  8D060004   LW A2, 4(T0)
9D00EC9C  AFA30010   SW V1, 16(SP)
9D00ECA0  27A50018   ADDIU A1, SP, 24
9D00ECA4  0F4035A6   JAL USB_HOST_DeviceTransfer
9D00ECA8  2407001F   ADDIU A3, ZERO, 31
1699:                
1700:                                    /* Map the result */
1701:                                    result = _USB_HOST_MSD_HostResultToMSDResultMap(hostResult); 
9D00ECAC  0F4059FD   JAL _USB_HOST_MSD_HostResultToMSDResultMap
9D00ECB0  00402021   ADDU A0, V0, ZERO
9D00ECB4  0B403B32   J 0x9D00ECC8
9D00ECB8  8FBF0024   LW RA, 36(SP)
1702:                                }
1703:                                else
1704:                                {
1705:                                    /* Un-commenting this line could result in too many messages on the console */
1706:                                    /*SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d is busy. Cannot schedule BOT.", msdInstanceIndex);*/
1707:                                    OSAL_MUTEX_Unlock(&(msdInstanceInfo->mutexMSDInstanceObject));
1708:                                    _USB_HOST_MSD_ERROR_CALLBACK(msdInstanceIndex, USB_HOST_MSD_ERROR_CODE_TRANSFER_BUSY);
1709:                                    result = USB_HOST_MSD_RESULT_BUSY;
9D00ECC0  03E00008   JR RA
9D00ECC4  24020005   ADDIU V0, ZERO, 5
1710:                                }
1711:                            }
1712:                            else
1713:                            {
1714:                                /* Could not get the mutex lock */
1715:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host MSD: MSD Instance %d mutex lock failed in BOT transfer request.", msdInstanceIndex);
1716:                                result = USB_HOST_MSD_RESULT_BUSY;
1717:                            }
1718:                        }
1719:                    }
1720:                
1721:                    return(result);
1722:                }
9D00ECC8  27BD0028   ADDIU SP, SP, 40
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/usb/src/dynamic/usb_host.c
1:                   /*******************************************************************************
2:                     USB Host Layer Implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_host.c
9:                   
10:                    Summary:
11:                      This file contains implementations of both private and public functions
12:                      of the USB Host Layer.
13:                  
14:                    Description:
15:                      This file contains the USB host layer implementation. This file should be
16:                      included in the project if USB Host functionality is desired.
17:                  *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute Software
24:                  only when embedded on a Microchip microcontroller or digital  signal  controller
25:                  that is integrated into your product or third party  product  (pursuant  to  the
26:                  sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
32:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
36:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
38:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
39:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include <stdlib.h>
50:                  #include <stdint.h>
51:                  #include <stdbool.h>
52:                  #include "system_config.h"
53:                  #include "usb/usb_common.h"
54:                  #include "usb/usb_chapter_9.h"
55:                  #include "system/common/sys_module.h"
56:                  #include "usb/usb_host.h"
57:                  #include "usb/src/usb_host_local.h"
58:                  #include "driver/tmr/drv_tmr.h"
59:                  #include "system/tmr/sys_tmr.h"
60:                  #include "system/debug/sys_debug.h"
61:                  #include "usb/src/usb_host_hub_mapping.h"
62:                  #include "osal/osal.h"
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Global Data
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  /*******************************************************
71:                   * Host layer object. There is only such object because
72:                   * multiple host controller will be controlled by only
73:                   * one host layer.
74:                   *******************************************************/
75:                  static USB_HOST_OBJ  gUSBHostObj;
76:                  
77:                  /*************************************************************
78:                   * Host bus objects. One object per bus on in other words
79:                   * one object per host controller. The index of the bus object
80:                   * is also the bus number. Hence bus object at index 1 in this
81:                   * array will be bus 1.
82:                   *************************************************************/
83:                  static USB_HOST_BUS_OBJ  gUSBHostBusList[USB_HOST_CONTROLLERS_NUMBER];
84:                  
85:                  /************************************************************
86:                   * Host device Objects. One object per attached device. This
87:                   * array tracks the attached device. Additional device objects
88:                   * are needed for root hubs.
89:                   ************************************************************/
90:                  static USB_HOST_DEVICE_OBJ  gUSBHostDeviceList [ USB_HOST_CONTROLLERS_NUMBER + USB_HOST_DEVICES_NUMBER ];
91:                  
92:                  /************************************************************
93:                   * Array of Pipe Objects. These pipes will be used by all the
94:                   * client drivers that needs to access attached devices. This 
95:                   * array is a shared pool. Pipe object are assigned to client
96:                   * drivers when client driver open pipes.
97:                   ************************************************************/
98:                  static USB_HOST_PIPE_OBJ  gUSBHostPipeObj[ USB_HOST_PIPES_NUMBER ];
99:                  
100:                 /************************************************************
101:                  * Array of transfer object. Each object tracks one transfer.
102:                  * This array is a shared pool. Transfer objects are assigned
103:                  * to client driver transfer requests.
104:                  ************************************************************/
105:                 static USB_HOST_TRANSFER_OBJ gUSBHostTransferObj[ USB_HOST_TRANSFERS_NUMBER ];
106:                 
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 // Section: USB HOST Layer Local Functions
110:                 // *****************************************************************************
111:                 // *****************************************************************************
112:                 
113:                 // *****************************************************************************
114:                 /* Function:
115:                     void * _USB_HOST_TimerCallback
116:                     (
117:                        uint32_t context,
118:                        uint32_t currtick
119:                     )
120:                 
121:                   Summary:
122:                     Function is called when the SYS_TMR_CallbackSingle expires.
123:                 
124:                   Description:
125:                     Function is called when the SYS_TMR_CallbackSingle expires.
126:                 
127:                   Remarks:
128:                     This is a local function and should not be called directly by the
129:                     application.
130:                 */    
131:                 
132:                 void _USB_HOST_TimerCallback(uint32_t context, uint32_t currtick)
133:                 {
134:                     USB_HOST_BUS_OBJ * busObj = ((USB_HOST_BUS_OBJ *)(context));
135:                     busObj->timerExpired = true;
9D01732C  24020001   ADDIU V0, ZERO, 1
136:                 }
137:                 
138:                 // *****************************************************************************
139:                 /* Function:
140:                     void * _USB_HOST_FindEndOfDescriptor(void * descriptor) 
141:                 
142:                   Summary:
143:                     Function finds the end of descritor marker and returns the pointer to where
144:                     the marker has started.
145:                 
146:                   Description:
147:                     Function finds the end of descriptor marker and returns the pointer to where
148:                     the marker has started.
149:                 
150:                   Remarks:
151:                     This is a local function and should not be called directly by the
152:                     application.
153:                 */    
154:                 
155:                 void * _USB_HOST_FindEndOfDescriptor(void * descriptor) 
156:                 {
157:                     uint8_t * search;
158:                     void * result = NULL;
159:                     int foundMarkers = 0;
160:                 
161:                     if(descriptor == NULL) 
9D015F10  10800010   BEQ A0, ZERO, 0x9D015F54
9D015F14  00801021   ADDU V0, A0, ZERO
9D015F18  24830001   ADDIU V1, A0, 1
9D015F1C  00003021   ADDU A2, ZERO, ZERO
9D015F20  00001021   ADDU V0, ZERO, ZERO
162:                     {
163:                         result = NULL;
164:                     }
165:                     else
166:                     {
167:                         search = (uint8_t *)(descriptor);
168:                         while(foundMarkers < 7)
9D015F4C  14A0FFF9   BNE A1, ZERO, 0x9D015F34
9D015F50  24630001   ADDIU V1, V1, 1
9D015F54  03E00008   JR RA
9D015F58  00000000   NOP
169:                         {
170:                             if(*search == 0xFF)
9D015F24  240400FF   ADDIU A0, ZERO, 255
9D015F34  9065FFFF   LBU A1, -1(V1)
9D015F38  14A40008   BNE A1, A0, 0x9D015F5C
9D015F3C  2467FFFF   ADDIU A3, V1, -1
171:                             {
172:                                 /* Found a marker */
173:                                 foundMarkers ++;
9D015F40  24C60001   ADDIU A2, A2, 1
174:                                 if(foundMarkers == 1)
9D015F28  0B4057CD   J 0x9D015F34
9D015F2C  24080001   ADDIU T0, ZERO, 1
9D015F30  24630001   ADDIU V1, V1, 1
9D015F44  10C80008   BEQ A2, T0, 0x9D015F68
9D015F48  28C50007   SLTI A1, A2, 7
175:                                 {
176:                                     /* This is the first marker we found. Save the memory
177:                                      * location */
178:                                     result = search;
179:                                 }
180:                 
181:                             }
182:                             else
183:                             {
184:                                 /* Reset the result */
185:                                 foundMarkers = 0;
9D015F5C  00003021   ADDU A2, ZERO, ZERO
186:                                 result = NULL;
9D015F60  0B4057CC   J 0x9D015F30
187:                             }
188:                 
189:                             search ++;
190:                         }
191:                     }
192:                 
193:                     return(result);
194:                 }
195:                 
196:                 // *****************************************************************************
197:                 /* Function:
198:                     void _USB_HOST_RootHubEventDisable(void) 
199:                 
200:                   Summary:
201:                     Disables all root hub events.
202:                 
203:                   Description:
204:                     This function will disable all root hub events.
205:                 
206:                   Remarks:
207:                     This is a local function and should not be called directly by the
208:                     application.
209:                 */    
210:                 
211:                 void _USB_HOST_RootHubEventDisable(void)
212:                 {
9D016928  27BDFFE8   ADDIU SP, SP, -24
9D01692C  AFBF0014   SW RA, 20(SP)
9D016930  AFB00010   SW S0, 16(SP)
213:                     int iterator;
214:                     USB_HOST_BUS_OBJ * busObj;
215:                 
216:                     for(iterator = 0; iterator < USB_HOST_CONTROLLERS_NUMBER; iterator ++)
217:                     {
218:                         busObj = &gUSBHostBusList[iterator];
219:                         
220:                         /* Disable the event. Save the event status */
221:                         busObj->eventsStatusRestore = busObj->hcdInterface->hostEventsDisable(busObj->hcdHandle);
9D016934  3C028001   LUI V0, -32767
9D016938  24503D78   ADDIU S0, V0, 15736
9D01693C  8E03000C   LW V1, 12(S0)
9D016940  8C630014   LW V1, 20(V1)
9D016944  0060F809   JALR V1
9D016948  8C443D78   LW A0, 15736(V0)
9D01694C  A202004A   SB V0, 74(S0)
222:                     } 
223:                 }
9D016950  8FBF0014   LW RA, 20(SP)
224:                 
225:                 // *****************************************************************************
226:                 /* Function:
227:                     void _USB_HOST_RootHubEventEnable(void) 
228:                 
229:                   Summary:
230:                     Enables all root hub events.
231:                 
232:                   Description:
233:                     This function will enables all root hub events.
234:                 
235:                   Remarks:
236:                     This is a local function and should not be called directly by the
237:                     application.
238:                 */    
239:                 
240:                 void _USB_HOST_RootHubEventEnable(void)
241:                 {
9D016AF4  27BDFFE8   ADDIU SP, SP, -24
9D016AF8  AFBF0014   SW RA, 20(SP)
242:                     int iterator;
243:                     USB_HOST_BUS_OBJ * busObj;
244:                 
245:                     for(iterator = 0; iterator < USB_HOST_CONTROLLERS_NUMBER; iterator ++)
246:                     {
247:                         busObj = &gUSBHostBusList[iterator];
248:                         
249:                         /* Restore the events to what their status was when they were disabled  */
250:                         busObj->hcdInterface->hostEventsEnable(busObj->hcdHandle, busObj->eventsStatusRestore);
9D016AFC  3C038001   LUI V1, -32767
9D016B00  24623D78   ADDIU V0, V1, 15736
9D016B04  8C44000C   LW A0, 12(V0)
9D016B08  8C860018   LW A2, 24(A0)
9D016B0C  8C643D78   LW A0, 15736(V1)
9D016B10  00C0F809   JALR A2
9D016B14  9045004A   LBU A1, 74(V0)
251:                     } 
252:                 }
9D016B18  8FBF0014   LW RA, 20(SP)
253:                 
254:                 // *****************************************************************************
255:                 /* Function:
256:                     bool _USB_HOST_NoInterfacesOwned
257:                     (
258:                         USB_HOST_DEVICE_OBJ * deviceObj,
259:                     );
260:                 
261:                   Summary:
262:                     This function will return true if no interface have been owned and search
263:                     has reach end of TPL.
264:                 
265:                   Description:
266:                     This function will return true if no interface have been owned and search
267:                     has reach end of TPL. It will return false if at least one interface is
268:                     claimed or if all the interfaces are empty.
269:                 
270:                   Remarks:
271:                     This is a local function and should not be called directly by the
272:                     application.
273:                 */    
274:                 
275:                 bool _USB_HOST_NoInterfacesOwned
276:                 (
277:                     USB_HOST_DEVICE_OBJ * deviceObj
278:                 )
279:                 {
280:                     bool result = false;
9D016034  00001021   ADDU V0, ZERO, ZERO
281:                     USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
282:                     int iterator;
283:                 
284:                     /* Check every interface in this device */
285:                     for(iterator = 0; iterator < USB_HOST_DEVICE_INTERFACES_NUMBER; iterator ++)
9D016064  1460FFF4   BNE V1, ZERO, 0x9D016038
9D016068  24840020   ADDIU A0, A0, 32
9D01606C  03E00008   JR RA
9D016070  00000000   NOP
286:                     {
287:                         interfaceInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[iterator]);
288:                         if(interfaceInfo->interfaceDescriptor != NULL)
9D016038  8C850104   LW A1, 260(A0)
9D01603C  50A00009   BEQL A1, ZERO, 0x9D016064
9D016040  2463FFFF   ADDIU V1, V1, -1
289:                         {
290:                             /* Interface has valid interface descriptor. Check if is owned */
291:                             if((interfaceInfo->interfaceDriver == NULL) && (interfaceInfo->tplEntryMatched >= gUSBHostObj.nTPLEntries))
9D016028  3C028001   LUI V0, -32767
9D01602C  90473DD4   LBU A3, 15828(V0)
9D016030  24030005   ADDIU V1, ZERO, 5
9D016044  8C82010C   LW V0, 268(A0)
9D016048  1440000A   BNE V0, ZERO, 0x9D016074
9D01604C  00000000   NOP
9D016050  8C820118   LW V0, 280(A0)
9D016054  0047102A   SLT V0, V0, A3
9D016058  14400008   BNE V0, ZERO, 0x9D01607C
9D01605C  2463FFFF   ADDIU V1, V1, -1
292:                             {
293:                                 /* This means all the driver were tried and this interface was
294:                                  * not owned */
295:                                 result = true;
9D016060  24020001   ADDIU V0, ZERO, 1
296:                             }
297:                             else
298:                             {
299:                                 /* Either the interface is claimed or all TPL entries have
300:                                  * not been searched */
301:                                 result = false;
9D016074  03E00008   JR RA
9D016078  00001021   ADDU V0, ZERO, ZERO
302:                                 break;
303:                             }
304:                         }
305:                     }
306:                     
307:                     return(result);
308:                 }
9D01607C  03E00008   JR RA
309:                 
310:                 // *****************************************************************************
311:                 /* Function:
312:                     void _USB_HOST_UpdateInterfaceStatus
313:                     (
314:                         USB_HOST_DEVICE_OBJ * deviceObj,
315:                         int busIndex
316:                     );
317:                 
318:                   Summary:
319:                     This function will update status of the interfaces.
320:                 
321:                   Description:
322:                     This function will update the status of the interfaces. If a interface is
323:                     not assigned it is either assigned to the device level driver or it is
324:                     assigned to an interface driver. The function will call the tasks routines
325:                     of the interface driver. It checks if the all device is not owned at all
326:                     then it will move the device to an error state.
327:                 
328:                   Remarks:
329:                     This is a local function and should not be called directly by the
330:                     application.
331:                 */    
332:                 
333:                 void _USB_HOST_UpdateInterfaceStatus
334:                 (
335:                     USB_HOST_DEVICE_OBJ * deviceObj,
336:                     int busIndex
337:                 )
338:                 {
9D00989C  27BDFFB0   ADDIU SP, SP, -80
9D0098A0  AFBF004C   SW RA, 76(SP)
9D0098A4  AFB70048   SW S7, 72(SP)
9D0098A8  AFB60044   SW S6, 68(SP)
9D0098AC  AFB50040   SW S5, 64(SP)
9D0098B0  AFB4003C   SW S4, 60(SP)
9D0098B4  AFB30038   SW S3, 56(SP)
9D0098B8  AFB20034   SW S2, 52(SP)
9D0098BC  AFB10030   SW S1, 48(SP)
9D0098C0  AFB0002C   SW S0, 44(SP)
339:                     USB_HOST_BUS_OBJ * busObj;
340:                     USB_HOST_INTERFACE_DESC_INFO * interfaceInfo, * interfaceInfoIterator;
341:                     USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandles[USB_HOST_DEVICE_INTERFACES_NUMBER];
342:                     USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
343:                     USB_INTERFACE_ASSOCIATION_DESCRIPTOR * interfaceAssociation;
344:                     int iterator, iadIterator;
345:                 
346:                     busObj = &(gUSBHostBusList[busIndex]);
347:                 
348:                     /* This redundant statement is added to avoid warning in a case where the
349:                      * debug messages are disabled. */
350:                     busObj = busObj;
351:                     
352:                     if((deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY) && 
9D0098C4  8C8300F0   LW V1, 240(A0)
9D0098C8  2402000F   ADDIU V0, ZERO, 15
9D0098CC  146200AA   BNE V1, V0, 0x9D009B78
9D0098D0  00808821   ADDU S1, A0, ZERO
9D0098D4  908201A5   LBU V0, 421(A0)
9D0098D8  2442FFFF   ADDIU V0, V0, -1
9D0098DC  304200FF   ANDI V0, V0, 255
9D0098E0  2C4200FE   SLTIU V0, V0, 254
9D0098E4  504000A5   BEQL V0, ZERO, 0x9D009B7C
9D0098E8  8FBF004C   LW RA, 76(SP)
353:                             (deviceObj->configDescriptorInfo.configurationNumber > 0) &&
354:                             (deviceObj->configDescriptorInfo.configurationNumber != USB_HOST_CONFIGURATION_NUMBER_INVALID))
355:                     {
356:                         /* This means that the device is in a running state and the device is
357:                          * configured */
358:                         for(iterator = 0; iterator < deviceObj->nInterfaces ; iterator ++)
9D0098EC  908200D5   LBU V0, 213(A0)
9D0098F0  58400087   BLEZL V0, 0x9D009B10
9D0098F4  8E2200E0   LW V0, 224(S1)
9D0098F8  24900104   ADDIU S0, A0, 260
9D0098FC  00009021   ADDU S2, ZERO, ZERO
9D009A88  0B4026BF   J 0x9D009AFC
9D009A8C  26520001   ADDIU S2, S2, 1
9D009AF8  26520001   ADDIU S2, S2, 1
9D009AFC  922200D5   LBU V0, 213(S1)
9D009B00  0242102A   SLT V0, S2, V0
9D009B04  1440FF80   BNE V0, ZERO, 0x9D009908
9D009B08  26100020   ADDIU S0, S0, 32
359:                         {
360:                             interfaceInfo = &deviceObj->configDescriptorInfo.interfaceInfo[iterator];
361:                 
362:                             if(interfaceInfo->interfaceDriver != NULL)
9D009908  8E020008   LW V0, 8(S0)
9D00990C  10400006   BEQ V0, ZERO, 0x9D009928
9D009910  02009821   ADDU S3, S0, ZERO
363:                             {
364:                                 /* The interface is owned. Run the tasks routine of this driver */
365:                                 interfaceInfo->interfaceDriver->interfaceTasks(interfaceInfo->interfaceHandle);
9D009914  8C420028   LW V0, 40(V0)
9D009918  0040F809   JALR V0
9D00991C  8E04000C   LW A0, 12(S0)
9D009920  0B4026BF   J 0x9D009AFC
9D009924  26520001   ADDIU S2, S2, 1
366:                             }
367:                             else
368:                             {
369:                                 /* Driver is not assigned. Check if this device has a device
370:                                  * level driver and that this interface has not already been
371:                                  * tried with that driver */
372:                 
373:                                 if((deviceObj->deviceClientDriver != NULL) && (!interfaceInfo->wasTriedWithDeviceDriver))
9D009928  8E2200E0   LW V0, 224(S1)
9D00992C  5040002B   BEQL V0, ZERO, 0x9D0099DC
9D009930  8E670014   LW A3, 20(S3)
9D009934  92030010   LBU V1, 16(S0)
9D009938  54600028   BNEL V1, ZERO, 0x9D0099DC
9D00993C  8E670014   LW A3, 20(S3)
374:                                 {
375:                                     /* The device is owned and the interface has not been tried
376:                                      * yet with the device driver. Call the interface assign
377:                                      * function of the device client driver */
378:                 
379:                                     if(interfaceInfo->interfaceAssociationDescriptor != NULL)
9D009940  8E030004   LW V1, 4(S0)
9D009944  50600019   BEQL V1, ZERO, 0x9D0099AC
9D009948  8E070000   LW A3, 0(S0)
380:                                     {
381:                                         /* IAD Case. Prepare the table of interfaces and assign
382:                                          * all of them to the same driver */
383:                 
384:                                         interfaceInfoIterator = interfaceInfo;
385:                                         iadIterator = 0;
386:                                         while(interfaceInfoIterator != NULL)
9D00994C  1200000E   BEQ S0, ZERO, 0x9D009988
9D009950  27A30010   ADDIU V1, SP, 16
9D009954  02001021   ADDU V0, S0, ZERO
9D009958  00003021   ADDU A2, ZERO, ZERO
9D009978  1440FFF8   BNE V0, ZERO, 0x9D00995C
9D00997C  24630004   ADDIU V1, V1, 4
9D009980  0B402664   J 0x9D009990
9D009984  8E2200E0   LW V0, 224(S1)
9D009988  00003021   ADDU A2, ZERO, ZERO
387:                                         {
388:                                             /* Add the handle of this interface to the interface
389:                                              * table. Assign the device level driver to all
390:                                              * interfaces. */
391:                                             interfaceHandles[iadIterator] = interfaceInfoIterator->interfaceHandle;
9D00995C  8C44000C   LW A0, 12(V0)
9D009960  AC640000   SW A0, 0(V1)
392:                                             interfaceInfoIterator->interfaceDriver = deviceObj->deviceClientDriver;
9D009964  8E2400E0   LW A0, 224(S1)
9D009968  AC440008   SW A0, 8(V0)
393:                                             interfaceInfoIterator->wasTriedWithDeviceDriver = true;
9D00996C  A0540010   SB S4, 16(V0)
394:                                             iadIterator ++;
9D009970  24C60001   ADDIU A2, A2, 1
395:                                             interfaceInfoIterator = interfaceInfoIterator->nextInterface;
9D009974  8C42001C   LW V0, 28(V0)
396:                                         }
397:                 
398:                                         /* Now the interfaceHandles table has the handles of all
399:                                          * the interfaces in this IAD. Call the device client
400:                                          * driver interface assign function with this table. */
401:                 
402:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Assigning IAD group to device driver", busIndex, deviceObj->deviceAddress);
403:                                         deviceObj->deviceClientDriver->interfaceAssign(interfaceHandles,
9D00998C  8E2200E0   LW V0, 224(S1)
9D009990  8C42001C   LW V0, 28(V0)
9D009994  27A40010   ADDIU A0, SP, 16
9D009998  8E25004C   LW A1, 76(S1)
9D00999C  0040F809   JALR V0
9D0099A0  8E670004   LW A3, 4(S3)
9D0099A4  0B4026BF   J 0x9D009AFC
9D0099A8  26520001   ADDIU S2, S2, 1
404:                                                 deviceObj->deviceIdentifier, iadIterator, (uint8_t *)(interfaceInfo->interfaceAssociationDescriptor));
405:                                     }
406:                                     else if(interfaceInfo->interfaceDescriptor != NULL)
9D0099AC  10E00052   BEQ A3, ZERO, 0x9D009AF8
9D0099B0  27A40010   ADDIU A0, SP, 16
407:                                     {
408:                                         /* Non IAD case. Prepare the interface handle table. In
409:                                          * case of a non IAD this will be one interface and
410:                                          * hence one handle only. */
411:                 
412:                                         interfaceHandles[0] = interfaceInfo->interfaceHandle;
9D0099B4  8E03000C   LW V1, 12(S0)
9D0099B8  AFA30010   SW V1, 16(SP)
413:                 
414:                                         /* We assign the driver before calling the
415:                                          * interfaceAssign function. This will allow the client
416:                                          * to release the interface if it chooses to and the host
417:                                          * will try re-matching the interface. */
418:                 
419:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Assigning interface to device driver", busIndex, deviceObj->deviceAddress);
420:                                         interfaceInfo->interfaceDriver = deviceObj->deviceClientDriver;
9D0099BC  AE020008   SW V0, 8(S0)
421:                                         deviceObj->deviceClientDriver->interfaceAssign(interfaceHandles,
9D0099C0  8E2200E0   LW V0, 224(S1)
9D0099C4  8C42001C   LW V0, 28(V0)
9D0099C8  8E25004C   LW A1, 76(S1)
9D0099CC  0040F809   JALR V0
9D0099D0  24060001   ADDIU A2, ZERO, 1
422:                                                 deviceObj->deviceIdentifier, 1, (uint8_t *)(interfaceInfo->interfaceDescriptor));
423:                 
424:                                         /* Set the flag indicating this was tried with device
425:                                          * driver. */
426:                                         interfaceInfo->wasTriedWithDeviceDriver = true;
9D009904  24140001   ADDIU S4, ZERO, 1
9D0099D4  0B4026BE   J 0x9D009AF8
9D0099D8  A2140010   SB S4, 16(S0)
427:                                     }
428:                                 }
429:                                 else
430:                                 {
431:                                     /* This means the interface driver is never assigned, or if
432:                                      * there is a client driver it has released the interface,
433:                                      * or there isn't a device level client driver. Check the
434:                                      * TPL for a match. Has this searched reached the end of the
435:                                      * TPL table */
436:                 
437:                                     if(interfaceInfo->tplEntryMatched < gUSBHostObj.nTPLEntries)
9D009900  3C158001   LUI S5, -32767
9D0099DC  26A33DC8   ADDIU V1, S5, 15816
9D0099E0  9076000C   LBU S6, 12(V1)
9D0099E4  00F6182A   SLT V1, A3, S6
9D0099E8  50600044   BEQL V1, ZERO, 0x9D009AFC
9D0099EC  26520001   ADDIU S2, S2, 1
438:                                     {
439:                                         /* Not tried with all TPL entries */
440:                                         if(interfaceInfo->interfaceAssociationDescriptor != NULL)
9D0099F0  8E630004   LW V1, 4(S3)
9D0099F4  50600026   BEQL V1, ZERO, 0x9D009A90
9D0099F8  8E770000   LW S7, 0(S3)
441:                                         {
442:                                             /* IAD case */
443:                 
444:                                             USB_HOST_CLIENT_DRIVER * matchedClientDriver;
445:                                             int matchedTPLEntry;
446:                 
447:                                             /* Get the Interface association descriptor */
448:                                             interfaceAssociation = interfaceInfo->interfaceAssociationDescriptor;
449:                 
450:                                             /* Search the TPL for a driver */
451:                                             interfaceInfo->tplEntryMatched = _USB_HOST_FindClassSubClassProtocolDriver(interfaceAssociation->bFunctionClass,
9D0099FC  90640004   LBU A0, 4(V1)
9D009A00  90650005   LBU A1, 5(V1)
9D009A04  90660006   LBU A2, 6(V1)
9D009A08  0F404D1D   JAL _USB_HOST_FindClassSubClassProtocolDriver
9D009A0C  24E70001   ADDIU A3, A3, 1
452:                                                     interfaceAssociation->bFunctionSubClass, interfaceAssociation->bFunctionProtocol, interfaceInfo->tplEntryMatched + 1);
453:                 
454:                                             /* Did we find a driver match */
455:                                             if(interfaceInfo->tplEntryMatched < gUSBHostObj.nTPLEntries)
9D009A10  0056B02A   SLT S6, V0, S6
9D009A14  12C00038   BEQ S6, ZERO, 0x9D009AF8
9D009A18  AE620014   SW V0, 20(S3)
456:                                             {
457:                                                 /* Yes we did */
458:                                                 interfaceInfoIterator = interfaceInfo;
9D009A40  02601821   ADDU V1, S3, ZERO
459:                                                 iadIterator = 0;
9D009A44  00003021   ADDU A2, ZERO, ZERO
9D009A70  00003021   ADDU A2, ZERO, ZERO
460:                                                 matchedTPLEntry = interfaceInfo->tplEntryMatched;
461:                                                 matchedClientDriver = gUSBHostObj.tpl[interfaceInfo->tplEntryMatched].hostClientDriver;
9D009A1C  26A33DC8   ADDIU V1, S5, 15816
9D009A20  8C640010   LW A0, 16(V1)
9D009A24  00021880   SLL V1, V0, 2
9D009A28  00022900   SLL A1, V0, 4
9D009A2C  00651821   ADDU V1, V1, A1
9D009A30  00831821   ADDU V1, A0, V1
462:                 
463:                                                 while(interfaceInfoIterator != NULL)
9D009A34  1260000E   BEQ S3, ZERO, 0x9D009A70
9D009A38  8C670010   LW A3, 16(V1)
9D009A3C  27A40010   ADDIU A0, SP, 16
9D009A60  1460FFF9   BNE V1, ZERO, 0x9D009A48
9D009A64  24840004   ADDIU A0, A0, 4
9D009A68  0B40269E   J 0x9D009A78
9D009A6C  8CE2001C   LW V0, 28(A3)
464:                                                 {
465:                                                     /* Add the handle of this interface to the interface
466:                                                      * table. Assign the device level driver to all
467:                                                      * interfaces. */
468:                                                     interfaceHandles[iadIterator] = interfaceInfoIterator->interfaceHandle;
9D009A48  8C65000C   LW A1, 12(V1)
9D009A4C  AC850000   SW A1, 0(A0)
469:                                                     interfaceInfoIterator->interfaceDriver = matchedClientDriver;
9D009A50  AC670008   SW A3, 8(V1)
470:                                                     interfaceInfoIterator->tplEntryMatched = matchedTPLEntry;
9D009A54  AC620014   SW V0, 20(V1)
471:                                                     iadIterator ++;
9D009A58  24C60001   ADDIU A2, A2, 1
472:                                                     interfaceInfoIterator = interfaceInfoIterator->nextInterface;
9D009A5C  8C63001C   LW V1, 28(V1)
473:                                                 }
474:                 
475:                                                 /* Now the interfaceHandles table has the
476:                                                  * handles of all the interfaces in this IAD.
477:                                                  * Call the client driver interface assign
478:                                                  * function with this table. */
479:                                                 
480:                                                 SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Assigning IAD to TPL entry %d", busIndex, deviceObj->deviceAddress, matchedTPLEntry);
481:                                                 matchedClientDriver->interfaceAssign(interfaceHandles,
9D009A74  8CE2001C   LW V0, 28(A3)
9D009A78  27A40010   ADDIU A0, SP, 16
9D009A7C  8E25004C   LW A1, 76(S1)
9D009A80  0040F809   JALR V0
9D009A84  8E670004   LW A3, 4(S3)
482:                                                         deviceObj->deviceIdentifier, iadIterator, (uint8_t *)(interfaceInfo->interfaceAssociationDescriptor));
483:                                             }
484:                                         }
485:                                         else if(interfaceInfo->interfaceDescriptor != NULL)
9D009A90  52E0001A   BEQL S7, ZERO, 0x9D009AFC
9D009A94  26520001   ADDIU S2, S2, 1
486:                                         {
487:                                             /* Single interface case */
488:                                             interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(interfaceInfo->interfaceDescriptor);
489:                 
490:                                             /* Search for a driver */
491:                                             interfaceInfo->tplEntryMatched = _USB_HOST_FindClassSubClassProtocolDriver(interfaceDescriptor->bInterfaceClass,
9D009A98  92E40005   LBU A0, 5(S7)
9D009A9C  92E50006   LBU A1, 6(S7)
9D009AA0  92E60007   LBU A2, 7(S7)
9D009AA4  0F404D1D   JAL _USB_HOST_FindClassSubClassProtocolDriver
9D009AA8  24E70001   ADDIU A3, A3, 1
492:                                                     interfaceDescriptor->bInterfaceSubClass, interfaceDescriptor->bInterfaceProtocol, interfaceInfo->tplEntryMatched + 1);
493:                 
494:                                             /* Did we find a driver match */
495:                                             if(interfaceInfo->tplEntryMatched < gUSBHostObj.nTPLEntries)
9D009AAC  0056B02A   SLT S6, V0, S6
9D009AB0  12C00011   BEQ S6, ZERO, 0x9D009AF8
9D009AB4  AE620014   SW V0, 20(S3)
496:                                             {
497:                                                 /* This means we found a match. Assign the
498:                                                  * driver. Create the interface table with one 
499:                                                  * interface handle. */
500:                                                 
501:                                                 SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Assigning Interface to TPL entry %d", busIndex, deviceObj->deviceAddress, interfaceInfo->tplEntryMatched);
502:                                                 interfaceHandles[0] = interfaceInfo->interfaceHandle;
9D009AB8  8E63000C   LW V1, 12(S3)
9D009ABC  AFA30010   SW V1, 16(SP)
503:                                                 interfaceInfo->interfaceDriver = gUSBHostObj.tpl[interfaceInfo->tplEntryMatched].hostClientDriver;
9D009AC0  26A33DC8   ADDIU V1, S5, 15816
9D009AC4  8C630010   LW V1, 16(V1)
9D009AC8  00022080   SLL A0, V0, 2
9D009ACC  00021100   SLL V0, V0, 4
9D009AD0  00821021   ADDU V0, A0, V0
9D009AD4  00621021   ADDU V0, V1, V0
9D009AD8  8C420010   LW V0, 16(V0)
9D009ADC  AE620008   SW V0, 8(S3)
504:                                                 interfaceInfo->interfaceDriver->interfaceAssign(interfaceHandles, 
9D009AE0  8C42001C   LW V0, 28(V0)
9D009AE4  27A40010   ADDIU A0, SP, 16
9D009AE8  8E25004C   LW A1, 76(S1)
9D009AEC  24060001   ADDIU A2, ZERO, 1
9D009AF0  0040F809   JALR V0
9D009AF4  02E03821   ADDU A3, S7, ZERO
505:                                                         deviceObj->deviceIdentifier, 1, (uint8_t *)(interfaceInfo->interfaceDescriptor));
506:                                             }
507:                                         }
508:                                     }
509:                                 }
510:                             }
511:                         }
512:                 
513:                         /* We have to keep check if all the interfaces and the device are
514:                          * owned. If we reach a point where none are owned and the search has
515:                          * reached the end of TPL, then we move the device to an error state.
516:                          * Moving the device to an error state will reduce the processing that
517:                          * the host has to do for this device */
518:                 
519:                         if((deviceObj->deviceClientDriver == NULL) &&
9D009B0C  8E2200E0   LW V0, 224(S1)
9D009B10  1440001A   BNE V0, ZERO, 0x9D009B7C
9D009B14  8FBF004C   LW RA, 76(SP)
9D009B20  8E2300E4   LW V1, 228(S1)
9D009B24  0062102A   SLT V0, V1, V0
9D009B28  54400015   BNEL V0, ZERO, 0x9D009B80
9D009B2C  8FB70048   LW S7, 72(SP)
520:                                 (deviceObj->tplEntryTried >= gUSBHostObj.nTPLEntries) &&
9D009B18  3C028001   LUI V0, -32767
9D009B1C  90423DD4   LBU V0, 15828(V0)
9D009B38  10400010   BEQ V0, ZERO, 0x9D009B7C
9D009B3C  8FBF004C   LW RA, 76(SP)
521:                                 (_USB_HOST_NoInterfacesOwned(deviceObj)))
9D009B30  0F40580A   JAL _USB_HOST_NoInterfacesOwned
9D009B34  02202021   ADDU A0, S1, ZERO
522:                         {
523:                             /* This means that no driver will match this device. Move this
524:                              * device to an error state */
525:                 
526:                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d not matched to any TPL entry", busIndex, deviceObj->deviceAddress);
527:                             deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D009B40  2402FFFF   ADDIU V0, ZERO, -1
9D009B44  AE2200F0   SW V0, 240(S1)
528:                             deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D009B48  8E22006C   LW V0, 108(S1)
9D009B4C  8C420020   LW V0, 32(V0)
9D009B50  0040F809   JALR V0
9D009B54  8E240058   LW A0, 88(S1)
529:                             if(gUSBHostObj.hostEventHandler != NULL)
9D009B58  3C028001   LUI V0, -32767
9D009B5C  8C423DC8   LW V0, 15816(V0)
9D009B60  10400005   BEQ V0, ZERO, 0x9D009B78
9D009B64  24040001   ADDIU A0, ZERO, 1
530:                             {
531:                                 /* Send an event to the application */
532:                                 gUSBHostObj.hostEventHandler(USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context);
9D009B68  00002821   ADDU A1, ZERO, ZERO
9D009B6C  3C038001   LUI V1, -32767
9D009B70  0040F809   JALR V0
9D009B74  8C663DCC   LW A2, 15820(V1)
533:                             }
534:                         }
535:                     }
536:                 }
9D009B78  8FBF004C   LW RA, 76(SP)
537:                 
538:                 // *****************************************************************************
539:                 /* Function:
540:                     void _USB_HOST_ReleaseInterfaceDrivers
541:                     (
542:                         USB_HOST_DEVICE_OBJ * deviceObj,
543:                     );
544:                 
545:                   Summary:
546:                     This function will release all the loaded interface drivers.
547:                 
548:                   Description:
549:                     This function will release all the loaded interface drivers. The matching
550:                     driver index for each interface will be updated to indicate that the
551:                     matching should start at the top of the TPL table.
552:                 
553:                   Remarks:
554:                     This is a local function and should not be called directly by the
555:                     application.
556:                 */    
557:                 
558:                 void _USB_HOST_ReleaseInterfaceDrivers
559:                 (
560:                     USB_HOST_DEVICE_OBJ * deviceObj
561:                 )
562:                 {
9D015570  27BDFFD8   ADDIU SP, SP, -40
9D015574  AFBF0024   SW RA, 36(SP)
9D015578  AFB40020   SW S4, 32(SP)
9D01557C  AFB3001C   SW S3, 28(SP)
9D015580  AFB20018   SW S2, 24(SP)
9D015584  AFB10014   SW S1, 20(SP)
9D015588  AFB00010   SW S0, 16(SP)
9D01558C  00808021   ADDU S0, A0, ZERO
563:                     int iterator;
564:                     USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
565:                 
566:                     for(iterator = 0; iterator < USB_HOST_DEVICE_INTERFACES_NUMBER; iterator ++)
9D015590  00009021   ADDU S2, ZERO, ZERO
9D015598  24130005   ADDIU S3, ZERO, 5
9D0155C4  26520001   ADDIU S2, S2, 1
9D0155C8  1653FFF4   BNE S2, S3, 0x9D01559C
9D0155CC  26100020   ADDIU S0, S0, 32
567:                     {
568:                         interfaceInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[iterator]);
569:                         if(interfaceInfo->interfaceDriver != NULL)
9D01559C  8E02010C   LW V0, 268(S0)
9D0155A0  10400005   BEQ V0, ZERO, 0x9D0155B8
9D0155A4  02008821   ADDU S1, S0, ZERO
570:                         {
571:                             interfaceInfo->interfaceDriver->interfaceRelease(interfaceInfo->interfaceHandle);
9D0155A8  8C420020   LW V0, 32(V0)
9D0155AC  0040F809   JALR V0
9D0155B0  8E040110   LW A0, 272(S0)
572:                             interfaceInfo->interfaceDriver = NULL;
9D0155B4  AE00010C   SW ZERO, 268(S0)
573:                         }
574:                 
575:                         /* Clear up the other interface members */
576:                         interfaceInfo->tplEntryMatched = -1;
9D015594  2414FFFF   ADDIU S4, ZERO, -1
9D0155B8  AE340118   SW S4, 280(S1)
577:                         interfaceInfo->interfaceDescriptor = NULL;
9D0155BC  AE200104   SW ZERO, 260(S1)
578:                         interfaceInfo->wasTriedWithDeviceDriver = false;
9D0155C0  A2200114   SB ZERO, 276(S1)
579:                     }
580:                 }
9D0155D0  8FBF0024   LW RA, 36(SP)
581:                 
582:                 // *****************************************************************************
583:                 /* Function:
584:                     void _USB_HOST_ConfigurationDescriptorParse
585:                     (
586:                         USB_HOST_DEVICE_OBJ * deviceObj,
587:                     );
588:                 
589:                   Summary:
590:                     This function will parse the configuration descriptor contained in the
591:                     configurationDescriptor of the configDescriptorInfo structure in deviceObj
592:                     and will populate the interface tables. If the configuration descriptor
593:                     contains IADs, it will then link the interfaces as defined by the IAD.
594:                 
595:                   Description:
596:                     This function will parse the configuration descriptor contained in the
597:                     configurationDescriptor of the configDescriptorInfo structure in deviceObj
598:                     and will populate the interface tables. If the configuration descriptor
599:                     contains IADs, it will then link the interfaces as defined by the IAD.
600:                 
601:                   Remarks:
602:                     This is a local function and should not be called directly by the
603:                     application.
604:                 */    
605:                 
606:                 bool _USB_HOST_ConfigurationDescriptorParse
607:                 (
608:                     USB_HOST_DEVICE_OBJ * deviceObj
609:                 )
610:                 {
9D010930  27BDFFB0   ADDIU SP, SP, -80
9D010934  AFBF004C   SW RA, 76(SP)
9D010938  AFB70048   SW S7, 72(SP)
9D01093C  AFB60044   SW S6, 68(SP)
9D010940  AFB50040   SW S5, 64(SP)
9D010944  AFB4003C   SW S4, 60(SP)
9D010948  AFB30038   SW S3, 56(SP)
9D01094C  AFB20034   SW S2, 52(SP)
9D010950  AFB10030   SW S1, 48(SP)
9D010954  AFB0002C   SW S0, 44(SP)
9D010958  00809021   ADDU S2, A0, ZERO
611:                     USB_HOST_INTERFACE_DESCRIPTOR_QUERY interfaceQueryObj;
612:                     USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor;
613:                     USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
614:                     USB_INTERFACE_ASSOCIATION_DESCRIPTOR * interfaceAssociation;
615:                     USB_HOST_INTERFACE_DESC_INFO * interfaceDescInfo, * previousInterface;
616:                     USB_HOST_IAD_QUERY iadQueryObj;
617:                     bool result = true;
618:                     unsigned int iterator;
619:                     uint8_t bFirstInterface;
620:                     uint8_t bInterfaceCount;
621:                 
622:                     /* Get the device index and the pnp identifier. These are needed to form the
623:                      * interface handle */
624:                     unsigned int deviceIndex = USB_HOST_DEVICE_INDEX(deviceObj->deviceIdentifier);
9D01095C  8C82004C   LW V0, 76(A0)
9D010960  304300FF   ANDI V1, V0, 255
625:                     unsigned int pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier);
9D010964  00021402   SRL V0, V0, 16
626:                 
627:                     /* Get the configuration descriptor and the number of interfaces */
628:                     configurationDescriptor = deviceObj->configDescriptorInfo.configurationDescriptor;
9D010968  8C910100   LW S1, 256(A0)
629:                     int nInterfaces = configurationDescriptor->bNumInterfaces;
9D01096C  92360004   LBU S6, 4(S1)
630:                 
631:                     /* Reset the interface query context. Set up the interface query to find 
632:                      * interface by number and alternate setting 0 */
633:                     USB_HOST_DeviceInterfaceQueryContextClear(&interfaceQueryObj);
634:                     interfaceQueryObj.flags = USB_HOST_INTERFACE_QUERY_BY_NUMBER|USB_HOST_INTERFACE_QUERY_ALT_SETTING;
9D010974  24040003   ADDIU A0, ZERO, 3
9D010978  AFA40018   SW A0, 24(SP)
635:                     interfaceQueryObj.bAlternateSetting = 0;
636:                 
637:                     for(iterator = 0; iterator < nInterfaces; iterator ++)
9D01097C  12C0001A   BEQ S6, ZERO, 0x9D0109E8
9D010980  A3A00011   SB ZERO, 17(SP)
9D010984  02C0B821   ADDU S7, S6, ZERO
9D010994  00009821   ADDU S3, ZERO, ZERO
9D0109D0  26730001   ADDIU S3, S3, 1
9D0109D4  0277102B   SLTU V0, S3, S7
9D0109D8  1440FFF0   BNE V0, ZERO, 0x9D01099C
9D0109DC  26100020   ADDIU S0, S0, 32
9D0109E0  0B40427B   J 0x9D0109EC
9D0109E4  24100001   ADDIU S0, ZERO, 1
9D0109E8  24100001   ADDIU S0, ZERO, 1
638:                     {
639:                         /* Search for interface descriptor */
640:                         interfaceQueryObj.bInterfaceNumber = iterator;
9D01099C  A3B30010   SB S3, 16(SP)
641:                         interfaceDescriptor = USB_HOST_DeviceInterfaceDescriptorQuery(configurationDescriptor, &interfaceQueryObj);
9D0109A0  02202021   ADDU A0, S1, ZERO
9D0109A4  0F4042F8   JAL USB_HOST_DeviceInterfaceDescriptorQuery
9D0109A8  27A50010   ADDIU A1, SP, 16
642:                         if(interfaceDescriptor == NULL)
9D0109AC  5040000F   BEQL V0, ZERO, 0x9D0109EC
9D0109B0  00008021   ADDU S0, ZERO, ZERO
643:                         {
644:                             /* This should never happen. The host will check a configuration
645:                              * descriptor for error before it allows the device to reach this
646:                              * stage. Cannot say why the interface descriptor was not found */
647:                             result = false;
648:                             break;
649:                         }
650:                 
651:                         /* Initialize the interface descriptor information object */
652:                         interfaceDescInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[iterator]);
653:                         interfaceDescInfo->interfaceDescriptor = interfaceDescriptor;
9D0109B4  AE020104   SW V0, 260(S0)
654:                         interfaceDescInfo->interfaceAssociationDescriptor = NULL;
9D0109B8  AE000108   SW ZERO, 264(S0)
655:                         interfaceDescInfo->currentAlternateSetting = 0;
9D0109BC  A200011C   SB ZERO, 284(S0)
656:                         interfaceDescInfo->interfaceHandle = _USB_HOST_DeviceInterfaceHandleGet(pnpIdentifier, iterator, deviceIndex);
9D010988  0002AC00   SLL S5, V0, 16
9D01098C  02A3A825   OR S5, S5, V1
9D010990  02408021   ADDU S0, S2, ZERO
9D0109C0  00131200   SLL V0, S3, 8
9D0109C4  00551025   OR V0, V0, S5
9D0109C8  AE020110   SW V0, 272(S0)
657:                         interfaceDescInfo->tplEntryMatched = -1;
9D010998  2414FFFF   ADDIU S4, ZERO, -1
9D0109CC  AE140118   SW S4, 280(S0)
658:                     }
659:                 
660:                     /* Update the number of interfaces in the device object */
661:                     deviceObj->nInterfaces = nInterfaces;
9D0109EC  A25600D5   SB S6, 213(S2)
662:                 
663:                     /* Now we search the configuration descriptor for IADs. Clear the search
664:                      * context before we start the search. */
665:                     USB_HOST_DeviceIADQueryContextClear(&iadQueryObj);
666:                     
667:                     do
668:                     {
669:                         /* We will search for any IAD.  */
670:                         iadQueryObj.flags = USB_HOST_IAD_QUERY_FLAG_ANY;
9D0109F4  AFA00020   SW ZERO, 32(SP)
671:                 
672:                         /* Search for IAD */
673:                         interfaceAssociation = USB_HOST_DeviceIADQuery(configurationDescriptor, &iadQueryObj);
9D0109F8  02202021   ADDU A0, S1, ZERO
9D0109FC  0F4051DC   JAL USB_HOST_DeviceIADQuery
9D010A00  27A50020   ADDIU A1, SP, 32
674:                 
675:                         if(interfaceAssociation != NULL)
9D010A04  50400016   BEQL V0, ZERO, 0x9D010A60
9D010A08  02001021   ADDU V0, S0, ZERO
676:                         {
677:                             /* Get the starting interface and the number of contiguous
678:                              * interfaces */
679:                             bInterfaceCount = interfaceAssociation->bInterfaceCount;
680:                             bFirstInterface = interfaceAssociation->bFirstInterface;
9D010A0C  90450002   LBU A1, 2(V0)
681:                             previousInterface = NULL;
9D010A2C  00003021   ADDU A2, ZERO, ZERO
682:                 
683:                             for(iterator = bFirstInterface; iterator < (bFirstInterface + bInterfaceCount); iterator ++)
9D010A10  90480003   LBU T0, 3(V0)
9D010A14  00A84021   ADDU T0, A1, T0
9D010A18  00A8182B   SLTU V1, A1, T0
9D010A1C  1060FFF5   BEQ V1, ZERO, 0x9D0109F4
9D010A20  00051940   SLL V1, A1, 5
9D010A24  24630104   ADDIU V1, V1, 260
9D010A28  02431821   ADDU V1, S2, V1
9D010A4C  24A50001   ADDIU A1, A1, 1
9D010A50  10A8FFE8   BEQ A1, T0, 0x9D0109F4
9D010A54  24630020   ADDIU V1, V1, 32
9D010A58  0B40428C   J 0x9D010A30
9D010A5C  00E03021   ADDU A2, A3, ZERO
684:                             {
685:                                 /* Get the pointer to the interface descriptor object for this
686:                                  * interface. Set the interfaceAssociationDescriptor member to
687:                                  * point to IAD. Set the next descriptor to point to the next
688:                                  * interface descriptor in the group. */
689:                                 interfaceDescInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[iterator]);
9D010A30  00603821   ADDU A3, V1, ZERO
690:                                 interfaceDescInfo->interfaceAssociationDescriptor = interfaceAssociation;
691:                 
692:                                 if(previousInterface == NULL)
9D010A34  14C00003   BNE A2, ZERO, 0x9D010A44
9D010A38  AC620004   SW V0, 4(V1)
9D010A3C  0B404293   J 0x9D010A4C
9D010A40  AC60001C   SW ZERO, 28(V1)
693:                                 {
694:                                     /* This is the first interface in this group. We set the
695:                                      * previous interface to the current interface. */
696:                                     previousInterface = interfaceDescInfo;
697:                                     previousInterface->nextInterface = NULL;
698:                                 }
699:                                 else
700:                                 {
701:                                     /* This is the not the first interface in the group. Set the
702:                                      * next interface of previous one to this one. Then set
703:                                      * previous to this interface. */
704:                                     previousInterface->nextInterface = interfaceDescInfo;
9D010A44  ACC3001C   SW V1, 28(A2)
705:                                     interfaceDescInfo->nextInterface = NULL;
9D010A48  AC60001C   SW ZERO, 28(V1)
706:                                     previousInterface = interfaceDescInfo;
707:                                 }
708:                             }
709:                         }
710:                         else
711:                         {
712:                             /* No more IAD in this configuration descriptor */
713:                         }
714:                     } while(interfaceAssociation != NULL);
715:                 
716:                     /* At this point, if there was an IAD, say 2 IAD with interface 0 and 1 and
717:                      * 2 and 3. The interfaceAssociationDescriptor of interfaceInfo[0] and
718:                      * interfaceInfo[1] will point to the parent IAD.
719:                      * interfaceInfo[0].nextInterface will point to interfaceInfo[1] and
720:                      * interfaceInfo[1].nextInterface will be NULL because it is the last
721:                      * interface in this group. Similarly interfaceAssociationDescriptor of
722:                      * interfaceInfo[2] and interfaceInfo[3] will point to the parent IAD.
723:                      * interfaceInfo[2].nextInterface will point to interfaceInfo[3] and
724:                      * interfaceInfo[3].nextInterface will be NULL because it is the last
725:                      * interface in this group. */
726:                     return(result);
727:                 }
9D010A60  8FBF004C   LW RA, 76(SP)
728:                 
729:                 // *****************************************************************************
730:                 /* Function:
731:                     int _USB_HOST_FindClassSubClassProtocolDriver
732:                     (
733:                         uint8_t bDeviceClass,
734:                         uint8_t bDeviceSubClass,
735:                         uint8_t bDeviceProtocol,
736:                         int startPoint
737:                     );
738:                 
739:                   Summary:
740:                     This function will search for matching class subclass protocol driver in the
741:                     TPL table.
742:                 
743:                   Description:
744:                     This function will search for matching class subclass protocol driver in the
745:                     TPL table. If a driver was not found, the function will return the last
746:                     index of the TPL table + 1. The function will start searching from (and
747:                     including) startPoint.
748:                 
749:                   Remarks:
750:                     This is a local function and should not be called directly by the
751:                     application.
752:                 */    
753:                 
754:                 int _USB_HOST_FindClassSubClassProtocolDriver
755:                 (
756:                     uint8_t bDeviceClass,
757:                     uint8_t bDeviceSubClass,
758:                     uint8_t bDeviceProtocol,
759:                     int startPoint
760:                 )
761:                 {
9D013474  00E01021   ADDU V0, A3, ZERO
9D013478  308400FF   ANDI A0, A0, 255
9D01347C  30A500FF   ANDI A1, A1, 255
762:                     USB_HOST_TPL_ENTRY * tpl;
763:                     int iterator;
764:                     USB_HOST_OBJ * hostObj = &gUSBHostObj;
765:                     unsigned int matched = 0;
9D0134AC  00001821   ADDU V1, ZERO, ZERO
766:                     unsigned int tplFlags;
767:                 
768:                     for(iterator = startPoint; iterator < hostObj->nTPLEntries; iterator ++)
9D013480  3C038001   LUI V1, -32767
9D013484  90693DD4   LBU T1, 15828(V1)
9D013488  00E9182A   SLT V1, A3, T1
9D01348C  1060002C   BEQ V1, ZERO, 0x9D013540
9D013490  30C600FF   ANDI A2, A2, 255
9D013494  00071880   SLL V1, A3, 2
9D013498  00073900   SLL A3, A3, 4
9D01349C  00671821   ADDU V1, V1, A3
9D0134A0  3C078001   LUI A3, -32767
9D0134A4  8CE83DD8   LW T0, 15832(A3)
9D0134A8  01034021   ADDU T0, T0, V1
9D013530  24420001   ADDIU V0, V0, 1
9D013534  0049382A   SLT A3, V0, T1
9D013538  14E0FFDD   BNE A3, ZERO, 0x9D0134B0
9D01353C  25080014   ADDIU T0, T0, 20
769:                     {
770:                         tpl = &hostObj->tpl[iterator];
771:                 
772:                         /* Check if this entry is a class subclass protocol entry */
773:                         if(tpl->tplFlags.driverType == TPL_FLAG_CLASS_SUBCLASS_PROTOCOL)
9D0134B0  8D070008   LW A3, 8(T0)
9D0134B4  30E70001   ANDI A3, A3, 1
9D0134B8  54E0001E   BNEL A3, ZERO, 0x9D013534
9D0134BC  24420001   ADDIU V0, V0, 1
774:                         {
775:                             /* First we check if which field match */
776:                 
777:                             if(bDeviceClass == tpl->id.cl_sc_p.classCode)
9D0134C0  910A0000   LBU T2, 0(T0)
778:                             {
779:                                 /* Class matched */
780:                                 matched |= 0x2;
9D0134C4  34670002   ORI A3, V1, 2
9D0134C8  01445026   XOR T2, T2, A0
9D0134CC  00EA180A   MOVZ V1, A3, T2
781:                             }
782:                 
783:                             if(bDeviceSubClass == tpl->id.cl_sc_p.subClassCode)
9D0134D0  910A0001   LBU T2, 1(T0)
784:                             {
785:                                 /* Subclass matched */
786:                                 matched |= 0x4;
9D0134D4  34670004   ORI A3, V1, 4
9D0134D8  01455026   XOR T2, T2, A1
9D0134DC  00EA180A   MOVZ V1, A3, T2
787:                             }
788:                 
789:                             if(bDeviceProtocol == tpl->id.cl_sc_p.protocolCode)
9D0134E0  910A0002   LBU T2, 2(T0)
790:                             {
791:                                 /* Protocol matched */
792:                                 matched |= 0x8;
9D0134E4  34670008   ORI A3, V1, 8
9D0134E8  01465026   XOR T2, T2, A2
9D0134EC  00EA180A   MOVZ V1, A3, T2
793:                             }
794:                 
795:                             tplFlags = (tpl->tplFlags.ignoreClass << 1) | (tpl->tplFlags.ignoreSubClass << 2) | (tpl->tplFlags.ignoreProtocol << 3);
9D0134F0  8D070008   LW A3, 8(T0)
9D0134F4  7CEB0080   EXT T3, A3, 2, 1
9D0134F8  000B5880   SLL T3, T3, 2
9D0134FC  7CEA0040   EXT T2, A3, 1, 1
9D013500  000A5040   SLL T2, T2, 1
9D013504  016A5025   OR T2, T3, T2
9D013508  7CE700C0   EXT A3, A3, 3, 1
9D01350C  000738C0   SLL A3, A3, 3
9D013510  01473825   OR A3, T2, A3
796:                             matched = matched & (~(tplFlags & 0xE));
9D013514  30EA000E   ANDI T2, A3, 14
9D013518  000A5027   NOR T2, ZERO, T2
9D01351C  006A1824   AND V1, V1, T2
797:                 
798:                             /* Now check if the criteria matches */
799:                             if((tplFlags & 0xE) == ((~matched) & 0xE))
9D013520  00035027   NOR T2, ZERO, V1
9D013524  314A000E   ANDI T2, T2, 14
9D013528  11470005   BEQ T2, A3, 0x9D013540
9D01352C  00000000   NOP
800:                             {
801:                                 /* We found a match */
802:                                 break;
803:                             }
804:                         }
805:                     }
806:                 
807:                     return(iterator);
808:                 }
9D013540  03E00008   JR RA
809:                 
810:                 // *****************************************************************************
811:                 /* Function:
812:                     void _USB_HOST_UpdateConfigurationState
813:                     (
814:                         USB_HOST_DEVICE_OBJ * deviceObj,
815:                         int busIndex
816:                     );
817:                 
818:                   Summary:
819:                     This function will update the configuration state of the device.
820:                 
821:                   Description:
822:                     This function will check if the device configuration needs to be changed. If
823:                     so then it gets the configuration, parses the configuration, sets up the
824:                     interface tables and then sets the configuration.
825:                 
826:                   Remarks:
827:                     This is a local function and should not be called directly by the
828:                     application.
829:                 */    
830:                 
831:                 void _USB_HOST_UpdateConfigurationState
832:                 (
833:                     USB_HOST_DEVICE_OBJ * deviceObj,
834:                     int busIndex
835:                 )
836:                 {
9D006098  27BDFFD8   ADDIU SP, SP, -40
9D00609C  AFBF0024   SW RA, 36(SP)
9D0060A0  AFB10020   SW S1, 32(SP)
9D0060A4  AFB0001C   SW S0, 28(SP)
837:                     USB_HOST_BUS_OBJ * busObj;
838:                     USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor;
839:                     USB_HOST_DEVICE_EVENT_CONFIGURATION_SET_DATA eventData;
840:                     int iterator;
841:                 
842:                     busObj = &(gUSBHostBusList[busIndex]);
843:                     
844:                     /* This redundant statement is added to avoid warning in a case where the
845:                      * debug messages are disabled. */
846:                     busObj = busObj;
847:                     
848:                     /* Only proceed if the device is in a ready state */
849:                     if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY)
9D0060A8  8C8300F0   LW V1, 240(A0)
9D0060AC  2402000F   ADDIU V0, ZERO, 15
9D0060B0  1462011F   BNE V1, V0, 0x9D006530
9D0060B4  00808021   ADDU S0, A0, ZERO
850:                     {
851:                         switch(deviceObj->configurationState)
9D0060B8  8C8201AC   LW V0, 428(A0)
9D0060BC  2C420008   SLTIU V0, V0, 8
9D0060C0  1040011B   BEQ V0, ZERO, 0x9D006530
9D0060C4  3C029D00   LUI V0, -25344
9D0060C8  8C8301AC   LW V1, 428(A0)
9D0060CC  00031880   SLL V1, V1, 2
9D0060D0  244260E0   ADDIU V0, V0, 24800
9D0060D4  7C43100A   LWX V0, V1(V0)
9D0060D8  00400008   JR V0
9D0060DC  00000000   NOP
852:                         {
853:                             case USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG:
854:                 
855:                                 /* We don't have to do anything here. The state indicates that
856:                                  * the device is ready for configuration, but somebody has to
857:                                  * set it */
858:                 
859:                                 break;
860:                 
861:                             case USB_HOST_DEVICE_CONFIG_STATE_START:
862:                 
863:                                 /* Start the process of setting the configuration. We first get
864:                                  * the configuration header. The requestedConfigurationNumber
865:                                  * member of deviceObj contains the index of the configuration to be
866:                                  * set */
867:                 
868:                                 _USB_HOST_FillSetupPacket(
9D006100  908200FC   LBU V0, 252(A0)
9D006104  24420200   ADDIU V0, V0, 512
9D006108  3042FFFF   ANDI V0, V0, -1
9D006144  248200D6   ADDIU V0, A0, 214
869:                                         &(deviceObj->setupPacket),
870:                                         ( USB_SETUP_DIRN_DEVICE_TO_HOST |
871:                                           USB_SETUP_TYPE_STANDARD |
872:                                           USB_SETUP_RECIPIENT_DEVICE ),
873:                                         USB_REQUEST_GET_DESCRIPTOR,
874:                                         ( USB_DESCRIPTOR_CONFIGURATION << 8 )+ deviceObj->requestedConfigurationNumber , 0 , 9 ) ;
875:                 
876:                                 /* Fill IRP */
877:                                 deviceObj->controlTransferObj.controlIRP.data = ( void * )deviceObj->buffer;
9D00613C  24820094   ADDIU V0, A0, 148
9D006140  AC820010   SW V0, 16(A0)
878:                                 deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D006148  AC82000C   SW V0, 12(A0)
879:                                 deviceObj->controlTransferObj.controlIRP.size = 9;
9D00614C  24020009   ADDIU V0, ZERO, 9
9D006150  AC820014   SW V0, 20(A0)
880:                                 deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D006154  AC800024   SW ZERO, 36(A0)
881:                 
882:                                 /* Set the next state */
883:                                 deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIG_DESCRIPTOR_HEADER_GET;
9D006158  24020003   ADDIU V0, ZERO, 3
9D00615C  AC8201AC   SW V0, 428(A0)
884:                 
885:                                 /* Submit the IRP */
886:                                 if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D006160  8C82006C   LW V0, 108(A0)
9D006164  8C42000C   LW V0, 12(V0)
9D006168  8C840058   LW A0, 88(A0)
9D00616C  0040F809   JALR V0
9D006170  2605000C   ADDIU A1, S0, 12
9D006174  104000EF   BEQ V0, ZERO, 0x9D006534
9D006178  8FBF0024   LW RA, 36(SP)
887:                                             &(deviceObj->controlTransferObj.controlIRP)))
888:                                 {
889:                                     /* We need to be able to send the IRP. We move the
890:                                      * device to an error state. Close the pipe and send
891:                                      * an event to the application. */
892:                                     SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Configuration Descriptor IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);
893:                                     deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D00617C  2402FFFF   ADDIU V0, ZERO, -1
9D006180  AE0200F0   SW V0, 240(S0)
894:                                     deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D006184  8E02006C   LW V0, 108(S0)
9D006188  8C420020   LW V0, 32(V0)
9D00618C  0040F809   JALR V0
9D006190  8E040058   LW A0, 88(S0)
895:                                     if(gUSBHostObj.hostEventHandler != NULL)
9D006194  3C028001   LUI V0, -32767
9D006198  8C423DC8   LW V0, 15816(V0)
9D00619C  104000E4   BEQ V0, ZERO, 0x9D006530
9D0061A0  24040001   ADDIU A0, ZERO, 1
896:                                     {
897:                                         /* Send an event to the application */
898:                                         gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D0061A4  00002821   ADDU A1, ZERO, ZERO
9D0061A8  3C038001   LUI V1, -32767
9D0061AC  0040F809   JALR V0
9D0061B0  8C663DCC   LW A2, 15820(V1)
899:                                     }
900:                                 }
901:                 
902:                                 break;
903:                 
904:                             case USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIG_DESCRIPTOR_HEADER_GET:
905:                 
906:                                 /* Here we are waiting for Get Short Configuration header to
907:                                  * complete */
908:                                 if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED)
9D0061BC  8C820018   LW V0, 24(A0)
9D0061C0  14400004   BNE V0, ZERO, 0x9D0061D4
9D0061C4  00000000   NOP
909:                                 {
910:                                     /* IRP was successful. Go to the next state */
911:                                     SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Obtained Configuration Descriptor header", busIndex, deviceObj->deviceAddress);  
912:                                     deviceObj->configurationState =  USB_HOST_DEVICE_CONFIG_STATE_CONFIG_DESCRIPTOR_GET;
9D0061C8  24020004   ADDIU V0, ZERO, 4
9D0061CC  0B40194C   J 0x9D006530
9D0061D0  AC8201AC   SW V0, 428(A0)
913:                                 }
914:                                 else
915:                                 {
916:                                     /* The IRP did not complete successfully. */
917:                                     if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0061D4  044100D7   BGEZ V0, 0x9D006534
9D0061D8  8FBF0024   LW RA, 36(SP)
918:                                     {
919:                                         /* Close the pipe */
920:                                         deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0061DC  8C82006C   LW V0, 108(A0)
9D0061E0  8C420020   LW V0, 32(V0)
9D0061E4  0040F809   JALR V0
9D0061E8  8C840058   LW A0, 88(A0)
921:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Error while obtaining Configuration Descriptor header", busIndex, deviceObj->deviceAddress);  
922:                                         deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0061EC  2402FFFF   ADDIU V0, ZERO, -1
9D0061F0  AE0200F0   SW V0, 240(S0)
923:                 
924:                                         /* We should send an event to the application
925:                                          * and then wait for device attach */
926:                                         if(gUSBHostObj.hostEventHandler != NULL)
9D0061F4  3C028001   LUI V0, -32767
9D0061F8  8C423DC8   LW V0, 15816(V0)
9D0061FC  104000CC   BEQ V0, ZERO, 0x9D006530
9D006200  24040001   ADDIU A0, ZERO, 1
927:                                         {
928:                                             gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D006204  00002821   ADDU A1, ZERO, ZERO
9D006208  3C038001   LUI V1, -32767
9D00620C  0040F809   JALR V0
9D006210  8C663DCC   LW A2, 15820(V1)
929:                                         }
930:                                     }
931:                                 }
932:                                 break;
933:                 
934:                             case USB_HOST_DEVICE_CONFIG_STATE_CONFIG_DESCRIPTOR_GET:
935:                 
936:                                 /* Allocate memory and then get the entire configuration
937:                                  * descriptor */
938:                                 if(deviceObj->configDescriptorInfo.configurationDescriptor != NULL)
9D00621C  8C840100   LW A0, 256(A0)
9D006220  50800004   BEQL A0, ZERO, 0x9D006234
9D006224  92020096   LBU V0, 150(S0)
939:                                 {
940:                                     USB_HOST_FREE(deviceObj->configDescriptorInfo.configurationDescriptor);
9D006228  0F402C7E   JAL free
9D00622C  00000000   NOP
941:                                 }
942:                 
943:                                 /* Now allocate memory. While allocating the memory, we allocate
944:                                  * 7 additional bytes to store the end of configuration
945:                                  * descriptor memory configuration marker. This marker will
946:                                  * allow the query functions to identify the end of the
947:                                  * configuration descriptor */
948:                 
949:                                 configurationDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)(deviceObj->buffer);
950:                                 deviceObj->configDescriptorInfo.configurationDescriptor = USB_HOST_MALLOC(configurationDescriptor->wTotalLength + 7);
9D006230  92020096   LBU V0, 150(S0)
9D006234  92110097   LBU S1, 151(S0)
9D006238  00118A00   SLL S1, S1, 8
9D00623C  02228825   OR S1, S1, V0
9D006240  0F400B2F   JAL malloc
9D006244  26240007   ADDIU A0, S1, 7
951:                 
952:                                 if(deviceObj->configDescriptorInfo.configurationDescriptor == NULL)
9D006248  14400011   BNE V0, ZERO, 0x9D006290
9D00624C  AE020100   SW V0, 256(S0)
953:                                 {
954:                                     /* The memory allocation failed. We need memory to continue.
955:                                      * We have to stop here */
956:                                     deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D006250  2402FFFF   ADDIU V0, ZERO, -1
9D006254  AE0200F0   SW V0, 240(S0)
957:                                     deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D006258  8E02006C   LW V0, 108(S0)
9D00625C  8C420020   LW V0, 32(V0)
9D006260  0040F809   JALR V0
9D006264  8E040058   LW A0, 88(S0)
958:                                     if(gUSBHostObj.hostEventHandler != NULL)
9D006268  3C028001   LUI V0, -32767
9D00626C  8C423DC8   LW V0, 15816(V0)
9D006270  104000AF   BEQ V0, ZERO, 0x9D006530
9D006274  24040001   ADDIU A0, ZERO, 1
959:                                     {
960:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Could not allocate memory for Configuration Descriptor", busIndex, deviceObj->deviceAddress);
961:                                         gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D006278  00002821   ADDU A1, ZERO, ZERO
9D00627C  3C038001   LUI V1, -32767
9D006280  0040F809   JALR V0
9D006284  8C663DCC   LW A2, 15820(V1)
962:                                     }
963:                                 }
964:                                 else
965:                                 {
966:                                     /* Place a request for the full configuration descriptor */
967:                                     _USB_HOST_FillSetupPacket(
9D006290  920300FC   LBU V1, 252(S0)
9D006294  24630200   ADDIU V1, V1, 512
9D006298  3063FFFF   ANDI V1, V1, -1
9D0062D0  260200D6   ADDIU V0, S0, 214
968:                                             &(deviceObj->setupPacket), ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
969:                                             USB_REQUEST_GET_DESCRIPTOR, ( USB_DESCRIPTOR_CONFIGURATION << 8 ) + deviceObj->requestedConfigurationNumber,
970:                                             0 ,configurationDescriptor->wTotalLength) ;
971:                 
972:                                     /* Create the IRP */
973:                                     deviceObj->controlTransferObj.controlIRP.data = deviceObj->configDescriptorInfo.configurationDescriptor;
9D0062CC  AE020010   SW V0, 16(S0)
974:                                     deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D0062D4  AE02000C   SW V0, 12(S0)
975:                                     deviceObj->controlTransferObj.controlIRP.size = configurationDescriptor->wTotalLength;
9D0062D8  AE110014   SW S1, 20(S0)
976:                                     deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D0062DC  AE000024   SW ZERO, 36(S0)
977:                                     deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIG_DESCRIPTOR_GET;
9D0062E0  24020005   ADDIU V0, ZERO, 5
9D0062E4  AE0201AC   SW V0, 428(S0)
978:                 
979:                                     /* Submit the IRP */
980:                                     if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D0062E8  8E02006C   LW V0, 108(S0)
9D0062EC  8C42000C   LW V0, 12(V0)
9D0062F0  8E040058   LW A0, 88(S0)
9D0062F4  0040F809   JALR V0
9D0062F8  2605000C   ADDIU A1, S0, 12
9D0062FC  1040008D   BEQ V0, ZERO, 0x9D006534
9D006300  8FBF0024   LW RA, 36(SP)
981:                                                 &(deviceObj->controlTransferObj.controlIRP)))
982:                                     {
983:                                         /* We need to be able to send the IRP. We move the
984:                                          * device to an error state. Close the pipe and send
985:                                          * an event to the application. */
986:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Configuration Descriptor IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);
987:                                         deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D006304  2402FFFF   ADDIU V0, ZERO, -1
9D006308  AE0200F0   SW V0, 240(S0)
988:                                         deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D00630C  8E02006C   LW V0, 108(S0)
9D006310  8C420020   LW V0, 32(V0)
9D006314  0040F809   JALR V0
9D006318  8E040058   LW A0, 88(S0)
989:                                         if(gUSBHostObj.hostEventHandler != NULL)
9D00631C  3C028001   LUI V0, -32767
9D006320  8C423DC8   LW V0, 15816(V0)
9D006324  10400082   BEQ V0, ZERO, 0x9D006530
9D006328  24040001   ADDIU A0, ZERO, 1
990:                                         {
991:                                             /* Send an event to the application */
992:                                             gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D00632C  00002821   ADDU A1, ZERO, ZERO
9D006330  3C038001   LUI V1, -32767
9D006334  0040F809   JALR V0
9D006338  8C663DCC   LW A2, 15820(V1)
993:                                         }
994:                                     }
995:                                 }
996:                 
997:                                 break;
998:                 
999:                             case USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIG_DESCRIPTOR_GET:
1000:                
1001:                                /* Here we check if we have received the configuration
1002:                                 * descriptor */
1003:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED) 
9D006344  8C820018   LW V0, 24(A0)
9D006348  14400004   BNE V0, ZERO, 0x9D00635C
9D00634C  00000000   NOP
1004:                                {
1005:                                    /* We have received the configuration descriptor. 
1006:                                     * We can set this configuration. */
1007:                
1008:                                    deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_CONFIGURATION_SET;
9D006350  24020006   ADDIU V0, ZERO, 6
9D006354  0B40194C   J 0x9D006530
9D006358  AC8201AC   SW V0, 428(A0)
1009:                                }
1010:                                else
1011:                                {
1012:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D00635C  04410075   BGEZ V0, 0x9D006534
9D006360  8FBF0024   LW RA, 36(SP)
1013:                                    {
1014:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Error while obtaining Configuration Descriptor.", busIndex, deviceObj->deviceAddress);  
1015:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D006364  8C82006C   LW V0, 108(A0)
9D006368  8C420020   LW V0, 32(V0)
9D00636C  0040F809   JALR V0
9D006370  8C840058   LW A0, 88(A0)
1016:                
1017:                                        /* Move the device to error state */
1018:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D006374  2402FFFF   ADDIU V0, ZERO, -1
9D006378  AE0200F0   SW V0, 240(S0)
1019:                                        
1020:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D00637C  3C028001   LUI V0, -32767
9D006380  8C423DC8   LW V0, 15816(V0)
9D006384  1040006A   BEQ V0, ZERO, 0x9D006530
9D006388  24040001   ADDIU A0, ZERO, 1
1021:                                        {
1022:                                            gUSBHostObj.hostEventHandler(USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D00638C  00002821   ADDU A1, ZERO, ZERO
9D006390  3C038001   LUI V1, -32767
9D006394  0040F809   JALR V0
9D006398  8C663DCC   LW A2, 15820(V1)
1023:                                        }
1024:                                    }
1025:                                }
1026:                
1027:                                break;
1028:                
1029:                            case USB_HOST_DEVICE_CONFIG_STATE_CONFIGURATION_SET:
1030:                
1031:                                /* In this state, the host will set the configuration */
1032:                                _USB_HOST_FillSetupPacket(
9D0063D4  248200D6   ADDIU V0, A0, 214
1033:                                        &(deviceObj->setupPacket),
1034:                                        ( USB_SETUP_DIRN_HOST_TO_DEVICE |
1035:                                          USB_SETUP_TYPE_STANDARD |
1036:                                          USB_SETUP_RECIPIENT_DEVICE ),
1037:                                        USB_REQUEST_SET_CONFIGURATION,
1038:                                        deviceObj->configDescriptorInfo.configurationDescriptor->bConfigurationValue,
9D0063A4  8C820100   LW V0, 256(A0)
9D0063A8  90420005   LBU V0, 5(V0)
1039:                                        0 ,0 ) ;
1040:                
1041:                                /* Fill IRP */
1042:                                deviceObj->controlTransferObj.controlIRP.data = NULL;
9D0063D0  AC800010   SW ZERO, 16(A0)
1043:                                deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D0063D8  AC82000C   SW V0, 12(A0)
1044:                                deviceObj->controlTransferObj.controlIRP.size = 0;
9D0063DC  AC800014   SW ZERO, 20(A0)
1045:                                deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D0063E0  AC800024   SW ZERO, 36(A0)
1046:                                deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIGURATION_SET;
9D0063E4  24020007   ADDIU V0, ZERO, 7
9D0063E8  AC8201AC   SW V0, 428(A0)
1047:                
1048:                                /* Submit the IRP */
1049:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D0063EC  8C82006C   LW V0, 108(A0)
9D0063F0  8C42000C   LW V0, 12(V0)
9D0063F4  8C840058   LW A0, 88(A0)
9D0063F8  0040F809   JALR V0
9D0063FC  2605000C   ADDIU A1, S0, 12
9D006400  1040004C   BEQ V0, ZERO, 0x9D006534
9D006404  8FBF0024   LW RA, 36(SP)
1050:                                            &(deviceObj->controlTransferObj.controlIRP)))
1051:                                {
1052:                                    /* We need to be able to send the IRP. We move the
1053:                                     * device to an error state. Close the pipe and send
1054:                                     * an event to the application. */
1055:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Set Configuration IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);  
1056:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D006408  2402FFFF   ADDIU V0, ZERO, -1
9D00640C  AE0200F0   SW V0, 240(S0)
1057:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D006410  8E02006C   LW V0, 108(S0)
9D006414  8C420020   LW V0, 32(V0)
9D006418  0040F809   JALR V0
9D00641C  8E040058   LW A0, 88(S0)
1058:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D006420  3C028001   LUI V0, -32767
9D006424  8C423DC8   LW V0, 15816(V0)
9D006428  10400041   BEQ V0, ZERO, 0x9D006530
9D00642C  24040001   ADDIU A0, ZERO, 1
1059:                                    {
1060:                                        /* Send an event to the application */
1061:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D006430  00002821   ADDU A1, ZERO, ZERO
9D006434  3C038001   LUI V1, -32767
9D006438  0040F809   JALR V0
9D00643C  8C663DCC   LW A2, 15820(V1)
1062:                                    }
1063:                                }
1064:                
1065:                                break;
1066:                
1067:                            case USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIGURATION_SET:
1068:                
1069:                                /* Here we check if the set configuration has completed */
1070:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED) 
9D006448  8C820018   LW V0, 24(A0)
9D00644C  14400028   BNE V0, ZERO, 0x9D0064F0
9D006450  00000000   NOP
1071:                                {
1072:                                    /* The configuration set was successful. Unload the existing
1073:                                     * interface drivers */
1074:                
1075:                                    _USB_HOST_ReleaseInterfaceDrivers(deviceObj);
9D006454  0F40555C   JAL _USB_HOST_ReleaseInterfaceDrivers
9D006458  00000000   NOP
1076:                
1077:                                    /* Insert the end of the configuration descriptor marker
1078:                                     * into the configuration */
1079:                                    configurationDescriptor = deviceObj->configDescriptorInfo.configurationDescriptor;
9D00645C  8E030100   LW V1, 256(S0)
1080:                                    for(iterator = 0; iterator < 7; iterator ++)
9D006460  00001021   ADDU V0, ZERO, ZERO
9D006468  24060007   ADDIU A2, ZERO, 7
9D006484  24420001   ADDIU V0, V0, 1
9D006488  1446FFF8   BNE V0, A2, 0x9D00646C
9D00648C  A0870000   SB A3, 0(A0)
1081:                                    {
1082:                                        /* The end of configuration descriptor is 7 bytes, each
1083:                                         * 0xFF */
1084:                                        ((uint8_t *)(configurationDescriptor))[configurationDescriptor->wTotalLength + iterator] = 0xFF;
9D006464  2407FFFF   ADDIU A3, ZERO, -1
9D00646C  90650002   LBU A1, 2(V1)
9D006470  90640003   LBU A0, 3(V1)
9D006474  00042200   SLL A0, A0, 8
9D006478  00852025   OR A0, A0, A1
9D00647C  00622821   ADDU A1, V1, V0
9D006480  00A42021   ADDU A0, A1, A0
1085:                                    }
1086:                                    
1087:                                    /* Parse the configuration descriptor and then update the
1088:                                     * interface tables. */
1089:                                    if(!_USB_HOST_ConfigurationDescriptorParse(deviceObj))
9D006490  0F40424C   JAL _USB_HOST_ConfigurationDescriptorParse
9D006494  02002021   ADDU A0, S0, ZERO
9D006498  54400004   BNEL V0, ZERO, 0x9D0064AC
9D00649C  8E020100   LW V0, 256(S0)
1090:                                    {
1091:                                        /* The parsing failed */
1092:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Error in configuration desciptor", busIndex, deviceObj->deviceAddress);  
1093:                                        eventData.result = USB_HOST_RESULT_FAILURE;
9D0064A0  2402FFA8   ADDIU V0, ZERO, -88
9D0064A4  0B40192F   J 0x9D0064BC
9D0064A8  AFA20014   SW V0, 20(SP)
1094:                                    }
1095:                                    else
1096:                                    {
1097:                                        /* The parsing worked. Update the active configuration
1098:                                         * to indicate that the configuration has been set */
1099:                
1100:                                        deviceObj->configDescriptorInfo.configurationNumber = deviceObj->configDescriptorInfo.configurationDescriptor->bConfigurationValue;
9D0064AC  90420005   LBU V0, 5(V0)
9D0064B0  A20201A5   SB V0, 421(S0)
1101:                                        eventData.result = USB_HOST_RESULT_SUCCESS;
9D0064B4  24020001   ADDIU V0, ZERO, 1
9D0064B8  AFA20014   SW V0, 20(SP)
1102:                                    }
1103:                
1104:                                    /* If there is device level client driver, then we let it
1105:                                     * know that the configuration has been set. */
1106:                
1107:                                    eventData.requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
9D0064BC  26020004   ADDIU V0, S0, 4
9D0064C0  AFA20010   SW V0, 16(SP)
1108:                                    if(deviceObj->deviceClientDriver != NULL)
9D0064C4  8E0200E0   LW V0, 224(S0)
9D0064C8  10400006   BEQ V0, ZERO, 0x9D0064E4
9D0064CC  00002821   ADDU A1, ZERO, ZERO
1109:                                    {
1110:                                        deviceObj->deviceClientDriver->deviceEventHandler(deviceObj->deviceClientHandle,
9D0064D0  8C420018   LW V0, 24(V0)
9D0064D4  8E040050   LW A0, 80(S0)
9D0064D8  27A60010   ADDIU A2, SP, 16
9D0064DC  0040F809   JALR V0
9D0064E0  8E070008   LW A3, 8(S0)
1111:                                                USB_HOST_DEVICE_EVENT_CONFIGURATION_SET, &eventData, deviceObj->controlTransferObj.context);
1112:                                    }
1113:                
1114:                                    /* The configuration set is complete. We are ready to set
1115:                                     * another configuration if requested. Return the control
1116:                                     * transfer object back */
1117:                
1118:                                    deviceObj->controlTransferObj.inUse = false;
9D0064E4  A2000004   SB ZERO, 4(S0)
9D0064E8  0B40194C   J 0x9D006530
9D0064EC  AE0001AC   SW ZERO, 428(S0)
1119:                                    deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG;
1120:                                }
1121:                                else
1122:                                {
1123:                                    /* The set configuration request failed */
1124:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0064F0  04410010   BGEZ V0, 0x9D006534
9D0064F4  8FBF0024   LW RA, 36(SP)
1125:                                    {
1126:                                        eventData.result = USB_HOST_RESULT_FAILURE;
9D0064F8  2402FFA8   ADDIU V0, ZERO, -88
9D0064FC  AFA20014   SW V0, 20(SP)
1127:                                        /* If there is device level client driver, then we let it
1128:                                         * know that the configuration has been set. */
1129:                                        
1130:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Could not set configuration.", busIndex, deviceObj->deviceAddress);  
1131:                
1132:                                        eventData.requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
9D006500  24820004   ADDIU V0, A0, 4
9D006504  AFA20010   SW V0, 16(SP)
1133:                                        if(deviceObj->deviceClientDriver != NULL)
9D006508  8C8200E0   LW V0, 224(A0)
9D00650C  10400006   BEQ V0, ZERO, 0x9D006528
9D006510  00002821   ADDU A1, ZERO, ZERO
1134:                                        {
1135:                                            deviceObj->deviceClientDriver->deviceEventHandler(deviceObj->deviceClientHandle,
9D006514  8C420018   LW V0, 24(V0)
9D006518  8C840050   LW A0, 80(A0)
9D00651C  27A60010   ADDIU A2, SP, 16
9D006520  0040F809   JALR V0
9D006524  8E070008   LW A3, 8(S0)
1136:                                                    USB_HOST_DEVICE_EVENT_CONFIGURATION_SET, &eventData, deviceObj->controlTransferObj.context);
1137:                                        }
1138:                                        deviceObj->controlTransferObj.inUse = false;
9D006528  A2000004   SB ZERO, 4(S0)
1139:                                        deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG;
9D00652C  AE0001AC   SW ZERO, 428(S0)
1140:                
1141:                                    }
1142:                                }
1143:                                break;
1144:                
1145:                            default:
1146:                                break;
1147:                        }
1148:                    }
1149:                }
9D0061B4  0B40194D   J 0x9D006534
9D0061B8  8FBF0024   LW RA, 36(SP)
9D006214  0B40194D   J 0x9D006534
9D006218  8FBF0024   LW RA, 36(SP)
9D006288  0B40194D   J 0x9D006534
9D00628C  8FBF0024   LW RA, 36(SP)
9D00633C  0B40194D   J 0x9D006534
9D006340  8FBF0024   LW RA, 36(SP)
9D00639C  0B40194D   J 0x9D006534
9D0063A0  8FBF0024   LW RA, 36(SP)
9D006440  0B40194D   J 0x9D006534
9D006444  8FBF0024   LW RA, 36(SP)
9D006530  8FBF0024   LW RA, 36(SP)
1150:                
1151:                // *****************************************************************************
1152:                /* Function:
1153:                    void _USB_HOST_UpdateDeviceOwnership
1154:                    (
1155:                        USB_HOST_DEVICE_OBJ * deviceObj,
1156:                        int busIndex
1157:                    );
1158:                
1159:                  Summary:
1160:                    This function will find a device level owner client driver.
1161:                
1162:                  Description:
1163:                    This function will find a device level client driver owner. If a VID PID
1164:                    level driver is not found then a device level class subclass protocol driver
1165:                    needs to be found. If device was released, then a new owner needs to be
1166:                    found. If the end of the TPL table is reached, then the stop searching and
1167:                    hand over ownership of the device to the host. If a driver is attached, the
1168:                    function will call the tasks routine of this driver.
1169:                
1170:                  Remarks:
1171:                    This is a local function and should not be called directly by the
1172:                    application.
1173:                */    
1174:                
1175:                void _USB_HOST_UpdateDeviceOwnership
1176:                (
1177:                    USB_HOST_DEVICE_OBJ * deviceObj,
1178:                    int busIndex
1179:                )
1180:                {
9D00AF68  27BDFFE0   ADDIU SP, SP, -32
9D00AF6C  AFBF001C   SW RA, 28(SP)
9D00AF70  AFB20018   SW S2, 24(SP)
9D00AF74  AFB10014   SW S1, 20(SP)
9D00AF78  AFB00010   SW S0, 16(SP)
1181:                    int tplSearch;
1182:                    USB_HOST_TPL_ENTRY * tpl;
1183:                    USB_DEVICE_DESCRIPTOR * deviceDescriptor;
1184:                    USB_HOST_BUS_OBJ * busObj;
1185:                
1186:                    busObj = &(gUSBHostBusList[busIndex]);
1187:                
1188:                    /* This redundant statement is added to avoid warning in a case where the
1189:                     * debug messages are disabled. */
1190:                    busObj = busObj;
1191:                    
1192:                    /* Check if the device is in a ready state. */
1193:                    if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY)
9D00AF7C  8C8300F0   LW V1, 240(A0)
9D00AF80  2402000F   ADDIU V0, ZERO, 15
9D00AF84  14620096   BNE V1, V0, 0x9D00B1E0
9D00AF88  00808021   ADDU S0, A0, ZERO
1194:                    {
1195:                        deviceDescriptor = &(deviceObj->deviceDescriptor);
1196:                
1197:                        if(deviceObj->deviceClientDriver != NULL)
9D00AF8C  8C8200E0   LW V0, 224(A0)
9D00AF90  50400008   BEQL V0, ZERO, 0x9D00AFB4
9D00AF94  8E1100E4   LW S1, 228(S0)
1198:                        {
1199:                            /* Run the tasks routine */
1200:                            deviceObj->deviceClientDriver->deviceTasks(deviceObj->deviceClientHandle);
9D00AF98  8C420014   LW V0, 20(V0)
9D00AF9C  0040F809   JALR V0
9D00AFA0  8C840050   LW A0, 80(A0)
1201:                        }
1202:                
1203:                        /* Matching is needed only if the device is not claimed and we have not
1204:                         * already reached the end of the table*/
1205:                
1206:                        if((deviceObj->deviceClientDriver == NULL) && (!(deviceObj->tplEntryTried >= gUSBHostObj.nTPLEntries)))
9D00AFA4  8E0200E0   LW V0, 224(S0)
9D00AFA8  1440004D   BNE V0, ZERO, 0x9D00B0E0
9D00AFAC  3C028001   LUI V0, -32767
9D00AFB0  8E1100E4   LW S1, 228(S0)
9D00AFB4  3C028001   LUI V0, -32767
9D00AFB8  90523DD4   LBU S2, 15828(V0)
9D00AFBC  0232102A   SLT V0, S1, S2
9D00AFC0  5040004C   BEQL V0, ZERO, 0x9D00B0F4
9D00AFC4  8E0200E0   LW V0, 224(S0)
1207:                        {
1208:                            /* The initial value (on device connect) of tplEntryTried is -1. So then
1209:                             * the tplSearch will start matching from 0. If this is not the first
1210:                             * time matching, then matching will start from the next entry in the
1211:                             * TPL table */
1212:                
1213:                            SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d Looking for Device Level Driver.", busIndex, deviceObj->deviceAddress);
1214:                            for (tplSearch = (deviceObj->tplEntryTried + 1); tplSearch < gUSBHostObj.nTPLEntries; tplSearch ++)
9D00AFC8  26310001   ADDIU S1, S1, 1
9D00AFCC  0232102A   SLT V0, S1, S2
9D00AFD0  10400041   BEQ V0, ZERO, 0x9D00B0D8
9D00AFD4  00111080   SLL V0, S1, 2
9D00AFD8  00111900   SLL V1, S1, 4
9D00AFDC  00431021   ADDU V0, V0, V1
9D00AFE0  3C038001   LUI V1, -32767
9D00AFE4  8C633DD8   LW V1, 15832(V1)
9D00AFE8  00621021   ADDU V0, V1, V0
9D00B0A4  0232182A   SLT V1, S1, S2
9D00B0A8  1460FFD0   BNE V1, ZERO, 0x9D00AFEC
9D00B0AC  24420014   ADDIU V0, V0, 20
9D00B0B0  0B402C37   J 0x9D00B0DC
9D00B0B4  AE1100E4   SW S1, 228(S0)
1215:                            {
1216:                                tpl = &gUSBHostObj.tpl[tplSearch];
1217:                
1218:                                if(tpl->tplFlags.driverType == TPL_FLAG_VID_PID)
9D00AFEC  8C430008   LW V1, 8(V0)
9D00AFF0  30640001   ANDI A0, V1, 1
9D00AFF4  5080002B   BEQL A0, ZERO, 0x9D00B0A4
9D00AFF8  26310001   ADDIU S1, S1, 1
1219:                                {
1220:                                    /* This entry is a VID PID Entry */
1221:                
1222:                                    if(tpl->tplFlags.ignoreVIDPID)
9D00AFFC  30640020   ANDI A0, V1, 32
9D00B000  50800004   BEQL A0, ZERO, 0x9D00B014
9D00B004  30630010   ANDI V1, V1, 16
1223:                                    {
1224:                                        /* This means we should attach this driver as the entry says
1225:                                         * that ignore the VID PID and match */
1226:                
1227:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d matched entry %d in TPL table", 
1228:                                                busIndex, deviceObj->deviceAddress, tplSearch);
1229:                
1230:                                        deviceObj->deviceClientDriver = (USB_HOST_CLIENT_DRIVER *)(tpl->hostClientDriver);
9D00B008  8C420010   LW V0, 16(V0)
1231:                                        break;
9D00B00C  0B402C2E   J 0x9D00B0B8
9D00B010  AE0200E0   SW V0, 224(S0)
1232:                                    }
1233:                                    else if(tpl->tplFlags.pidMasked)
9D00B014  10600013   BEQ V1, ZERO, 0x9D00B064
9D00B018  92060084   LBU A2, 132(S0)
1234:                                    {
1235:                                        /* This means we should apply the specified mask to the PID
1236:                                         * field and then compare. */
1237:                
1238:                                        if((deviceDescriptor->idVendor == tpl->id.vid_pid.vid) && 
9D00B01C  92030085   LBU V1, 133(S0)
9D00B020  00031A00   SLL V1, V1, 8
9D00B024  94440000   LHU A0, 0(V0)
9D00B028  00661825   OR V1, V1, A2
9D00B02C  5483001D   BNEL A0, V1, 0x9D00B0A4
9D00B030  26310001   ADDIU S1, S1, 1
9D00B048  94440002   LHU A0, 2(V0)
9D00B04C  00C31824   AND V1, A2, V1
9D00B050  54830014   BNEL A0, V1, 0x9D00B0A4
9D00B054  26310001   ADDIU S1, S1, 1
1239:                                                ((deviceDescriptor->idProduct & tpl->pidMask) == tpl->id.vid_pid.pid))
9D00B034  92030086   LBU V1, 134(S0)
9D00B038  92060087   LBU A2, 135(S0)
9D00B03C  00063200   SLL A2, A2, 8
9D00B040  00C33025   OR A2, A2, V1
9D00B044  94430004   LHU V1, 4(V0)
1240:                                        {
1241:                                            /* Criteria matched */
1242:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d matched entry %d in TPL table", 
1243:                                                    busIndex, deviceObj->deviceAddress, tplSearch);
1244:                
1245:                                            deviceObj->deviceClientDriver = (USB_HOST_CLIENT_DRIVER *)(tpl->hostClientDriver);
9D00B058  8C420010   LW V0, 16(V0)
1246:                                            break;
9D00B05C  0B402C2E   J 0x9D00B0B8
9D00B060  AE0200E0   SW V0, 224(S0)
1247:                                        }
1248:                                    }
1249:                                    else if((deviceDescriptor->idVendor == tpl->id.vid_pid.vid) && 
9D00B064  92030085   LBU V1, 133(S0)
9D00B068  00031A00   SLL V1, V1, 8
9D00B06C  94440000   LHU A0, 0(V0)
9D00B070  00661825   OR V1, V1, A2
9D00B074  5483000B   BNEL A0, V1, 0x9D00B0A4
9D00B078  26310001   ADDIU S1, S1, 1
9D00B088  94440002   LHU A0, 2(V0)
9D00B08C  00661825   OR V1, V1, A2
9D00B090  54830004   BNEL A0, V1, 0x9D00B0A4
9D00B094  26310001   ADDIU S1, S1, 1
1250:                                            (deviceDescriptor->idProduct == tpl->id.vid_pid.pid))
9D00B07C  92060086   LBU A2, 134(S0)
9D00B080  92030087   LBU V1, 135(S0)
9D00B084  00031A00   SLL V1, V1, 8
1251:                                    {
1252:                                        /* Criteria matched */
1253:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d matched entry %d in TPL table", 
1254:                                                busIndex, deviceObj->deviceAddress, tplSearch);
1255:                                        deviceObj->deviceClientDriver = (USB_HOST_CLIENT_DRIVER *)(tpl->hostClientDriver);
9D00B098  8C420010   LW V0, 16(V0)
1256:                                        break;
9D00B09C  0B402C2E   J 0x9D00B0B8
9D00B0A0  AE0200E0   SW V0, 224(S0)
1257:                                    }
1258:                                }
1259:                            }
1260:                
1261:                            if(deviceObj->deviceClientDriver != NULL)
9D00B0B8  8E0200E0   LW V0, 224(S0)
9D00B0BC  50400007   BEQL V0, ZERO, 0x9D00B0DC
9D00B0C0  AE1100E4   SW S1, 228(S0)
1262:                            {
1263:                                /* This means a driver was found. Call the driver assign function */
1264:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Assigning device level driver to device %d", busIndex, deviceObj->deviceAddress);
1265:                                deviceObj->deviceClientDriver->deviceAssign(deviceObj->deviceClientHandle, deviceObj->deviceIdentifier, &(deviceObj->deviceDescriptor));
9D00B0C4  8C42000C   LW V0, 12(V0)
9D00B0C8  8E040050   LW A0, 80(S0)
9D00B0CC  8E05004C   LW A1, 76(S0)
9D00B0D0  0040F809   JALR V0
9D00B0D4  2606007C   ADDIU A2, S0, 124
1266:                            }
1267:                
1268:                            /* Irrespective of the search result, we keep track of where the search 
1269:                             * stopped. If the search stopped at the end and no driver was assigned
1270:                             * then we know there was no VID PID match for this device. */
1271:                            deviceObj->tplEntryTried = tplSearch;
9D00B0D8  AE1100E4   SW S1, 228(S0)
1272:                        }
1273:                        
1274:                        if((deviceObj->tplEntryTried >= gUSBHostObj.nTPLEntries ) && (deviceObj->deviceClientDriver == NULL))
9D00B0DC  3C028001   LUI V0, -32767
9D00B0E0  90523DD4   LBU S2, 15828(V0)
9D00B0E4  8E0200E4   LW V0, 228(S0)
9D00B0E8  0052102A   SLT V0, V0, S2
9D00B0EC  1440001E   BNE V0, ZERO, 0x9D00B168
9D00B0F0  8E0200E0   LW V0, 224(S0)
9D00B0F4  1440003B   BNE V0, ZERO, 0x9D00B1E4
9D00B0F8  8FBF001C   LW RA, 28(SP)
1275:                        {
1276:                            /* This means VID PID matching failed and it has reached the end of
1277:                             * the TPL table. The device can be owned at a VID PID level or a
1278:                             * device class subclass protocol level. If the VID PID matching
1279:                             * reached the end of the table then we should check if device level
1280:                             * class subclass protocol can be matched. All this only if the
1281:                             * device specifies class subclass protocol at a device level and
1282:                             * the device level class subclass protocol matching has not reached
1283:                             * the end of the table */
1284:                
1285:                            if(deviceDescriptor->bDeviceClass != 0x0)
9D00B0FC  92040080   LBU A0, 128(S0)
9D00B100  1080001C   BEQ A0, ZERO, 0x9D00B174
9D00B104  3C028001   LUI V0, -32767
1286:                            {
1287:                                /* This means the device level class, subclass and protocol can 
1288:                                 * be matched. Check if we have already tried this */
1289:                                if((deviceObj->deviceClScPTried < gUSBHostObj.nTPLEntries) && 
9D00B108  8E0700E8   LW A3, 232(S0)
9D00B10C  00F2102A   SLT V0, A3, S2
9D00B110  10400018   BEQ V0, ZERO, 0x9D00B174
9D00B114  3C028001   LUI V0, -32767
1290:                                        (deviceObj->deviceClientDriver == NULL))
1291:                                {
1292:                                    /* Search for match from the last match position. If the
1293:                                     * device was just connected */
1294:                
1295:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d Looking for Device Level CL SC P driver", busIndex, deviceObj->deviceAddress);
1296:                                    deviceObj->deviceClScPTried = _USB_HOST_FindClassSubClassProtocolDriver(deviceDescriptor->bDeviceClass,
9D00B118  92050081   LBU A1, 129(S0)
9D00B11C  92060082   LBU A2, 130(S0)
9D00B120  0F404D1D   JAL _USB_HOST_FindClassSubClassProtocolDriver
9D00B124  24E70001   ADDIU A3, A3, 1
1297:                                            deviceDescriptor->bDeviceSubClass, deviceDescriptor->bDeviceProtocol, deviceObj->deviceClScPTried + 1);
1298:                
1299:                                    if(deviceObj->deviceClScPTried < gUSBHostObj.nTPLEntries)
9D00B128  0052902A   SLT S2, V0, S2
9D00B12C  1240000D   BEQ S2, ZERO, 0x9D00B164
9D00B130  AE0200E8   SW V0, 232(S0)
1300:                                    {
1301:                                        /* This means we found a match. Assign the corresponding driver */
1302:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d. Assiging Device CL SC P Driver %d", 
1303:                                                busIndex, deviceObj->deviceAddress, deviceObj->deviceClScPTried);
1304:                                        deviceObj->deviceClientDriver = (USB_HOST_CLIENT_DRIVER *)(gUSBHostObj.tpl[deviceObj->deviceClScPTried].hostClientDriver);
9D00B134  3C038001   LUI V1, -32767
9D00B138  8C643DD8   LW A0, 15832(V1)
9D00B13C  24030014   ADDIU V1, ZERO, 20
9D00B140  70432802   MUL A1, V0, V1
9D00B144  00A41021   ADDU V0, A1, A0
9D00B148  8C420010   LW V0, 16(V0)
9D00B14C  AE0200E0   SW V0, 224(S0)
1305:                                        deviceObj->deviceClientDriver->deviceAssign(deviceObj->deviceClientHandle, deviceObj->deviceIdentifier, &(deviceObj->deviceDescriptor));
9D00B150  8C42000C   LW V0, 12(V0)
9D00B154  8E040050   LW A0, 80(S0)
9D00B158  8E05004C   LW A1, 76(S0)
9D00B15C  0040F809   JALR V0
9D00B160  2606007C   ADDIU A2, S0, 124
1306:                                    }
1307:                                }
1308:                            }
1309:                        }
1310:                
1311:                        if(deviceObj->deviceClientDriver == NULL)
9D00B164  8E0200E0   LW V0, 224(S0)
9D00B168  1440001E   BNE V0, ZERO, 0x9D00B1E4
9D00B16C  8FBF001C   LW RA, 28(SP)
1312:                        {
1313:                            /* The device is not owned. The host layer must try to set the
1314:                             * configuration */
1315:                
1316:                            if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1317:                            {
1318:                                if((deviceObj->configurationState == USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG)
9D00B18C  8E0201AC   LW V0, 428(S0)
9D00B190  14400011   BNE V0, ZERO, 0x9D00B1D8
9D00B194  24030001   ADDIU V1, ZERO, 1
1319:                                        && (deviceDescriptor->bNumConfigurations > 0)
9D00B198  9202008D   LBU V0, 141(S0)
9D00B19C  1040000F   BEQ V0, ZERO, 0x9D00B1DC
9D00B1A0  3C028001   LUI V0, -32767
1320:                                        && (deviceObj->configDescriptorInfo.configurationNumber == USB_HOST_CONFIGURATION_NUMBER_INVALID))
9D00B1A4  920301A5   LBU V1, 421(S0)
9D00B1A8  240200FF   ADDIU V0, ZERO, 255
9D00B1AC  1462000A   BNE V1, V0, 0x9D00B1D8
9D00B1B0  24030001   ADDIU V1, ZERO, 1
1321:                                {
1322:                                    /* The device is not configured, is ready to be configured
1323:                                     * and has at least one configuration. Check if the control
1324:                                     * transfer object is available to implement this command.
1325:                                     * */
1326:                                    if(!deviceObj->controlTransferObj.inUse)
9D00B1B4  92020004   LBU V0, 4(S0)
9D00B1B8  14400008   BNE V0, ZERO, 0x9D00B1DC
9D00B1BC  3C028001   LUI V0, -32767
1327:                                    {
1328:                                        /* This means we can set the configuration. We set to the
1329:                                         * first configuration */
1330:                                        deviceObj->controlTransferObj.inUse = true;
9D00B1C0  24020001   ADDIU V0, ZERO, 1
9D00B1C4  A2020004   SB V0, 4(S0)
1331:                                        deviceObj->requestedConfigurationNumber = 0;
9D00B1C8  A20000FC   SB ZERO, 252(S0)
1332:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d Setting first configuration", busIndex, deviceObj->deviceAddress); 
1333:                                        deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_START;
9D00B1CC  24020001   ADDIU V0, ZERO, 1
9D00B1D0  AE0201AC   SW V0, 428(S0)
1334:                                    }
1335:                                }
1336:                
1337:                                OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
1338:                            }
1339:                            else
1340:                            {
1341:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Mutex Lock failed", busIndex, deviceObj->deviceAddress); 
1342:                                /* OSAL error must be handled here. This needs to be implemented
1343:                                 * */
1344:                            }
1345:                        }
1346:                    }
1347:                }
9D00B1E0  8FBF001C   LW RA, 28(SP)
1348:                
1349:                // *****************************************************************************
1350:                /* Function:
1351:                    USB_HOST_RESULT USB_HOST_DeviceControlTransfer 
1352:                    ( 
1353:                        USB_HOST_CONTROL_PIPE_HANDLE pipeHandle
1354:                        USB_HOST_TRANSFER_HANDLE * transferHandle
1355:                        USB_SETUP_PACKET * setupPacket,
1356:                        void * data,
1357:                        USB_HOST_DEVICE_CONTROL_REQUEST_COMPLETE_CALLBACK callback,
1358:                        uintptr_t context
1359:                    );
1360:                
1361:                  Summary:
1362:                    Schedules a control transfer.
1363:                
1364:                  Description:
1365:                    This function schedules a control transfer. pipeHandle contains a handle to
1366:                    a control pipe obtained through the USB_HOST_DeviceControlPipeOpen() function.
1367:                    setupPacket points to the setup command to be sent in the Setup Stage of the
1368:                    control transfer. The size and the direction of the data stage is indicated
1369:                    by the setup packet. In case of control transfers where there is no data
1370:                    stage, data is ignored and can be NULL. In all other cases, data should point
1371:                    to the data to data be transferred in the data stage of the control
1372:                    transfer. 
1373:                    
1374:                    If the transfer was scheduled successfully, transferHandle will contain a
1375:                    transfer handle that uniquely identifies this transfer. If the transfer
1376:                    could not be scheduled successfully, transferHandle will contain
1377:                    USB_HOST_TRANSFER_HANDLE_INVALID.
1378:                
1379:                    When the control transfer completes, the host layer will call the specified
1380:                    callback function. The context parameter specified here will be returned in
1381:                    the callback.
1382:                
1383:                  Remarks:
1384:                    Refer to usb_host_client_driver.h for usage details.
1385:                */
1386:                
1387:                USB_HOST_RESULT USB_HOST_DeviceControlTransfer
1388:                (
1389:                    USB_HOST_CONTROL_PIPE_HANDLE pipeHandle,
1390:                    USB_HOST_TRANSFER_HANDLE * transferHandle,
1391:                    USB_SETUP_PACKET * setupPacket,
1392:                    void * data,
1393:                    USB_HOST_DEVICE_CONTROL_REQUEST_COMPLETE_CALLBACK callback,
1394:                    uintptr_t context
1395:                )
1396:                {
9D010A8C  27BDFFE0   ADDIU SP, SP, -32
9D010A90  AFBF001C   SW RA, 28(SP)
9D010A94  AFB10018   SW S1, 24(SP)
9D010A98  AFB00014   SW S0, 20(SP)
1397:                    USB_HOST_DEVICE_OBJ  *deviceObj;
1398:                    uint8_t deviceIndex ;
1399:                    uint16_t pnpIdentifier;
1400:                    USB_HOST_RESULT result = USB_HOST_RESULT_FAILURE;
9D010B28  2405FFA8   ADDIU A1, ZERO, -88
1401:                
1402:                    if(transferHandle == NULL)
9D010A9C  10A00047   BEQ A1, ZERO, 0x9D010BBC
9D010AA0  00A08821   ADDU S1, A1, ZERO
1403:                    {
1404:                        /* transferHandle cannot be NULL */
1405:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
9D010BBC  0B4042F2   J 0x9D010BC8
9D010BC0  2405FFA3   ADDIU A1, ZERO, -93
9D010BC4  2405FFA0   ADDIU A1, ZERO, -96
1406:                    }
1407:                    else
1408:                    {
1409:                        /* Set transfer handle to invalid as the default value */
1410:                        *transferHandle = USB_HOST_TRANSFER_HANDLE_INVALID;
9D010AA4  2402FFFF   ADDIU V0, ZERO, -1
1411:                
1412:                        if(pipeHandle == USB_HOST_CONTROL_PIPE_HANDLE_INVALID)
9D010AA8  10820046   BEQ A0, V0, 0x9D010BC4
9D010AAC  ACA20000   SW V0, 0(A1)
1413:                        {
1414:                            /* Pipe handle is not valid */
1415:                            result = USB_HOST_RESULT_PIPE_HANDLE_INVALID;
1416:                        }
1417:                        else if(setupPacket == NULL)
9D010AB0  50C00045   BEQL A2, ZERO, 0x9D010BC8
9D010AB4  2405FFA3   ADDIU A1, ZERO, -93
1418:                        {
1419:                            /* Required parameters are NULL */
1420:                            result = USB_HOST_RESULT_PARAMETER_INVALID;
1421:                        }
1422:                        else if((setupPacket->wLength != 0) && (data == NULL))
9D010AB8  90C30006   LBU V1, 6(A2)
9D010ABC  90C20007   LBU V0, 7(A2)
9D010AC0  00021200   SLL V0, V0, 8
9D010AC4  00431025   OR V0, V0, V1
9D010AC8  10400003   BEQ V0, ZERO, 0x9D010AD8
9D010ACC  308300FF   ANDI V1, A0, 255
9D010AD0  50E0003D   BEQL A3, ZERO, 0x9D010BC8
9D010AD4  2405FFA3   ADDIU A1, ZERO, -93
1423:                        {
1424:                            /* If this is not a zero data stage control transfer then data cannot
1425:                             * be NULL. */
1426:                            result = USB_HOST_RESULT_PARAMETER_INVALID;
1427:                        }
1428:                        else
1429:                        {
1430:                
1431:                            /* The control pipe handle is the same as the device object handle. We get
1432:                             * the index of the device object that owns this pipe. */
1433:                            deviceIndex =  USB_HOST_DEVICE_INDEX( pipeHandle );
1434:                
1435:                            /* PNP identifier is needed for the IRP user data */
1436:                            pnpIdentifier = USB_HOST_PNP_IDENTIFIER( pipeHandle );
1437:                
1438:                            /* Get a pointer to the device object */
1439:                            deviceObj = &gUSBHostDeviceList[deviceIndex];
9D010AD8  00031100   SLL V0, V1, 4
9D010ADC  00038180   SLL S0, V1, 6
9D010AE0  02028023   SUBU S0, S0, V0
9D010AE4  001010C0   SLL V0, S0, 3
9D010AE8  02028021   ADDU S0, S0, V0
9D010AEC  3C028001   LUI V0, -32767
9D010AF0  24423A18   ADDIU V0, V0, 14872
9D010AF4  00508021   ADDU S0, V0, S0
1440:                
1441:                            /* Get a mutual exclusion lock as this is a global resource */
1442:                            if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1443:                            {
1444:                                if(!deviceObj->controlTransferObj.inUse)
9D010B0C  92020004   LBU V0, 4(S0)
9D010B10  14400006   BNE V0, ZERO, USB_HOST_DeviceControlTransfer::OSAL_MUTEX_Unlock
9D010B14  24080001   ADDIU T0, ZERO, 1
1445:                                {
1446:                                    /* This means that there no control request in progress. We can assign
1447:                                     * request now. The transfer handle is updated to point to the device
1448:                                     * control transfer object. */
1449:                
1450:                                    deviceObj->controlTransferObj.inUse = true;
9D010B18  24020001   ADDIU V0, ZERO, 1
9D010B1C  A2020004   SB V0, 4(S0)
1451:                                    *transferHandle = (USB_HOST_TRANSFER_HANDLE)(&deviceObj->controlTransferObj);
9D010B20  26020004   ADDIU V0, S0, 4
9D010B24  AE220000   SW V0, 0(S1)
1452:                                }
1453:                                else
1454:                                {
1455:                                    /* A control transfer is in progress. */
1456:                                    result = USB_HOST_RESULT_REQUEST_BUSY;
1457:                                }
1458:                
1459:                                /* Unlock the mutual exclusion */
1460:                                OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
1461:                            }
1462:                            else
1463:                            {
1464:                                /* The mutual exclusion could not be obtained */
1465:                                result = USB_HOST_RESULT_REQUEST_BUSY;
1466:                            }
1467:                
1468:                            if(*transferHandle != USB_HOST_TRANSFER_HANDLE_INVALID)
9D010B34  8E280000   LW T0, 0(S1)
9D010B38  2402FFFF   ADDIU V0, ZERO, -1
9D010B3C  11020022   BEQ T0, V0, 0x9D010BC8
9D010B40  00042402   SRL A0, A0, 16
1469:                            {
1470:                                /* Set up the control transfer object */
1471:                                deviceObj->controlTransferObj.requestType = USB_HOST_CONTROL_REQUEST_TYPE_CLIENT_DRIVER_SPECIFIC;
9D010B44  AE000044   SW ZERO, 68(S0)
1472:                                deviceObj->controlTransferObj.controlIRP.data = data;
9D010B48  AE070010   SW A3, 16(S0)
1473:                                deviceObj->controlTransferObj.controlIRP.setup = setupPacket;
9D010B4C  AE06000C   SW A2, 12(S0)
1474:                                deviceObj->controlTransferObj.controlIRP.size = setupPacket->wLength;
9D010B50  90C50006   LBU A1, 6(A2)
9D010B54  90C20007   LBU V0, 7(A2)
9D010B58  00021200   SLL V0, V0, 8
9D010B5C  00451025   OR V0, V0, A1
9D010B60  AE020014   SW V0, 20(S0)
1475:                                deviceObj->controlTransferObj.controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
9D010B64  3C029D01   LUI V0, -25343
9D010B68  2442E060   ADDIU V0, V0, -8096
9D010B6C  AE020024   SW V0, 36(S0)
1476:                                deviceObj->controlTransferObj.controlIRP.userData = _USB_HOST_ControlTransferIRPUserData(pnpIdentifier, 0, deviceIndex);
9D010B70  00042400   SLL A0, A0, 16
9D010B74  00831825   OR V1, A0, V1
9D010B78  AE030020   SW V1, 32(S0)
1477:                                deviceObj->controlTransferObj.context = context;
9D010B7C  8FA20034   LW V0, 52(SP)
9D010B80  AE020008   SW V0, 8(S0)
1478:                                deviceObj->controlTransferObj.callback = callback;
9D010B84  8FA20030   LW V0, 48(SP)
9D010B88  AE020048   SW V0, 72(S0)
1479:                
1480:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(deviceObj->controlTransferObj.controlIRP)))
9D010B8C  8E02006C   LW V0, 108(S0)
9D010B90  8C42000C   LW V0, 12(V0)
9D010B94  8E040058   LW A0, 88(S0)
9D010B98  0040F809   JALR V0
9D010B9C  2605000C   ADDIU A1, S0, 12
9D010BA0  10400009   BEQ V0, ZERO, 0x9D010BC8
9D010BA4  24050001   ADDIU A1, ZERO, 1
1481:                                {
1482:                                    /* There was a problem while submitting the IRP. Update the result and
1483:                                     * the transfer handle. Return the control transfer object back to the
1484:                                     * device object */
1485:                
1486:                                    result = USB_HOST_RESULT_FAILURE;
1487:                                    deviceObj->controlTransferObj.inUse = false;
9D010BA8  A2000004   SB ZERO, 4(S0)
1488:                                    *transferHandle = USB_HOST_TRANSFER_HANDLE_INVALID;
9D010BAC  2402FFFF   ADDIU V0, ZERO, -1
9D010BB0  AE220000   SW V0, 0(S1)
9D010BB4  0B4042F2   J 0x9D010BC8
9D010BB8  2405FFA8   ADDIU A1, ZERO, -88
1489:                                }
1490:                                else
1491:                                {
1492:                                    result = USB_HOST_RESULT_SUCCESS;
1493:                                }
1494:                            }
1495:                        }
1496:                    }
1497:                
1498:                    return result;
1499:                }
9D010BC8  00A01021   ADDU V0, A1, ZERO
1500:                
1501:                // *****************************************************************************
1502:                /* Function:
1503:                    bool _USB_HOST_DeviceConfigurationDescriptorErrorCheck
1504:                    (
1505:                        USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor
1506:                    );
1507:                
1508:                  Summary:
1509:                    This function checks the configuration descriptor for errors.
1510:                
1511:                  Description:
1512:                    This function checks the configuration descriptor for errors. The following
1513:                    errors are checked. The sizes reported by each descriptor headers are added
1514:                    up to check if this sum is equal to total configuration descriptor size
1515:                    reported in the configuration descriptor header, The number of endpoint
1516:                    descriptors in an interface match the endpoints specified in the interface
1517:                    descriptor and the number of interfaces mentioned in the configuration
1518:                    header match the number of descriptors found in the configuration
1519:                    descriptor.
1520:                
1521:                  Remarks:
1522:                    This is a local function and should not be called directly by the
1523:                    application.
1524:                */    
1525:                
1526:                bool _USB_HOST_DeviceConfigurationDescriptorErrorCheck
1527:                (
1528:                    USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor
1529:                )
1530:                {
1531:                    uint8_t * search;
1532:                    bool result = false;
9D00FCD4  00001021   ADDU V0, ZERO, ZERO
9D00FDD8  03E00008   JR RA
9D00FDDC  00001021   ADDU V0, ZERO, ZERO
1533:                    uint8_t bNumInterfaces;
1534:                    uint8_t bNumEndpoints;
1535:                    int uniqueInterfaces = 0;
9D00FCF4  00002021   ADDU A0, ZERO, ZERO
1536:                    int nEndpointsFound = 0;
1537:                    uint8_t * endpointSearch;
1538:                    int currentInterfaceNumber = -1;
9D00FCF0  2409FFFF   ADDIU T1, ZERO, -1
1539:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
1540:                    USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
1541:                    uint16_t configDescriptorSize, analyzedSize = 0;
9D00FCAC  00003021   ADDU A2, ZERO, ZERO
9D00FCD0  00003021   ADDU A2, ZERO, ZERO
1542:                    
1543:                    /* This function checks the configuration descriptor for errors */
1544:                
1545:                    if(configurationDescriptor == NULL)
9D00FC84  10800054   BEQ A0, ZERO, 0x9D00FDD8
9D00FC88  00000000   NOP
1546:                	{
1547:                        /* The input parameter is not valid. Note that the result is already 
1548:                         * false. */
1549:                	}
1550:                    else
1551:                    {
1552:                        configDescriptorSize = configurationDescriptor->wTotalLength;
9D00FC8C  90820002   LBU V0, 2(A0)
9D00FC90  90870003   LBU A3, 3(A0)
9D00FC94  00073A00   SLL A3, A3, 8
9D00FC98  00E23825   OR A3, A3, V0
1553:                
1554:                        /* Check the size of each descriptor in the configuration descriptor and
1555:                         * make sure that the size adds up. */
1556:                
1557:                        search = (uint8_t *)(configurationDescriptor);
1558:                        while(search < ((uint8_t *)(configurationDescriptor) + configDescriptorSize))
9D00FC9C  00872821   ADDU A1, A0, A3
9D00FCA0  0085102B   SLTU V0, A0, A1
9D00FCA4  1040000A   BEQ V0, ZERO, 0x9D00FCD0
9D00FCA8  00801021   ADDU V0, A0, ZERO
9D00FCBC  0045182B   SLTU V1, V0, A1
9D00FCC0  1460FFFB   BNE V1, ZERO, 0x9D00FCB0
9D00FCC4  30C6FFFF   ANDI A2, A2, -1
9D00FCC8  0B403F36   J 0x9D00FCD8
9D00FCCC  00001021   ADDU V0, ZERO, ZERO
1559:                        {
1560:                            /* Start adding the size of each descriptor */
1561:                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
1562:                            analyzedSize += descriptorHeader->size;
9D00FCB0  90430000   LBU V1, 0(V0)
9D00FCB4  00C33021   ADDU A2, A2, V1
1563:                            search += descriptorHeader->size;
9D00FCB8  00431021   ADDU V0, V0, V1
1564:                        }
1565:                
1566:                        /* Check if the analyzed matches the size reported in the configuration 
1567:                         * descriptor header */
1568:                
1569:                        if(analyzedSize != configDescriptorSize)
9D00FCD8  14C70045   BNE A2, A3, 0x9D00FDF0
9D00FCDC  24860009   ADDIU A2, A0, 9
1570:                        {
1571:                            /* The size does not match. result is already false, so nothing to
1572:                             * do here. */
1573:                        }
1574:                        else
1575:                        {
1576:                            /* Now we check if the number of reported interface descriptors 
1577:                             * exist. Interfaces start with 0 */   
1578:                            
1579:                            search = (uint8_t *)(configurationDescriptor);
1580:                            
1581:                            /* Start the search after the configuration descriptor*/
1582:                            search += (sizeof(USB_CONFIGURATION_DESCRIPTOR)); 
9D00FCEC  00C01021   ADDU V0, A2, ZERO
1583:                            bNumInterfaces = configurationDescriptor->bNumInterfaces;
1584:                            
1585:                            /* Keep searching till we have either reached the end of the 
1586:                             * configuration descriptor or till we have found all the 
1587:                             * interfaces. While searching we need to notes that interfaces can
1588:                             * have alternate settings. */
1589:                            
1590:                            while(search < ((uint8_t *)(configurationDescriptor) + configDescriptorSize))
9D00FCE0  00C5102B   SLTU V0, A2, A1
9D00FCE4  10400015   BEQ V0, ZERO, 0x9D00FD3C
9D00FCE8  90870004   LBU A3, 4(A0)
9D00FD2C  5460FFF4   BNEL V1, ZERO, 0x9D00FD00
9D00FD30  90430001   LBU V1, 1(V0)
9D00FD34  03E00008   JR RA
9D00FD38  00001021   ADDU V0, ZERO, ZERO
9D00FD3C  03E00008   JR RA
9D00FD40  28E20001   SLTI V0, A3, 1
1591:                            {
1592:                                descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
1593:                                if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE)
9D00FCF8  24080004   ADDIU T0, ZERO, 4
9D00FCFC  90430001   LBU V1, 1(V0)
9D00FD00  54680006   BNEL V1, T0, 0x9D00FD1C
9D00FD04  90430000   LBU V1, 0(V0)
1594:                                {
1595:                                    /* We found an interface descriptor. We need to make sure
1596:                                     * that we have not found this before. */
1597:                                    interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(search);
1598:                                    if(currentInterfaceNumber != interfaceDescriptor->bInterfaceNumber)
9D00FD08  90430002   LBU V1, 2(V0)
9D00FD0C  10690002   BEQ V1, T1, 0x9D00FD18
9D00FD10  00604821   ADDU T1, V1, ZERO
1599:                                    {
1600:                                        /* We have found an unique interface number */
1601:                                        currentInterfaceNumber = interfaceDescriptor->bInterfaceNumber;
1602:                                        uniqueInterfaces ++;
9D00FD14  24840001   ADDIU A0, A0, 1
1603:                                    }
1604:                                }
1605:                
1606:                                search += descriptorHeader->size;
9D00FD18  90430000   LBU V1, 0(V0)
9D00FD1C  00431021   ADDU V0, V0, V1
1607:                                if (uniqueInterfaces >= bNumInterfaces)
9D00FD20  0087182A   SLT V1, A0, A3
9D00FD24  10600007   BEQ V1, ZERO, 0x9D00FD44
9D00FD28  0045182B   SLTU V1, V0, A1
1608:                                {
1609:                                    /* This means we have found all the interfaces. Don't bother
1610:                                     * searching any more. */
1611:                                    break;
1612:                                }
1613:                            }
1614:                
1615:                            if(uniqueInterfaces < bNumInterfaces)
1616:                            {
1617:                                /* This means the configuration descriptor does not contain all
1618:                                 * the interface descriptors. result is still false so nothing
1619:                                 * to do here. */
1620:                                
1621:                            }
1622:                            else
1623:                            {
1624:                                /* Now we make sure the number of descriptors in the endpoint 
1625:                                 * match what is reported in the endpoint. */
1626:                                search = (uint8_t *)(configurationDescriptor);
1627:                                
1628:                                /* Start the search after the configuration descriptor*/
1629:                                search += (sizeof(USB_CONFIGURATION_DESCRIPTOR)); 
1630:                                bNumInterfaces = configurationDescriptor->bNumInterfaces;
1631:                                
1632:                                /* The logic in the code below requires the default value of
1633:                                 * result to be true. */
1634:                                result = true;
1635:                                
1636:                                /* Locate an interface descriptor and then check the number of  
1637:                                 * endpoints it has. */ 
1638:                                while(search < ((uint8_t *)(configurationDescriptor) + configDescriptorSize))
9D00FDC4  00C5102B   SLTU V0, A2, A1
9D00FDC8  5440FFE1   BNEL V0, ZERO, 0x9D00FD50
9D00FDCC  90C20001   LBU V0, 1(A2)
9D00FDD0  03E00008   JR RA
9D00FDD4  24020001   ADDIU V0, ZERO, 1
1639:                                {
1640:                                    descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
1641:                                    if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE)
9D00FD44  24070004   ADDIU A3, ZERO, 4
9D00FD4C  90C20001   LBU V0, 1(A2)
9D00FD50  1447001B   BNE V0, A3, 0x9D00FDC0
9D00FD54  90C20000   LBU V0, 0(A2)
1642:                                    {
1643:                                        /* Found an interface descriptor. Now analyze the endpoints
1644:                                         * it contains. */
1645:                
1646:                                        nEndpointsFound = 0;
1647:                                        interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(search);
1648:                                        bNumEndpoints = interfaceDescriptor->bNumEndPoints;
1649:                                        endpointSearch = search + descriptorHeader->size;
9D00FD58  00C21021   ADDU V0, A2, V0
1650:                                        
1651:                                        /* Start another while loop to search for endpoints */
1652:                                        while(endpointSearch < ((uint8_t *)(configurationDescriptor) + configDescriptorSize)) 
9D00FD5C  0045182B   SLTU V1, V0, A1
9D00FD60  10600013   BEQ V1, ZERO, 0x9D00FDB0
9D00FD64  90C80004   LBU T0, 4(A2)
9D00FDA0  5480FFF6   BNEL A0, ZERO, 0x9D00FD7C
9D00FDA4  90440001   LBU A0, 1(V0)
1653:                                        {
1654:                                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(endpointSearch);
1655:                
1656:                                            /* Unless this is the last interface in the configuration
1657:                                             * descriptor,all endpoint belonging to an interface must
1658:                                             * be arranged in the descriptor between two interface
1659:                                             * descriptors. */
1660:                                            
1661:                                            if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE)
9D00FD68  90440001   LBU A0, 1(V0)
9D00FD6C  10870011   BEQ A0, A3, 0x9D00FDB4
9D00FD70  00001821   ADDU V1, ZERO, ZERO
9D00FD7C  10870018   BEQ A0, A3, 0x9D00FDE0
9D00FD80  00892026   XOR A0, A0, T1
1662:                                            {
1663:                                                /* This means we have reached another interface
1664:                                                 * descriptor but not the end of the configuration
1665:                                                 * descriptor. Stop searching and see how many
1666:                                                 * endpoints we found. */
1667:                                                break;
1668:                                            }
1669:                                            
1670:                                            if(descriptorHeader->descType == USB_DESCRIPTOR_ENDPOINT)
9D00FD48  24090005   ADDIU T1, ZERO, 5
1671:                                            {
1672:                                                /* We found an endpoint. Increment the count */
1673:                                                nEndpointsFound ++;
9D00FD74  0B403F61   J 0x9D00FD84
9D00FD78  00892026   XOR A0, A0, T1
9D00FD84  2C840001   SLTIU A0, A0, 1
9D00FD88  00641821   ADDU V1, V1, A0
1674:                                            }
1675:                                            endpointSearch += descriptorHeader->size;
9D00FD8C  90440000   LBU A0, 0(V0)
9D00FD90  00441021   ADDU V0, V0, A0
1676:                
1677:                                            if(nEndpointsFound >= bNumEndpoints)
9D00FD94  0068202A   SLT A0, V1, T0
9D00FD98  10800006   BEQ A0, ZERO, 0x9D00FDB4
9D00FD9C  0045202B   SLTU A0, V0, A1
1678:                                            {
1679:                                                /* We found all the breakpoints that we were 
1680:                                                 * looking for. */
1681:                                                break;
1682:                                            }
1683:                                        }
1684:                
1685:                                        /* Did we find out all the endpoints */
1686:                                        if(nEndpointsFound != bNumEndpoints)
9D00FDB4  1503000C   BNE T0, V1, 0x9D00FDE8
9D00FDB8  00000000   NOP
1687:                                        {
1688:                                            /* No point in continuing */
1689:                                            result = false;
9D00FDA8  03E00008   JR RA
9D00FDAC  00001021   ADDU V0, ZERO, ZERO
9D00FDB0  00001821   ADDU V1, ZERO, ZERO
9D00FDE0  03E00008   JR RA
9D00FDE4  00001021   ADDU V0, ZERO, ZERO
9D00FDE8  03E00008   JR RA
9D00FDEC  00001021   ADDU V0, ZERO, ZERO
1690:                                            break;   
1691:                                        }
1692:                                    }
1693:                
1694:                                    /* Here if the descriptor was not an endpoint or if it was 
1695:                                     * an endpoint, then endpoint search was successful. */
1696:                
1697:                                    if(result == false)
1698:                                    {
1699:                                        /* Stop processing altogether because while processing
1700:                                         * and interface, there was an endpoint mismatch */
1701:                                        break;
1702:                                    }
1703:                                    else
1704:                                    {
1705:                                        /* Continue to process interface descriptors*/
1706:                                        search += ((USB_DESCRIPTOR_HEADER *)(search))->size;
9D00FDBC  90C20000   LBU V0, 0(A2)
9D00FDC0  00C23021   ADDU A2, A2, V0
1707:                                    }
1708:                                }
1709:                            }
1710:                        }
1711:                    }
1712:                
1713:                    return(result);
1714:                }
9D00FDF0  03E00008   JR RA
1715:                
1716:                // *****************************************************************************
1717:                /* Function:
1718:                    uint8_t _USB_HOST_GetNewAddress( USB_HOST_BUS_OBJ *busObj )
1719:                
1720:                  Summary:
1721:                    Searches and allocates a new device address.
1722:                
1723:                  Description:
1724:                    This function searches and allocates a new device address.
1725:                
1726:                  Remarks:
1727:                    This is a local function and should not be called by the application
1728:                    directly.
1729:                */
1730:                
1731:                uint8_t _USB_HOST_GetNewAddress( USB_HOST_BUS_OBJ *busObj )
1732:                {
1733:                    uint8_t tempAddress;
1734:                
1735:                    /* Find Free address */
1736:                    for ( tempAddress = 1; tempAddress <= USB_HOST_DEVICES_NUMBER ; tempAddress++ )
1737:                    {
1738:                        if ((busObj->addressBits[ tempAddress / 8] & (1 << ( tempAddress % 8 ))) == 0)
9D016B24  90820014   LBU V0, 20(A0)
9D016B28  7C420040   EXT V0, V0, 1, 1
1739:                        {
1740:                            break;
1741:                        }
1742:                    }
1743:                
1744:                    /*Mark for allocated address */
1745:                    busObj->addressBits[ tempAddress / 8] |= (1 << ( tempAddress % 8 ));
9D016B2C  24030001   ADDIU V1, ZERO, 1
9D016B30  24050002   ADDIU A1, ZERO, 2
9D016B34  00A2180B   MOVN V1, A1, V0
9D016B38  00601021   ADDU V0, V1, ZERO
9D016B3C  24030001   ADDIU V1, ZERO, 1
9D016B40  00431804   SLLV V1, V1, V0
9D016B44  90850014   LBU A1, 20(A0)
9D016B48  00651825   OR V1, V1, A1
1746:                    return tempAddress;
1747:                }
9D016B4C  03E00008   JR RA
1748:                
1749:                // *****************************************************************************
1750:                /* Function:
1751:                    void _USB_HOST_FillSetupPacket
1752:                    (
1753:                        USB_SETUP_PACKET *setupPacket ,
1754:                        uint8_t requestType,
1755:                        uint8_t request ,
1756:                        uint16_t value,
1757:                        uint16_t index,
1758:                        uint16_t length
1759:                    )
1760:                
1761:                  Summary:
1762:                    Helper function to create setup packet.
1763:                
1764:                  Description:
1765:                    Helper function to create setup packet
1766:                
1767:                  Remarks:
1768:                    This is a local function and should not be called by the application
1769:                    directly.
1770:                */
1771:                
1772:                void _USB_HOST_FillSetupPacket
1773:                (
1774:                    USB_SETUP_PACKET *setupPacket ,
1775:                    uint8_t requestType,
1776:                    uint8_t request ,
1777:                    uint16_t value,
1778:                    uint16_t index,
1779:                    uint16_t length
1780:                )
1781:                {
00000000  00000000   NOP
1782:                    setupPacket->bmRequestType = requestType;
9D00100C  2403FF80   ADDIU V1, ZERO, -128
9D001154  A20000D6   SB ZERO, 214(S0)
9D00136C  2403FF80   ADDIU V1, ZERO, -128
9D0014B8  2403FF80   ADDIU V1, ZERO, -128
9D001664  2404FF80   ADDIU A0, ZERO, -128
9D00610C  2403FF80   ADDIU V1, ZERO, -128
9D00629C  2404FF80   ADDIU A0, ZERO, -128
9D0063AC  A08000D6   SB ZERO, 214(A0)
9D010DEC  24050002   ADDIU A1, ZERO, 2
0000000C  00000000   NOP
000000DC  00000000   NOP
00000100  00000000   NOP
00000124  00000000   NOP
1783:                    setupPacket->bRequest = request ;
9D001014  24030006   ADDIU V1, ZERO, 6
9D001158  24030005   ADDIU V1, ZERO, 5
9D001374  24030006   ADDIU V1, ZERO, 6
9D0014C0  24030006   ADDIU V1, ZERO, 6
9D00166C  24040006   ADDIU A0, ZERO, 6
9D006114  24030006   ADDIU V1, ZERO, 6
9D0062A4  24040006   ADDIU A0, ZERO, 6
9D0063B0  24030009   ADDIU V1, ZERO, 9
9D010DF4  A20200D7   SB V0, 215(S0)
00000010  00000000   NOP
000000E4  00000000   NOP
00000108  00000000   NOP
0000012C  00000000   NOP
1784:                    setupPacket->wValue = value ;
9D00101C  A20000D8   SB ZERO, 216(S0)
9D001160  A20200D8   SB V0, 216(S0)
9D00137C  A20000D8   SB ZERO, 216(S0)
9D0014C8  A20200D8   SB V0, 216(S0)
9D001674  A20300D8   SB V1, 216(S0)
9D00611C  A08200D8   SB V0, 216(A0)
9D0062AC  A20300D8   SB V1, 216(S0)
9D0063B8  A08200D8   SB V0, 216(A0)
9D010DF8  A60000D8   SH ZERO, 216(S0)
00000014  00000000   NOP
000000F0  00000000   NOP
00000138  00000000   NOP
1785:                    setupPacket->wIndex = index ;
9D001028  A20000DA   SB ZERO, 218(S0)
9D001168  A20000DA   SB ZERO, 218(S0)
9D001388  A20000DA   SB ZERO, 218(S0)
9D0014D4  A20000DA   SB ZERO, 218(S0)
9D001680  A20000DA   SB ZERO, 218(S0)
9D006128  A08000DA   SB ZERO, 218(A0)
9D0062B8  A20000DA   SB ZERO, 218(S0)
9D0063C0  A08000DA   SB ZERO, 218(A0)
9D010DFC  A60400DA   SH A0, 218(S0)
00000020  00000000   NOP
000000F4  00000000   NOP
0000013C  00000000   NOP
1786:                    setupPacket->wLength = length;
9D001030  24030008   ADDIU V1, ZERO, 8
9D001170  A20000DC   SB ZERO, 220(S0)
9D001390  A20200DC   SB V0, 220(S0)
9D0014DC  24020009   ADDIU V0, ZERO, 9
9D001688  A21200DC   SB S2, 220(S0)
9D006130  24020009   ADDIU V0, ZERO, 9
9D0062C0  A21100DC   SB S1, 220(S0)
9D0063C8  A08000DC   SB ZERO, 220(A0)
9D010E00  A60000DC   SH ZERO, 220(S0)
0000002C  00000000   NOP
00000118  00000000   NOP
1787:                }
1788:                
1789:                // *****************************************************************************
1790:                /* Function:
1791:                    void _USB_HOST_MakeDeviceReady
1792:                    ( 
1793:                        USB_HOST_DEVICE_OBJ * deviceObj, 
1794:                        int busIndex
1795:                    )
1796:                
1797:                  Summary:
1798:                    Maintains the state of the device at a device level.
1799:                
1800:                  Description:
1801:                    Maintains the state of the device at a device level. Moves the state of the
1802:                    device from attached to ready. It opens the control transfer pipe and checks
1803:                    configuration descriptors for errors.
1804:                
1805:                  Remarks:
1806:                    This is a local function and should not be called by the application
1807:                    directly.
1808:                */
1809:                
1810:                void _USB_HOST_MakeDeviceReady
1811:                (
1812:                    USB_HOST_DEVICE_OBJ *deviceObj, 
1813:                    int busIndex
1814:                )
1815:                {
9D000E08  27BDFFC8   ADDIU SP, SP, -56
9D000E0C  AFBF0034   SW RA, 52(SP)
9D000E10  AFB20030   SW S2, 48(SP)
9D000E14  AFB1002C   SW S1, 44(SP)
9D000E18  AFB00028   SW S0, 40(SP)
1816:                    USB_HOST_BUS_OBJ * busObj;
1817:                    USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor;
1818:                    bool interruptIsEnabled;
1819:                   
1820:                    busObj = &(gUSBHostBusList[busIndex]);
9D000E28  00051100   SLL V0, A1, 4
9D000E2C  00052980   SLL A1, A1, 6
9D000E30  00452821   ADDU A1, V0, A1
9D000E34  3C048001   LUI A0, -32767
9D000E38  24843D78   ADDIU A0, A0, 15736
1821:                    
1822:                    if(!deviceObj->inUse)
9D000E1C  90820000   LBU V0, 0(A0)
9D000E20  10400299   BEQ V0, ZERO, 0x9D001888
9D000E24  00808021   ADDU S0, A0, ZERO
1823:                    {
1824:                        /* Although this should not happen, we make sure that we dont run tasks
1825:                         * for device object that is not valid */
1826:                    }
1827:                    else
1828:                    {
1829:                        switch (deviceObj->deviceState)
9D000E3C  8E0200F0   LW V0, 240(S0)
9D000E40  24420001   ADDIU V0, V0, 1
9D000E44  2C430010   SLTIU V1, V0, 16
9D000E48  1060028F   BEQ V1, ZERO, 0x9D001888
9D000E4C  00858821   ADDU S1, A0, A1
9D000E50  00021080   SLL V0, V0, 2
9D000E54  3C039D00   LUI V1, -25344
9D000E58  24630E68   ADDIU V1, V1, 3688
9D000E5C  7C62100A   LWX V0, V0(V1)
9D000E60  00400008   JR V0
9D000E64  00000000   NOP
1830:                        {
1831:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION:
1832:                
1833:                                /* If another device is enumerating on the bus, then we don't do
1834:                                 * anything. Only one device can enumerate on the bus */
1835:                
1836:                                if(!busObj->deviceIsEnumerating)
9D000EA8  92220015   LBU V0, 21(S1)
9D000EAC  14400277   BNE V0, ZERO, 0x9D00188C
9D000EB0  8FBF0034   LW RA, 52(SP)
1837:                                {
1838:                                    /* Remember which device is enumerating */
1839:                                    busObj->enumeratingDeviceIdentifier = deviceObj->deviceIdentifier;
9D000EB4  8E02004C   LW V0, 76(S0)
9D000EB8  AE22004C   SW V0, 76(S1)
1840:                
1841:                                    /* Grab the flag */
1842:                                    busObj->deviceIsEnumerating = true;
9D000EBC  24020001   ADDIU V0, ZERO, 1
9D000EC0  A2220015   SB V0, 21(S1)
1843:                
1844:                                    /* Reset the device */
1845:                                    deviceObj->hubInterface->hubPortReset( deviceObj->hubHandle, deviceObj->devicePort );
9D000EC4  8E020070   LW V0, 112(S0)
9D000EC8  8C420000   LW V0, 0(V0)
9D000ECC  8E040068   LW A0, 104(S0)
9D000ED0  0040F809   JALR V0
9D000ED4  92050075   LBU A1, 117(S0)
1846:                
1847:                                    /* Change the device state */
1848:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_RESET_COMPLETE;
9D000ED8  24020001   ADDIU V0, ZERO, 1
9D000EDC  AE0200F0   SW V0, 240(S0)
1849:                
1850:                                    /* Check if the device object has any previous allocated memory. If
1851:                                     * so then free it up. Allocation is done for the
1852:                                     * configuration descriptor. */
1853:                                    if(deviceObj->configDescriptorInfo.configurationDescriptor != NULL)
9D000EE0  8E040100   LW A0, 256(S0)
9D000EE4  50800005   BEQL A0, ZERO, 0x9D000EFC
9D000EE8  8E040090   LW A0, 144(S0)
1854:                                    {
1855:                                        USB_HOST_FREE(deviceObj->configDescriptorInfo.configurationDescriptor);
9D000EEC  0F402C7E   JAL free
9D000EF0  00000000   NOP
1856:                                        deviceObj->configDescriptorInfo.configurationDescriptor = NULL;
9D000EF4  AE000100   SW ZERO, 256(S0)
1857:                                    }
1858:                
1859:                                    /* The holdingConfigurationDescriptor memory should be free
1860:                                     * but we double check this here just to be safe. */
1861:                                    if(deviceObj->holdingConfigurationDescriptor != NULL)
9D000EF8  8E040090   LW A0, 144(S0)
9D000EFC  10800263   BEQ A0, ZERO, 0x9D00188C
9D000F00  8FBF0034   LW RA, 52(SP)
1862:                                    {
1863:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D000F04  0F402C7E   JAL free
9D000F08  00000000   NOP
1864:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D000F0C  0B400622   J 0x9D001888
9D000F10  AE000090   SW ZERO, 144(S0)
1865:                                    }
1866:                
1867:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device Attach detected. Starting Enumeration.", busIndex);
1868:                                }
1869:                                break;
1870:                
1871:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_RESET_COMPLETE:
1872:                
1873:                                /* Check if the reset has completed */
1874:                                if(deviceObj->hubInterface->hubPortResetIsComplete( deviceObj->hubHandle ,deviceObj->devicePort ))
9D000F14  8E020070   LW V0, 112(S0)
9D000F18  8C420004   LW V0, 4(V0)
9D000F1C  8E040068   LW A0, 104(S0)
9D000F20  0040F809   JALR V0
9D000F24  92050075   LBU A1, 117(S0)
9D000F28  10400258   BEQ V0, ZERO, 0x9D00188C
9D000F2C  8FBF0034   LW RA, 52(SP)
1875:                                {
1876:                                    /* The reset has completed. We can also obtain the speed of the
1877:                                     * device. We give a reset recovery delay to the device */
1878:                                    deviceObj->speed = deviceObj->hubInterface->hubPortSpeedGet(deviceObj->hubHandle, deviceObj->devicePort);
9D000F30  8E020070   LW V0, 112(S0)
9D000F34  8C420010   LW V0, 16(V0)
9D000F38  8E040068   LW A0, 104(S0)
9D000F3C  0040F809   JALR V0
9D000F40  92050075   LBU A1, 117(S0)
9D000F44  AE020078   SW V0, 120(S0)
1879:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_START_RESET_SETTLING_DELAY;
9D000F48  24020002   ADDIU V0, ZERO, 2
9D000F4C  0B400622   J 0x9D001888
9D000F50  AE0200F0   SW V0, 240(S0)
1880:                                }
1881:                
1882:                                break;
1883:                
1884:                            case USB_HOST_DEVICE_STATE_START_RESET_SETTLING_DELAY:
1885:                
1886:                                /* In this state we start the Post Reset Settling delay */
1887:                                busObj->timerExpired = false;
9D000F54  A220004B   SB ZERO, 75(S1)
1888:                                busObj->busOperationsTimerHandle = SYS_TMR_CallbackSingle(100, (uintptr_t ) busObj, _USB_HOST_TimerCallback);
9D000F58  24040064   ADDIU A0, ZERO, 100
9D000F5C  02202821   ADDU A1, S1, ZERO
9D000F60  3C069D01   LUI A2, -25343
9D000F64  0F405C4C   JAL SYS_TMR_CallbackSingle
9D000F68  24C6732C   ADDIU A2, A2, 29484
1889:                                if(SYS_TMR_HANDLE_INVALID != busObj->busOperationsTimerHandle)
9D000F6C  2403FFFF   ADDIU V1, ZERO, -1
9D000F70  10430245   BEQ V0, V1, 0x9D001888
9D000F74  AE220044   SW V0, 68(S1)
1890:                                {
1891:                                    /* Wait for the post bus reset to complete */
1892:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_RESET_SETTLING_DELAY_COMPLETE;
9D000F78  24020003   ADDIU V0, ZERO, 3
9D000F7C  0B400622   J 0x9D001888
9D000F80  AE0200F0   SW V0, 240(S0)
1893:                                }
1894:                                else
1895:                                {
1896:                                    /* Continue to stay in the state */
1897:                                }
1898:                                break;
1899:                
1900:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_RESET_SETTLING_DELAY_COMPLETE:
1901:                
1902:                                /* In this state we are waiting for the reset settling delay to
1903:                                 * complete. */
1904:                
1905:                                if(busObj->timerExpired)
9D000F84  9222004B   LBU V0, 75(S1)
9D000F88  10400240   BEQ V0, ZERO, 0x9D00188C
9D000F8C  8FBF0034   LW RA, 52(SP)
1906:                                {
1907:                                    busObj->busOperationsTimerHandle = SYS_TMR_HANDLE_INVALID;
9D000F90  2412FFFF   ADDIU S2, ZERO, -1
9D000F94  AE320044   SW S2, 68(S1)
1908:                                    /* Settling delay has completed. Now we can open default address
1909:                                     * pipe and and get the configuration descriptor */
1910:                
1911:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device Reset Complete.", busIndex);
1912:                                    deviceObj->controlPipeHandle = deviceObj->hcdInterface->hostPipeSetup( deviceObj->hcdHandle,
9D000F98  8E02006C   LW V0, 108(S0)
9D000F9C  8E040064   LW A0, 100(S0)
9D000FA0  92070074   LBU A3, 116(S0)
9D000FA4  92030075   LBU V1, 117(S0)
9D000FA8  AFA30010   SW V1, 16(SP)
9D000FAC  AFA00014   SW ZERO, 20(SP)
9D000FB0  AFA00018   SW ZERO, 24(SP)
9D000FB4  24030008   ADDIU V1, ZERO, 8
9D000FB8  AFA3001C   SW V1, 28(SP)
9D000FBC  8E030078   LW V1, 120(S0)
9D000FC0  AFA30020   SW V1, 32(SP)
9D000FC4  8C42001C   LW V0, 28(V0)
9D000FC8  00002821   ADDU A1, ZERO, ZERO
9D000FCC  0040F809   JALR V0
9D000FD0  00003021   ADDU A2, ZERO, ZERO
1913:                                            USB_HOST_DEFAULT_ADDRESS , 0 /* Endpoint */, 
1914:                                            deviceObj->hubAddress /* Address of the hub */, 
1915:                                            deviceObj->devicePort /* Address of the port */, 
1916:                                            USB_TRANSFER_TYPE_CONTROL, /* Type of pipe to open */
1917:                                            0 /* bInterval */, 8 /* Endpoint Size */, deviceObj->speed );
1918:                
1919:                                    if(DRV_USB_HOST_PIPE_HANDLE_INVALID == deviceObj->controlPipeHandle)
9D000FD4  1452000D   BNE V0, S2, _USB_HOST_MakeDeviceReady::_USB_HOST_FillSetupPacket
9D000FD8  AE020058   SW V0, 88(S0)
1920:                                    {
1921:                                        /* We need a pipe else we cannot proceed */
1922:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Could not open control pipe. Device not supported.", busIndex);
1923:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D000FDC  2402FFFF   ADDIU V0, ZERO, -1
9D000FE0  AE0200F0   SW V0, 240(S0)
1924:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D000FE4  3C028001   LUI V0, -32767
9D000FE8  8C423DC8   LW V0, 15816(V0)
9D000FEC  10400005   BEQ V0, ZERO, 0x9D001004
9D000FF0  24040001   ADDIU A0, ZERO, 1
1925:                                        {
1926:                                            /* Send an event to the application */
1927:                                            gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D000FF4  00002821   ADDU A1, ZERO, ZERO
9D000FF8  3C038001   LUI V1, -32767
9D000FFC  0040F809   JALR V0
9D001000  8C663DCC   LW A2, 15820(V1)
9D001004  0B400622   J 0x9D001888
9D001008  A2200015   SB ZERO, 21(S1)
1928:                                        }
1929:                
1930:                                        /* Release the device is enumerating flag. Another
1931:                                         * device can start enumerating. */
1932:                                        busObj->deviceIsEnumerating = false;
1933:                                    }
1934:                                    else
1935:                                    {
1936:                                        /* Create a setup command to get the device descriptor */
1937:                                        _USB_HOST_FillSetupPacket(  &(deviceObj->setupPacket),
9D00104C  260300D6   ADDIU V1, S0, 214
1938:                                                ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
1939:                                                USB_REQUEST_GET_DESCRIPTOR, ( USB_DESCRIPTOR_DEVICE << 8 ), 0 , 8 ) ;
1940:                
1941:                                        /* Fill control IRP. Note the size of the control transfer data
1942:                                         * stage. We ask for the first 8 bytes of the device descriptor. */
1943:                
1944:                                        deviceObj->controlTransferObj.inUse = true;
9D00103C  24030001   ADDIU V1, ZERO, 1
9D001040  A2030004   SB V1, 4(S0)
1945:                                        deviceObj->controlTransferObj.controlIRP.data = (void *) &( deviceObj->deviceDescriptor );
9D001044  2603007C   ADDIU V1, S0, 124
9D001048  AE030010   SW V1, 16(S0)
1946:                                        deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket ) ;
9D001050  AE03000C   SW V1, 12(S0)
1947:                                        deviceObj->controlTransferObj.controlIRP.size = 8 ;
9D001054  24030008   ADDIU V1, ZERO, 8
9D001058  AE030014   SW V1, 20(S0)
1948:                                        deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D00105C  AE000024   SW ZERO, 36(S0)
1949:                
1950:                                        /* Change device state to next state */
1951:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_GET_DEVICE_DESCRIPTOR_SHORT;
9D001060  24030004   ADDIU V1, ZERO, 4
9D001064  AE0300F0   SW V1, 240(S0)
1952:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Requesting Device Descriptor.", busIndex);
1953:                
1954:                                        /* Submit the IRP */
1955:                                        if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit(deviceObj->controlPipeHandle, 
9D001068  8E03006C   LW V1, 108(S0)
9D00106C  8C63000C   LW V1, 12(V1)
9D001070  00402021   ADDU A0, V0, ZERO
9D001074  0060F809   JALR V1
9D001078  2605000C   ADDIU A1, S0, 12
9D00107C  10400203   BEQ V0, ZERO, 0x9D00188C
9D001080  8FBF0034   LW RA, 52(SP)
1956:                                                    &(deviceObj->controlTransferObj.controlIRP)))
1957:                                        {
1958:                                            /* We need to be able to send the IRP. We move the
1959:                                             * device to an error state. Close the pipe and send
1960:                                             * an event to the application. */
1961:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device Descriptor IRP failed. Device not supported.", busIndex);
1962:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D001084  2402FFFF   ADDIU V0, ZERO, -1
9D001088  AE0200F0   SW V0, 240(S0)
1963:                                            deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D00108C  8E02006C   LW V0, 108(S0)
9D001090  8C420020   LW V0, 32(V0)
9D001094  0040F809   JALR V0
9D001098  8E040058   LW A0, 88(S0)
1964:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D00109C  3C028001   LUI V0, -32767
9D0010A0  8C423DC8   LW V0, 15816(V0)
9D0010A4  10400005   BEQ V0, ZERO, 0x9D0010BC
9D0010A8  24040001   ADDIU A0, ZERO, 1
1965:                                            {
1966:                                                /* Send an event to the application */
1967:                                                gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D0010AC  00002821   ADDU A1, ZERO, ZERO
9D0010B0  3C038001   LUI V1, -32767
9D0010B4  0040F809   JALR V0
9D0010B8  8C663DCC   LW A2, 15820(V1)
1968:                                            }
1969:                
1970:                                            /* Release the device is enumerating flag. Another
1971:                                             * device can start enumerating. */
1972:                                            busObj->deviceIsEnumerating = false;
9D0010BC  0B400622   J 0x9D001888
9D0010C0  A2200015   SB ZERO, 21(S1)
1973:                                        }
1974:                                    }
1975:                                }
1976:                                break;
1977:                
1978:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_GET_DEVICE_DESCRIPTOR_SHORT:
1979:                
1980:                                /* Check if the Device Descriptor was obtained */
1981:                                if ( deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED )
9D0010C4  8E020018   LW V0, 24(S0)
9D0010C8  14400005   BNE V0, ZERO, 0x9D0010E0
9D0010CC  00000000   NOP
1982:                                {
1983:                                    /* The IRP completed. deviceObj->deviceDescriptor has the device
1984:                                     * descriptor. We can move to addressing state. */
1985:                
1986:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_SET_ADDRESS;
9D0010D0  24020005   ADDIU V0, ZERO, 5
9D0010D4  AE0200F0   SW V0, 240(S0)
9D0010D8  0B400622   J 0x9D001888
9D0010DC  A20000F4   SB ZERO, 244(S0)
1987:                
1988:                                    /* Reset the enumeration failure count */
1989:                                    deviceObj->enumerationFailCount = 0;
1990:                
1991:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device Descriptor obtained. Setting device address.", busIndex);
1992:                
1993:                                }
1994:                                else if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0010E0  044101EA   BGEZ V0, 0x9D00188C
9D0010E4  8FBF0034   LW RA, 52(SP)
1995:                                {
1996:                                    /* The IRP failed. We will either reset the device or place
1997:                                     * it in an error state. In either case the control pipe
1998:                                     * should be closed. */
1999:                
2000:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0010E8  8E02006C   LW V0, 108(S0)
9D0010EC  8C420020   LW V0, 32(V0)
9D0010F0  0040F809   JALR V0
9D0010F4  8E040058   LW A0, 88(S0)
2001:                
2002:                                    /* Release the device is enumerating flag. This will give
2003:                                     * another device the chance to start enumerating. The
2004:                                     * enumeration of this device will be re-attempted after
2005:                                     * the possible enumeration of the other device. */
2006:                                    busObj->deviceIsEnumerating = false;
9D0010F8  A2200015   SB ZERO, 21(S1)
2007:                
2008:                                    /* Check if we should retry the enumeration sequence */
2009:                                    if (deviceObj->enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT)
9D0010FC  920200F4   LBU V0, 244(S0)
9D001100  2C430003   SLTIU V1, V0, 3
9D001104  50600005   BEQL V1, ZERO, 0x9D00111C
9D001108  2402FFFF   ADDIU V0, ZERO, -1
2010:                                    {
2011:                                        /* Yes we should retry. Update the retry count */
2012:                                        deviceObj->enumerationFailCount ++ ;
9D00110C  24420001   ADDIU V0, V0, 1
9D001110  A20200F4   SB V0, 244(S0)
9D001114  0B400622   J 0x9D001888
9D001118  AE0000F0   SW ZERO, 240(S0)
2013:                
2014:                                        /* Set device state for reset */
2015:                                        deviceObj->deviceState =  USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
2016:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device Descriptor Request Failed. Trying again.", busIndex);
2017:                                    }
2018:                                    else
2019:                                    {
2020:                                        /* We tried three times but were not able to get a proper
2021:                                         * device response. Place the device in an error state. */
2022:                
2023:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D00111C  AE0200F0   SW V0, 240(S0)
2024:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device Request Failed 3 times. Device not supported.", busIndex);
2025:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D001120  3C028001   LUI V0, -32767
9D001124  8C423DC8   LW V0, 15816(V0)
9D001128  104001D7   BEQ V0, ZERO, 0x9D001888
9D00112C  24040001   ADDIU A0, ZERO, 1
2026:                                        {
2027:                                            /* Send an event to the application */
2028:                                            gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D001130  00002821   ADDU A1, ZERO, ZERO
9D001134  3C038001   LUI V1, -32767
9D001138  0040F809   JALR V0
9D00113C  8C663DCC   LW A2, 15820(V1)
2029:                                        }
2030:                                    }
2031:                                }
2032:                
2033:                                break;
2034:                
2035:                            case USB_HOST_DEVICE_STATE_SET_ADDRESS:
2036:                
2037:                                deviceObj->deviceAddress = _USB_HOST_GetNewAddress( busObj );
9D001148  0F405AC9   JAL _USB_HOST_GetNewAddress
9D00114C  02202021   ADDU A0, S1, ZERO
9D001150  A2020060   SB V0, 96(S0)
2038:                
2039:                                /* Create the setup request */
2040:                                _USB_HOST_FillSetupPacket(  &(deviceObj->setupPacket),
9D001180  260200D6   ADDIU V0, S0, 214
2041:                                        ( USB_SETUP_DIRN_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
2042:                                        USB_REQUEST_SET_ADDRESS , deviceObj->deviceAddress , 0 , 0 ) ;
2043:                
2044:                                /* Create the IRP packet */
2045:                                deviceObj->controlTransferObj.controlIRP.data = (void *) ( deviceObj->buffer );
9D001178  26020094   ADDIU V0, S0, 148
9D00117C  AE020010   SW V0, 16(S0)
2046:                                deviceObj->controlTransferObj.controlIRP.setup = &( deviceObj->setupPacket ) ;
9D001184  AE02000C   SW V0, 12(S0)
2047:                                deviceObj->controlTransferObj.controlIRP.size = 0 ;
9D001188  AE000014   SW ZERO, 20(S0)
2048:                                deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D00118C  AE000024   SW ZERO, 36(S0)
2049:                
2050:                                /* Set the next host layer state */
2051:                                deviceObj->deviceState = USB_HOST_DEVICE_STATE_WATING_FOR_SET_ADDRESS_COMPLETE;
9D001190  24020006   ADDIU V0, ZERO, 6
9D001194  AE0200F0   SW V0, 240(S0)
2052:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Setting Device Address to %d.", busIndex, deviceObj->deviceAddress);
2053:                
2054:                                /* Submit the IRP */
2055:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, & (deviceObj->controlTransferObj.controlIRP)))
9D001198  8E02006C   LW V0, 108(S0)
9D00119C  8C42000C   LW V0, 12(V0)
9D0011A0  8E040058   LW A0, 88(S0)
9D0011A4  0040F809   JALR V0
9D0011A8  2605000C   ADDIU A1, S0, 12
9D0011AC  104001B7   BEQ V0, ZERO, 0x9D00188C
9D0011B0  8FBF0034   LW RA, 52(SP)
2056:                                {
2057:                                    /* We need to be able to send the IRP. We move the device to
2058:                                     * an error state. Close the pipe and send an event to the
2059:                                     * application. The assigned address will be released when
2060:                                     * the device in un-plugged. */
2061:                
2062:                                    SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Set Addres IRP failed. Device not supported.", busIndex);
2063:                
2064:                                    /* Move the device to error state */
2065:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0011B4  2402FFFF   ADDIU V0, ZERO, -1
9D0011B8  AE0200F0   SW V0, 240(S0)
2066:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0011BC  8E02006C   LW V0, 108(S0)
9D0011C0  8C420020   LW V0, 32(V0)
9D0011C4  0040F809   JALR V0
9D0011C8  8E040058   LW A0, 88(S0)
2067:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D0011CC  3C028001   LUI V0, -32767
9D0011D0  8C423DC8   LW V0, 15816(V0)
9D0011D4  10400005   BEQ V0, ZERO, 0x9D0011EC
9D0011D8  24040001   ADDIU A0, ZERO, 1
2068:                                    {
2069:                                        /* Send an event to the application */
2070:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D0011DC  00002821   ADDU A1, ZERO, ZERO
9D0011E0  3C038001   LUI V1, -32767
9D0011E4  0040F809   JALR V0
9D0011E8  8C663DCC   LW A2, 15820(V1)
2071:                                    }
2072:                
2073:                                    /* Release the device is enumerating flag. Another device
2074:                                     * can start enumerating. */
2075:                                    busObj->deviceIsEnumerating = false;
9D0011EC  0B400622   J 0x9D001888
9D0011F0  A2200015   SB ZERO, 21(S1)
2076:                                }
2077:                
2078:                                break;
2079:                
2080:                            case USB_HOST_DEVICE_STATE_WATING_FOR_SET_ADDRESS_COMPLETE:
2081:                
2082:                                /* In this state the host is waiting for the set address request
2083:                                 * to complete */
2084:                                if ( deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED )
9D0011F4  8E020018   LW V0, 24(S0)
9D0011F8  1440002B   BNE V0, ZERO, 0x9D0012A8
9D0011FC  00000000   NOP
2085:                                {
2086:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Set Address complete", busIndex);
2087:                
2088:                                    /* This means the Set Address request completed
2089:                                     * successfully. Now we can open an addressed control
2090:                                     * transfer pipe. Close the current control pipe. This one
2091:                                     * is to device address 0 */
2092:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle); 
9D001200  8E02006C   LW V0, 108(S0)
9D001204  8C420020   LW V0, 32(V0)
9D001208  0040F809   JALR V0
9D00120C  8E040058   LW A0, 88(S0)
2093:                
2094:                                    /* Reset the enumeration failure count */
2095:                                    deviceObj->enumerationFailCount = 0x00;
9D001210  A20000F4   SB ZERO, 244(S0)
2096:                
2097:                                    /* Open the new addressed pipe */
2098:                                    deviceObj->controlPipeHandle = deviceObj->hcdInterface->hostPipeSetup( deviceObj->hcdHandle,
9D001214  8E02006C   LW V0, 108(S0)
9D001218  8E040064   LW A0, 100(S0)
9D00121C  92050060   LBU A1, 96(S0)
9D001220  92070074   LBU A3, 116(S0)
9D001224  92030075   LBU V1, 117(S0)
9D001228  AFA30010   SW V1, 16(SP)
9D00122C  AFA00014   SW ZERO, 20(SP)
9D001230  AFA00018   SW ZERO, 24(SP)
9D001234  92030083   LBU V1, 131(S0)
9D001238  AFA3001C   SW V1, 28(SP)
9D00123C  8E030078   LW V1, 120(S0)
9D001240  AFA30020   SW V1, 32(SP)
9D001244  8C42001C   LW V0, 28(V0)
9D001248  0040F809   JALR V0
9D00124C  00003021   ADDU A2, ZERO, ZERO
2099:                                            deviceObj->deviceAddress, 0 /* Endpoint */, deviceObj->hubAddress, deviceObj->devicePort,
2100:                                            USB_TRANSFER_TYPE_CONTROL/* Pipe type */, 0, /* bInterval */
2101:                                            deviceObj->deviceDescriptor.bMaxPacketSize0, deviceObj->speed );
2102:                
2103:                                    if( DRV_USB_HOST_PIPE_HANDLE_INVALID == deviceObj->controlPipeHandle )
9D001250  2403FFFF   ADDIU V1, ZERO, -1
9D001254  14430011   BNE V0, V1, 0x9D00129C
9D001258  AE020058   SW V0, 88(S0)
2104:                                    {
2105:                                        /* The control pipe could not be opened. We cannot
2106:                                         * do anything. We cannot support the device.
2107:                                         * Release the device address */
2108:                
2109:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d. Could not open addressed control pipe. Device not supported", busIndex);
2110:                                        _USB_HOST_FreeAddress ( deviceObj->deviceIdentifier );
9D00125C  0F405674   JAL _USB_HOST_FreeAddress
9D001260  8E04004C   LW A0, 76(S0)
2111:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D001264  2402FFFF   ADDIU V0, ZERO, -1
9D001268  AE0200F0   SW V0, 240(S0)
2112:                
2113:                                        /* Send an event to the application */
2114:                                        if(gUSBHostObj.hostEventHandler == NULL)
9D00126C  3C028001   LUI V0, -32767
9D001270  8C423DC8   LW V0, 15816(V0)
9D001274  54400184   BNEL V0, ZERO, 0x9D001888
9D001278  A2200015   SB ZERO, 21(S1)
2115:                                        {
2116:                                            gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D00127C  24040001   ADDIU A0, ZERO, 1
9D001280  3C028001   LUI V0, -32767
9D001284  8C463DCC   LW A2, 15820(V0)
9D001288  00001021   ADDU V0, ZERO, ZERO
9D00128C  0040F809   JALR V0
9D001290  00002821   ADDU A1, ZERO, ZERO
9D001294  0B400622   J 0x9D001888
9D001298  A2200015   SB ZERO, 21(S1)
2117:                                        }
2118:                
2119:                                        /* Release the device is enumerating flag. Another
2120:                                         * device can start enumerating. */
2121:                                        busObj->deviceIsEnumerating = false;
2122:                                    }
2123:                                    else
2124:                                    {
2125:                                        /* The pipe was opened and we can continue with the
2126:                                         * rest of the enumeration */
2127:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_POST_SET_ADDRESS_DELAY;
9D00129C  24020007   ADDIU V0, ZERO, 7
9D0012A0  0B400622   J 0x9D001888
9D0012A4  AE0200F0   SW V0, 240(S0)
2128:                                    }
2129:                                }
2130:                                else
2131:                                {
2132:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0012A8  04410178   BGEZ V0, 0x9D00188C
9D0012AC  8FBF0034   LW RA, 52(SP)
2133:                                    {
2134:                                        /* The Set Address Request failed. We should either
2135:                                         * retry or place the device in error state. In any case
2136:                                         * the the control pipe should be closed. */
2137:                
2138:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0012B0  8E02006C   LW V0, 108(S0)
9D0012B4  8C420020   LW V0, 32(V0)
9D0012B8  0040F809   JALR V0
9D0012BC  8E040058   LW A0, 88(S0)
2139:                
2140:                                        /* Release the device is enumerating flag. This will give
2141:                                         * another device the chance to start enumerating. The
2142:                                         * enumeration of this device will be re-attempted after
2143:                                         * the possible enumeration of the other device. */
2144:                                        busObj->deviceIsEnumerating = false;
9D0012C0  A2200015   SB ZERO, 21(S1)
2145:                
2146:                                        /* Should we retry? */
2147:                                        if (deviceObj-> enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT )
9D0012C4  920200F4   LBU V0, 244(S0)
9D0012C8  2C430003   SLTIU V1, V0, 3
9D0012CC  50600007   BEQL V1, ZERO, 0x9D0012EC
9D0012D0  2402FFFF   ADDIU V0, ZERO, -1
2148:                                        {
2149:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d. Set Address failed. Trying again.", busIndex);
2150:                
2151:                                            /* Yes we should. Increment the failure count */
2152:                                            deviceObj->enumerationFailCount ++ ;
9D0012D4  24420001   ADDIU V0, V0, 1
9D0012D8  A20200F4   SB V0, 244(S0)
2153:                
2154:                                            /* The device address must be released because this
2155:                                             * will be attempted again */
2156:                                            _USB_HOST_FreeAddress(deviceObj->deviceIdentifier);
9D0012DC  0F405674   JAL _USB_HOST_FreeAddress
9D0012E0  8E04004C   LW A0, 76(S0)
9D0012E4  0B400622   J 0x9D001888
9D0012E8  AE0000F0   SW ZERO, 240(S0)
2157:                
2158:                                            /* Set device state for enumeration */
2159:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION; 
2160:                                        }
2161:                                        else
2162:                                        {
2163:                                            /* We have tried enumeration multiple times and
2164:                                             * failed. */
2165:                
2166:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d. Set Address failed 3 times. Device not supported.", busIndex);
2167:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0012EC  AE0200F0   SW V0, 240(S0)
2168:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D0012F0  3C028001   LUI V0, -32767
9D0012F4  8C423DC8   LW V0, 15816(V0)
9D0012F8  10400163   BEQ V0, ZERO, 0x9D001888
9D0012FC  24040001   ADDIU A0, ZERO, 1
2169:                                            {
2170:                                                /* Send the event to the application */
2171:                                                gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D001300  00002821   ADDU A1, ZERO, ZERO
9D001304  3C038001   LUI V1, -32767
9D001308  0040F809   JALR V0
9D00130C  8C663DCC   LW A2, 15820(V1)
2172:                                            }
2173:                                        }
2174:                                    }
2175:                                }
2176:                
2177:                                break;
2178:                
2179:                            case USB_HOST_DEVICE_STATE_POST_SET_ADDRESS_DELAY:
2180:                
2181:                                /* After the address has been set, we provide a delay of 50
2182:                                 * milliseconds */
2183:                                busObj->timerExpired = false;
9D001318  A220004B   SB ZERO, 75(S1)
2184:                                busObj->busOperationsTimerHandle = SYS_TMR_CallbackSingle( 50, (uintptr_t ) busObj, _USB_HOST_TimerCallback);;
9D00131C  24040032   ADDIU A0, ZERO, 50
9D001320  02202821   ADDU A1, S1, ZERO
9D001324  3C069D01   LUI A2, -25343
9D001328  0F405C4C   JAL SYS_TMR_CallbackSingle
9D00132C  24C6732C   ADDIU A2, A2, 29484
2185:                
2186:                                if(SYS_TMR_HANDLE_INVALID != busObj->busOperationsTimerHandle)
9D001330  2403FFFF   ADDIU V1, ZERO, -1
9D001334  10430154   BEQ V0, V1, 0x9D001888
9D001338  AE220044   SW V0, 68(S1)
2187:                                {
2188:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_POST_SET_ADDRESS_DELAY;
9D00133C  24020008   ADDIU V0, ZERO, 8
9D001340  0B400622   J 0x9D001888
9D001344  AE0200F0   SW V0, 240(S0)
2189:                                }
2190:                                break;
2191:                
2192:                            case USB_HOST_DEVICE_STATE_WAITING_POST_SET_ADDRESS_DELAY:
2193:                
2194:                                /* Here we check if the post device set address delay has
2195:                                 * completed */
2196:                                if(busObj->timerExpired)
9D001348  9222004B   LBU V0, 75(S1)
9D00134C  1040014F   BEQ V0, ZERO, 0x9D00188C
9D001350  8FBF0034   LW RA, 52(SP)
2197:                                {
2198:                                    busObj->busOperationsTimerHandle = SYS_TMR_HANDLE_INVALID ;
9D001354  2402FFFF   ADDIU V0, ZERO, -1
9D001358  AE220044   SW V0, 68(S1)
2199:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Post Set Address Delay completed.", busIndex);
2200:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Requesting Full Device Descriptor.", busIndex, deviceObj->deviceAddress);
2201:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_GET_DEVICE_DESCRIPTOR_FULL;
9D00135C  24020009   ADDIU V0, ZERO, 9
9D001360  0B400622   J 0x9D001888
9D001364  AE0200F0   SW V0, 240(S0)
2202:                                }
2203:                                break;
2204:                
2205:                            case USB_HOST_DEVICE_STATE_GET_DEVICE_DESCRIPTOR_FULL:
2206:                
2207:                                /* In the state the host layer requests for the full device
2208:                                 * descriptor. Create the setup packet. */
2209:                                _USB_HOST_FillSetupPacket( &(deviceObj->setupPacket), ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
9D0013A0  260300D6   ADDIU V1, S0, 214
2210:                                        USB_REQUEST_GET_DESCRIPTOR, ( USB_DESCRIPTOR_DEVICE << 8 ), 0 , deviceObj->deviceDescriptor.bLength ) ;
9D001368  9202007C   LBU V0, 124(S0)
2211:                
2212:                                /* Fill IRP */
2213:                                deviceObj->controlTransferObj.controlIRP.data = (void *) &( deviceObj->deviceDescriptor );
9D001398  2603007C   ADDIU V1, S0, 124
9D00139C  AE030010   SW V1, 16(S0)
2214:                                deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D0013A4  AE03000C   SW V1, 12(S0)
2215:                                deviceObj->controlTransferObj.controlIRP.size = deviceObj->deviceDescriptor.bLength;
9D0013A8  AE020014   SW V0, 20(S0)
2216:                                deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D0013AC  AE000024   SW ZERO, 36(S0)
2217:                
2218:                                deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_GET_DEVICE_DESCRIPTOR_FULL;
9D0013B0  2402000A   ADDIU V0, ZERO, 10
9D0013B4  AE0200F0   SW V0, 240(S0)
2219:                
2220:                                /* Submit the IRP */
2221:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(deviceObj->controlTransferObj.controlIRP)))
9D0013B8  8E02006C   LW V0, 108(S0)
9D0013BC  8C42000C   LW V0, 12(V0)
9D0013C0  8E040058   LW A0, 88(S0)
9D0013C4  0040F809   JALR V0
9D0013C8  2605000C   ADDIU A1, S0, 12
9D0013CC  1040012F   BEQ V0, ZERO, 0x9D00188C
9D0013D0  8FBF0034   LW RA, 52(SP)
2222:                                {
2223:                                    /* We need to be able to send the IRP. We move the device to
2224:                                     * an error state. Close the pipe and send an event to the
2225:                                     * application. */
2226:                
2227:                                    SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Device Descriptor IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);
2228:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0013D4  2402FFFF   ADDIU V0, ZERO, -1
9D0013D8  AE0200F0   SW V0, 240(S0)
2229:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0013DC  8E02006C   LW V0, 108(S0)
9D0013E0  8C420020   LW V0, 32(V0)
9D0013E4  0040F809   JALR V0
9D0013E8  8E040058   LW A0, 88(S0)
2230:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D0013EC  3C028001   LUI V0, -32767
9D0013F0  8C423DC8   LW V0, 15816(V0)
9D0013F4  10400005   BEQ V0, ZERO, 0x9D00140C
9D0013F8  24040001   ADDIU A0, ZERO, 1
2231:                                    {
2232:                                        /* Send an event to the application */
2233:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D0013FC  00002821   ADDU A1, ZERO, ZERO
9D001400  3C038001   LUI V1, -32767
9D001404  0040F809   JALR V0
9D001408  8C663DCC   LW A2, 15820(V1)
2234:                                    }
2235:                
2236:                                    /* Release the device is enumerating flag. Another device
2237:                                     * can start enumerating. */
2238:                                    busObj->deviceIsEnumerating = false;
9D00140C  0B400622   J 0x9D001888
9D001410  A2200015   SB ZERO, 21(S1)
2239:                                }
2240:                                break;
2241:                
2242:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_GET_DEVICE_DESCRIPTOR_FULL:
2243:                
2244:                                /* Here we are waiting for Get Full Device Descriptor to
2245:                                 * complete */
2246:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED)
9D001414  8E020018   LW V0, 24(S0)
9D001418  14400008   BNE V0, ZERO, 0x9D00143C
9D00141C  00000000   NOP
2247:                                {
2248:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Full Device Descriptor obtained.", busIndex, deviceObj->deviceAddress);
2249:                
2250:                                    /* IRP was successful. Go to the next state */
2251:                                    deviceObj->deviceState =  USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_SHORT;
9D001420  2402000B   ADDIU V0, ZERO, 11
9D001424  AE0200F0   SW V0, 240(S0)
2252:                
2253:                                    /* Reset the enumeration failure count */
2254:                                    deviceObj->enumerationFailCount = 0x00;
9D001428  A20000F4   SB ZERO, 244(S0)
2255:                
2256:                                    /* Update the number of configurations */
2257:                                    deviceObj->nConfiguration = deviceObj->deviceDescriptor.bNumConfigurations;
9D00142C  9202008D   LBU V0, 141(S0)
9D001430  A20200D4   SB V0, 212(S0)
9D001434  0B400622   J 0x9D001888
9D001438  A20000F5   SB ZERO, 245(S0)
2258:                
2259:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d contains %d configurations.", busIndex, deviceObj->deviceAddress, deviceObj->nConfiguration);
2260:                
2261:                                    /* Reset the configuration check count to indicate that we are
2262:                                     * checking the first configuration */
2263:                                    deviceObj->configurationCheckCount = 0;
2264:                                }
2265:                                else
2266:                                {
2267:                                    /* The IRP did not complete successfully. */
2268:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D00143C  04410113   BGEZ V0, 0x9D00188C
9D001440  8FBF0034   LW RA, 52(SP)
2269:                                    {
2270:                                        /* Close the pipe */
2271:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D001444  8E02006C   LW V0, 108(S0)
9D001448  8C420020   LW V0, 32(V0)
9D00144C  0040F809   JALR V0
9D001450  8E040058   LW A0, 88(S0)
2272:                
2273:                                        /* Release the device is enumerating flag. This will give
2274:                                         * another device the chance to start enumerating. The
2275:                                         * enumeration of this device will be re-attempted after
2276:                                         * the possible enumeration of the other device. */
2277:                                        busObj->deviceIsEnumerating = false;
9D001454  A2200015   SB ZERO, 21(S1)
2278:                
2279:                                        /* Should we retry */
2280:                                        if (deviceObj->enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT )
9D001458  920200F4   LBU V0, 244(S0)
9D00145C  2C430003   SLTIU V1, V0, 3
9D001460  50600007   BEQL V1, ZERO, 0x9D001480
9D001464  2402FFFF   ADDIU V0, ZERO, -1
2281:                                        {
2282:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Device Descriptor Request Failed. Trying again", busIndex, deviceObj->deviceAddress);
2283:                
2284:                                            /* Yes we should. Increment the enumeration
2285:                                             * count and reset the device */
2286:                                            deviceObj->enumerationFailCount ++ ;
9D001468  24420001   ADDIU V0, V0, 1
9D00146C  A20200F4   SB V0, 244(S0)
2287:                
2288:                                            /* The device address must be release because the
2289:                                             * enumeration process will be repeated */
2290:                                            _USB_HOST_FreeAddress(deviceObj->deviceIdentifier);
9D001470  0F405674   JAL _USB_HOST_FreeAddress
9D001474  8E04004C   LW A0, 76(S0)
9D001478  0B400622   J 0x9D001888
9D00147C  AE0000F0   SW ZERO, 240(S0)
2291:                
2292:                                            /* Set device state for enumeration */
2293:                                            deviceObj->deviceState =  USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
2294:                                        }
2295:                                        else
2296:                                        {
2297:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D001480  AE0200F0   SW V0, 240(S0)
2298:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Device Request Failed 3 times. Device not supported.", busIndex, deviceObj->deviceAddress);
2299:                
2300:                                            /* We should send an event to the application and
2301:                                             * then wait for device attach */
2302:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D001484  3C028001   LUI V0, -32767
9D001488  8C423DC8   LW V0, 15816(V0)
9D00148C  104000FE   BEQ V0, ZERO, 0x9D001888
9D001490  24040001   ADDIU A0, ZERO, 1
2303:                                            {
2304:                                                gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D001494  00002821   ADDU A1, ZERO, ZERO
9D001498  3C038001   LUI V1, -32767
9D00149C  0040F809   JALR V0
9D0014A0  8C663DCC   LW A2, 15820(V1)
2305:                                            }
2306:                                        }
2307:                                    }
2308:                                }
2309:                                break;
2310:                
2311:                            case USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_SHORT:
2312:                
2313:                                /* In this state the host will get the configuration descriptor
2314:                                 * header. This is needed so that we know what is the
2315:                                 * configuration descriptor size  */
2316:                
2317:                                _USB_HOST_FillSetupPacket( &(deviceObj->setupPacket), ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ), USB_REQUEST_GET_DESCRIPTOR,
9D0014AC  920200F5   LBU V0, 245(S0)
9D0014B0  24420200   ADDIU V0, V0, 512
9D0014B4  3042FFFF   ANDI V0, V0, -1
9D0014F0  260200D6   ADDIU V0, S0, 214
2318:                                        ( USB_DESCRIPTOR_CONFIGURATION << 8 )+ deviceObj->configurationCheckCount , 0 , 9 ) ;
2319:                
2320:                                /* Fill IRP */
2321:                                deviceObj->controlTransferObj.controlIRP.data = ( void * )deviceObj->buffer;
9D0014E8  26020094   ADDIU V0, S0, 148
9D0014EC  AE020010   SW V0, 16(S0)
2322:                                deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D0014F4  AE02000C   SW V0, 12(S0)
2323:                                deviceObj->controlTransferObj.controlIRP.size = 9;
9D0014F8  24020009   ADDIU V0, ZERO, 9
9D0014FC  AE020014   SW V0, 20(S0)
2324:                                deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D001500  AE000024   SW ZERO, 36(S0)
2325:                
2326:                                deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_GET_CONFIGURATION_DESCRIPTOR_SHORT;
9D001504  2402000C   ADDIU V0, ZERO, 12
9D001508  AE0200F0   SW V0, 240(S0)
2327:                
2328:                                /* Submit the IRP */
2329:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D00150C  8E02006C   LW V0, 108(S0)
9D001510  8C42000C   LW V0, 12(V0)
9D001514  8E040058   LW A0, 88(S0)
9D001518  0040F809   JALR V0
9D00151C  2605000C   ADDIU A1, S0, 12
9D001520  104000DA   BEQ V0, ZERO, 0x9D00188C
9D001524  8FBF0034   LW RA, 52(SP)
2330:                                            &(deviceObj->controlTransferObj.controlIRP)))
2331:                                {
2332:                                    /* We need to be able to send the IRP. We move the device to
2333:                                     * an error state. Close the pipe and send an event to the
2334:                                     * application. */
2335:                                    SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Configuration Descriptor IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);
2336:                
2337:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D001528  2402FFFF   ADDIU V0, ZERO, -1
9D00152C  AE0200F0   SW V0, 240(S0)
2338:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D001530  8E02006C   LW V0, 108(S0)
9D001534  8C420020   LW V0, 32(V0)
9D001538  0040F809   JALR V0
9D00153C  8E040058   LW A0, 88(S0)
2339:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D001540  3C028001   LUI V0, -32767
9D001544  8C423DC8   LW V0, 15816(V0)
9D001548  10400005   BEQ V0, ZERO, 0x9D001560
9D00154C  24040001   ADDIU A0, ZERO, 1
2340:                                    {
2341:                                        /* Send an event to the application */
2342:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D001550  00002821   ADDU A1, ZERO, ZERO
9D001554  3C038001   LUI V1, -32767
9D001558  0040F809   JALR V0
9D00155C  8C663DCC   LW A2, 15820(V1)
2343:                                    }
2344:                
2345:                                    /* Release the device is enumerating flag. Another
2346:                                     * device can start enumerating. */
2347:                                    busObj->deviceIsEnumerating = false;
9D001560  0B400622   J 0x9D001888
9D001564  A2200015   SB ZERO, 21(S1)
2348:                                }
2349:                
2350:                                break;
2351:                
2352:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_GET_CONFIGURATION_DESCRIPTOR_SHORT:
2353:                                /* Here we are waiting for Get Short Configuration Descriptor to
2354:                                 * complete */
2355:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED)
9D001568  8E020018   LW V0, 24(S0)
9D00156C  14400005   BNE V0, ZERO, 0x9D001584
9D001570  00000000   NOP
2356:                                {
2357:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Short Configuration Descriptor Request passed.", busIndex, deviceObj->deviceAddress);
2358:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Getting Full Configuration Descriptor.", busIndex, deviceObj->deviceAddress);
2359:                
2360:                                    /* IRP was successful. Go to the next state */
2361:                                    deviceObj->deviceState =  USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_FULL;
9D001574  2402000D   ADDIU V0, ZERO, 13
9D001578  AE0200F0   SW V0, 240(S0)
9D00157C  0B400622   J 0x9D001888
9D001580  A20000F4   SB ZERO, 244(S0)
2362:                
2363:                                    /* Reset the enumeration failure count */
2364:                                    deviceObj->enumerationFailCount = 0x00;
2365:                                }
2366:                                else
2367:                                {
2368:                                    /* The IRP did not complete successfully. */
2369:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D001584  044100C1   BGEZ V0, 0x9D00188C
9D001588  8FBF0034   LW RA, 52(SP)
2370:                                    {
2371:                                        /* Close the pipe */
2372:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D00158C  8E02006C   LW V0, 108(S0)
9D001590  8C420020   LW V0, 32(V0)
9D001594  0040F809   JALR V0
9D001598  8E040058   LW A0, 88(S0)
2373:                
2374:                                        /* Release the device is enumerating flag. This will give
2375:                                         * another device the chance to start enumerating. The
2376:                                         * enumeration of this device will be re-attempted after
2377:                                         * the possible enumeration of the other device. */
2378:                                        busObj->deviceIsEnumerating = false;
9D00159C  A2200015   SB ZERO, 21(S1)
2379:                
2380:                                        /* Should we retry */
2381:                                        if (deviceObj->enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT )
9D0015A0  920200F4   LBU V0, 244(S0)
9D0015A4  2C430003   SLTIU V1, V0, 3
9D0015A8  50600008   BEQL V1, ZERO, 0x9D0015CC
9D0015AC  2402FFFF   ADDIU V0, ZERO, -1
2382:                                        {
2383:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Configuration Descriptor Request Failed. Trying again", busIndex, deviceObj->deviceAddress);
2384:                
2385:                                            /* Yes we should. Increment the enumeration count
2386:                                             * and reset the device */
2387:                                            deviceObj->enumerationFailCount ++ ;
9D0015B0  24420001   ADDIU V0, V0, 1
9D0015B4  A20200F4   SB V0, 244(S0)
2388:                
2389:                                            /* Set device state for enumeration */
2390:                                            deviceObj->deviceState =  USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
9D0015B8  AE0000F0   SW ZERO, 240(S0)
2391:                
2392:                                            /* Release the device address */
2393:                                            _USB_HOST_FreeAddress(deviceObj->deviceIdentifier);
9D0015BC  0F405674   JAL _USB_HOST_FreeAddress
9D0015C0  8E04004C   LW A0, 76(S0)
9D0015C4  0B400623   J 0x9D00188C
9D0015C8  8FBF0034   LW RA, 52(SP)
2394:                                        }
2395:                                        else
2396:                                        {
2397:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Configuration Request Failed 3 times. Device not supported.", busIndex, deviceObj->deviceAddress);
2398:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0015CC  AE0200F0   SW V0, 240(S0)
2399:                
2400:                                            /* We should send an event to the application and
2401:                                             * then wait for device attach */
2402:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D0015D0  3C028001   LUI V0, -32767
9D0015D4  8C423DC8   LW V0, 15816(V0)
9D0015D8  104000AB   BEQ V0, ZERO, 0x9D001888
9D0015DC  24040001   ADDIU A0, ZERO, 1
2403:                                            {
2404:                                                gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D0015E0  00002821   ADDU A1, ZERO, ZERO
9D0015E4  3C038001   LUI V1, -32767
9D0015E8  0040F809   JALR V0
9D0015EC  8C663DCC   LW A2, 15820(V1)
2405:                                            }
2406:                                        }
2407:                                    }
2408:                                }
2409:                                break;
2410:                
2411:                            case USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_FULL:
2412:                
2413:                                /* Here we will try to allocate memory for the full
2414:                                 * configuration descriptor and then get the full configuration
2415:                                 * descriptor. */  
2416:                
2417:                                configurationDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)(deviceObj->buffer);
2418:                                deviceObj->holdingConfigurationDescriptor = USB_HOST_MALLOC(configurationDescriptor->wTotalLength);
9D0015F8  92020096   LBU V0, 150(S0)
9D0015FC  92120097   LBU S2, 151(S0)
9D001600  00129200   SLL S2, S2, 8
9D001604  02429025   OR S2, S2, V0
9D001608  0F400B2F   JAL malloc
9D00160C  02402021   ADDU A0, S2, ZERO
2419:                
2420:                                if(deviceObj->holdingConfigurationDescriptor == NULL)
9D001610  14400011   BNE V0, ZERO, 0x9D001658
9D001614  AE020090   SW V0, 144(S0)
2421:                                {
2422:                                    /* The memory allocation failed. We need memory to continue.
2423:                                     * We have to stop here */
2424:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D001618  2402FFFF   ADDIU V0, ZERO, -1
9D00161C  AE0200F0   SW V0, 240(S0)
2425:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D001620  8E02006C   LW V0, 108(S0)
9D001624  8C420020   LW V0, 32(V0)
9D001628  0040F809   JALR V0
9D00162C  8E040058   LW A0, 88(S0)
2426:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D001630  3C028001   LUI V0, -32767
9D001634  8C423DC8   LW V0, 15816(V0)
9D001638  10400005   BEQ V0, ZERO, 0x9D001650
9D00163C  24040001   ADDIU A0, ZERO, 1
2427:                                    {
2428:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d. Insufficient memory for Configuration Descriptor", busIndex);
2429:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D001640  00002821   ADDU A1, ZERO, ZERO
9D001644  3C038001   LUI V1, -32767
9D001648  0040F809   JALR V0
9D00164C  8C663DCC   LW A2, 15820(V1)
9D001650  0B400622   J 0x9D001888
9D001654  A2200015   SB ZERO, 21(S1)
2430:                                    }
2431:                
2432:                                    /* Release the device is enumerating flag. Another
2433:                                     * device can start enumerating. */
2434:                                    busObj->deviceIsEnumerating = false;
2435:                                }
2436:                                else
2437:                                {
2438:                                    /* Place a request for the full configuration descriptor */
2439:                                    _USB_HOST_FillSetupPacket( &(deviceObj->setupPacket), ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
9D001658  920300F5   LBU V1, 245(S0)
9D00165C  24630200   ADDIU V1, V1, 512
9D001660  3063FFFF   ANDI V1, V1, -1
9D001698  260200D6   ADDIU V0, S0, 214
2440:                                            USB_REQUEST_GET_DESCRIPTOR, ( USB_DESCRIPTOR_CONFIGURATION << 8 ) + deviceObj->configurationCheckCount ,
2441:                                            0 ,configurationDescriptor->wTotalLength) ;
2442:                
2443:                                    /* Create the IRP. Note that the configuration descriptor is
2444:                                     * read into the holding configuration descriptor. The
2445:                                     * holding configuration descriptor memory area is used as a
2446:                                     * temporary holding area only. The memory is freed once the
2447:                                     * configuration descriptor has been checked for errors */
2448:                
2449:                                    deviceObj->controlTransferObj.controlIRP.data = deviceObj->holdingConfigurationDescriptor;
9D001694  AE020010   SW V0, 16(S0)
2450:                                    deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D00169C  AE02000C   SW V0, 12(S0)
2451:                                    deviceObj->controlTransferObj.controlIRP.size = configurationDescriptor->wTotalLength;
9D0016A0  AE120014   SW S2, 20(S0)
2452:                                    deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D0016A4  AE000024   SW ZERO, 36(S0)
2453:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_GET_CONFIGURATION_DESCRIPTOR_FULL;
9D0016A8  2402000E   ADDIU V0, ZERO, 14
9D0016AC  AE0200F0   SW V0, 240(S0)
2454:                
2455:                                    /* Submit the IRP */
2456:                                    if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D0016B0  8E02006C   LW V0, 108(S0)
9D0016B4  8C42000C   LW V0, 12(V0)
9D0016B8  8E040058   LW A0, 88(S0)
9D0016BC  0040F809   JALR V0
9D0016C0  2605000C   ADDIU A1, S0, 12
9D0016C4  10400071   BEQ V0, ZERO, 0x9D00188C
9D0016C8  8FBF0034   LW RA, 52(SP)
2457:                                                &(deviceObj->controlTransferObj.controlIRP)))
2458:                                    {
2459:                                        /* We need to be able to send the IRP. We move the
2460:                                         * device to an error state. Close the pipe and send an
2461:                                         * event to the application. */
2462:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Configuration Request IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);
2463:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0016CC  2402FFFF   ADDIU V0, ZERO, -1
9D0016D0  AE0200F0   SW V0, 240(S0)
2464:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0016D4  8E02006C   LW V0, 108(S0)
9D0016D8  8C420020   LW V0, 32(V0)
9D0016DC  0040F809   JALR V0
9D0016E0  8E040058   LW A0, 88(S0)
2465:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D0016E4  0F402C7E   JAL free
9D0016E8  8E040090   LW A0, 144(S0)
2466:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D0016EC  AE000090   SW ZERO, 144(S0)
2467:                
2468:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D0016F0  3C028001   LUI V0, -32767
9D0016F4  8C423DC8   LW V0, 15816(V0)
9D0016F8  10400005   BEQ V0, ZERO, 0x9D001710
9D0016FC  24040001   ADDIU A0, ZERO, 1
2469:                                        {
2470:                                            /* Send an event to the application */
2471:                                            gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D001700  00002821   ADDU A1, ZERO, ZERO
9D001704  3C038001   LUI V1, -32767
9D001708  0040F809   JALR V0
9D00170C  8C663DCC   LW A2, 15820(V1)
2472:                                        }
2473:                
2474:                                        /* Release the device is enumerating flag. Another
2475:                                         * device can start enumerating. */
2476:                                        busObj->deviceIsEnumerating = false;
9D001710  0B400622   J 0x9D001888
9D001714  A2200015   SB ZERO, 21(S1)
2477:                                    }
2478:                                }
2479:                
2480:                                break;
2481:                
2482:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_GET_CONFIGURATION_DESCRIPTOR_FULL:
2483:                
2484:                                /* In this state we are waiting for the full configuration
2485:                                 * descriptor */
2486:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED)
9D001718  8E020018   LW V0, 24(S0)
9D00171C  1440002F   BNE V0, ZERO, 0x9D0017DC
9D001720  00000000   NOP
2487:                                {
2488:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Get Full Configuration Descriptor Request passed.", busIndex, deviceObj->deviceAddress);
2489:                
2490:                                    /* Reset the failure counter */
2491:                                    deviceObj->enumerationFailCount = 0;
9D001724  A20000F4   SB ZERO, 244(S0)
2492:                
2493:                                    /* The configuration descriptor will be in
2494:                                     * holdingConfigurationDescriptor member of device object.
2495:                                     * Check it for errors */
2496:                
2497:                                    if(_USB_HOST_DeviceConfigurationDescriptorErrorCheck(deviceObj->holdingConfigurationDescriptor) &&
9D001728  8E120090   LW S2, 144(S0)
9D00172C  0F403F21   JAL _USB_HOST_DeviceConfigurationDescriptorErrorCheck
9D001730  02402021   ADDU A0, S2, ZERO
9D001734  10400017   BEQ V0, ZERO, 0x9D001794
9D001738  2402FFFF   ADDIU V0, ZERO, -1
9D00173C  92420004   LBU V0, 4(S2)
9D001740  2C420006   SLTIU V0, V0, 6
9D001744  10400013   BEQ V0, ZERO, 0x9D001794
9D001748  2402FFFF   ADDIU V0, ZERO, -1
2498:                                            (deviceObj->holdingConfigurationDescriptor->bNumInterfaces <= USB_HOST_DEVICE_INTERFACES_NUMBER))
2499:                                    {
2500:                                        /* This means there are no errors in the configuration
2501:                                         * descriptor. Have we checked all configuration
2502:                                         * descriptors. Update the configurationCheckCount
2503:                                         * variable */
2504:                
2505:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d No errors detected in Configuration Descriptor %d.", 
2506:                                                busIndex, deviceObj->deviceAddress, deviceObj->configurationCheckCount);
2507:                
2508:                                        deviceObj->configurationCheckCount ++;
9D00174C  920200F5   LBU V0, 245(S0)
9D001750  24420001   ADDIU V0, V0, 1
9D001754  304200FF   ANDI V0, V0, 255
9D001758  A20200F5   SB V0, 245(S0)
2509:                
2510:                                        if(deviceObj->configurationCheckCount >= deviceObj->nConfiguration)
9D00175C  920300D4   LBU V1, 212(S0)
9D001760  0043102B   SLTU V0, V0, V1
9D001764  14400006   BNE V0, ZERO, 0x9D001780
9D001768  2402000B   ADDIU V0, ZERO, 11
2511:                                        {
2512:                                            /* This means we have checked all the configurations
2513:                                             * and there are no errors. We are okay to move the
2514:                                             * device to the ready state */
2515:                
2516:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_READY;
9D00176C  2402000F   ADDIU V0, ZERO, 15
9D001770  AE0200F0   SW V0, 240(S0)
2517:                
2518:                                            /* Release the control transfer object */
2519:                                            deviceObj->controlTransferObj.inUse = false;
9D001774  A2000004   SB ZERO, 4(S0)
9D001778  0B4005E1   J 0x9D001784
9D00177C  A2200015   SB ZERO, 21(S1)
2520:                
2521:                                            /* Release the device is enumerating flag. Another
2522:                                             * device can start enumerating. */
2523:                                            busObj->deviceIsEnumerating = false;
2524:                                        }
2525:                                        else
2526:                                        {
2527:                                            /* Check the next configuration specified by
2528:                                             * configurationCheckCount */
2529:                
2530:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_SHORT;
9D001780  AE0200F0   SW V0, 240(S0)
2531:                                        }
2532:                
2533:                                        /* Free up the allocated memory */
2534:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D001784  0F402C7E   JAL free
9D001788  8E040090   LW A0, 144(S0)
2535:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D00178C  0B400622   J 0x9D001888
9D001790  AE000090   SW ZERO, 144(S0)
2536:                                    }
2537:                                    else
2538:                                    {
2539:                                        /* The configuration check failed. Either there was an
2540:                                         * error in the configuration or the configuration has
2541:                                         * too many interfaces. We cannot use this
2542:                                         * device */
2543:                
2544:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D001794  AE0200F0   SW V0, 240(S0)
2545:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D001798  8E02006C   LW V0, 108(S0)
9D00179C  8C420020   LW V0, 32(V0)
9D0017A0  0040F809   JALR V0
9D0017A4  8E040058   LW A0, 88(S0)
2546:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D0017A8  0F402C7E   JAL free
9D0017AC  8E040090   LW A0, 144(S0)
2547:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D0017B0  AE000090   SW ZERO, 144(S0)
2548:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D0017B4  3C028001   LUI V0, -32767
9D0017B8  8C423DC8   LW V0, 15816(V0)
9D0017BC  10400005   BEQ V0, ZERO, 0x9D0017D4
9D0017C0  24040001   ADDIU A0, ZERO, 1
2549:                                        {
2550:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Errors detected in Configuration Descriptor %d. Device not supported", busIndex, deviceObj->deviceAddress, deviceObj->configurationCheckCount);
2551:                
2552:                                            gUSBHostObj.hostEventHandler(USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context);
9D0017C4  00002821   ADDU A1, ZERO, ZERO
9D0017C8  3C038001   LUI V1, -32767
9D0017CC  0040F809   JALR V0
9D0017D0  8C663DCC   LW A2, 15820(V1)
2553:                                        }
2554:                
2555:                                        /* Release the device is enumerating flag. Another
2556:                                         * device can start enumerating. */
2557:                                        busObj->deviceIsEnumerating = false;
9D0017D4  0B400622   J 0x9D001888
9D0017D8  A2200015   SB ZERO, 21(S1)
2558:                                    }
2559:                                }
2560:                                else
2561:                                {
2562:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0017DC  0441002B   BGEZ V0, 0x9D00188C
9D0017E0  8FBF0034   LW RA, 52(SP)
2563:                                    {
2564:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0017E4  8E02006C   LW V0, 108(S0)
9D0017E8  8C420020   LW V0, 32(V0)
9D0017EC  0040F809   JALR V0
9D0017F0  8E040058   LW A0, 88(S0)
2565:                
2566:                                        /* Release the device is enumerating flag. This will give
2567:                                         * another device the chance to start enumerating. The
2568:                                         * enumeration of this device will be re-attempted after
2569:                                         * the possible enumeration of the other device. */
2570:                                        busObj->deviceIsEnumerating = false;
9D0017F4  A2200015   SB ZERO, 21(S1)
2571:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D0017F8  0F402C7E   JAL free
9D0017FC  8E040090   LW A0, 144(S0)
2572:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D001800  AE000090   SW ZERO, 144(S0)
2573:                
2574:                                        if (deviceObj->enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT )
9D001804  920200F4   LBU V0, 244(S0)
9D001808  2C430003   SLTIU V1, V0, 3
9D00180C  50600008   BEQL V1, ZERO, 0x9D001830
9D001810  2402FFFF   ADDIU V0, ZERO, -1
2575:                                        {
2576:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Get Configuration Descriptor Request failed. Trying again", busIndex, deviceObj->deviceAddress);
2577:                
2578:                                            /* Increment the failure count */
2579:                                            deviceObj->enumerationFailCount ++ ;
9D001814  24420001   ADDIU V0, V0, 1
9D001818  A20200F4   SB V0, 244(S0)
2580:                
2581:                                            /* Set device state for enumeration */
2582:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
9D00181C  AE0000F0   SW ZERO, 240(S0)
2583:                
2584:                                            /* Release allocated device address */
2585:                                            _USB_HOST_FreeAddress(deviceObj->deviceIdentifier);
9D001820  0F405674   JAL _USB_HOST_FreeAddress
9D001824  8E04004C   LW A0, 76(S0)
9D001828  0B400623   J 0x9D00188C
9D00182C  8FBF0034   LW RA, 52(SP)
2586:                                        }
2587:                                        else
2588:                                        {
2589:                                            /* Move the device to error state */
2590:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D001830  AE0200F0   SW V0, 240(S0)
2591:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Get Configuration Descriptor Request failed 3 times. Device not supported", busIndex, deviceObj->deviceAddress);
2592:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D001834  3C028001   LUI V0, -32767
9D001838  8C423DC8   LW V0, 15816(V0)
9D00183C  10400012   BEQ V0, ZERO, 0x9D001888
9D001840  24040001   ADDIU A0, ZERO, 1
2593:                                            {
2594:                                                gUSBHostObj.hostEventHandler(USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D001844  00002821   ADDU A1, ZERO, ZERO
9D001848  3C038001   LUI V1, -32767
9D00184C  0040F809   JALR V0
9D001850  8C663DCC   LW A2, 15820(V1)
2595:                                            }
2596:                                        }
2597:                                    }
2598:                                }
2599:                                break;
2600:                                
2601:                            case USB_HOST_DEVICE_STATE_ERROR:
2602:                                
2603:                                /* The device has entered an error state. 
2604:                                 * The control pipe should have been closed already. 
2605:                                 * We will only assign an invalid value to the pipe handle. 
2606:                                 * Note that we are doing this in an atomically, just to be safe.
2607:                                 *  The device then enters the Error holding state. In this state,
2608:                                 *  the device must be detached. */
2609:                                
2610:                                interruptIsEnabled = SYS_INT_Disable();
9D00185C  0F405C0B   JAL SYS_INT_Disable
9D001860  00000000   NOP
2611:                                
2612:                                deviceObj->controlPipeHandle = DRV_USB_HOST_PIPE_HANDLE_INVALID;
9D001864  2403FFFF   ADDIU V1, ZERO, -1
2613:                                
2614:                                if(interruptIsEnabled)
9D001868  10400005   BEQ V0, ZERO, 0x9D001880
9D00186C  AE030058   SW V1, 88(S0)
2615:                                {
2616:                                    SYS_INT_Enable();
2617:                                }
2618:                                
2619:                                deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR_HOLDING;
9D001880  2402FFFE   ADDIU V0, ZERO, -2
9D001884  AE0200F0   SW V0, 240(S0)
2620:                                break;
2621:                                
2622:                            case USB_HOST_DEVICE_STATE_ERROR_HOLDING:
2623:                                
2624:                                break;
2625:                
2626:                            case USB_HOST_DEVICE_STATE_READY:
2627:                
2628:                                /* This means the device state is ready for further processing.
2629:                                 * The host layer will now try to match the device to the
2630:                                 * client driver. The client driver can start interacting with
2631:                                 * the device */
2632:                                break;
2633:                            default:
2634:                                break;
2635:                        }
2636:                    }
2637:                }
9D001140  0B400623   J 0x9D00188C
9D001144  8FBF0034   LW RA, 52(SP)
9D001310  0B400623   J 0x9D00188C
9D001314  8FBF0034   LW RA, 52(SP)
9D0014A4  0B400623   J 0x9D00188C
9D0014A8  8FBF0034   LW RA, 52(SP)
9D0015F0  0B400623   J 0x9D00188C
9D0015F4  8FBF0034   LW RA, 52(SP)
9D001854  0B400623   J 0x9D00188C
9D001858  8FBF0034   LW RA, 52(SP)
9D001888  8FBF0034   LW RA, 52(SP)
2638:                
2639:                // *****************************************************************************
2640:                /* Function:
2641:                    void _USB_HOST_UpdateDeviceTask(int busIndex)
2642:                
2643:                  Summary:
2644:                    This function maintains the state of each device on the bus.
2645:                
2646:                  Description:
2647:                    This function maintains the state of each device on the bus.
2648:                
2649:                  Remarks:
2650:                    This is a local function and should not be called directly by the 
2651:                    application.
2652:                */
2653:                
2654:                void _USB_HOST_UpdateDeviceTask(int busIndex)
2655:                {
9D0151D8  27BDFFE0   ADDIU SP, SP, -32
9D0151DC  AFBF001C   SW RA, 28(SP)
9D0151E0  AFB10018   SW S1, 24(SP)
9D0151E4  AFB00014   SW S0, 20(SP)
2656:                    USB_HOST_BUS_OBJ * busObj;
2657:                    USB_HOST_DEVICE_OBJ * deviceObj = NULL ;
2658:                
2659:                    busObj = &(gUSBHostBusList[busIndex]);
9D0151E8  00041900   SLL V1, A0, 4
9D0151EC  00041180   SLL V0, A0, 6
9D0151F0  00621821   ADDU V1, V1, V0
2660:                
2661:                    /* The first device on the bus is the root hub. We don't maintain the state
2662:                     * of the root hub. So get the next device on the bus. */
2663:                    deviceObj = busObj->busDeviceList;
9D0151F4  3C028001   LUI V0, -32767
9D0151F8  24423D78   ADDIU V0, V0, 15736
9D0151FC  00431021   ADDU V0, V0, V1
9D015200  8C420010   LW V0, 16(V0)
2664:                    deviceObj = deviceObj->nextDeviceObj;
9D015204  8C5001A8   LW S0, 424(V0)
2665:                
2666:                    while(deviceObj != NULL)
9D015208  12000010   BEQ S0, ZERO, 0x9D01524C
9D01520C  00808821   ADDU S1, A0, ZERO
9D015244  1600FFF3   BNE S0, ZERO, 0x9D015214
9D015248  02002021   ADDU A0, S0, ZERO
2667:                    {
2668:                        /* Check if the device is addressed, get the device descriptor, check
2669:                         * all the configuration descriptors and move the device to the ready
2670:                         * state */
2671:                        _USB_HOST_MakeDeviceReady(deviceObj, busIndex);
9D015210  02002021   ADDU A0, S0, ZERO
9D015214  0F400382   JAL _USB_HOST_MakeDeviceReady
9D015218  02202821   ADDU A1, S1, ZERO
2672:                
2673:                        /* If the device is not owned then find a driver that can own it */
2674:                        _USB_HOST_UpdateDeviceOwnership (deviceObj, busIndex);
9D01521C  02002021   ADDU A0, S0, ZERO
9D015220  0F402BDA   JAL _USB_HOST_UpdateDeviceOwnership
9D015224  02202821   ADDU A1, S1, ZERO
2675:                        
2676:                        /* If the configuration needs to be set, then set the configuration */
2677:                        _USB_HOST_UpdateConfigurationState(deviceObj, busIndex);
9D015228  02002021   ADDU A0, S0, ZERO
9D01522C  0F401826   JAL _USB_HOST_UpdateConfigurationState
9D015230  02202821   ADDU A1, S1, ZERO
2678:                        
2679:                        /* If the device is configured, update the state of the interfaces */
2680:                        _USB_HOST_UpdateInterfaceStatus(deviceObj, busIndex);
9D015234  02002021   ADDU A0, S0, ZERO
9D015238  0F402627   JAL _USB_HOST_UpdateInterfaceStatus
9D01523C  02202821   ADDU A1, S1, ZERO
2681:                
2682:                        //_USB_HOST_UpdateClientDriverState ( deviceObj );
2683:                
2684:                        deviceObj =   deviceObj->nextDeviceObj ;
9D015240  8E1001A8   LW S0, 424(S0)
2685:                    }
2686:                }
9D01524C  8FBF001C   LW RA, 28(SP)
2687:                
2688:                // *****************************************************************************
2689:                /* Function:
2690:                    void _USB_HOST_FreeAddress ( USB_HOST_DEVICE_OBJ_HANDLE deviceIdentifier)
2691:                
2692:                  Summary:
2693:                    Frees up the address bit assigned to this device hence making the address 
2694:                    available.
2695:                
2696:                  Description:
2697:                    This function frees up the address bit assigned to this device hence making 
2698:                    the address available.
2699:                
2700:                  Remarks:
2701:                    This is a local function and should not be called directly by the 
2702:                    application.
2703:                */
2704:                
2705:                void _USB_HOST_FreeAddress ( USB_HOST_DEVICE_OBJ_HANDLE deviceIdentifier  )
2706:                {
2707:                    uint8_t busNumber;
2708:                    int deviceIndex;
2709:                    uint8_t deviceAddress;
2710:                    USB_HOST_BUS_OBJ *busObj;
2711:                    USB_HOST_DEVICE_OBJ *deviceObj;
2712:                
2713:                    /* Get the device array index and the bus number from the device object
2714:                     * handle */
2715:                    deviceIndex = USB_HOST_DEVICE_INDEX (deviceIdentifier);
9D0159D0  308300FF   ANDI V1, A0, 255
2716:                    busNumber = USB_HOST_BUS_NUMBER (deviceIdentifier);
2717:                    
2718:                    busObj =  &( gUSBHostBusList[busNumber]);
9D015A00  00041900   SLL V1, A0, 4
9D015A04  00042180   SLL A0, A0, 6
9D015A08  00642021   ADDU A0, V1, A0
9D015A0C  3C038001   LUI V1, -32767
9D015A10  24633D78   ADDIU V1, V1, 15736
9D015A14  00641821   ADDU V1, V1, A0
2719:                    deviceObj = &( gUSBHostDeviceList [ deviceIndex ]);
9D0159D4  00032900   SLL A1, V1, 4
9D0159D8  00031180   SLL V0, V1, 6
9D0159DC  00451023   SUBU V0, V0, A1
9D0159E0  000218C0   SLL V1, V0, 3
9D0159E4  00431021   ADDU V0, V0, V1
2720:                    deviceAddress = deviceObj->deviceAddress;
9D0159E8  3C038001   LUI V1, -32767
9D0159EC  24633A18   ADDIU V1, V1, 14872
9D0159F0  00621021   ADDU V0, V1, V0
9D0159F4  90420060   LBU V0, 96(V0)
2721:                    
2722:                    if(deviceAddress == 0)
9D0159F8  10400010   BEQ V0, ZERO, 0x9D015A3C
9D0159FC  7C843A00   EXT A0, A0, 8, 8
2723:                    {
2724:                        /* Don't do anything */
2725:                    }
2726:                    else
2727:                    {
2728:                        /* The address is no longer being used. Clear up the bit assigned to this
2729:                         * device address. Address now becomes available. */
2730:                        busObj->addressBits[ deviceAddress/ 8 ] &= ~(1 << ( deviceAddress % 8));
9D015A18  000228C2   SRL A1, V0, 3
2731:                    }
2732:                }
2733:                
2734:                // *****************************************************************************
2735:                /* Function:
2736:                    USB_HOST_RESULT _USB_HOST_IRPResultToHostResult( USB_HOST_IRP * irp )
2737:                 
2738:                  Summary:
2739:                    This function maps the IRP completion result to a USB_HOST_RESULT type.
2740:                
2741:                  Description:
2742:                    This function maps the IRP completion result to a USB_HOST_RESULT type.
2743:                
2744:                  Remarks
2745:                    This is a local function and should not be called directly by the
2746:                    application.
2747:                */
2748:                
2749:                USB_HOST_RESULT _USB_HOST_IRPResultToHostResult(USB_HOST_IRP * irp)
2750:                {
2751:                    USB_HOST_RESULT result;
2752:                    switch(irp->status)
9D0163CC  8C83000C   LW V1, 12(A0)
9D0163D0  2402FFFF   ADDIU V0, ZERO, -1
9D0163D4  5062000E   BEQL V1, V0, 0x9D016410
9D0163D8  2402FF9F   ADDIU V0, ZERO, -97
9D0163DC  04630006   BGEZL V1, 0x9D0163F8
9D0163E0  28630002   SLTI V1, V1, 2
9D0163E4  2404FFFB   ADDIU A0, ZERO, -5
9D0163E8  10640009   BEQ V1, A0, 0x9D016410
9D0163EC  2402FF9E   ADDIU V0, ZERO, -98
9D0163F8  10600003   BEQ V1, ZERO, 0x9D016408
9D0163FC  00000000   NOP
2753:                    {
2754:                        case USB_HOST_IRP_STATUS_ABORTED:
2755:                            /* IRP was terminated by the application */
2756:                            result = USB_HOST_RESULT_TRANSFER_ABORTED;
2757:                            break; 
2758:                
2759:                        case USB_HOST_IRP_STATUS_ERROR_STALL:
2760:                            /* IRP was terminated because of a STALL */
2761:                            result = USB_HOST_RESULT_REQUEST_STALLED;
2762:                            break;
2763:                
2764:                        case USB_HOST_IRP_STATUS_COMPLETED:
2765:                        case USB_HOST_IRP_STATUS_COMPLETED_SHORT:
2766:                            /* IRP has been completed */
2767:                            result = USB_HOST_RESULT_SUCCESS;
2768:                            break;
9D016400  03E00008   JR RA
9D016404  24020001   ADDIU V0, ZERO, 1
2769:                
2770:                        case USB_HOST_IRP_STATUS_ERROR_UNKNOWN: 
2771:                        case USB_HOST_IRP_STATUS_ERROR_BUS: 
2772:                        case USB_HOST_IRP_STATUS_ERROR_DATA: 
2773:                        case USB_HOST_IRP_STATUS_ERROR_NAK_TIMEOUT:
2774:                        default:
2775:                            result = USB_HOST_RESULT_FAILURE;
9D0163F0  03E00008   JR RA
9D0163F4  2402FFA8   ADDIU V0, ZERO, -88
2776:                            break;
9D016408  03E00008   JR RA
9D01640C  2402FFA8   ADDIU V0, ZERO, -88
2777:                    }
2778:                    return (result);
2779:                }
9D016410  03E00008   JR RA
2780:                
2781:                // *****************************************************************************
2782:                /* Function:
2783:                    void _USB_HOST_DataTransferIRPCallback( USB_HOST_IRP * irp )
2784:                 
2785:                  Summary:
2786:                    This is the callback for IRPs submitted through the
2787:                    USB_HOST_DeviceTransfer() function.
2788:                
2789:                  Description:
2790:                    This is the callback function for IRPs submitted through the
2791:                    USB_HOST_DeviceTransfer() function. The function will get the
2792:                    USB_HOST_TRANSFER_OBJ object associated with this IRP, find out the
2793:                    interface on which the transfer took place and then call the
2794:                    interfaceEventHandler function of the client driver that owns this
2795:                    interface.
2796:                
2797:                  Remarks
2798:                    This is a local function and should not be called directly by the
2799:                    application.
2800:                */
2801:                
2802:                void _USB_HOST_DataTransferIRPCallback( USB_HOST_IRP * irp )
2803:                {
9D015150  27BDFFD0   ADDIU SP, SP, -48
9D015154  AFBF002C   SW RA, 44(SP)
9D015158  AFB20028   SW S2, 40(SP)
9D01515C  AFB10024   SW S1, 36(SP)
9D015160  AFB00020   SW S0, 32(SP)
2804:                    USB_HOST_TRANSFER_OBJ * transferObj;
2805:                    USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
2806:                    USB_HOST_CLIENT_DRIVER * clientDriver;
2807:                    
2808:                    USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE_DATA eventData;
2809:                
2810:                    /* The user data field of the IRP contains the address of the transfer
2811:                     * object the own this IRP. */
2812:                    transferObj = (USB_HOST_TRANSFER_OBJ *)(irp->userData);
9D015164  8C900014   LW S0, 20(A0)
2813:                
2814:                    /* The transfer object contains the reference to the interface object */
2815:                    interfaceInfo = transferObj->interfaceInfoObj;
9D015168  8E110040   LW S1, 64(S0)
2816:                
2817:                    /* Get a pointer to the client driver than owns this interface */
2818:                    clientDriver = interfaceInfo->interfaceDriver;
9D01516C  8E320008   LW S2, 8(S1)
2819:                
2820:                    /* Set up the event data object */
2821:                    eventData.length = irp->size;
9D015170  8C820008   LW V0, 8(A0)
9D015174  AFA20018   SW V0, 24(SP)
2822:                    eventData.transferHandle = (USB_HOST_TRANSFER_HANDLE)(transferObj);
2823:                
2824:                    /* We need to map IRP completion status to event data completion status */
2825:                    eventData.result = _USB_HOST_IRPResultToHostResult(irp);
9D015178  0F4058F3   JAL _USB_HOST_IRPResultToHostResult
9D01517C  AFB00010   SW S0, 16(SP)
9D015180  AFA20014   SW V0, 20(SP)
2826:                    
2827:                    /* If the the USB_HOST_DeviceTransfer function will be called, it should 
2828:                     * know that the host layer is in an interrupt context */
2829:                    gUSBHostObj.isInInterruptContext = true;
9D015184  24030001   ADDIU V1, ZERO, 1
9D015188  3C028001   LUI V0, -32767
9D01518C  24423DC8   ADDIU V0, V0, 15816
9D015190  A0430017   SB V1, 23(V0)
2830:                    
2831:                    /* We need to make sure that the interface is owned because the device could
2832:                     * have been detached between the time that this transfer was submitted
2833:                     * and the callback arrived */
2834:                    
2835:                    if(clientDriver != NULL)
9D015194  12400006   BEQ S2, ZERO, 0x9D0151B0
9D015198  00002821   ADDU A1, ZERO, ZERO
2836:                    {
2837:                        clientDriver->interfaceEventHandler(interfaceInfo->interfaceHandle, 
9D01519C  8E420024   LW V0, 36(S2)
9D0151A0  8E24000C   LW A0, 12(S1)
9D0151A4  27A60010   ADDIU A2, SP, 16
9D0151A8  0040F809   JALR V0
9D0151AC  8E070004   LW A3, 4(S0)
2838:                                USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE, &eventData, transferObj->context);
2839:                    }
2840:                    
2841:                    gUSBHostObj.isInInterruptContext = false;
9D0151B0  3C028001   LUI V0, -32767
9D0151B4  24423DC8   ADDIU V0, V0, 15816
9D0151B8  A0400017   SB ZERO, 23(V0)
2842:                
2843:                    /* Deallocate the transfer object */
2844:                    transferObj->inUse = false;
9D0151BC  A2000000   SB ZERO, 0(S0)
2845:                }
9D0151C0  8FBF002C   LW RA, 44(SP)
2846:                
2847:                // *****************************************************************************
2848:                /* Function:
2849:                    void _USB_HOST_DeviceControlTransferCallback( USB_HOST_IRP * irp )
2850:                 
2851:                  Summary:
2852:                    This is the callback for control IRPs submitted through the
2853:                    USB_HOST_DeviceControlTransfer() function.
2854:                
2855:                  Description:
2856:                    This is the callback function for control IRPs submitted through the
2857:                    USB_HOST_DeviceControlTransfer() function. The function will get the
2858:                    USB_HOST_CONTROL_TRANSFER_OBJ object associated with this IRP, find out the
2859:                    type of control request call the callback function associated with the
2860:                    control transfer.
2861:                
2862:                  Remarks
2863:                    This is a local function and should not be called directly by the
2864:                    application.
2865:                */
2866:                
2867:                void  _USB_HOST_DeviceControlTransferCallback( USB_HOST_IRP * irp )
2868:                {
9D00E060  27BDFFB0   ADDIU SP, SP, -80
9D00E064  AFBF004C   SW RA, 76(SP)
9D00E068  AFB30048   SW S3, 72(SP)
9D00E06C  AFB20044   SW S2, 68(SP)
9D00E070  AFB10040   SW S1, 64(SP)
9D00E074  AFB0003C   SW S0, 60(SP)
9D00E078  00809021   ADDU S2, A0, ZERO
2869:                    int deviceIndex;
2870:                    int interfaceIndex;
2871:                    USB_HOST_DEVICE_OBJ * deviceObj;
2872:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj;
2873:                    USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
2874:                    USB_HOST_RESULT result;
2875:                    USB_HOST_DEVICE_INTERFACE_EVENT_PIPE_HALT_CLEAR_COMPLETE_DATA pipeHaltEventData;
2876:                    USB_HOST_DEVICE_INTERFACE_EVENT_SET_INTERFACE_COMPLETE_DATA interfaceCompleteData;
2877:                    USB_HOST_DEVICE_EVENT_CONFIGURATION_DESCRIPTOR_GET_COMPLETE_DATA configurationGetCompleteData;
2878:                
2879:                    /* The userData field of the IRP will be a bit map that contains the pnp
2880:                     * identifier, the control transfer object index and the index of the device
2881:                     * object that submitted this control transfer. */
2882:                
2883:                    deviceIndex = USB_HOST_DEVICE_INDEX(irp->userData);
9D00E07C  8C910014   LW S1, 20(A0)
9D00E080  322200FF   ANDI V0, S1, 255
2884:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
9D00E084  00021900   SLL V1, V0, 4
9D00E088  00028180   SLL S0, V0, 6
9D00E08C  02038023   SUBU S0, S0, V1
9D00E090  001010C0   SLL V0, S0, 3
9D00E094  02028021   ADDU S0, S0, V0
9D00E098  3C028001   LUI V0, -32767
9D00E09C  24423A18   ADDIU V0, V0, 14872
9D00E0A0  00508021   ADDU S0, V0, S0
2885:                
2886:                    controlTransferObj = &deviceObj->controlTransferObj;
2887:                
2888:                    /* Map the IRP result to USB_HOST_RESULT */
2889:                    result = _USB_HOST_IRPResultToHostResult(irp); 
9D00E0A4  0F4058F3   JAL _USB_HOST_IRPResultToHostResult
9D00E0A8  26130004   ADDIU S3, S0, 4
2890:                
2891:                    switch ( controlTransferObj->requestType )
9D00E0AC  8E030044   LW V1, 68(S0)
9D00E0B0  2C630005   SLTIU V1, V1, 5
9D00E0B4  1060005A   BEQ V1, ZERO, 0x9D00E220
9D00E0B8  3C039D01   LUI V1, -25343
9D00E0BC  8E040044   LW A0, 68(S0)
9D00E0C0  00042080   SLL A0, A0, 2
9D00E0C4  2463E0D4   ADDIU V1, V1, -7980
9D00E0C8  7C64180A   LWX V1, A0(V1)
9D00E0CC  00600008   JR V1
9D00E0D0  00000000   NOP
2892:                    {
2893:                        case USB_HOST_CONTROL_REQUEST_TYPE_CLIENT_DRIVER_SPECIFIC:
2894:                
2895:                            /* This was a client driver specific control request. Call the
2896:                             * register callback */
2897:                
2898:                            if(controlTransferObj->callback != NULL)
9D00E0E8  8E030048   LW V1, 72(S0)
9D00E0EC  5060004D   BEQL V1, ZERO, 0x9D00E224
9D00E0F0  A2000004   SB ZERO, 4(S0)
2899:                            {
2900:                                ((USB_HOST_DEVICE_CONTROL_REQUEST_COMPLETE_CALLBACK)(controlTransferObj->callback))(deviceObj->deviceIdentifier, 
9D00E0F4  8E04004C   LW A0, 76(S0)
9D00E0F8  8E470008   LW A3, 8(S2)
9D00E0FC  8E050008   LW A1, 8(S0)
9D00E100  AFA50010   SW A1, 16(SP)
9D00E104  02602821   ADDU A1, S3, ZERO
9D00E108  0060F809   JALR V1
9D00E10C  00403021   ADDU A2, V0, ZERO
2901:                                (USB_HOST_REQUEST_HANDLE)(controlTransferObj), result, irp->size, controlTransferObj->context );
2902:                            }
2903:                            break;
2904:                
2905:                        case USB_HOST_CONTROL_REQUEST_TYPE_PIPE_HALT_CLEAR:
2906:                
2907:                            /* This is standard control transfer request. Send the event to
2908:                             * the client driver that requested this. The IRP user data in this
2909:                             * case will also contain the interface index. */
2910:                
2911:                            interfaceIndex = USB_HOST_INTERFACE_INDEX(irp->userData);
9D00E118  7E233A00   EXT V1, S1, 8, 8
2912:                            interfaceInfo = &deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex];
9D00E11C  24630008   ADDIU V1, V1, 8
9D00E120  00031940   SLL V1, V1, 5
9D00E124  02031821   ADDU V1, S0, V1
2913:                
2914:                            /* Prepare the event data */
2915:                            pipeHaltEventData.result = result;
9D00E128  AFA2001C   SW V0, 28(SP)
2916:                            pipeHaltEventData.requestHandle = (USB_HOST_REQUEST_HANDLE)(controlTransferObj);
9D00E12C  AFB30018   SW S3, 24(SP)
2917:                
2918:                            /* Send the event to the interface event handler */
2919:                            if((interfaceInfo->interfaceDriver != NULL) && 
9D00E130  8C62000C   LW V0, 12(V1)
9D00E134  1040003A   BEQ V0, ZERO, 0x9D00E220
9D00E138  24630004   ADDIU V1, V1, 4
9D00E140  10400037   BEQ V0, ZERO, 0x9D00E220
9D00E144  24050002   ADDIU A1, ZERO, 2
2920:                                    (interfaceInfo->interfaceDriver->interfaceEventHandler != NULL))
9D00E13C  8C420024   LW V0, 36(V0)
2921:                            {
2922:                                interfaceInfo->interfaceDriver->interfaceEventHandler(interfaceInfo->interfaceHandle,
9D00E148  8C64000C   LW A0, 12(V1)
9D00E14C  27A60018   ADDIU A2, SP, 24
9D00E150  0040F809   JALR V0
9D00E154  8E070008   LW A3, 8(S0)
2923:                                        USB_HOST_DEVICE_INTERFACE_EVENT_PIPE_HALT_CLEAR_COMPLETE, &pipeHaltEventData, controlTransferObj->context);
2924:                            }
2925:                
2926:                            break;
2927:                
2928:                        case USB_HOST_CONTROL_REQUEST_TYPE_INTERFACE_SET:
2929:                
2930:                            /* This is standard control transfer request. Send the event to
2931:                             * the client driver that requested this. The IRP user data in this
2932:                             * case will also contain the interface index. */
2933:                
2934:                            interfaceIndex = USB_HOST_INTERFACE_INDEX(irp->userData);
9D00E160  7E233A00   EXT V1, S1, 8, 8
2935:                            interfaceInfo = &deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex];
9D00E164  24630008   ADDIU V1, V1, 8
9D00E168  00031940   SLL V1, V1, 5
9D00E16C  02031821   ADDU V1, S0, V1
9D00E170  24630004   ADDIU V1, V1, 4
2936:                
2937:                            /* Prepare the event data */
2938:                            interfaceCompleteData.result = result;
9D00E174  AFA20024   SW V0, 36(SP)
2939:                            interfaceCompleteData.requestHandle = (USB_HOST_REQUEST_HANDLE)(controlTransferObj);
2940:                
2941:                            if(result == USB_HOST_RESULT_SUCCESS)
9D00E178  24040001   ADDIU A0, ZERO, 1
9D00E17C  14440003   BNE V0, A0, 0x9D00E18C
9D00E180  AFB30020   SW S3, 32(SP)
2942:                            {
2943:                                /* This means the alternate setting request was successful. We
2944:                                 * should updated the current alternate setting on this
2945:                                 * interface */
2946:                                interfaceInfo->currentAlternateSetting = deviceObj->requestedAlternateSetting;
9D00E184  92020061   LBU V0, 97(S0)
9D00E188  A0620018   SB V0, 24(V1)
2947:                            }
2948:                
2949:                            /* Send the event to the interface event handler */
2950:                            if((interfaceInfo->interfaceDriver != NULL) && 
9D00E18C  8C620008   LW V0, 8(V1)
9D00E190  50400024   BEQL V0, ZERO, 0x9D00E224
9D00E194  A2000004   SB ZERO, 4(S0)
9D00E19C  10400020   BEQ V0, ZERO, 0x9D00E220
9D00E1A0  24050001   ADDIU A1, ZERO, 1
2951:                                    (interfaceInfo->interfaceDriver->interfaceEventHandler != NULL))
9D00E198  8C420024   LW V0, 36(V0)
2952:                            {
2953:                                interfaceInfo->interfaceDriver->interfaceEventHandler(interfaceInfo->interfaceHandle,
9D00E1A4  8C64000C   LW A0, 12(V1)
9D00E1A8  27A60020   ADDIU A2, SP, 32
9D00E1AC  0040F809   JALR V0
9D00E1B0  8E070008   LW A3, 8(S0)
2954:                                        USB_HOST_DEVICE_INTERFACE_EVENT_SET_INTERFACE_COMPLETE, &interfaceCompleteData, controlTransferObj->context);
2955:                            }
2956:                
2957:                            break;
2958:                
2959:                        case USB_HOST_CONTROL_REQUEST_TYPE_STRING_DESCRIPTOR:
2960:                
2961:                            /* This request originated from the application. The context and the
2962:                             * callback field of the control transfer object contain callback
2963:                             * and context specified by the application. */
2964:                
2965:                            if(controlTransferObj->callback != NULL)
9D00E1BC  8E030048   LW V1, 72(S0)
9D00E1C0  10600017   BEQ V1, ZERO, 0x9D00E220
9D00E1C4  24040001   ADDIU A0, ZERO, 1
2966:                            {
2967:                                /* This means we have a callback that we can call */
2968:                                if(result == USB_HOST_RESULT_SUCCESS)
9D00E1C8  14440006   BNE V0, A0, 0x9D00E1E4
9D00E1CC  02602021   ADDU A0, S3, ZERO
2969:                                {
2970:                                    ((USB_HOST_STRING_REQUEST_COMPLETE_CALLBACK)(controlTransferObj->callback))
2971:                                        ((USB_HOST_REQUEST_HANDLE)controlTransferObj, irp->size, controlTransferObj->context);
9D00E1D0  8E450008   LW A1, 8(S2)
9D00E1D4  0060F809   JALR V1
9D00E1D8  8E060008   LW A2, 8(S0)
9D00E1DC  0B403889   J 0x9D00E224
9D00E1E0  A2000004   SB ZERO, 4(S0)
2972:                
2973:                                }
2974:                                else
2975:                                {
2976:                                    /* The string descriptor request failed. Invoke the callback
2977:                                     * with string size as 0 */
2978:                                    ((USB_HOST_STRING_REQUEST_COMPLETE_CALLBACK)(controlTransferObj->callback))
2979:                                        ((USB_HOST_REQUEST_HANDLE)controlTransferObj, irp->size, controlTransferObj->context);
9D00E1E4  8E450008   LW A1, 8(S2)
9D00E1E8  0060F809   JALR V1
9D00E1EC  8E060008   LW A2, 8(S0)
2980:                                }
2981:                            }
2982:                
2983:                            break;
2984:                
2985:                        case USB_HOST_CONTROL_REQUEST_TYPE_CONFIGURATION_DESCRIPTOR_GET:
2986:                
2987:                            /* This request originated from the client driver. An event should
2988:                             * be sent to the device level event handler. Populate the event
2989:                             * data. */
2990:                
2991:                            configurationGetCompleteData.requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
9D00E1F8  AFB30028   SW S3, 40(SP)
2992:                            configurationGetCompleteData.result = result; 
9D00E1FC  AFA2002C   SW V0, 44(SP)
2993:                            
2994:                            if(deviceObj->deviceClientDriver != NULL)
9D00E200  8E0200E0   LW V0, 224(S0)
9D00E204  10400006   BEQ V0, ZERO, 0x9D00E220
9D00E208  24050001   ADDIU A1, ZERO, 1
2995:                            {
2996:                                deviceObj->deviceClientDriver->deviceEventHandler(deviceObj->deviceClientHandle,
9D00E20C  8C420018   LW V0, 24(V0)
9D00E210  8E040050   LW A0, 80(S0)
9D00E214  27A60028   ADDIU A2, SP, 40
9D00E218  0040F809   JALR V0
9D00E21C  8E070008   LW A3, 8(S0)
2997:                                        USB_HOST_DEVICE_EVENT_CONFIGURATION_DESCRIPTOR_GET_COMPLETE, &configurationGetCompleteData, 
2998:                                        deviceObj->controlTransferObj.context);
2999:                            }
3000:                
3001:                
3002:                        default:
3003:                            break;
3004:                    }
3005:                
3006:                    /* Release the control transfer object back */
3007:                    controlTransferObj->inUse = false;
9D00E110  0B403889   J 0x9D00E224
9D00E114  A2000004   SB ZERO, 4(S0)
9D00E158  0B403889   J 0x9D00E224
9D00E15C  A2000004   SB ZERO, 4(S0)
9D00E1B4  0B403889   J 0x9D00E224
9D00E1B8  A2000004   SB ZERO, 4(S0)
9D00E1F0  0B403889   J 0x9D00E224
9D00E1F4  A2000004   SB ZERO, 4(S0)
9D00E220  A2000004   SB ZERO, 4(S0)
3008:                }
9D00E224  8FBF004C   LW RA, 76(SP)
3009:                
3010:                // *****************************************************************************
3011:                // *****************************************************************************
3012:                // Section: USB HOST Layer System Interface Implementations
3013:                // *****************************************************************************
3014:                // *****************************************************************************
3015:                
3016:                // *****************************************************************************
3017:                /* Function:
3018:                    SYS_MODULE_OBJ USB_HOST_Initialize
3019:                    (
3020:                       const SYS_MODULE_INIT * const init
3021:                   )
3022:                
3023:                  Summary:
3024:                    Initializes the USB Host layer instance specified by the index.
3025:                
3026:                  Description:
3027:                    This routine initializes the USB Host Layer. This function must be called
3028:                    before any other Host layer function can be called. The initialization data
3029:                    is specified by the init parameter.  This function is typically called in
3030:                    the SYS_Initialize() function. The initialization completion may require the
3031:                    USB_HOST_Tasks() routine to execute.  The initialization function does not
3032:                    start the operation of the Host on the USB.  This must be done explicitly
3033:                    via the USB_HOST_BusEnable() function.
3034:                
3035:                  Remarks:
3036:                    Refer to usb_host.h for usage information.
3037:                */
3038:                
3039:                SYS_MODULE_OBJ  USB_HOST_Initialize
3040:                (
3041:                    const SYS_MODULE_INIT * initData
3042:                )
3043:                {
9D011ED0  27BDFFD8   ADDIU SP, SP, -40
9D011ED4  AFBF0024   SW RA, 36(SP)
9D011ED8  AFB30020   SW S3, 32(SP)
9D011EDC  AFB2001C   SW S2, 28(SP)
9D011EE0  AFB10018   SW S1, 24(SP)
9D011EE4  AFB00014   SW S0, 20(SP)
3044:                    int hcCount;
3045:                    SYS_MODULE_OBJ result;
3046:                    uint32_t tplEntryCount;
3047:                    USB_HOST_BUS_OBJ *busObj;
3048:                    USB_HOST_TPL_ENTRY *tplEntry;
3049:                    USB_HOST_INIT *hostInit = NULL;
3050:                    USB_HOST_OBJ *hostObj = &(gUSBHostObj);
3051:                
3052:                    /* Typecast the initialization data parameter and check if it is NULL. The
3053:                     * host layer cannot be initialized if the initialization data structure is
3054:                     * NULL. */
3055:                
3056:                    hostInit = ( USB_HOST_INIT * ) initData ;
3057:                    result =SYS_MODULE_OBJ_INVALID;
9D011F30  03E00008   JR RA
9D011F34  2402FFFF   ADDIU V0, ZERO, -1
3058:                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host Layer: Entering USB_HOST_Initialize().");
3059:                
3060:                    if(NULL  == hostInit )
9D011E40  1080003B   BEQ A0, ZERO, 0x9D011F30
9D011E44  3C038001   LUI V1, -32767
3061:                    {
3062:                        SYS_DEBUG_MESSAGE( SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Initialization data is NULL is USB_HOST_Initialize().");
3063:                    }
3064:                    else
3065:                    {
3066:                        if(OSAL_RESULT_TRUE != OSAL_MUTEX_Create(&(gUSBHostObj.mutexControlTransferObj)))
3067:                        {
3068:                            /* Could not create the mutual exclusion */
3069:                            SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Could not create Control Transfer Mutex in USB_HOST_Initialize().");
3070:                        }
3071:                        else
3072:                        {
3073:                            if(OSAL_RESULT_TRUE != OSAL_MUTEX_Create(&(gUSBHostObj.mutexPipeObj)))
3074:                            {
3075:                                /* Could not create the mutual exclusion*/
3076:                                SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Could not create Pipe Object Mutex in USB_HOST_Initialize().");
3077:                            }
3078:                            else
3079:                            {
3080:                                if(OSAL_RESULT_TRUE != OSAL_MUTEX_Create(&(gUSBHostObj.mutexTransferObj)))
3081:                                {
3082:                                    /* Could not create the mutual exclusion */
3083:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Could not create Transfer Object Mutex in USB_HOST_Initialize().");
3084:                                }
3085:                                else
3086:                                {
3087:                                    /* Initialize the bus objects */
3088:                                    for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3089:                                    {
3090:                                        busObj  = &(gUSBHostBusList[hcCount]);
3091:                
3092:                                        /* Update the Host Controller Driver. This index will be used
3093:                                         * when the Host Layer opens the driver (at root hub enumeration
3094:                                         * time). */
3095:                                        busObj->hcdIndex = hostInit->hostControllerDrivers[hcCount].drvIndex;
9D011E5C  8C820008   LW V0, 8(A0)
9D011E60  94450000   LHU A1, 0(V0)
9D011E64  3C068001   LUI A2, -32767
9D011E68  24C23D78   ADDIU V0, A2, 15736
9D011E6C  A4450004   SH A1, 4(V0)
3096:                
3097:                                        /* By default bus state is disabled */
3098:                                        busObj->state = USB_HOST_BUS_STATE_DISABLED ;
9D011E70  AC400008   SW ZERO, 8(V0)
3099:                
3100:                                        /* Pointer to the HCD interface */
3101:                                        busObj->hcdInterface = ( DRV_USB_HOST_INTERFACE * ) ( hostInit->hostControllerDrivers [hcCount]).hcdInterface ;
9D011E74  8C850008   LW A1, 8(A0)
9D011E78  8CA50004   LW A1, 4(A1)
9D011E7C  AC45000C   SW A1, 12(V0)
3102:                
3103:                                        /* Attached Device list will be NULL*/
3104:                                        busObj->busDeviceList = NULL ;
9D011E80  AC400010   SW ZERO, 16(V0)
3105:                
3106:                                        /* Initialize HCD handle to invalid */
3107:                                        busObj->hcdHandle   = DRV_HANDLE_INVALID ;
9D011E84  2405FFFF   ADDIU A1, ZERO, -1
9D011E88  ACC53D78   SW A1, 15736(A2)
3108:                
3109:                                        /* This flag is set when any device is enumerating on the bus. 
3110:                                         * Initialize as false. */
3111:                                        busObj->deviceIsEnumerating = false ;
9D011E8C  A0400015   SB ZERO, 21(V0)
3112:                
3113:                                        /* Initialize handle of the system timer that this bus object will use */
3114:                                        busObj->busOperationsTimerHandle = SYS_TMR_HANDLE_INVALID;
9D011E90  AC450044   SW A1, 68(V0)
3115:                
3116:                                        /* Bus bandwidth constants */
3117:                                        busObj->totalBandwidth = 1000;
9D011E94  240503E8   ADDIU A1, ZERO, 1000
9D011E98  AC450018   SW A1, 24(V0)
3118:                                        busObj->availableBandwidth = 1000;
9D011E9C  AC45001C   SW A1, 28(V0)
3119:                
3120:                                        /* Device Plug and Play identifier */
3121:                                        busObj->pnpIdentifier = 0x00;
9D011EA0  A4400048   SH ZERO, 72(V0)
3122:                
3123:                                        /* Device address " 0 " for newly connected device 
3124:                                           Device address is " 1 " for reserved for RootHUB 
3125:                                           Mark there as reserved  */
3126:                                        busObj->addressBits[0] = ( uint8_t ) 0x03;
9D011EA4  24050003   ADDIU A1, ZERO, 3
9D011EA8  A0450014   SB A1, 20(V0)
3127:                                    }
3128:                
3129:                                    /* The host layer is now ready */
3130:                                    hostObj->status = SYS_STATUS_READY;
9D011EAC  24020002   ADDIU V0, ZERO, 2
9D011EB0  AC620008   SW V0, 8(V1)
3131:                
3132:                                    /* Get the pointer to the Host TPL and the
3133:                                     * number of entries in the TPL table. */
3134:                
3135:                                    hostObj->tpl = hostInit->tplList ;
9D011EB4  8C820004   LW V0, 4(A0)
9D011EB8  AC620010   SW V0, 16(V1)
3136:                                    hostObj->nTPLEntries = hostInit->nTPLEntries;
9D011EBC  8C820000   LW V0, 0(A0)
9D011EC0  A062000C   SB V0, 12(V1)
3137:                
3138:                                    /* Initialize all drivers in TPL List */
3139:                                    for ( tplEntryCount = 0 ; tplEntryCount < hostObj->nTPLEntries ; tplEntryCount++ )
9D011EC4  304200FF   ANDI V0, V0, 255
9D011EC8  10400022   BEQ V0, ZERO, 0x9D011F54
9D011ECC  3C028001   LUI V0, -32767
9D011EE8  00008821   ADDU S1, ZERO, ZERO
9D011EEC  00008021   ADDU S0, ZERO, ZERO
9D011F10  26100001   ADDIU S0, S0, 1
9D011F14  9242000C   LBU V0, 12(S2)
9D011F18  0202102B   SLTU V0, S0, V0
9D011F1C  1440FFF5   BNE V0, ZERO, 0x9D011EF4
9D011F20  26310014   ADDIU S1, S1, 20
3140:                                    {
3141:                                        tplEntry = &(hostObj->tpl[tplEntryCount]);
9D011EF0  3C138001   LUI S3, -32767
9D011EF4  26723DC8   ADDIU S2, S3, 15816
9D011EF8  8E420010   LW V0, 16(S2)
9D011EFC  00511021   ADDU V0, V0, S1
3142:                                        (( USB_HOST_CLIENT_DRIVER *)tplEntry->hostClientDriver)->initialize( tplEntry->hostClientDriverInitData );
9D011F00  8C430010   LW V1, 16(V0)
9D011F04  8C630000   LW V1, 0(V1)
9D011F08  0060F809   JALR V1
9D011F0C  8C44000C   LW A0, 12(V0)
3143:                                    }
3144:                
3145:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host Layer: Exiting USB_HOST_Initialize() successfully.");
3146:                                    result = ((SYS_MODULE_OBJ)hostObj);
9D011F24  3C028001   LUI V0, -32767
9D011F28  0B4047CE   J 0x9D011F38
9D011F2C  24423DC8   ADDIU V0, V0, 15816
3147:                                }
3148:                            }
3149:                        }
3150:                    }
3151:                
3152:                    return(result);
3153:                }
9D011F38  8FBF0024   LW RA, 36(SP)
3154:                
3155:                // *****************************************************************************
3156:                /* Function:
3157:                    SYS_STATUS USB_HOST_Status( SYS_MODULE_OBJ object )
3158:                
3159:                  Summary:
3160:                    Dynamic implementation of USB_HOST_Status system interface function.
3161:                
3162:                  Description:
3163:                    This is the dynamic implementation of USB_HOST_Status system interface
3164:                    function.
3165:                
3166:                  Remarks:
3167:                    See usb_host.h for usage information.
3168:                */
3169:                
3170:                SYS_STATUS USB_HOST_Status (SYS_MODULE_OBJ usbHostObject)
3171:                {
3172:                    USB_HOST_OBJ * hostObj =  (USB_HOST_OBJ *)usbHostObject;
3173:                    SYS_STATUS result = SYS_STATUS_UNINITIALIZED;
3174:                
3175:                    /* Check if we have a valid object */
3176:                    if(NULL ==  hostObj)
00000000  00000000   NOP
3177:                    {
3178:                        SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Invalid System Module Object in USB_HOST_Status().");
3179:                    }
3180:                    else
3181:                    {
3182:                        /* Return the system status of the Host Layer */
3183:                        result = hostObj->status;
00000008  00000000   NOP
3184:                    }
3185:                
3186:                    return(result);
3187:                }
00000010  00000000   NOP
3188:                
3189:                // *****************************************************************************
3190:                /* Function:
3191:                    void USB_HOST_Deinitialize ( SYS_MODULE_OBJ usbHostObject )
3192:                
3193:                  Summary:
3194:                    Dynamic implementation of USB_HOST_Deinitialize system interface function.
3195:                
3196:                  Description:
3197:                    This is the dynamic implementation of USB_HOST_Deinitialize system interface
3198:                    function.
3199:                
3200:                  Remarks:
3201:                    See usb_host.h for usage information.
3202:                */
3203:                
3204:                void USB_HOST_Deinitialize ( SYS_MODULE_OBJ usbHostObject )
3205:                {
3206:                    /* Host object */
3207:                    USB_HOST_OBJ * hostObj =  (USB_HOST_OBJ *)usbHostObject;
3208:                
3209:                    /* Check for NULL pointer */
3210:                    if(NULL == hostObj )
3211:                    {
3212:                        SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Invalid System Module Object in USB_HOST_Deinitialize().");
3213:                    }
3214:                    else
3215:                    {
3216:                        /* Set the instance status to de-initialized */
3217:                        hostObj->status =  SYS_STATUS_UNINITIALIZED ;
3218:                    }
3219:                }
3220:                
3221:                // *****************************************************************************
3222:                // *****************************************************************************
3223:                // Section: USB HOST Layer Client Interface Implementations
3224:                // *****************************************************************************
3225:                // *****************************************************************************
3226:                
3227:                // *****************************************************************************
3228:                /* Function:
3229:                    USB_HOST_RESULT USB_HOST_DeviceGetFirst 
3230:                    (
3231:                        USB_HOST_BUS bus, 
3232:                        USB_HOST_DEVICE_INFO * deviceInfo
3233:                    );
3234:                
3235:                  Summary:
3236:                    Returns information about the first attached device on the bus.
3237:                
3238:                  Description:
3239:                    This function returns information about the first attached device on the
3240:                    specified bus. The USB_HOST_DeviceGetNext() function can be used to get the
3241:                    reference to the next attached device on the bus. The USB_HOST_DEVICE_INFO
3242:                    object is provided by the application.The device information will be
3243:                    populated into this object. If there are no devices attached on the bus, the
3244:                    function will set the deviceObjHandle parameter, in the USB_HOST_DEVICE_INFO
3245:                    object, to USB_HOST_DEVICE_OBJ_HANDLE INVALID. 
3246:                    
3247:                  Remarks:
3248:                    None.
3249:                */
3250:                
3251:                USB_HOST_RESULT USB_HOST_DeviceGetFirst 
3252:                (
3253:                    USB_HOST_BUS bus, 
3254:                    USB_HOST_DEVICE_INFO * deviceInfo
3255:                )
3256:                {
00000000  00000000   NOP
3257:                    USB_HOST_RESULT result = USB_HOST_RESULT_SUCCESS;
3258:                
3259:                    USB_HOST_BUS_OBJ * busObj;
3260:                    USB_HOST_DEVICE_OBJ * deviceObj, * rootHub;
3261:                
3262:                    if(bus >= USB_HOST_CONTROLLERS_NUMBER)
00000004  00000000   NOP
3263:                    {
3264:                        /* This is an invalid bus */
3265:                        result = USB_HOST_RESULT_BUS_UNKNOWN;
00000094  00000000   NOP
3266:                    }
3267:                    else if (NULL == deviceInfo)
0000000C  00000000   NOP
3268:                    {
3269:                        /* Parameter is not valid */
3270:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
0000009C  00000000   NOP
3271:                    }
3272:                    else 
3273:                    {
3274:                        /* Get a pointer to the bus object */
3275:                        busObj = &gUSBHostBusList[bus];
3276:                
3277:                        /* Set the initial value of the device Info object to invalid incase we
3278:                         * have to exit with a failure */
3279:                        deviceInfo->deviceObjHandle = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
00000014  00000000   NOP
3280:                
3281:                        if(busObj->state < USB_HOST_BUS_STATE_ENABLED)
0000001C  00000000   NOP
3282:                        {
3283:                            /* Bus is not enabled */
3284:                            result = USB_HOST_RESULT_BUS_NOT_ENABLED;
000000A4  00000000   NOP
3285:                        }
3286:                        else 
3287:                        {
3288:                            /* Get the pointer to the first attached device. This will be the
3289:                             * root hub. The next device after the root hub is the device
3290:                             * attached to the bus.  */
3291:                
3292:                            rootHub = busObj->busDeviceList;
3293:                            deviceObj = rootHub->nextDeviceObj;
00000030  00000000   NOP
3294:                            result = USB_HOST_RESULT_END_OF_DEVICE_LIST;
3295:                
3296:                            while(deviceObj != NULL)
0000003C  00000000   NOP
00000084  00000000   NOP
3297:                            {
3298:                                /* A device can be reported only if it is ready for interaction
3299:                                 * with the application. If we come across a device which is not
3300:                                 * ready, then we skip it */
3301:                                if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY)
00000044  00000000   NOP
00000058  00000000   NOP
3302:                                {
3303:                                    /* We have a device connected on the bus. Populate the device
3304:                                     * info object with details about this device */
3305:                                    deviceInfo->deviceObjHandle = deviceObj->deviceIdentifier;
00000050  00000000   NOP
00000060  00000000   NOP
3306:                                    deviceInfo->deviceAddress = deviceObj->deviceAddress;
00000068  00000000   NOP
3307:                                    deviceInfo->bus = USB_HOST_BUS_NUMBER(deviceObj->deviceIdentifier); 
00000070  00000000   NOP
3308:                                    result = USB_HOST_RESULT_SUCCESS;
3309:                                    break;
00000078  00000000   NOP
3310:                                }
3311:                                else
3312:                                {
3313:                                    deviceObj = deviceObj->nextDeviceObj;
00000080  00000000   NOP
3314:                                }
3315:                            }
3316:                        }
3317:                    }
3318:                    
3319:                    return(result);
3320:                }
000000AC  00000000   NOP
3321:                
3322:                // *****************************************************************************
3323:                /* Function:
3324:                    USB_HOST_RESULT USB_HOST_DeviceGetNext (USB_HOST_DEVICE_INFO * deviceInfo);
3325:                
3326:                  Summary:
3327:                    Returns information about the next device on the bus.
3328:                
3329:                  Description:
3330:                    This function returns information of the next device attached on the bus.
3331:                    The  USB_HOST_DeviceGetFirst() function should have been called at least once
3332:                    on the deviceInfo object.  Then calling this function repeatedly on the
3333:                    deviceInfo object will return information about the next attached device on
3334:                    the bus. When there are no more attached devices to report, the function
3335:                    returns USB_HOST_RESULT_END_OF_DEVICE_LIST.
3336:                
3337:                    Calling the USB_HOST_DeviceGetFirst() function on the deviceInfo object
3338:                    after the USB_HOST_DeviceGetNext() function has been called will cause the
3339:                    host to reset the deviceInfo object to point to the first attached device.
3340:                
3341:                  Remarks:
3342:                    None.
3343:                */
3344:                
3345:                USB_HOST_RESULT USB_HOST_DeviceGetNext (USB_HOST_DEVICE_INFO * deviceInfo)
3346:                {
3347:                    USB_HOST_RESULT result = USB_HOST_RESULT_SUCCESS;
3348:                    USB_HOST_DEVICE_OBJ * deviceObj = NULL;
3349:                    unsigned int index = 0;
3350:                
3351:                    if(NULL == deviceInfo)
00000000  00000000   NOP
3352:                    {
3353:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
00000088  00000000   NOP
3354:                    }
3355:                    else
3356:                    {
3357:                        /* Get the device index */
3358:                        index = USB_HOST_DEVICE_INDEX(deviceInfo->deviceObjHandle);
00000008  00000000   NOP
3359:                
3360:                        if(USB_HOST_DEVICES_NUMBER <= index)
00000010  00000000   NOP
3361:                        {
3362:                            /* Index is not valid. This should not happen unless the deviceInfo
3363:                             * has bee tampered with. */
3364:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
00000090  00000000   NOP
3365:                        }
3366:                        else
3367:                        {
3368:                            /* Get a pointer to the device object */
3369:                            deviceObj = &gUSBHostDeviceList[index];
3370:                
3371:                            /* Cross the PNP identifier against the PNP identifier of the device
3372:                             * that is in the device list. If they don't match then this means
3373:                             * that device was unplugged and another device has been connected
3374:                             * */
3375:                
3376:                            if(USB_HOST_PNP_IDENTIFIER(deviceInfo->deviceObjHandle) != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
00000018  00000000   NOP
3377:                            {
3378:                                result = USB_HOST_RESULT_DEVICE_UNKNOWN;
00000098  00000000   NOP
3379:                            }
3380:                            else 
3381:                            {
3382:                                /* Set default result */
3383:                                result = USB_HOST_RESULT_END_OF_DEVICE_LIST;
3384:                                deviceObj = deviceObj->nextDeviceObj;
00000028  00000000   NOP
3385:                                while(deviceObj != NULL)
00000030  00000000   NOP
00000078  00000000   NOP
3386:                                {
3387:                
3388:                                    if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY)
00000038  00000000   NOP
0000004C  00000000   NOP
3389:                                    {
3390:                                        deviceInfo->deviceObjHandle = deviceObj->deviceIdentifier;
00000044  00000000   NOP
00000054  00000000   NOP
3391:                                        deviceInfo->bus = USB_HOST_BUS_NUMBER(deviceObj->deviceIdentifier);
0000005C  00000000   NOP
3392:                                        deviceInfo->deviceAddress = deviceObj->deviceAddress;
00000064  00000000   NOP
3393:                                        result = USB_HOST_RESULT_SUCCESS;
3394:                                        break;
0000006C  00000000   NOP
3395:                                    }
3396:                                    else
3397:                                    {
3398:                                        deviceObj = deviceObj->nextDeviceObj;
00000074  00000000   NOP
3399:                                    }
3400:                                }
3401:                            }
3402:                        }
3403:                    }
3404:                
3405:                    return(result);
3406:                }
000000A0  00000000   NOP
3407:                
3408:                // *****************************************************************************
3409:                /* Function:
3410:                    USB_HOST_RESULT USB_HOST_EventHandlerSet
3411:                    (
3412:                        USB_HOST_EVENT_HANDLER * eventHandler,
3413:                        uintptr_t context
3414:                    )
3415:                
3416:                  Summary:
3417:                    USB Host Layer Event Handler Callback Function set function.
3418:                
3419:                  Description:
3420:                    This is the USB Host Layer Event Handler Callback Set function. An
3421:                    application can receive USB Host Layer events by using this function to
3422:                    register and event handler callback function. The application can
3423:                    additionally specify a specific context which will returned with the event
3424:                    handler callback function. The event handler must be set (this function must
3425:                    be called) before any of the USB buses are enabled.
3426:                
3427:                  Remarks:
3428:                    See usb_host.h for usage information.
3429:                */
3430:                
3431:                USB_HOST_RESULT USB_HOST_EventHandlerSet
3432:                (
3433:                    USB_HOST_EVENT_HANDLER  eventHandler,
3434:                    uintptr_t context
3435:                )
3436:                {
3437:                    /* Assign the event handler. The event handler can be NULL in which case the
3438:                     * host layer will not generate events. The context is returned along with
3439:                     * the event */
3440:                
3441:                    gUSBHostObj.hostEventHandler = eventHandler ;
9D0171F0  3C028001   LUI V0, -32767
9D0171F4  AC443DC8   SW A0, 15816(V0)
3442:                    gUSBHostObj.context = context ;
9D0171F8  24423DC8   ADDIU V0, V0, 15816
9D0171FC  AC450004   SW A1, 4(V0)
3443:                    return (USB_HOST_RESULT_SUCCESS);
3444:                }
9D017200  03E00008   JR RA
3445:                
3446:                // *****************************************************************************
3447:                /* Function:
3448:                    USB_HOST_RESULT USB_HOST_DeviceSpeedGet 
3449:                    (
3450:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle, 
3451:                        USB_SPEED * speed
3452:                    )
3453:                
3454:                  Summary:
3455:                    Returns the speed at which this device is operating.
3456:                
3457:                  Description:
3458:                    This function returns the speed at which this device is operating.
3459:                
3460:                  Precondition:
3461:                    The USB_HOST_Initialize() function should have been called. 
3462:                
3463:                  Parameters:
3464:                    deviceObjHandle - handle to the device whose speed is required.
3465:                
3466:                    speed - output parameter. Will contain the speed of the device if the
3467:                    function was successful.
3468:                    
3469:                  Returns:
3470:                    USB_HOST_RESULT_SUCCESS - The function was successful. speed will contain
3471:                    the speed of the device.
3472:                    USB_HOST_RESULT_DEVICE_UNKNOWN - The device does not exist in the system.
3473:                    speed will contain USB_SPEED_ERROR. 
3474:                    USB_HOST_RESULT_FAILURE - an unknown error occurred.
3475:                
3476:                  Example:
3477:                    <code>
3478:                    </code>
3479:                
3480:                  Remarks:
3481:                    None.
3482:                */
3483:                
3484:                USB_HOST_RESULT USB_HOST_DeviceSpeedGet 
3485:                ( 
3486:                    USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle, 
3487:                    USB_SPEED * speed
3488:                )
3489:                {
3490:                    USB_HOST_RESULT  result = USB_HOST_RESULT_SUCCESS;
00000030  00000000   NOP
3491:                    unsigned int index = 0;
3492:                    USB_HOST_DEVICE_OBJ * deviceObj = NULL;
3493:                
3494:                    /* Check if the parameter is NULL */
3495:                    if(NULL == speed)
00000000  00000000   NOP
3496:                    {
3497:                       result = USB_HOST_RESULT_PARAMETER_INVALID;
00000038  00000000   NOP
3498:                    }
3499:                    else
3500:                    {
3501:                       /* Check if the device index is valid */
3502:                        index = USB_HOST_DEVICE_INDEX(deviceObjHandle);
00000008  00000000   NOP
3503:                        if(USB_HOST_DEVICES_NUMBER <= index)
0000000C  00000000   NOP
3504:                        {
3505:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
00000040  00000000   NOP
3506:                        }
3507:                        else
3508:                        {
3509:                            /* Get the pointer to the device object */
3510:                            deviceObj = &gUSBHostDeviceList[index];
3511:                
3512:                            /* Validate the plug and play identifier */
3513:                            if(USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier ) != USB_HOST_PNP_IDENTIFIER(deviceObjHandle))
00000014  00000000   NOP
3514:                            {
3515:                                /* The device handle is pointing to a device that does not exist
3516:                                 * in the system */
3517:                                result = USB_HOST_RESULT_DEVICE_UNKNOWN;
3518:                            }
3519:                            else
3520:                            {
3521:                                /* Everything checks out. Return the device speed */
3522:                                *speed = deviceObj->speed;
00000024  00000000   NOP
3523:                            }
3524:                        }
3525:                    }
3526:                
3527:                    return(result);
3528:                }
00000048  00000000   NOP
3529:                
3530:                // *****************************************************************************
3531:                /* Function:
3532:                    USB_HOST_RESULT USB_HOST_BusEnable(USB_HOST_BUS bus)
3533:                
3534:                  Summary:
3535:                    Starts host operations.
3536:                
3537:                  Description:
3538:                    The function starts the operation of the USB Host Bus. It enables the root
3539:                    hub associated with specified bus and starts the process of detecting
3540:                    attached devices and enumerating them. The USB_HOST_EventHandlerSet()
3541:                    function should have been called to register an application host layer event
3542:                    handler before the Host layer is enabled (before the USB_HOST_BusEnable()
3543:                    function is called).  This will ensure that the application does not miss
3544:                    any host events.
3545:                
3546:                  Remarks:
3547:                    See usb_host.h for usage information.
3548:                */
3549:                
3550:                USB_HOST_RESULT USB_HOST_BusEnable(USB_HOST_BUS bus)
3551:                {
9D015C60  308400FF   ANDI A0, A0, 255
3552:                    USB_HOST_BUS_OBJ        *busObj;
3553:                    int                      hcCount;
3554:                    USB_HOST_RESULT          status = USB_HOST_RESULT_FALSE ;
3555:                
3556:                    /* Note that this function only sets the state of the bus object
3557:                     * to indicate that the bus needs will be enabled. The actual enabling is
3558:                     * performed in the USB Host Layer Tasks Routine. */
3559:                
3560:                    if ( bus == USB_HOST_BUS_ALL )
9D015C64  240200FF   ADDIU V0, ZERO, 255
9D015C68  14820009   BNE A0, V0, 0x9D015C90
9D015C6C  3C028001   LUI V0, -32767
3561:                    {
3562:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3563:                        {
3564:                            busObj  = &(gUSBHostBusList[hcCount]);
3565:                
3566:                            if(busObj->state < USB_HOST_BUS_STATE_ENABLING)
9D015C70  8C423D80   LW V0, 15744(V0)
9D015C74  2C420002   SLTIU V0, V0, 2
9D015C78  10400003   BEQ V0, ZERO, 0x9D015C88
9D015C7C  24030002   ADDIU V1, ZERO, 2
3567:                            {
3568:                                /* This means the bus is not enabled. Set the state to enable
3569:                                 * the bus. */
3570:                                busObj->state = USB_HOST_BUS_STATE_ENABLING ;
9D015C80  3C028001   LUI V0, -32767
9D015C84  AC433D80   SW V1, 15744(V0)
9D015C88  03E00008   JR RA
9D015C8C  24020001   ADDIU V0, ZERO, 1
3571:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d About to Open Root Hub Driver.", hcCount);
3572:                            }
3573:                            status  =   USB_HOST_RESULT_SUCCESS ;
3574:                        }
3575:                    }
3576:                    /* Enable specific bus */
3577:                    else
3578:                    {
3579:                        /* Validate bus number */
3580:                        if( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
9D015C90  5480000B   BNEL A0, ZERO, 0x9D015CC0
9D015C94  2402FFA6   ADDIU V0, ZERO, -90
3581:                        {
3582:                            status = USB_HOST_RESULT_BUS_UNKNOWN;
3583:                        }
3584:                        else
3585:                        {
3586:                            busObj  = &(gUSBHostBusList[bus]);
3587:                            if(busObj->state < USB_HOST_BUS_STATE_ENABLING)
9D015C98  3C028001   LUI V0, -32767
9D015C9C  8C433D80   LW V1, 15744(V0)
9D015CA0  2C630002   SLTIU V1, V1, 2
9D015CA4  10600006   BEQ V1, ZERO, 0x9D015CC0
9D015CA8  24020001   ADDIU V0, ZERO, 1
3588:                            {
3589:                                /* This means the bus is not enabled. Set the state to enable
3590:                                 * the bus. */
3591:                                busObj->state = USB_HOST_BUS_STATE_ENABLING ;
9D015CAC  24030002   ADDIU V1, ZERO, 2
9D015CB0  3C028001   LUI V0, -32767
9D015CB4  AC433D80   SW V1, 15744(V0)
3592:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d About to Open Root Hub Driver.", bus);
3593:                            }
3594:                            status = USB_HOST_RESULT_SUCCESS;
9D015CB8  03E00008   JR RA
9D015CBC  24020001   ADDIU V0, ZERO, 1
3595:                        }
3596:                    }
3597:                
3598:                    return ( status );
3599:                }
9D015CC0  03E00008   JR RA
3600:                
3601:                // *****************************************************************************
3602:                /* Function:
3603:                    USB_HOST_RESULT USB_HOST_BusIsEnabled(USB_HOST_BUS bus)
3604:                
3605:                  Summary:
3606:                    Checks if the bus is enabled.
3607:                
3608:                  Description:
3609:                    The function returns the enable status of the bus. It can be called after
3610:                    the USB_HOST_BusEnable() function is called, to check if the bus has been
3611:                    enabled yet. If the bus parameter is set to USB_HOST_BUS_ALL, then the
3612:                    function will check the enable status of all the busses and will return true
3613:                    only if all the busses are enabled.
3614:                
3615:                     Remarks:
3616:                    See usb_host.h for usage information.
3617:                
3618:                  Remarks:
3619:                    None.
3620:                */
3621:                
3622:                USB_HOST_RESULT USB_HOST_BusIsEnabled(USB_HOST_BUS bus)
3623:                {
9D0166A8  308400FF   ANDI A0, A0, 255
3624:                    USB_HOST_BUS_OBJ        *busObj;
3625:                    int                      hcCount;
3626:                    USB_HOST_RESULT          status = USB_HOST_RESULT_TRUE ;
3627:                
3628:                    if ( bus == USB_HOST_BUS_ALL )
9D0166AC  240200FF   ADDIU V0, ZERO, 255
9D0166B0  14820005   BNE A0, V0, 0x9D0166C8
9D0166B4  3C028001   LUI V0, -32767
3629:                    {
3630:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3631:                        {
3632:                            busObj  = &(gUSBHostBusList[hcCount]);
3633:                            if(busObj->state <= USB_HOST_BUS_STATE_WAIT_FOR_ENABLE_COMPLETE)
9D0166B8  8C423D80   LW V0, 15744(V0)
9D0166BC  2C420004   SLTIU V0, V0, 4
9D0166C0  03E00008   JR RA
9D0166C4  38420001   XORI V0, V0, 1
3634:                            {
3635:                                /* This means at least one bus is being enabled. And so all
3636:                                 * buses are not enabled yet. */
3637:                                status = USB_HOST_RESULT_FALSE;
3638:                                break;
3639:                            }
3640:                            else
3641:                            {
3642:                                /* The default value of status is USB_HOST_RESULT_TRUE */
3643:                            }
3644:                        }
3645:                    }
3646:                    else
3647:                    {
3648:                        /* Validate bus number */
3649:                        if( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
9D0166C8  14800006   BNE A0, ZERO, 0x9D0166E4
9D0166CC  00000000   NOP
3650:                        {
3651:                            status = USB_HOST_RESULT_BUS_UNKNOWN;
3652:                        }
3653:                        else
3654:                        {
3655:                            busObj  = &(gUSBHostBusList[bus]);
3656:                            if(busObj->state < USB_HOST_BUS_STATE_ENABLED)
9D0166D0  3C028001   LUI V0, -32767
9D0166D4  8C423D80   LW V0, 15744(V0)
9D0166D8  2C420004   SLTIU V0, V0, 4
9D0166DC  03E00008   JR RA
9D0166E0  38420001   XORI V0, V0, 1
3657:                            {
3658:                                /* The bus is in the process of being enabled or is not enabled
3659:                                 * at all. */
3660:                                status = USB_HOST_RESULT_FALSE;
3661:                            }
3662:                            else
3663:                            {
3664:                                /* The default value of status is USB_HOST_RESULT_TRUE */
3665:                            }
3666:                        }
3667:                    }
3668:                
3669:                    return ( status );
3670:                }
9D0166E4  03E00008   JR RA
3671:                
3672:                // *****************************************************************************
3673:                /* Function:
3674:                    USB_HOST_RESULT USB_HOST_BusSuspend (USB_HOST_BUS bus);
3675:                
3676:                  Summary:
3677:                    Suspends the bus.
3678:                
3679:                  Description:
3680:                    The function suspends the bus. All devices on the bus will be suspended. If
3681:                    bus  is specified as USB_HOST_BUS_ALL, all the buses managed by this host
3682:                    will be suspended.
3683:                
3684:                  Precondition:
3685:                    The USB_HOST_BusEnable() function should have been called to enable the bus.
3686:                
3687:                  Remarks:
3688:                    See usb_host.h for usage information.
3689:                */
3690:                
3691:                USB_HOST_RESULT USB_HOST_BusSuspend (USB_HOST_BUS bus)
3692:                {
00000000  00000000   NOP
3693:                    USB_HOST_BUS_OBJ        *busObj;
3694:                    int                     hcCount;
3695:                    USB_HOST_RESULT         status = USB_HOST_RESULT_SUCCESS ;
0000006C  00000000   NOP
3696:                
3697:                    if ( bus == USB_HOST_BUS_ALL )
00000004  00000000   NOP
3698:                    {
3699:                        /* Suspend all USB busses in the system */
3700:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3701:                        {
3702:                            busObj  = &(gUSBHostBusList[hcCount]);
3703:                
3704:                            if( busObj->state < USB_HOST_BUS_STATE_ENABLED )
00000010  00000000   NOP
3705:                            {
3706:                                /* This means the bus is not enabled yet */
3707:                                status = USB_HOST_RESULT_BUS_NOT_ENABLED;
00000074  00000000   NOP
3708:                                break;
3709:                            }
3710:                            else if(busObj->state > USB_HOST_BUS_STATE_ENABLED)
00000020  00000000   NOP
3711:                            {
3712:                                /* This means the bus is already being suspended or is in a
3713:                                 * suspended state. */
3714:                            }
3715:                            else 
3716:                            {
3717:                                /* This means the bus is in enabled state. Set the state to
3718:                                 * suspending */
3719:                                busObj->state = USB_HOST_BUS_STATE_SUSPENDING;
0000002C  00000000   NOP
3720:                            }
3721:                        }
3722:                    }
3723:                    else
3724:                    {
3725:                        /* Suspend a specific bus. Validate bus number */
3726:                        if( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
0000003C  00000000   NOP
3727:                        {
3728:                            status = USB_HOST_RESULT_BUS_UNKNOWN;
0000007C  00000000   NOP
3729:                        }
3730:                        else
3731:                        {   /* Set a state for enabling will be in task routine */
3732:                            busObj  = &(gUSBHostBusList[bus]);
3733:                
3734:                            if( busObj->state < USB_HOST_BUS_STATE_ENABLED )
00000044  00000000   NOP
3735:                            {
3736:                                /* This means the bus is not enabled yet */
3737:                                status = USB_HOST_RESULT_BUS_NOT_ENABLED;
00000084  00000000   NOP
3738:                            }
3739:                            else if(busObj->state > USB_HOST_BUS_STATE_ENABLED)
00000058  00000000   NOP
3740:                            {
3741:                                /* This means the bus is already being suspended or is in a
3742:                                 * suspended state. */
3743:                            }
3744:                            else 
3745:                            {
3746:                                /* This means the bus is in enabled state. Set the state to
3747:                                 * suspending */
3748:                                busObj->state = USB_HOST_BUS_STATE_SUSPENDING;
00000060  00000000   NOP
3749:                            }
3750:                        }
3751:                    }
3752:                
3753:                    return ( status );
3754:                }
00000088  00000000   NOP
3755:                
3756:                // *****************************************************************************
3757:                /* Function:
3758:                    USB_HOST_RESULT USB_HOST_BusIsSuspended (USB_HOST_BUS bus)
3759:                
3760:                  Summary:
3761:                    Returns the suspend status of the bus.
3762:                
3763:                  Description:
3764:                    This function returns suspend status of the specified USB bus. This function
3765:                    can be used to check the completion of the Resume operation started by using
3766:                    the USB_HOST_BusResume() function. If the Resume signaling has completed,
3767:                    the USB_HOST_BusIsSuspended() function would return USB_HOST_RESULT_FALSE
3768:                    indicating that the bus is not suspended.  Calling the
3769:                    USB_HOST_BusIsSuspended() with bus specified as USB_HOST_BUS_ALL returns the
3770:                    suspend status of the all USB segments that are managed by the host layer.
3771:                    The function would return USB_HOST_RESULT_TRUE only if all the bus are in a
3772:                    suspended state.
3773:                
3774:                Remarks:
3775:                    See usb_host.h for usage information.
3776:                */
3777:                
3778:                USB_HOST_RESULT USB_HOST_BusIsSuspended (USB_HOST_BUS bus)
3779:                {
00000000  00000000   NOP
3780:                    USB_HOST_BUS_OBJ    *busObj;
3781:                    int                 hcCount;
3782:                    USB_HOST_RESULT     status = USB_HOST_RESULT_SUCCESS ;
3783:                
3784:                    if ( bus == USB_HOST_BUS_ALL )
00000004  00000000   NOP
3785:                    {
3786:                        /* Check if all USB busses are suspended */
3787:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3788:                        {
3789:                            busObj  = &(gUSBHostBusList[hcCount]);
3790:                            if( busObj->state < USB_HOST_BUS_STATE_ENABLED)
00000010  00000000   NOP
3791:                            {
3792:                                /* Bus is not enabled yet */
3793:                                status = USB_HOST_RESULT_BUS_NOT_ENABLED ;
00000054  00000000   NOP
3794:                                break;
3795:                            }
3796:                            else if(busObj->state <= USB_HOST_BUS_STATE_SUSPENDING)
00000020  00000000   NOP
3797:                            {
3798:                                /* Bus is not suspended */
3799:                                status = USB_HOST_RESULT_FALSE;
3800:                                break;
3801:                            }
3802:                            else
3803:                            {
3804:                                /* No action required */
3805:                            }
3806:                        }
3807:                    }
3808:                    else
3809:                    {
3810:                        /* Check if this bus is suspended. Validate the bus number */
3811:                        if ( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
0000002C  00000000   NOP
3812:                        {
3813:                            status = USB_HOST_RESULT_BUS_UNKNOWN ;
0000005C  00000000   NOP
3814:                        }
3815:                        else
3816:                        {
3817:                            busObj  = &(gUSBHostBusList[bus]);
3818:                            if( busObj->state < USB_HOST_BUS_STATE_ENABLED)
00000034  00000000   NOP
3819:                            {
3820:                                /* Bus is not enabled yet */
3821:                                status = USB_HOST_RESULT_BUS_NOT_ENABLED ;
3822:                            }
3823:                            else if(busObj->state < USB_HOST_BUS_STATE_SUSPENDED)
00000048  00000000   NOP
3824:                            {
3825:                                /* Bus is not suspended */
3826:                                status = USB_HOST_RESULT_FALSE;
3827:                            }
3828:                            else
3829:                            {
3830:                                /* No action required */
3831:                            }
3832:                        }
3833:                    }
3834:                
3835:                    return ( status );
3836:                }
00000064  00000000   NOP
3837:                
3838:                // *****************************************************************************
3839:                /* Function:
3840:                    USB_HOST_RESULT USB_HOST_BusResume (USB_HOST_BUS bus);
3841:                
3842:                  Summary:
3843:                    Resumes the bus.
3844:                
3845:                  Description:
3846:                    The function resumes the bus. All devices on the bus will be receive resume
3847:                    signaling. If bus is specified as USB_HOST_BUS_ALL, all the buses managed by
3848:                    this host will be resumed.
3849:                
3850:                  Remarks:
3851:                    See usb_host.h for usage information.
3852:                */
3853:                
3854:                USB_HOST_RESULT USB_HOST_BusResume (USB_HOST_BUS bus)
3855:                {
3856:                    /* This function is not implemented in this release of the USB Host Layer */
3857:                
3858:                    USB_HOST_RESULT status = USB_HOST_RESULT_FAILURE ;
3859:                
3860:                    return status;
3861:                }
00000000  00000000   NOP
3862:                
3863:                // *****************************************************************************
3864:                /* Function:
3865:                    USB_HOST_DEVICE_OBJ_HANDLE USB_HOST_DeviceEnumerate
3866:                    (
3867:                        USB_HOST_DEVICE_OBJ_HANDLE parentHubObjHandle, 
3868:                        uint8_t port 
3869:                    );
3870:                
3871:                  Summary:
3872:                    This function will request the host layer to enumerate an attached device.
3873:                
3874:                  Description:
3875:                    This function will request the host layer to enumerate an attached device.
3876:                    It is called by the hub driver or the root hub when a device is attached.The
3877:                    function will return a device object handle to the caller. The caller must
3878:                    specify this handle when the device is detached.
3879:                
3880:                  Remarks:
3881:                    Refer to usb_host_client_driver.h for usage information.
3882:                */
3883:                
3884:                USB_HOST_DEVICE_OBJ_HANDLE USB_HOST_DeviceEnumerate
3885:                (
3886:                    USB_HOST_DEVICE_OBJ_HANDLE parentDeviceIdentifier, 
3887:                    uint8_t port
3888:                )
3889:                {
9D00D89C  27BDFFD0   ADDIU SP, SP, -48
9D00D8A0  AFBF002C   SW RA, 44(SP)
9D00D8A4  AFB50028   SW S5, 40(SP)
9D00D8A8  AFB40024   SW S4, 36(SP)
9D00D8AC  AFB30020   SW S3, 32(SP)
9D00D8B0  AFB2001C   SW S2, 28(SP)
9D00D8B4  AFB10018   SW S1, 24(SP)
9D00D8B8  AFB00014   SW S0, 20(SP)
9D00D8BC  00808021   ADDU S0, A0, ZERO
3890:                    bool pnpIsUnique;
3891:                    uint32_t busNumber;
3892:                    uint32_t deviceCount;
3893:                    USB_HOST_BUS_OBJ * busObj;
3894:                    uint8_t parentDeviceNumber;
3895:                    USB_HOST_DEVICE_OBJ * newDeviceObj = NULL,* parentDeviceObj;
9D00D918  00003821   ADDU A3, ZERO, ZERO
3896:                    USB_HOST_DEVICE_OBJ  * deviceObj;
3897:                    bool interruptWasEnabled;
3898:                    USB_HOST_DEVICE_OBJ_HANDLE result = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
9D00DA70  2402FFFF   ADDIU V0, ZERO, -1
3899:                    USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor = NULL;
9D00D914  00008821   ADDU S1, ZERO, ZERO
3900:                
3901:                    /* Get the bus number and the device object index of the parent device. This
3902:                     * is needed to get the bus object and the parent device object */
3903:                
3904:                    busNumber =  USB_HOST_BUS_NUMBER(parentDeviceIdentifier ); 
3905:                    parentDeviceNumber = USB_HOST_DEVICE_INDEX(parentDeviceIdentifier );
3906:                    parentDeviceObj =  & gUSBHostDeviceList [ parentDeviceNumber ];
9D00D940  00041100   SLL V0, A0, 4
9D00D944  00041980   SLL V1, A0, 6
9D00D948  00621823   SUBU V1, V1, V0
9D00D94C  000310C0   SLL V0, V1, 3
9D00D950  00621821   ADDU V1, V1, V0
9D00D954  3C028001   LUI V0, -32767
9D00D958  24423A18   ADDIU V0, V0, 14872
9D00D95C  00431821   ADDU V1, V0, V1
3907:                    busObj  = &(gUSBHostBusList[busNumber]);
9D00D960  000A2100   SLL A0, T2, 4
9D00D964  000A1180   SLL V0, T2, 6
9D00D968  00821021   ADDU V0, A0, V0
9D00D96C  3C068001   LUI A2, -32767
9D00D970  24C63D78   ADDIU A2, A2, 15736
9D00D974  00C23021   ADDU A2, A2, V0
3908:                
3909:                    /* We disable all interrupts here. When a hub is attached, this function 
3910:                     * will be called from the IRP callback of the hub driver status IRP. This
3911:                     * callback runs in an interrupt context. We want the process of assigning
3912:                     * a device object to be atomic */
3913:                
3914:                    interruptWasEnabled = SYS_INT_Disable();
9D00D8C0  0F405C0B   JAL SYS_INT_Disable
9D00D8C4  30B200FF   ANDI S2, A1, 255
9D00D8C8  00409821   ADDU S3, V0, ZERO
3915:                
3916:                    /* Now search for a free device object. The search must start from the
3917:                     * USB_HOST_CONTROLLER_NUMBERS because the first set of device objects in
3918:                     * the device object array are reserved for root hub devices. */
3919:                
3920:                    for (deviceCount = USB_HOST_CONTROLLERS_NUMBER; 
3921:                            deviceCount < (USB_HOST_DEVICES_NUMBER + USB_HOST_CONTROLLERS_NUMBER); deviceCount ++ )
3922:                    {
3923:                        if (gUSBHostDeviceList[deviceCount].inUse == false )
9D00D8CC  3C028001   LUI V0, -32767
9D00D8D0  90423BC8   LBU V0, 15304(V0)
9D00D8D4  5440000F   BNEL V0, ZERO, 0x9D00D914
9D00D8D8  240B0002   ADDIU T3, ZERO, 2
3924:                        {
3925:                            /* This means we found a new object. Grab it and stop the search */
3926:                            newDeviceObj = &gUSBHostDeviceList[deviceCount];
3927:                
3928:                            /* Before we reset this object to zero, we must make a backup of the
3929:                             * configuration descriptor pointer, so that we can free this memory
3930:                             * before we start the enumeration process. The memory cannot be
3931:                             * freed here because this function is called in an interrupt
3932:                             * function. */
3933:                
3934:                            configurationDescriptor = newDeviceObj->configDescriptorInfo.configurationDescriptor;
9D00D8DC  3C158001   LUI S5, -32767
9D00D8E0  26B53A18   ADDIU S5, S5, 14872
9D00D8E4  8EB102B0   LW S1, 688(S5)
3935:                
3936:                            /* Completely clear up this object */
3937:                            memset (newDeviceObj, 0, sizeof(USB_HOST_DEVICE_OBJ));
9D00D8E8  3C148001   LUI S4, -32767
9D00D8EC  26943BC8   ADDIU S4, S4, 15304
9D00D8F0  02802021   ADDU A0, S4, ZERO
9D00D8F4  00002821   ADDU A1, ZERO, ZERO
9D00D8F8  0F405189   JAL memset
9D00D8FC  240601B0   ADDIU A2, ZERO, 432
3938:                
3939:                            /* Grab this object */
3940:                            newDeviceObj->inUse  = true;
9D00D900  24020001   ADDIU V0, ZERO, 1
9D00D904  A2A201B0   SB V0, 432(S5)
3941:                            break;
9D00D908  240B0001   ADDIU T3, ZERO, 1
9D00D90C  0B403647   J 0x9D00D91C
9D00D910  02803821   ADDU A3, S4, ZERO
3942:                        }
3943:                    }
3944:                
3945:                    /* We can now enable the interrupts */
3946:                    if(interruptWasEnabled)
9D00D91C  12600005   BEQ S3, ZERO, 0x9D00D934
9D00D920  00000000   NOP
3947:                    {
3948:                        SYS_INT_Enable();
3949:                    }
3950:                
3951:                    if(newDeviceObj != NULL)
9D00D934  10E0004E   BEQ A3, ZERO, 0x9D00DA70
9D00D938  7E0A3A00   EXT T2, S0, 8, 8
9D00D93C  320400FF   ANDI A0, S0, 255
3952:                    {
3953:                        /* This means we found a device object. Initialize the new device
3954:                         * object. The HCD interface will be always the HCD interface of the
3955:                         * parent */
3956:                
3957:                        newDeviceObj->hcdInterface = parentDeviceObj->hcdInterface;
9D00D978  8C62006C   LW V0, 108(V1)
9D00D97C  ACE2006C   SW V0, 108(A3)
3958:                        newDeviceObj->devicePort = port; 
9D00D980  A0F20075   SB S2, 117(A3)
3959:                        if (parentDeviceObj->deviceAddress == USB_HOST_ROOT_HUB_ADDRESS )
9D00D984  90640060   LBU A0, 96(V1)
9D00D988  24020001   ADDIU V0, ZERO, 1
9D00D98C  54820008   BNEL A0, V0, 0x9D00D9B0
9D00D990  ACE00070   SW ZERO, 112(A3)
3960:                        {
3961:                            /* If the parent device is the root hub, the hub interface for
3962:                             * the device should be root hub interface */
3963:                            newDeviceObj->hubInterface = &(parentDeviceObj->hcdInterface->rootHubInterface.rootHubPortInterface);
9D00D994  8C62006C   LW V0, 108(V1)
9D00D998  2442003C   ADDIU V0, V0, 60
9D00D99C  ACE20070   SW V0, 112(A3)
3964:                            newDeviceObj->hubAddress = 0;
9D00D9A0  A0E00074   SB ZERO, 116(A3)
3965:                            newDeviceObj->hubHandle = busObj->hcdHandle;
9D00D9A4  8CC20000   LW V0, 0(A2)
9D00D9A8  0B40366F   J 0x9D00D9BC
9D00D9AC  ACE20068   SW V0, 104(A3)
3966:                
3967:                        }
3968:                        else
3969:                        {
3970:                            /* If the parent device is a hub, then the hub interface for the
3971:                             * device should be the external hub interface */
3972:                
3973:                            newDeviceObj->hubInterface = USB_HOST_HUB_INTERFACE;
3974:                            newDeviceObj->hubAddress = parentDeviceObj->deviceAddress;
9D00D9B0  90620060   LBU V0, 96(V1)
9D00D9B4  A0E20074   SB V0, 116(A3)
3975:                            newDeviceObj->hubHandle = parentDeviceIdentifier;
9D00D9B8  ACF00068   SW S0, 104(A3)
3976:                        }
3977:                
3978:                        /* These members of the device object need to be initialized to specific
3979:                         * values */
3980:                        newDeviceObj->parentDeviceIdentifier = parentDeviceIdentifier;
9D00D9BC  ACF00054   SW S0, 84(A3)
3981:                        newDeviceObj->hcdHandle = busObj->hcdHandle;
9D00D9C0  8CC20000   LW V0, 0(A2)
9D00D9C4  ACE20064   SW V0, 100(A3)
3982:                        newDeviceObj->deviceAddress = USB_HOST_DEFAULT_ADDRESS ;
9D00D9C8  A0E00060   SB ZERO, 96(A3)
3983:                        newDeviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
9D00D9CC  ACE000F0   SW ZERO, 240(A3)
3984:                        newDeviceObj->tplEntryTried = -1;
9D00D9D0  2403FFFF   ADDIU V1, ZERO, -1
9D00D9D4  ACE300E4   SW V1, 228(A3)
3985:                        newDeviceObj->deviceClScPTried = -1;
9D00D9D8  ACE300E8   SW V1, 232(A3)
3986:                        newDeviceObj->configDescriptorInfo.configurationNumber = USB_HOST_CONFIGURATION_NUMBER_INVALID;
9D00D9DC  A0E301A5   SB V1, 421(A3)
3987:                
3988:                        /* Note that this memory address that is being assigned here will be
3989:                         * freed up before the enumeration process starts. */
3990:                        newDeviceObj->configDescriptorInfo.configurationDescriptor = configurationDescriptor;
9D00D9E0  ACF10100   SW S1, 256(A3)
3991:                
3992:                        /* Allocate a Plug N Play identifier. This identifier will be unique
3993:                         * to the attached device. It counts upwards and only repeats after
3994:                         * 0xFFFE. */
3995:                
3996:                        do
3997:                        {
3998:                            /* Increment the pnpIdentifier. */
3999:                            busObj->pnpIdentifier ++;
9D00D9F0  94C20048   LHU V0, 72(A2)
9D00D9F4  24420001   ADDIU V0, V0, 1
9D00D9F8  3042FFFF   ANDI V0, V0, -1
4000:                
4001:                            if(busObj->pnpIdentifier == 0xFFFE)
9D00D9E8  3408FFFE   ORI T0, ZERO, -2
9D00D9FC  50480002   BEQL V0, T0, 0x9D00DA08
9D00DA00  A4C90048   SH T1, 72(A2)
9D00DA04  A4C20048   SH V0, 72(A2)
4002:                            {
4003:                                /* Rollover to start from 1 */
4004:                                busObj->pnpIdentifier = 1;
9D00D9EC  24090001   ADDIU T1, ZERO, 1
4005:                            }
4006:                
4007:                            /* Check if this identifier is used by any device on this bus
4008:                             * */
4009:                
4010:                            deviceObj = busObj->busDeviceList;
9D00D9E4  8CC50010   LW A1, 16(A2)
4011:                            pnpIsUnique = true;
4012:                            while(deviceObj != NULL)
9D00DA08  50A0000D   BEQL A1, ZERO, 0x9D00DA40
9D00DA0C  8CA201A8   LW V0, 424(A1)
9D00DA34  5440FFFC   BNEL V0, ZERO, 0x9D00DA28
9D00DA38  9443004E   LHU V1, 78(V0)
4013:                            {
4014:                                if(USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier) == busObj->pnpIdentifier)
9D00DA10  94C40048   LHU A0, 72(A2)
9D00DA14  94A2004E   LHU V0, 78(A1)
9D00DA18  1044FFF5   BEQ V0, A0, 0x9D00D9F0
9D00DA1C  00A01021   ADDU V0, A1, ZERO
9D00DA28  5064FFF2   BEQL V1, A0, 0x9D00D9F4
9D00DA2C  94C20048   LHU V0, 72(A2)
4015:                                {
4016:                                    /* The proposed PNP is already in use. Stop scanning */
4017:                                    pnpIsUnique = false;
4018:                                    break;
4019:                                }
4020:                                else
4021:                                {
4022:                                    /* Get the next device */
4023:                                    deviceObj = deviceObj->nextDeviceObj;
9D00DA20  0B40368D   J 0x9D00DA34
9D00DA24  8C4201A8   LW V0, 424(V0)
9D00DA30  8C4201A8   LW V0, 424(V0)
4024:                                }
4025:                            }
4026:                        } while(pnpIsUnique == false);
4027:                
4028:                        /* Add this object to the bus device list */
4029:                        deviceObj = busObj->busDeviceList;
4030:                
4031:                        /* Get to the end of the list */
4032:                        while( deviceObj->nextDeviceObj != NULL )
9D00DA3C  8CA201A8   LW V0, 424(A1)
9D00DA40  50400003   BEQL V0, ZERO, 0x9D00DA50
9D00DA44  ACA701A8   SW A3, 424(A1)
4033:                        {
4034:                            deviceObj = deviceObj->nextDeviceObj;
9D00DA48  0B40368F   J 0x9D00DA3C
9D00DA4C  00402821   ADDU A1, V0, ZERO
4035:                        }
4036:                
4037:                        /* Add the object */
4038:                        deviceObj->nextDeviceObj = newDeviceObj;
4039:                
4040:                        /* Create the device object handle */
4041:                        newDeviceObj->deviceIdentifier = _USB_HOST_DeviceObjHandleGet(busObj->pnpIdentifier, busNumber, deviceCount);
9D00DA50  000A5200   SLL T2, T2, 8
9D00DA54  94C20048   LHU V0, 72(A2)
9D00DA58  00021400   SLL V0, V0, 16
9D00DA5C  01421025   OR V0, T2, V0
9D00DA60  004B1025   OR V0, V0, T3
9D00DA64  ACE2004C   SW V0, 76(A3)
9D00DA68  0B40369D   J 0x9D00DA74
9D00DA6C  ACE20050   SW V0, 80(A3)
4042:                        newDeviceObj->deviceClientHandle = newDeviceObj->deviceIdentifier;
4043:                
4044:                        /* Update result */
4045:                        result = newDeviceObj->deviceIdentifier;
4046:                    }
4047:                    else
4048:                    {
4049:                        /* We could not find a spare device object */
4050:                        SYS_DEBUG_MESSAGE( SYS_ERROR_INFO , "USB_HOST_DeviceEnumerate : Max Devices connected  \r\n");
4051:                    }
4052:                
4053:                    return(result);
4054:                }
9D00DA74  8FBF002C   LW RA, 44(SP)
4055:                
4056:                // *****************************************************************************
4057:                /* Function:
4058:                    void USB_HOST_DeviceDenumerate
4059:                    ( 
4060:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
4061:                    );
4062:                
4063:                  Summary:
4064:                    De-enumerates an attached device.
4065:                
4066:                  Description:
4067:                    This function de-enumerates an attached device. This function is called by the
4068:                    USB_HOST_DeviceDenumerate() function which in turn is called by the root hub
4069:                    or the external hub when a device is detached. The deviceObjHandle is the
4070:                    handle of the device that was detached. This is the same handle that was
4071:                    returned by the USB_HOST_DeviceEnumerate() function. This function will
4072:                    release the device and interface level drivers. It will then remove the
4073:                    object from the bus list and will deallocate the device object.
4074:                
4075:                    If the object to be removed is a hub, the hub driver will call the
4076:                    USB_HOST_DeviceDenumerate() function for all its ports. This function will
4077:                    not search for child devices when a parent is removed.
4078:                
4079:                  Remarks:
4080:                    This is a local function and should not be called directly by the
4081:                    application.
4082:                */
4083:                
4084:                void USB_HOST_DeviceDenumerate( USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle )
4085:                {
9D010514  27BDFFD8   ADDIU SP, SP, -40
9D010518  AFBF0024   SW RA, 36(SP)
9D01051C  AFB30020   SW S3, 32(SP)
9D010520  AFB2001C   SW S2, 28(SP)
9D010524  AFB10018   SW S1, 24(SP)
9D010528  AFB00014   SW S0, 20(SP)
4086:                    USB_HOST_DEVICE_OBJ  * prevDeviceObj, * deviceObj, * deleteDeviceObj;
4087:                    USB_HOST_BUS_OBJ * busObj;
4088:                    USB_HOST_CONFIGURATION_INFO * configurationInfo;
4089:                    int index, busIndex;
4090:                    bool interruptIsEnabled;
4091:                    
4092:                    /* Check if the device object handle is valid. */
4093:                    if(deviceObjHandle != USB_HOST_DEVICE_OBJ_HANDLE_INVALID)
9D01052C  2402FFFF   ADDIU V0, ZERO, -1
9D010530  1082004A   BEQ A0, V0, 0x9D01065C
9D010534  00808821   ADDU S1, A0, ZERO
4094:                    {
4095:                        /* Get the device index from the device object handle */
4096:                        index = USB_HOST_DEVICE_INDEX(deviceObjHandle);
9D010538  308300FF   ANDI V1, A0, 255
4097:                        deviceObj = &gUSBHostDeviceList[index];
9D01053C  00032100   SLL A0, V1, 4
9D010540  00031180   SLL V0, V1, 6
9D010544  00441023   SUBU V0, V0, A0
9D010548  000280C0   SLL S0, V0, 3
9D01054C  00501021   ADDU V0, V0, S0
9D010550  3C108001   LUI S0, -32767
9D010554  26103A18   ADDIU S0, S0, 14872
4098:                
4099:                        /* It is possible that this function can be called from two paths. The
4100:                         * main is the device detach path. The other path is the device
4101:                         * malfunction (possibly due to over current). The device malfunction
4102:                         * path will be detected in the Host Task routine context. But the
4103:                         * device detach path occurs in an interrupt context. We cannot allow
4104:                         * multiple entries on the same device. This may occur especially in the
4105:                         * case of a root hub, where the root hub driver will disable the power
4106:                         * to the device when it detects an overcurrent situation, but disabling
4107:                         * the power which may also cause a device detach interrupt, in which
4108:                         * case this function will re-enter with the same device object handle.
4109:                         * Hence we make this a critical section */
4110:                
4111:                        interruptIsEnabled = SYS_INT_Disable();
9D010558  0F405C0B   JAL SYS_INT_Disable
9D01055C  02028021   ADDU S0, S0, V0
9D010560  00409021   ADDU S2, V0, ZERO
4112:                        
4113:                        if(deviceObj->inUse)
9D010564  92020000   LBU V0, 0(S0)
9D010568  10400036   BEQ V0, ZERO, 0x9D010644
9D01056C  7E223A00   EXT V0, S1, 8, 8
4114:                        {
4115:                            busIndex = USB_HOST_BUS_NUMBER(deviceObjHandle);
4116:                            busObj = &gUSBHostBusList[busIndex];
9D010570  00029900   SLL S3, V0, 4
9D010574  00021180   SLL V0, V0, 6
9D010578  02621021   ADDU V0, S3, V0
9D01057C  3C138001   LUI S3, -32767
9D010580  26733D78   ADDIU S3, S3, 15736
9D010584  02629821   ADDU S3, S3, V0
4117:                            deleteDeviceObj = deviceObj;
4118:                
4119:                            /* If there is device level client driver, then release the client driver */
4120:                            if(deviceObj->deviceClientDriver != NULL )
9D010588  8E0200E0   LW V0, 224(S0)
9D01058C  50400005   BEQL V0, ZERO, 0x9D0105A4
9D010590  8E020100   LW V0, 256(S0)
4121:                            {
4122:                                deviceObj->deviceClientDriver->deviceRelease( deviceObj->deviceClientHandle);
9D010594  8C420010   LW V0, 16(V0)
9D010598  0040F809   JALR V0
9D01059C  8E040050   LW A0, 80(S0)
4123:                            }
4124:                
4125:                            /* Get the configuration information */
4126:                            configurationInfo = &(deviceObj->configDescriptorInfo);
4127:                
4128:                            if(configurationInfo->configurationDescriptor != NULL)
9D0105A0  8E020100   LW V0, 256(S0)
9D0105A4  50400004   BEQL V0, ZERO, 0x9D0105B8
9D0105A8  8E02006C   LW V0, 108(S0)
4129:                            {
4130:                                /* For each interface in the configuration, if the interface is assigned to
4131:                                 * client driver, then release these client drivers. */
4132:                
4133:                                _USB_HOST_ReleaseInterfaceDrivers(deviceObj); 
9D0105AC  0F40555C   JAL _USB_HOST_ReleaseInterfaceDrivers
9D0105B0  02002021   ADDU A0, S0, ZERO
4134:                            }
4135:                
4136:                            /* Close the control pipe */
4137:                            deviceObj->hcdInterface->hostPipeClose ( deviceObj->controlPipeHandle );
9D0105B4  8E02006C   LW V0, 108(S0)
9D0105B8  8C420020   LW V0, 32(V0)
9D0105BC  0040F809   JALR V0
9D0105C0  8E040058   LW A0, 88(S0)
4138:                            deviceObj->controlPipeHandle  = DRV_USB_HOST_PIPE_HANDLE_INVALID;
9D0105C4  2402FFFF   ADDIU V0, ZERO, -1
9D0105C8  AE020058   SW V0, 88(S0)
4139:                
4140:                            /* Release address */
4141:                            _USB_HOST_FreeAddress (deviceObj->deviceIdentifier);
9D0105CC  0F405674   JAL _USB_HOST_FreeAddress
9D0105D0  8E04004C   LW A0, 76(S0)
4142:                
4143:                            /* Any dynamic memory that is allocated to the device is released
4144:                             * when the device object is used again. The denumerate function
4145:                             * which could be called from an interrupt context is really a bad
4146:                             * place to free up memory. */
4147:                
4148:                            /* If this device was enumerating then release the enumeration flag */
4149:                            if((busObj->deviceIsEnumerating) && (busObj->enumeratingDeviceIdentifier == deviceObjHandle))
9D0105D4  92620015   LBU V0, 21(S3)
9D0105D8  50400005   BEQL V0, ZERO, 0x9D0105F0
9D0105DC  8E620010   LW V0, 16(S3)
9D0105E0  8E62004C   LW V0, 76(S3)
9D0105E4  50510001   BEQL V0, S1, 0x9D0105EC
9D0105E8  A2600015   SB ZERO, 21(S3)
4150:                            {
4151:                                /* Clear the enumerating flag, so that we can let other device
4152:                                 * enumerate */
4153:                                busObj->deviceIsEnumerating = false;
4154:                            }
4155:                
4156:                            /* The device needs to be removed from the bus list. The first device in the
4157:                             * bus list is the root hub. So prevDeviceObj here is the root hub device.
4158:                             * */ 
4159:                            prevDeviceObj = busObj->busDeviceList;
9D0105EC  8E620010   LW V0, 16(S3)
9D010604  0B404187   J 0x9D01061C
9D010608  00402821   ADDU A1, V0, ZERO
4160:                
4161:                            /* The device connect to the root hub is the device attached to the bus. */
4162:                            deviceObj = prevDeviceObj->nextDeviceObj;
9D0105F0  8C4501A8   LW A1, 424(V0)
4163:                
4164:                            while(deviceObj != NULL)
9D0105F4  10A00012   BEQ A1, ZERO, 0x9D010640
9D0105F8  00A01821   ADDU V1, A1, ZERO
9D010630  1460FFF6   BNE V1, ZERO, 0x9D01060C
9D010634  00000000   NOP
4165:                            {
4166:                                /* Check if this is the object to delete */
4167:                                if ( deleteDeviceObj == deviceObj  )
9D0105FC  5605000C   BNEL S0, A1, 0x9D010630
9D010600  8CA301A8   LW V1, 424(A1)
9D01060C  52030004   BEQL S0, V1, 0x9D010620
9D010610  8C6201A8   LW V0, 424(V1)
4168:                                {
4169:                                    /* Remove this device from the linked list */
4170:                                    prevDeviceObj->nextDeviceObj = deviceObj->nextDeviceObj ;
9D01061C  8C6201A8   LW V0, 424(V1)
9D010620  ACA201A8   SW V0, 424(A1)
4171:                
4172:                                    /* Clear the nextDeviceObj of the deleted device object */
4173:                                    deleteDeviceObj->nextDeviceObj = NULL;
4174:                                    break;
9D010624  0B404190   J 0x9D010640
9D010628  AE0001A8   SW ZERO, 424(S0)
4175:                                }
4176:                                else
4177:                                {
4178:                                    /* Else continue search till we have reached end of the list */
4179:                                    prevDeviceObj = deviceObj;
4180:                                    deviceObj = deviceObj->nextDeviceObj;
9D010614  0B40418B   J 0x9D01062C
9D010618  00602821   ADDU A1, V1, ZERO
9D01062C  8CA301A8   LW V1, 424(A1)
4181:                                }
4182:                            }
4183:                
4184:                            /* Deallocate the device object */
4185:                            deviceObj->inUse = false;
9D010638  0B404191   J 0x9D010644
9D01063C  A0600000   SB ZERO, 0(V1)
9D010640  A0600000   SB ZERO, 0(V1)
4186:                        }
4187:                        else
4188:                        {
4189:                            /* This means this object is not valid any more. We should not have
4190:                             * to do anything */
4191:                        }
4192:                        
4193:                        if(interruptIsEnabled)
9D010644  12400006   BEQ S2, ZERO, 0x9D010660
9D010648  8FBF0024   LW RA, 36(SP)
4194:                        {
4195:                            SYS_INT_Enable();
4196:                        }
4197:                    }
4198:                    else
4199:                    {
4200:                        /* The device object handle is not valid. We don't have to do anything */
4201:                    }
4202:                }
9D01065C  8FBF0024   LW RA, 36(SP)
4203:                
4204:                // *****************************************************************************
4205:                /* Function:
4206:                    void USB_HOST_Tasks (SYS_MODULE_OBJ object );
4207:                
4208:                  Summary:
4209:                    Maintains the USB Host Layer state machine.
4210:                
4211:                  Description:
4212:                    This routine maintains the USB Host layer state machine. It must be called
4213:                    frequently to ensure proper operation of the USB. This function should be
4214:                    called from the SYS_Tasks function.
4215:                
4216:                 Remarks:
4217:                    See usb_host.h for usage information.
4218:                */
4219:                
4220:                void USB_HOST_Tasks ( SYS_MODULE_OBJ usbHostObject )
4221:                {
9D00ECD4  27BDFFE0   ADDIU SP, SP, -32
9D00ECD8  AFBF001C   SW RA, 28(SP)
9D00ECDC  AFB10018   SW S1, 24(SP)
9D00ECE0  AFB00014   SW S0, 20(SP)
4222:                    /* Host object */
4223:                    USB_HOST_OBJ            *hostObj =  (USB_HOST_OBJ *)usbHostObject;
4224:                    USB_HOST_BUS_OBJ        *busObj;
4225:                    USB_HOST_DEVICE_OBJ     *rootHubDevice;
4226:                    uint32_t                rootHubUHD;
4227:                    int                     hcCount;
4228:                 
4229:                    /* Check if the host layer is ready. We do not run the tasks routine
4230:                     * otherwise */
4231:                    if ( hostObj->status != SYS_STATUS_READY)
9D00ECE4  8C830008   LW V1, 8(A0)
9D00ECE8  24020002   ADDIU V0, ZERO, 2
9D00ECEC  5462005F   BNEL V1, V0, 0x9D00EE6C
9D00ECF0  8FBF001C   LW RA, 28(SP)
4232:                    {
4233:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host Layer: Not ready in USB_HOST_Tasks().");
4234:                    }
4235:                    else
4236:                    {
4237:                        /* Maintain the state of each bus in the system */
4238:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
4239:                        {
4240:                            busObj  = &(gUSBHostBusList[hcCount]);
4241:                
4242:                            switch ( busObj->state)
9D00ECF4  3C028001   LUI V0, -32767
9D00ECF8  8C423D80   LW V0, 15744(V0)
9D00ECFC  24030003   ADDIU V1, ZERO, 3
9D00ED00  1043004B   BEQ V0, V1, 0x9D00EE30
9D00ED04  24030004   ADDIU V1, ZERO, 4
9D00ED08  10430055   BEQ V0, V1, 0x9D00EE60
9D00ED0C  24030002   ADDIU V1, ZERO, 2
9D00ED10  14430056   BNE V0, V1, 0x9D00EE6C
9D00ED14  8FBF001C   LW RA, 28(SP)
4243:                            {
4244:                                case USB_HOST_BUS_STATE_DISABLED:
4245:                                    /* No action required */
4246:                                    break;
4247:                
4248:                                case USB_HOST_BUS_STATE_ENABLING:
4249:                
4250:                                    /* The bus is being enabled. Try opening the HCD */
4251:                                    busObj->hcdHandle = busObj->hcdInterface->open(busObj->hcdIndex, DRV_IO_INTENT_EXCLUSIVE | 
9D00ED18  3C108001   LUI S0, -32767
9D00ED1C  26023D78   ADDIU V0, S0, 15736
9D00ED20  8C43000C   LW V1, 12(V0)
9D00ED24  8C630000   LW V1, 0(V1)
9D00ED28  94440004   LHU A0, 4(V0)
9D00ED2C  0060F809   JALR V1
9D00ED30  2405000F   ADDIU A1, ZERO, 15
4252:                                            DRV_IO_INTENT_NONBLOCKING | DRV_IO_INTENT_READWRITE );
4253:                
4254:                                    /* Validate the Open function status */
4255:                                    if (DRV_HANDLE_INVALID == busObj->hcdHandle )
9D00ED34  2403FFFF   ADDIU V1, ZERO, -1
9D00ED38  1043004B   BEQ V0, V1, 0x9D00EE68
9D00ED3C  AE023D78   SW V0, 15736(S0)
4256:                                    {
4257:                                        /* The driver may not open the first time. This is okay. We
4258:                                         * should try opening it again. The state of bus is not
4259:                                         * changed. */
4260:                                    }
4261:                                    else
4262:                                    {
4263:                                        /* Update the bus root hub information with the
4264:                                         * details of the controller. Get the bus speed, number of
4265:                                         * ports, the maximum current that the HCD can supply,
4266:                                         * pointer to the root hub port functions. */
4267:                
4268:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Root Hub Driver Opened.",hcCount);
4269:                                        busObj->rootHubInfo.speed =  busObj->hcdInterface->rootHubInterface.rootHubSpeedGet(busObj->hcdHandle);
9D00ED40  02008821   ADDU S1, S0, ZERO
9D00ED44  26103D78   ADDIU S0, S0, 15736
9D00ED48  8E03000C   LW V1, 12(S0)
9D00ED4C  8C630024   LW V1, 36(V1)
9D00ED50  0060F809   JALR V1
9D00ED54  00402021   ADDU A0, V0, ZERO
9D00ED58  AE020024   SW V0, 36(S0)
4270:                                        busObj->rootHubInfo.ports = busObj->hcdInterface->rootHubInterface.rootHubPortNumbersGet(busObj->hcdHandle);
9D00ED5C  8E02000C   LW V0, 12(S0)
9D00ED60  8C420028   LW V0, 40(V0)
9D00ED64  0040F809   JALR V0
9D00ED68  8E243D78   LW A0, 15736(S1)
9D00ED6C  A2020020   SB V0, 32(S0)
4271:                                        busObj->rootHubInfo.power =  busObj->hcdInterface->rootHubInterface.rootHubMaxCurrentGet(busObj->hcdHandle);
9D00ED70  8E02000C   LW V0, 12(S0)
9D00ED74  8C42002C   LW V0, 44(V0)
9D00ED78  0040F809   JALR V0
9D00ED7C  8E243D78   LW A0, 15736(S1)
9D00ED80  AE020028   SW V0, 40(S0)
4272:                                        busObj->rootHubInfo.rootHubPortInterface = busObj->hcdInterface->rootHubInterface.rootHubPortInterface;
9D00ED84  8E03000C   LW V1, 12(S0)
9D00ED88  8C67003C   LW A3, 60(V1)
9D00ED8C  8C660040   LW A2, 64(V1)
9D00ED90  8C650044   LW A1, 68(V1)
9D00ED94  8C640048   LW A0, 72(V1)
9D00ED98  8C62004C   LW V0, 76(V1)
9D00ED9C  AE07002C   SW A3, 44(S0)
9D00EDA0  AE060030   SW A2, 48(S0)
9D00EDA4  AE050034   SW A1, 52(S0)
9D00EDA8  AE040038   SW A0, 56(S0)
9D00EDAC  AE02003C   SW V0, 60(S0)
4273:                
4274:                                        /* We need to add the root hub as a device in the device
4275:                                         * list. In the gUSBHostDeviceList, the first
4276:                                         * USB_HOST_CONTROLLER_NUMBERS of objects is reserved for
4277:                                         * root hubs. Device Object 0 for root hub 0 and so on. We
4278:                                         * simply grab the device object reserved for the bus root
4279:                                         * hub that we processing and then initialize it. */
4280:                
4281:                                        rootHubDevice = &(gUSBHostDeviceList[hcCount]);
4282:                                        rootHubDevice->inUse = true;
9D00EDB0  3C028001   LUI V0, -32767
9D00EDB4  24060001   ADDIU A2, ZERO, 1
9D00EDB8  A0463A18   SB A2, 14872(V0)
4283:                
4284:                                        /* The plug and play identifier is a unique ID that gets
4285:                                         * incremented when a new device is attached to the bus. We
4286:                                         * consider the root hub enumeration as a new device */
4287:                
4288:                                        busObj->pnpIdentifier = busObj->pnpIdentifier + 1 ;
9D00EDBC  96050048   LHU A1, 72(S0)
9D00EDC0  24A50001   ADDIU A1, A1, 1
9D00EDC4  30A5FFFF   ANDI A1, A1, -1
9D00EDC8  A6050048   SH A1, 72(S0)
4289:                
4290:                                        /* The UHD for the root hub can now be formed. It is
4291:                                         * combination of the the PNP identifier, the
4292:                                         * gUSBHostDeviceList index and the bus number */
4293:                
4294:                                        rootHubUHD =  _USB_HOST_DeviceObjHandleGet(busObj->pnpIdentifier, hcCount, hcCount);  
9D00EDCC  00052C00   SLL A1, A1, 16
4295:                
4296:                                        /* Root hub has  device identifier and parent device
4297:                                         * identifier same. The hub interface is the HCD root hub
4298:                                         * interface. Each of these device object is a linked list
4299:                                         * node. We set the next object to NULL. */
4300:                                        
4301:                                        rootHubDevice->deviceIdentifier = rootHubUHD ;
9D00EDD0  24423A18   ADDIU V0, V0, 14872
9D00EDD4  AC45004C   SW A1, 76(V0)
4302:                                        rootHubDevice->parentDeviceIdentifier = rootHubUHD;
9D00EDD8  AC450054   SW A1, 84(V0)
4303:                                        rootHubDevice->hcdHandle = busObj->hcdHandle ;
9D00EDDC  8E243D78   LW A0, 15736(S1)
9D00EDE0  AC440064   SW A0, 100(V0)
4304:                                        rootHubDevice->deviceAddress = USB_HOST_ROOT_HUB_ADDRESS ;
9D00EDE4  A0460060   SB A2, 96(V0)
4305:                                        rootHubDevice->deviceState = USB_HOST_DEVICE_STATE_READY ;
9D00EDE8  2406000F   ADDIU A2, ZERO, 15
9D00EDEC  AC4600F0   SW A2, 240(V0)
4306:                                        rootHubDevice->hcdInterface = busObj->hcdInterface;
9D00EDF0  AC43006C   SW V1, 108(V0)
4307:                                        rootHubDevice->hubInterface = (USB_HUB_INTERFACE *) & ( busObj->hcdInterface->rootHubInterface);
9D00EDF4  24660024   ADDIU A2, V1, 36
9D00EDF8  AC460070   SW A2, 112(V0)
4308:                                        rootHubDevice->nextDeviceObj = NULL;
9D00EDFC  AC4001A8   SW ZERO, 424(V0)
4309:                
4310:                                        /* The first device in the bus is the root hub */
4311:                                        busObj->busDeviceList = rootHubDevice ;
9D00EE00  AE020010   SW V0, 16(S0)
4312:                
4313:                                        /* Initialize the root hub. The device identifier passed to
4314:                                         * the initialize function is returned as the parent ID when
4315:                                         * the root hub request for device attach. We then enable
4316:                                         * the root hub operation. The root hub operation enable
4317:                                         * function does not enable the root hub immediately. So we
4318:                                         * will have to continue checking the progress of the enable
4319:                                         * operation in another state. */
4320:                                        busObj->hcdInterface->rootHubInterface.rootHubInitialize( busObj->hcdHandle , rootHubDevice->deviceIdentifier );
9D00EE04  8C620038   LW V0, 56(V1)
9D00EE08  0040F809   JALR V0
9D00EE0C  00000000   NOP
4321:                                        busObj->hcdInterface->rootHubInterface.rootHubOperationEnable( busObj->hcdHandle , true );
9D00EE10  8E02000C   LW V0, 12(S0)
9D00EE14  8C420030   LW V0, 48(V0)
9D00EE18  8E243D78   LW A0, 15736(S1)
9D00EE1C  0040F809   JALR V0
9D00EE20  24050001   ADDIU A1, ZERO, 1
4322:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Enabling Root Hub operation.",hcCount);
4323:                                        busObj->state = USB_HOST_BUS_STATE_WAIT_FOR_ENABLE_COMPLETE ;
9D00EE24  24020003   ADDIU V0, ZERO, 3
9D00EE28  0B403B9A   J 0x9D00EE68
9D00EE2C  AE020008   SW V0, 8(S0)
4324:                                    }
4325:                
4326:                                    break;
4327:                
4328:                                case USB_HOST_BUS_STATE_WAIT_FOR_ENABLE_COMPLETE:
4329:                
4330:                                    /* Check if the root hub operation enable function has
4331:                                     * completed. If yes, then the bus enable routine has completed
4332:                                     * and we can update the bus state */
4333:                
4334:                                    if(busObj->hcdInterface->rootHubInterface.rootHubOperationIsEnabled(busObj->hcdHandle))
9D00EE30  3C028001   LUI V0, -32767
9D00EE34  24433D78   ADDIU V1, V0, 15736
9D00EE38  8C63000C   LW V1, 12(V1)
9D00EE3C  8C630034   LW V1, 52(V1)
9D00EE40  0060F809   JALR V1
9D00EE44  8C443D78   LW A0, 15736(V0)
9D00EE48  10400008   BEQ V0, ZERO, 0x9D00EE6C
9D00EE4C  8FBF001C   LW RA, 28(SP)
4335:                                    {
4336:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Root Hub Operation Enabled.",hcCount);
4337:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Updating Attached Device states.",hcCount);
4338:                                        busObj->state = USB_HOST_BUS_STATE_ENABLED;
9D00EE50  24030004   ADDIU V1, ZERO, 4
9D00EE54  3C028001   LUI V0, -32767
9D00EE58  0B403B9A   J 0x9D00EE68
9D00EE5C  AC433D80   SW V1, 15744(V0)
4339:                                    }
4340:                                    break;
4341:                
4342:                                case USB_HOST_BUS_STATE_ENABLED:
4343:                
4344:                                    /* Now that the bus is enabled, we can update the state of every
4345:                                     * device that is attached on this bus. */
4346:                
4347:                                    _USB_HOST_UpdateDeviceTask(hcCount);
9D00EE60  0F405476   JAL _USB_HOST_UpdateDeviceTask
9D00EE64  00002021   ADDU A0, ZERO, ZERO
4348:                                    break;
4349:                
4350:                                case USB_HOST_BUS_STATE_DISABLING:
4351:                
4352:                                    break;
4353:                
4354:                                case USB_HOST_BUS_STATE_SUSPENDING:
4355:                
4356:                                    break;
4357:                
4358:                                case USB_HOST_BUS_STATE_SUSPENDED:
4359:                
4360:                                    break;
4361:                
4362:                                default :
4363:                                    break;
4364:                            }
4365:                        }
4366:                    }
4367:                }
9D00EE68  8FBF001C   LW RA, 28(SP)
4368:                
4369:                // *****************************************************************************
4370:                /* Function:
4371:                    USB_ENDPOINT_DESCRIPTOR * USB_HOST_DeviceEndpointDescriptorQuery
4372:                    (
4373:                        USB_INTERFACE_DESCRIPTOR * interface
4374:                        USB_HOST_DESCRIPTOR_QUERY * query 
4375:                    );
4376:                
4377:                  Summary:
4378:                    Queries the configuration for the specified endpoint type and returns a
4379:                    pointer to the endpoint descriptor if found.
4380:                
4381:                  Description:
4382:                  This function queries the specified configuration for the specified endpoint
4383:                    type and returns a pointer to the endpoint descriptor if found. The return
4384:                    pointer will point to the standard endpoint descriptor and class specific
4385:                    endpoint descriptors for that endpoint. The search criteria can specified by
4386:                    using the flags. 
4387:                    
4388:                    In a case where there are multiple endpoints in the interface, the function
4389:                    can be called repetitively to continue the search till the end of the
4390:                    interface descriptor is reached or till the search fails.  The query object
4391:                    maintains the last point where the search was successful and continues the
4392:                    search from that point onwards. Resetting the query object (through the
4393:                    USB_HOST_DeviceEndpointQueryClear) function will reset the search object and
4394:                    cause the search to start from the top of the interface descriptor..
4395:                
4396:                  Remarks:
4397:                    This function is available in the PIC32 implementation of the USB Host.
4398:                */
4399:                
4400:                USB_ENDPOINT_DESCRIPTOR * USB_HOST_DeviceEndpointDescriptorQuery
4401:                (
4402:                    USB_INTERFACE_DESCRIPTOR * interface,
4403:                    USB_HOST_ENDPOINT_DESCRIPTOR_QUERY * query 
4404:                )
4405:                {
9D00FDF8  27BDFFD8   ADDIU SP, SP, -40
9D00FDFC  AFBF0024   SW RA, 36(SP)
9D00FE00  AFB30020   SW S3, 32(SP)
9D00FE04  AFB2001C   SW S2, 28(SP)
9D00FE08  AFB10018   SW S1, 24(SP)
9D00FE0C  AFB00014   SW S0, 20(SP)
4406:                    USB_ENDPOINT_DESCRIPTOR * result = NULL;
4407:                    USB_ENDPOINT_DESCRIPTOR * matchDescriptor = NULL;
4408:                    uint8_t * search;
4409:                    int bNumEndPoints, iterator;
4410:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
4411:                    USB_HOST_ENDPOINT_QUERY_FLAG matchedCriteria = 0;
4412:                    uint8_t * lastLocation;
4413:                
4414:                    /* Validate input parameters */
4415:                
4416:                    if((interface == NULL) || (query == NULL))
9D00FE10  1080004A   BEQ A0, ZERO, 0x9D00FF3C
9D00FE14  00809821   ADDU S3, A0, ZERO
9D00FE18  10A0004A   BEQ A1, ZERO, 0x9D00FF44
9D00FE1C  00A08821   ADDU S1, A1, ZERO
4417:                    {
4418:                        result = NULL;
9D00FF3C  0B403FD4   J 0x9D00FF50
9D00FF40  00001021   ADDU V0, ZERO, ZERO
9D00FF44  0B403FD4   J 0x9D00FF50
9D00FF48  00001021   ADDU V0, ZERO, ZERO
9D00FF4C  00001021   ADDU V0, ZERO, ZERO
4419:                    }
4420:                    else
4421:                    {
4422:                        /* Get the number of endpoints in this interface. If the context is
4423:                         * already equal pointing to the last endpoint in this interface then
4424:                         * we don't have anything to search. */
4425:                
4426:                        bNumEndPoints = interface->bNumEndPoints;
9D00FE20  90900004   LBU S0, 4(A0)
4427:                        if(bNumEndPoints == query->context)
9D00FE24  8CB20010   LW S2, 16(A1)
9D00FE28  52120049   BEQL S0, S2, 0x9D00FF50
9D00FE2C  00001021   ADDU V0, ZERO, ZERO
4428:                        {
4429:                            result = NULL;
4430:                        }
4431:                        else
4432:                        {
4433:                            /* This means parameters are valid. Irrespective of the context we
4434:                             * always start the search from the start of the interface descriptor. 
4435:                             * The lastLocation will contain the end of the configuration
4436:                             * descriptor address. */
4437:                
4438:                            search = (uint8_t *)(interface);
4439:                            lastLocation = (uint8_t *)(_USB_HOST_FindEndOfDescriptor(search));
9D00FE30  0F4057C4   JAL _USB_HOST_FindEndOfDescriptor
9D00FE34  00000000   NOP
9D00FE38  00402821   ADDU A1, V0, ZERO
4440:                            search += sizeof(USB_INTERFACE_DESCRIPTOR);
4441:                            for(iterator = 0; iterator < bNumEndPoints; iterator++) 
9D00FE3C  1A000043   BLEZ S0, 0x9D00FF4C
9D00FE40  26620009   ADDIU V0, S3, 9
9D00FE44  00003021   ADDU A2, ZERO, ZERO
9D00FF24  24C60001   ADDIU A2, A2, 1
9D00FF28  00D0182A   SLT V1, A2, S0
9D00FF2C  1460FFC9   BNE V1, ZERO, 0x9D00FE54
9D00FF30  0045182B   SLTU V1, V0, A1
9D00FF34  0B403FD4   J 0x9D00FF50
9D00FF38  00001021   ADDU V0, ZERO, ZERO
4442:                            {
4443:                                if(search < lastLocation)
9D00FE50  0045182B   SLTU V1, V0, A1
9D00FE54  50600034   BEQL V1, ZERO, 0x9D00FF28
9D00FE58  24C60001   ADDIU A2, A2, 1
4444:                                {
4445:                                    /* Clear the matched criteria for  fresh search */
4446:                                    matchedCriteria = 0;
9D00FE4C  24090004   ADDIU T1, ZERO, 4
9D00FEDC  01073826   XOR A3, T0, A3
9D00FEE0  00004021   ADDU T0, ZERO, ZERO
9D00FEE4  0127400A   MOVZ T0, T1, A3
9D00FEE8  01003821   ADDU A3, T0, ZERO
4447:                
4448:                                    descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
4449:                                    while(descriptorHeader->descType != USB_DESCRIPTOR_ENDPOINT)
9D00FE48  24040005   ADDIU A0, ZERO, 5
9D00FE5C  90430001   LBU V1, 1(V0)
9D00FE60  10640006   BEQ V1, A0, 0x9D00FE7C
9D00FE64  00000000   NOP
9D00FE70  90430001   LBU V1, 1(V0)
9D00FE74  5464FFFD   BNEL V1, A0, 0x9D00FE6C
9D00FE78  90430000   LBU V1, 0(V0)
4450:                                    {
4451:                                        /* This means we have found not found an endpoint descriptor
4452:                                         * yet. Continue searching. */
4453:                
4454:                                        search += descriptorHeader->size;
9D00FE68  90430000   LBU V1, 0(V0)
9D00FE6C  00431021   ADDU V0, V0, V1
4455:                                        descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
4456:                                    }
4457:                
4458:                                    /* This means we have found an endpoint descriptor */
4459:                                    matchDescriptor = (USB_ENDPOINT_DESCRIPTOR *)(search);
4460:                
4461:                                    /* Check if the query object already covered this in the
4462:                                     * previous search. We will know about this through the context
4463:                                     * */
4464:                
4465:                                    if((query->context > 0) && (iterator <= query->context))
9D00FE7C  52400006   BEQL S2, ZERO, 0x9D00FE98
9D00FE80  8E23000C   LW V1, 12(S1)
9D00FE84  0246182B   SLTU V1, S2, A2
9D00FE88  54600003   BNEL V1, ZERO, 0x9D00FE98
9D00FE8C  8E23000C   LW V1, 12(S1)
4466:                                    {
4467:                                        /* This means this endpoint was searched previously. Update
4468:                                         * search to point to the next descriptor. We should
4469:                                         * continue the search. */
4470:                
4471:                                        search += sizeof(USB_ENDPOINT_DESCRIPTOR);
4472:                                        continue;
9D00FE90  0B403FC9   J 0x9D00FF24
9D00FE94  24420007   ADDIU V0, V0, 7
4473:                
4474:                                    }
4475:                
4476:                                    /* Now check for matching criteria */
4477:                                    if(query->flags & USB_HOST_ENDPOINT_QUERY_BY_ENDPOINT_ADDRESS)
9D00FE98  30670001   ANDI A3, V1, 1
9D00FE9C  10E0000A   BEQ A3, ZERO, 0x9D00FEC8
9D00FEA0  30680004   ANDI T0, V1, 4
4478:                                    {
4479:                                        /* Check if the endpoint address matches the address */
4480:                                        if(matchDescriptor->bEndpointAddress == query->endpointAddress)
9D00FEA4  90470002   LBU A3, 2(V0)
9D00FEA8  92230000   LBU V1, 0(S1)
9D00FEAC  54E30004   BNEL A3, V1, 0x9D00FEC0
9D00FEB0  90430000   LBU V1, 0(V0)
4481:                                        {
4482:                                            /* This is a match. Update the context to remember on
4483:                                             * which iteration we matched. End the search. */
4484:                                            query->context = iterator + 1;
9D00FEB4  24C60001   ADDIU A2, A2, 1
4485:                                            result = matchDescriptor;
4486:                                            break;
9D00FEB8  0B403FD4   J 0x9D00FF50
9D00FEBC  AE260010   SW A2, 16(S1)
9D00FEC0  0B403FC9   J 0x9D00FF24
9D00FEC4  00431021   ADDU V0, V0, V1
4487:                                        }
4488:                                        else
4489:                                        {
4490:                                            search += descriptorHeader->size;
4491:                                        }
4492:                                    }
4493:                                    else
4494:                                    {
4495:                                        if(query->flags & USB_HOST_ENDPOINT_QUERY_BY_DIRECTION)
9D00FEC8  11000008   BEQ T0, ZERO, 0x9D00FEEC
9D00FECC  00003821   ADDU A3, ZERO, ZERO
4496:                                        {
4497:                                            /* Check if the endpoint direction matches */
4498:                                            if(query->direction == matchDescriptor->dirn)
9D00FED0  90470002   LBU A3, 2(V0)
9D00FED4  7CE701C0   EXT A3, A3, 7, 1
9D00FED8  8E280008   LW T0, 8(S1)
4499:                                            {
4500:                                                /* Update matchedCriteria. This will help us check
4501:                                                 * if all the query specified criteria have been
4502:                                                 * satisfied. */
4503:                                                matchedCriteria |= USB_HOST_ENDPOINT_QUERY_BY_DIRECTION;
4504:                                            }
4505:                                        }
4506:                
4507:                                        if(query->flags & USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE)
9D00FEEC  30680002   ANDI T0, V1, 2
9D00FEF0  11000006   BEQ T0, ZERO, 0x9D00FF0C
9D00FEF4  34E80002   ORI T0, A3, 2
4508:                                        {
4509:                                            /* Check if the endpoint direction matches */
4510:                                            if(query->transferType == matchDescriptor->transferType)
9D00FEF8  904A0003   LBU T2, 3(V0)
9D00FEFC  314A0003   ANDI T2, T2, 3
9D00FF00  8E2B0004   LW T3, 4(S1)
4511:                                            {
4512:                                                /* Update matchedCriteria. This will help us check
4513:                                                 * if all the query specified criteria have been
4514:                                                 * satisfied. */
4515:                                                matchedCriteria |= USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE;
9D00FF04  016A5026   XOR T2, T3, T2
9D00FF08  010A380A   MOVZ A3, T0, T2
4516:                                            }
4517:                                        }          
4518:                
4519:                                        if(matchedCriteria == query->flags)
9D00FF0C  54E30004   BNEL A3, V1, 0x9D00FF20
9D00FF10  90430000   LBU V1, 0(V0)
4520:                                        {
4521:                                            /* This means all the criteria matched. We can end the
4522:                                             * search. */
4523:                
4524:                                            query->context = iterator + 1;
9D00FF14  24C60001   ADDIU A2, A2, 1
4525:                                            result = matchDescriptor;
4526:                                            break;
9D00FF18  0B403FD4   J 0x9D00FF50
9D00FF1C  AE260010   SW A2, 16(S1)
4527:                                        }
4528:                                        else
4529:                                        {
4530:                                            /* This is not the endpoint descriptor. Advance the 
4531:                                             * search. */
4532:                                            search += descriptorHeader->size;
9D00FF20  00431021   ADDU V0, V0, V1
4533:                                        }
4534:                                    }
4535:                                }
4536:                                else
4537:                                {
4538:                                    /* This means we have reached the end of the descriptor. The
4539:                                     * search should stop. */
4540:                                }
4541:                            }
4542:                        } 
4543:                    }
4544:                    
4545:                    return(result);
4546:                }
9D00FF50  8FBF0024   LW RA, 36(SP)
4547:                
4548:                // *****************************************************************************
4549:                /* Function:
4550:                    USB_INTERFACE_DESCRIPTOR * USB_HOST_DeviceInterfaceDescriptorQuery
4551:                    (
4552:                        USB_CONFIGURATION_DESCRIPTOR * configuration
4553:                        USB_HOST_DESCRIPTOR_QUERY * query,
4554:                    );
4555:                
4556:                  Summary:
4557:                    Queries the active configuration for the specified interface.
4558:                
4559:                  Description:
4560:                    This function queries the active configuration for the specified interface
4561:                    and returns a pointer to the interface descriptor if found. The return
4562:                    pointer will point to the standard interface descriptor and class specific
4563:                    interface descriptors for that interface. The search criteria can specified
4564:                    by using the flags. 
4565:                    
4566:                    In a case where the interface has more than one alternate settings, the
4567:                    function can be called repetitively to continue the search till the end of the
4568:                    configuration descriptor is reached or till the search fails. The query flag
4569:                    in such should be set to ignore the alternate setting field.  The query
4570:                    object maintains the last point where the search was successful and
4571:                    continues the search from that point onwards. Resetting the query object
4572:                    (through the USB_HOST_QueryClear) function will reset the search object and
4573:                    cause the search to start from the top of the configuration descriptor.
4574:                
4575:                  Remarks:
4576:                    Refer to usb_host_client_driver.h for usage information.
4577:                */
4578:                
4579:                
4580:                USB_INTERFACE_DESCRIPTOR * USB_HOST_DeviceInterfaceDescriptorQuery
4581:                (
4582:                    USB_CONFIGURATION_DESCRIPTOR * configuration,
4583:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
4584:                )
4585:                {
4586:                    USB_INTERFACE_DESCRIPTOR * result = NULL;
9D010D0C  03E00008   JR RA
9D010D10  00001021   ADDU V0, ZERO, ZERO
9D010D14  03E00008   JR RA
9D010D18  00001021   ADDU V0, ZERO, ZERO
4587:                    USB_INTERFACE_DESCRIPTOR * matchedInterface;
4588:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
4589:                    uint16_t wTotalLength; 
4590:                    uint8_t * search;
4591:                
4592:                    USB_HOST_INTERFACE_QUERY_FLAG matchedCriteria = 0;
4593:                
4594:                    if((NULL == configuration) || (NULL == query))
9D010BE0  1080004A   BEQ A0, ZERO, 0x9D010D0C
9D010BE4  00000000   NOP
9D010BE8  10A0004A   BEQ A1, ZERO, 0x9D010D14
9D010BEC  24060004   ADDIU A2, ZERO, 4
4595:                    {
4596:                        /* Input parameter are NULL. Nothing to do here as the result is already
4597:                         * set to NULL. */
4598:                    }
4599:                    else
4600:                    {
4601:                        /* Input parameters are valid. Get the number of interfaces in this
4602:                         * configuration. This number does not include number of alternate
4603:                         * settings. The search must start after the configuration descriptor
4604:                         * header. */
4605:                
4606:                        wTotalLength = configuration->wTotalLength;
9D010BF0  90820002   LBU V0, 2(A0)
9D010BF4  90830003   LBU V1, 3(A0)
9D010BF8  00031A00   SLL V1, V1, 8
9D010BFC  00621825   OR V1, V1, V0
4607:                        search = (uint8_t *)(configuration) + sizeof(USB_CONFIGURATION_DESCRIPTOR);
9D010C00  24820009   ADDIU V0, A0, 9
4608:                
4609:                        /* Keep searching till we have reached the end of the configuration
4610:                         * descriptor or we have found a match */
4611:                        while(search < ((uint8_t *)(configuration) + wTotalLength))
9D010C04  0B40433E   J 0x9D010CF8
9D010C08  00832021   ADDU A0, A0, V1
9D010CF8  0044182B   SLTU V1, V0, A0
9D010CFC  1060000B   BEQ V1, ZERO, 0x9D010D2C
9D010D00  00000000   NOP
4612:                        {
4613:                            /* Search for an interface descriptor */
4614:                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
4615:                            
4616:                            /* The matchedCriteria bitmap must be cleared before every search */
4617:                            matchedCriteria = 0;
4618:                            
4619:                            while(descriptorHeader->descType != USB_DESCRIPTOR_INTERFACE)
9D010C1C  90430001   LBU V1, 1(V0)
9D010C20  5466FFFA   BNEL V1, A2, 0x9D010C0C
9D010C24  90430000   LBU V1, 0(V0)
9D010D04  0B404308   J 0x9D010C20
9D010D08  90430001   LBU V1, 1(V0)
4620:                            {
4621:                                search += descriptorHeader->size;
9D010C0C  00431021   ADDU V0, V0, V1
4622:                                descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
4623:                                
4624:                                /* Its possible we may reach the end of the configuration 
4625:                                 * descriptor here. So lets check to make sure we have a
4626:                                 * bounded check. */
4627:                                
4628:                                if(search >= ((uint8_t *)(configuration) + wTotalLength))
9D010C10  0044182B   SLTU V1, V0, A0
9D010C14  10600041   BEQ V1, ZERO, 0x9D010D1C
9D010C18  00000000   NOP
4629:                                {
4630:                                    /* We are at the end of the configuration descriptor. */
4631:                                    search = NULL;
4632:                                    break;
4633:                                }
4634:                            }
4635:                            
4636:                            if(search == NULL)
9D010C28  1040003E   BEQ V0, ZERO, 0x9D010D24
9D010C2C  00403821   ADDU A3, V0, ZERO
4637:                            {
4638:                                /* This means the above search loop reached the end of the 
4639:                                 * configuration descriptor. */
4640:                                result = NULL;
9D010D1C  03E00008   JR RA
9D010D20  00001021   ADDU V0, ZERO, ZERO
9D010D24  03E00008   JR RA
9D010D28  00000000   NOP
4641:                                break;
4642:                            }
4643:                
4644:                            /* This means we have found an interface descriptor. If the
4645:                             * query context (which is the location of the last search) is
4646:                             * greater than the current search location, this means this
4647:                             * interface was already covered in the previous search */
4648:                
4649:                            if(search <= (uint8_t *)(query->context))
9D010C30  8CA3000C   LW V1, 12(A1)
9D010C34  0062182B   SLTU V1, V1, V0
9D010C38  54600004   BNEL V1, ZERO, 0x9D010C4C
9D010C3C  8CA80008   LW T0, 8(A1)
4650:                            {
4651:                                /* This result was already obtained in the previous search. We
4652:                                 * must continue the search. */
4653:                
4654:                                search += descriptorHeader->size;
9D010C40  90420000   LBU V0, 0(V0)
4655:                                continue;
9D010C44  0B40433E   J 0x9D010CF8
9D010C48  00E21021   ADDU V0, A3, V0
4656:                            }
4657:                
4658:                            /* We can now start match the interface to the query */
4659:                            matchedInterface = (USB_INTERFACE_DESCRIPTOR *)(search);
4660:                
4661:                            if(query->flags & USB_HOST_INTERFACE_QUERY_BY_NUMBER)
9D010C4C  31090001   ANDI T1, T0, 1
9D010C50  11200005   BEQ T1, ZERO, 0x9D010C68
9D010C54  00001821   ADDU V1, ZERO, ZERO
4662:                            {
4663:                                /* Check if the interface number matches the specified interface
4664:                                 * number */
4665:                                if(matchedInterface->bInterfaceNumber == query->bInterfaceNumber)
9D010C58  90490002   LBU T1, 2(V0)
9D010C5C  90A30000   LBU V1, 0(A1)
9D010C60  01231826   XOR V1, T1, V1
9D010C64  2C630001   SLTIU V1, V1, 1
4666:                                {
4667:                                    matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_NUMBER;
4668:                                }
4669:                            }
4670:                
4671:                            if(query->flags & USB_HOST_INTERFACE_QUERY_ALT_SETTING)
9D010C68  31090002   ANDI T1, T0, 2
9D010C6C  11200007   BEQ T1, ZERO, 0x9D010C8C
9D010C70  31090004   ANDI T1, T0, 4
4672:                            {
4673:                                /* Check if the alternate number matches the specified alternate
4674:                                 * setting */
4675:                                if(matchedInterface->bAlternateSetting == query->bAlternateSetting)
9D010C74  90EB0003   LBU T3, 3(A3)
9D010C78  90AA0001   LBU T2, 1(A1)
4676:                                {
4677:                                    matchedCriteria |= USB_HOST_INTERFACE_QUERY_ALT_SETTING;
9D010C7C  34690002   ORI T1, V1, 2
9D010C80  016A5026   XOR T2, T3, T2
9D010C84  012A180A   MOVZ V1, T1, T2
4678:                                }
4679:                            }
4680:                
4681:                            if(query->flags & USB_HOST_INTERFACE_QUERY_BY_CLASS)
9D010C88  31090004   ANDI T1, T0, 4
9D010C8C  11200007   BEQ T1, ZERO, 0x9D010CAC
9D010C90  31090008   ANDI T1, T0, 8
4682:                            {
4683:                                /* Check if the class of the interface matches the specified
4684:                                 * class. */
4685:                                 if(query->bInterfaceClass == matchedInterface->bInterfaceClass)
9D010C94  90AB0002   LBU T3, 2(A1)
9D010C98  90EA0005   LBU T2, 5(A3)
4686:                                 {
4687:                                     matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_CLASS;
9D010C9C  34690004   ORI T1, V1, 4
9D010CA0  016A5026   XOR T2, T3, T2
9D010CA4  012A180A   MOVZ V1, T1, T2
4688:                                 }
4689:                            }
4690:                
4691:                            if(query->flags & USB_HOST_INTERFACE_QUERY_BY_SUBCLASS)
9D010CA8  31090008   ANDI T1, T0, 8
9D010CAC  11200007   BEQ T1, ZERO, 0x9D010CCC
9D010CB0  31090010   ANDI T1, T0, 16
4692:                            {
4693:                                /* Check if the interface subclass matches the specified
4694:                                 * interface subclass */
4695:                                if(matchedInterface->bInterfaceSubClass == query->bInterfaceSubClass)
9D010CB4  90EB0006   LBU T3, 6(A3)
9D010CB8  90AA0003   LBU T2, 3(A1)
4696:                                {
4697:                                    matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_SUBCLASS;
9D010CBC  34690008   ORI T1, V1, 8
9D010CC0  016A5026   XOR T2, T3, T2
9D010CC4  012A180A   MOVZ V1, T1, T2
4698:                                }
4699:                            }
4700:                
4701:                            if(query->flags & USB_HOST_INTERFACE_QUERY_BY_PROTOCOL)
9D010CC8  31090010   ANDI T1, T0, 16
9D010CCC  11200005   BEQ T1, ZERO, 0x9D010CE4
9D010CD0  34690010   ORI T1, V1, 16
4702:                            {
4703:                                /* Check if the interface protocol matches the specified
4704:                                 * interface protocol. */
4705:                                if(matchedInterface->bInterfaceProtocol == query->bInterfaceProtocol)
9D010CD4  90EB0007   LBU T3, 7(A3)
9D010CD8  90AA0004   LBU T2, 4(A1)
4706:                                {
4707:                                    matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_PROTOCOL;
9D010CDC  016A5026   XOR T2, T3, T2
9D010CE0  012A180A   MOVZ V1, T1, T2
4708:                                }
4709:                            }
4710:                
4711:                            if(matchedCriteria == query->flags)
9D010CE4  54680003   BNEL V1, T0, 0x9D010CF4
9D010CE8  90E20000   LBU V0, 0(A3)
4712:                            {
4713:                                /* This means we have matched the specified criteria. Save the
4714:                                 * location of the match and then stop searching. */
4715:                                
4716:                                query->context = (uintptr_t)(search);
4717:                                result = matchedInterface;
4718:                                break;
9D010CEC  03E00008   JR RA
9D010CF0  ACA2000C   SW V0, 12(A1)
4719:                            }
4720:                            else
4721:                            {
4722:                                /* Did not match the query criteria. */
4723:                                search += descriptorHeader->size;
9D010CF4  00E21021   ADDU V0, A3, V0
4724:                                continue;
4725:                            }
4726:                        }
4727:                    }
4728:                    
4729:                    return(result);
4730:                }
9D010D2C  03E00008   JR RA
4731:                
4732:                // *****************************************************************************
4733:                /* Function:
4734:                    void USB_HOST_DeviceEndpointQueryClear
4735:                    (
4736:                        USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
4737:                    );
4738:                
4739:                  Summary:
4740:                    Clear the query object.
4741:                
4742:                  Description:
4743:                    This function clears the query object context. Using the query after it has
4744:                    been clear will cause the USB_HOST_DeviceEndpointDescriptorQuery() and
4745:                    function to reset the search location to the start of the configuration
4746:                    descriptor.
4747:                
4748:                  Remarks
4749:                    Refer to usb_host_client_driver.h for usage details.
4750:                */
4751:                
4752:                void USB_HOST_DeviceEndpointQueryContextClear
4753:                (
4754:                    USB_HOST_ENDPOINT_DESCRIPTOR_QUERY * query
4755:                )
4756:                {
4757:                    if(NULL != query)
9D0172DC  54800001   BNEL A0, ZERO, 0x9D0172E4
4758:                    {
4759:                        /* Reset the context to 0 */
4760:                        query->context = 0;
9D00D510  AFA00038   SW ZERO, 56(SP)
4761:                    }
4762:                }
4763:                
4764:                // *****************************************************************************
4765:                /* Function:
4766:                    void USB_HOST_DeviceInterfaceQueryContextClear
4767:                    (
4768:                        USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
4769:                    );
4770:                
4771:                  Summary:
4772:                    Clear the query object.
4773:                
4774:                  Description:
4775:                    This function clears the query object context. Using the query after it has
4776:                    been clear will cause the USB_HOST_DeviceInterfaceDescriptorQuery() and
4777:                    function to reset the search location to the start of the configuration
4778:                    descriptor.
4779:                
4780:                  Remarks:
4781:                    Refer to usb_host_client_driver.h for usage details.
4782:                */    
4783:                
4784:                void USB_HOST_DeviceInterfaceQueryContextClear
4785:                (
4786:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
4787:                )
4788:                {
4789:                    if(NULL != query)
00000000  00000000   NOP
4790:                    {
4791:                        /* Reset the context to 0 */
4792:                        query->context = 0;
9D00D4E4  AFA00048   SW ZERO, 72(SP)
9D010970  AFA0001C   SW ZERO, 28(SP)
00000080  00000000   NOP
4793:                    }
4794:                } 
4795:                
4796:                // *****************************************************************************
4797:                /* Function:
4798:                    USB_HOST_CONTROL_PIPE_HANDLE USB_HOST_DeviceControlPipeOpen
4799:                    (
4800:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
4801:                    );
4802:                
4803:                  Summary:
4804:                    Open a control transfer pipe to the device.
4805:                
4806:                  Description:
4807:                    This function opens a control transfer pipe to the device. The return control
4808:                    pipe handle can be used in the USB_HOST_DeviceControlTransfer() function to
4809:                    schedule control transfers to the device.
4810:                
4811:                  Remarks:
4812:                    Refer to usb_host_client_driver.h for usage information.
4813:                */
4814:                
4815:                USB_HOST_CONTROL_PIPE_HANDLE USB_HOST_DeviceControlPipeOpen
4816:                (
4817:                    USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
4818:                )
4819:                {
9D016418  308300FF   ANDI V1, A0, 255
4820:                    uint8_t deviceIndex ;
4821:                    uint16_t pnpIdentifier;
4822:                    USB_HOST_DEVICE_OBJ  * deviceObj;
4823:                    USB_HOST_CONTROL_PIPE_HANDLE  controlPipeHandle = USB_HOST_CONTROL_PIPE_HANDLE_INVALID;
9D016450  00042402   SRL A0, A0, 16
9D016454  2403FFFF   ADDIU V1, ZERO, -1
9D016458  0064100B   MOVN V0, V1, A0
4824:                
4825:                    /* Get the device object index from the device object handle */
4826:                    deviceIndex =  USB_HOST_DEVICE_INDEX( deviceObjHandle );
4827:                
4828:                    /* Get a pointer to the device object */
4829:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
9D01641C  00032900   SLL A1, V1, 4
9D016420  00031180   SLL V0, V1, 6
9D016424  00451023   SUBU V0, V0, A1
9D016428  000218C0   SLL V1, V0, 3
9D01642C  00431021   ADDU V0, V0, V1
9D016430  3C038001   LUI V1, -32767
9D016434  24633A18   ADDIU V1, V1, 14872
9D016438  00621821   ADDU V1, V1, V0
4830:                
4831:                    if(deviceObj->inUse)
9D01643C  90650000   LBU A1, 0(V1)
9D016440  10A00006   BEQ A1, ZERO, 0x9D01645C
9D016444  2402FFFF   ADDIU V0, ZERO, -1
4832:                    {
4833:                        /* This means the device object is valid. Now check the plugNplay
4834:                         * identifier to make sure that device object handle is not stale */
4835:                
4836:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceObjHandle);
4837:                
4838:                        if(pnpIdentifier == USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
9D016448  8C62004C   LW V0, 76(V1)
9D01644C  00442026   XOR A0, V0, A0
4839:                        {
4840:                            /* The plugNplay identifier matches the one that device object
4841:                             * contains. The control pipe handle is the same as the device
4842:                             * object handle */
4843:                
4844:                            controlPipeHandle = (USB_HOST_CONTROL_PIPE_HANDLE)(deviceObj->deviceIdentifier);
4845:                        }
4846:                    }
4847:                
4848:                    return controlPipeHandle;
4849:                }
9D01645C  03E00008   JR RA
4850:                
4851:                // *****************************************************************************
4852:                /* Function:
4853:                    USB_HOST_RESULT USB_HOST_DeviceInterfaceRelease
4854:                    (
4855:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
4856:                    );
4857:                
4858:                  Summary:
4859:                    Releases an interface on the specified device.
4860:                
4861:                  Description:
4862:                    This function allows the application to release a claimed interface on the
4863:                    specified device and within the selected configuration on that device.
4864:                
4865:                  Remarks:
4866:                    Refer to usb_host_client_driver.h for usage information.
4867:                 */
4868:                
4869:                USB_HOST_RESULT USB_HOST_DeviceInterfaceRelease
4870:                (
4871:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
4872:                )
4873:                {
4874:                    int deviceIndex;
4875:                    int interfaceIndex;
4876:                    unsigned int pnpIdentifier;
4877:                    USB_HOST_RESULT result;
4878:                    USB_HOST_DEVICE_OBJ * deviceObj;
4879:                    USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
4880:                   
4881:                    
4882:                    deviceIndex = USB_HOST_DEVICE_INDEX(interfaceHandle);
9D0155F8  308400FF   ANDI A0, A0, 255
4883:                    interfaceIndex = USB_HOST_INTERFACE_INDEX(interfaceHandle);
9D0155F0  7C863A00   EXT A2, A0, 8, 8
4884:                    pnpIdentifier = USB_HOST_PNP_IDENTIFIER(interfaceHandle);
9D0155F4  00042C02   SRL A1, A0, 16
4885:                    
4886:                    /* Get the device object */
4887:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
9D0155FC  00041900   SLL V1, A0, 4
9D015600  00042180   SLL A0, A0, 6
9D015604  00832023   SUBU A0, A0, V1
9D015608  000410C0   SLL V0, A0, 3
9D01560C  00822021   ADDU A0, A0, V0
9D015610  3C028001   LUI V0, -32767
9D015614  24423A18   ADDIU V0, V0, 14872
9D015618  00441021   ADDU V0, V0, A0
4888:                    
4889:                    if(!deviceObj->inUse)
9D01561C  90430000   LBU V1, 0(V0)
9D015620  1060000D   BEQ V1, ZERO, 0x9D015658
9D015624  00000000   NOP
4890:                    {
4891:                        /* This device object is not in use. May have been disconnected */
4892:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
9D015658  03E00008   JR RA
9D01565C  2402FFA7   ADDIU V0, ZERO, -89
4893:                    }
4894:                    else 
4895:                    {
4896:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
9D015628  9443004E   LHU V1, 78(V0)
9D01562C  1465000C   BNE V1, A1, 0x9D015660
9D015630  24C60008   ADDIU A2, A2, 8
4897:                        {
4898:                            /* This device is not the same that client driver thinks it is */
4899:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
9D015660  03E00008   JR RA
9D015664  2402FFA7   ADDIU V0, ZERO, -89
4900:                        }
4901:                        else
4902:                        {
4903:                            interfaceInfo = &deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex];
9D015634  00063140   SLL A2, A2, 5
9D015638  00461021   ADDU V0, V0, A2
9D01563C  24430004   ADDIU V1, V0, 4
4904:                            if(interfaceInfo->interfaceDescriptor == NULL)
9D015640  8C420004   LW V0, 4(V0)
9D015644  10400008   BEQ V0, ZERO, 0x9D015668
9D015648  00000000   NOP
4905:                            {
4906:                                /* This means that the interface is not valid */
4907:                                result = USB_HOST_RESULT_INTERFACE_UNKNOWN;
4908:                            }
4909:                            else
4910:                            {
4911:                                /* Release the interface */
4912:                                interfaceInfo->interfaceDriver = NULL;
9D01564C  AC600008   SW ZERO, 8(V1)
4913:                                result = USB_HOST_RESULT_SUCCESS;
9D015650  03E00008   JR RA
9D015654  24020001   ADDIU V0, ZERO, 1
4914:                            }
4915:                        }
4916:                    }    
4917:                        
4918:                    return(result);
4919:                }
9D015668  03E00008   JR RA
4920:                
4921:                // *****************************************************************************
4922:                /* Function:
4923:                    void USB_HOST_DeviceTransfer
4924:                    ( 
4925:                        USB_HOST_PIPE_HANDLE pipeHandle
4926:                        USB_HOST_TRANSFER_HANDLE * transferHandle,
4927:                        void * data,
4928:                        size_t size,
4929:                        uintptr_t context
4930:                    );
4931:                
4932:                  Summary:
4933:                    Schedules a bulk, interrupt or isochronous transfer.
4934:                
4935:                  Description:
4936:                    This function schedules a bulk, interrupt or isochronous. pipeHandle
4937:                    contains a handle to a bulk, interrupt or isochronous pipe obtained through
4938:                    the USB_HOST_DevicePipeOpen() function .
4939:                    
4940:                    If the transfer was scheduled successfully, transferHandle will contain a
4941:                    transfer handle that uniquely identifies this transfer. If the transfer
4942:                    could not be scheduled successfully, transferHandle will contain
4943:                    USB_HOST_TRANSFER_HANDLE_INVALID.  
4944:                
4945:                    Multiple transfers can be queued. These transfers will be processed in the
4946:                    order they were scheduled. The host layer will called the interfaceEvent
4947:                    event handler with USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE_DATA
4948:                    when the transfer completes.
4949:                
4950:                  Remarks
4951:                    Refer to usb_host_client_driver.h for usage information.
4952:                */
4953:                
4954:                USB_HOST_RESULT USB_HOST_DeviceTransfer
4955:                (
4956:                    USB_HOST_PIPE_HANDLE pipeHandle,
4957:                    USB_HOST_TRANSFER_HANDLE * transferHandle,
4958:                    void * data,
4959:                    size_t size,
4960:                    uintptr_t context
4961:                )
4962:                {
9D00D698  27BDFFD0   ADDIU SP, SP, -48
9D00D69C  AFBF002C   SW RA, 44(SP)
9D00D6A0  AFB60028   SW S6, 40(SP)
9D00D6A4  AFB50024   SW S5, 36(SP)
9D00D6A8  AFB40020   SW S4, 32(SP)
9D00D6AC  AFB3001C   SW S3, 28(SP)
9D00D6B0  AFB20018   SW S2, 24(SP)
9D00D6B4  AFB10014   SW S1, 20(SP)
9D00D6B8  AFB00010   SW S0, 16(SP)
4963:                    uint8_t deviceIndex;
4964:                    uint8_t interfaceIndex;
4965:                    USB_HOST_DEVICE_OBJ *deviceObj;
4966:                    USB_HOST_TRANSFER_OBJ * transferObj = NULL;
9D00D7A0  0000B021   ADDU S6, ZERO, ZERO
4967:                    USB_HOST_PIPE_OBJ *pipeObj;
4968:                    DRV_USB_HOST_PIPE_HANDLE drvPipeHandle;
4969:                    USB_HOST_INTERFACE_DESC_INFO *interfaceInfo;
4970:                    USB_HOST_RESULT result = USB_HOST_RESULT_SUCCESS ;
4971:                    OSAL_RESULT osalResult;
4972:                    USB_HOST_OBJ * hostObj;
4973:                    int search;
4974:                
4975:                    if(NULL == transferHandle)
9D00D6BC  10A0005C   BEQ A1, ZERO, 0x9D00D830
9D00D6C0  00A08021   ADDU S0, A1, ZERO
4976:                    {
4977:                        /* transferHandle cannot be NULL */
4978:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
9D00D830  0B40361C   J 0x9D00D870
9D00D834  2403FFA3   ADDIU V1, ZERO, -93
4979:                    }
4980:                    else
4981:                    {
4982:                        /* Initialize transfer handle in anticipation of an error */
4983:                        *transferHandle = USB_HOST_TRANSFER_HANDLE_INVALID;
9D00D6C4  2402FFFF   ADDIU V0, ZERO, -1
4984:                
4985:                        if(USB_HOST_PIPE_HANDLE_INVALID == pipeHandle)
9D00D6C8  1082005B   BEQ A0, V0, 0x9D00D838
9D00D6CC  ACA20000   SW V0, 0(A1)
9D00D6D0  00C09821   ADDU S3, A2, ZERO
4986:                        {
4987:                            /* Pipe handle is not valid */
4988:                            result = USB_HOST_RESULT_PIPE_HANDLE_INVALID;
9D00D838  0B40361C   J 0x9D00D870
9D00D83C  2403FFA0   ADDIU V1, ZERO, -96
4989:                        }
4990:                        else if ((size != 0) && (NULL == data))
9D00D6D4  10E00003   BEQ A3, ZERO, 0x9D00D6E4
9D00D6D8  00E08821   ADDU S1, A3, ZERO
9D00D6DC  10C00064   BEQ A2, ZERO, 0x9D00D870
9D00D6E0  2403FFA3   ADDIU V1, ZERO, -93
4991:                        {
4992:                            /* If size is greater than 0, then data cannot be NULL */
4993:                            result = USB_HOST_RESULT_PARAMETER_INVALID;
4994:                        }
4995:                        else
4996:                        {
4997:                            /* Pointer to the host layer object */
4998:                            hostObj = &gUSBHostObj;
4999:                
5000:                            /* pipeHandle is pointer to the pipe object */
5001:                            pipeObj = (USB_HOST_PIPE_OBJ *)(pipeHandle);
5002:                
5003:                            /* The pipeObj contains the handle to the interface that this pipe
5004:                             * belongs to. The interface handle contains the index of the owner
5005:                             * device. We need this owner device index so that we can get the
5006:                             * pointer to the HCD functions. */
5007:                
5008:                            deviceIndex =  USB_HOST_DEVICE_INDEX( pipeObj->interfaceHandle );
9D00D6E4  8C820004   LW V0, 4(A0)
9D00D6E8  304500FF   ANDI A1, V0, 255
5009:                            interfaceIndex =  USB_HOST_INTERFACE_INDEX ( pipeObj->interfaceHandle );
5010:                            deviceObj = &gUSBHostDeviceList[deviceIndex];
9D00D6EC  00053100   SLL A2, A1, 4
9D00D6F0  00051980   SLL V1, A1, 6
9D00D6F4  00661823   SUBU V1, V1, A2
9D00D6F8  000390C0   SLL S2, V1, 3
9D00D6FC  00721821   ADDU V1, V1, S2
9D00D700  3C128001   LUI S2, -32767
9D00D704  26523A18   ADDIU S2, S2, 14872
9D00D708  02439021   ADDU S2, S2, V1
9D00D70C  7C543A00   EXT S4, V0, 8, 8
5011:                            interfaceInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex]);
9D00D710  26940008   ADDIU S4, S4, 8
9D00D714  0014A140   SLL S4, S4, 5
9D00D718  0254A021   ADDU S4, S2, S4
9D00D71C  26940004   ADDIU S4, S4, 4
5012:                
5013:                            /* Get the driver pipe handle */
5014:                            drvPipeHandle = pipeObj->pipeHandle ;
9D00D720  8C950008   LW S5, 8(A0)
5015:                
5016:                            /* We need to now search for a free transfer object. It is possible that
5017:                             * the USB_HOST_DeviceTransfer() function will be called from the
5018:                             * transfer event. It is also possible that this function is called from
5019:                             * another thread. We will use a mutual exclusion to protect the transfer
5020:                             * object pool. But the mutual exclusion should be take only if the host if
5021:                             * this function is not being called in an interrupt context.*/
5022:                
5023:                            if(!hostObj->isInInterruptContext)
9D00D724  3C028001   LUI V0, -32767
9D00D728  24423DC8   ADDIU V0, V0, 15816
9D00D72C  90420017   LBU V0, 23(V0)
9D00D730  304200FF   ANDI V0, V0, 255
9D00D734  14400044   BNE V0, ZERO, 0x9D00D848
9D00D738  3C028001   LUI V0, -32767
5024:                            {
5025:                                /* We can take mutual exclusion only if we are not in interrupt context */
5026:                                osalResult = OSAL_MUTEX_Lock(&hostObj->mutexTransferObj, OSAL_WAIT_FOREVER);
5027:                            }
5028:                            else
5029:                            {
5030:                                /* We are in interrupt context. So the rest of the code flow
5031:                                 * should continue. */
5032:                                osalResult = OSAL_RESULT_TRUE;
5033:                            }
5034:                
5035:                            /* The execution reaches this point (in an RTOS setting) if the
5036:                             * mutual exclusion lock was taken, or if the mutual exclusion failed. We must disable all
5037:                             * root hub events so this operation is atomic */
5038:                            
5039:                            if(osalResult == OSAL_RESULT_TRUE)
5040:                            {
5041:                                _USB_HOST_RootHubEventDisable();
9D00D848  0F405A4A   JAL _USB_HOST_RootHubEventDisable
9D00D84C  00000000   NOP
5042:                                
5043:                                for(search = 0; search < USB_HOST_TRANSFERS_NUMBER; search ++)
9D00D76C  00001021   ADDU V0, ZERO, ZERO
9D00D798  1444FFEF   BNE V0, A0, 0x9D00D758
9D00D79C  24630044   ADDIU V1, V1, 68
9D00D864  24020001   ADDIU V0, ZERO, 1
9D00D868  0B4035D6   J 0x9D00D758
9D00D86C  2404000A   ADDIU A0, ZERO, 10
5044:                                {
5045:                                    if(!gUSBHostTransferObj[search].inUse)
9D00D758  90680000   LBU T0, 0(V1)
9D00D75C  5500000E   BNEL T0, ZERO, 0x9D00D798
9D00D760  24420001   ADDIU V0, V0, 1
9D00D850  3C028001   LUI V0, -32767
9D00D854  904236D0   LBU V0, 14032(V0)
9D00D858  1040FFC4   BEQ V0, ZERO, 0x9D00D76C
9D00D85C  3C038001   LUI V1, -32767
9D00D860  24633714   ADDIU V1, V1, 14100
5046:                                    {
5047:                                        /* We found a transfer object. Allocate it and then update
5048:                                         * the transfer handle. */
5049:                
5050:                                        transferObj = &gUSBHostTransferObj[search];
9D00D764  0B4035DD   J 0x9D00D774
9D00D768  0002B080   SLL S6, V0, 2
9D00D770  0002B080   SLL S6, V0, 2
9D00D774  00021180   SLL V0, V0, 6
9D00D778  02C21021   ADDU V0, S6, V0
9D00D77C  3C168001   LUI S6, -32767
9D00D780  26D636D0   ADDIU S6, S6, 14032
9D00D784  02C2B021   ADDU S6, S6, V0
5051:                                        transferObj->inUse = true;
9D00D788  24020001   ADDIU V0, ZERO, 1
9D00D78C  A2C20000   SB V0, 0(S6)
5052:                                        *transferHandle = (USB_HOST_TRANSFER_HANDLE)(transferObj);
5053:                                            break;
9D00D790  0B4035E9   J 0x9D00D7A4
9D00D794  AE160000   SW S6, 0(S0)
5054:                                    }
5055:                                }
5056:                                
5057:                                _USB_HOST_RootHubEventEnable();
9D00D7A4  0F405ABD   JAL _USB_HOST_RootHubEventEnable
9D00D7A8  00000000   NOP
5058:                
5059:                                /* Return the mutual exclusion */
5060:                                if(!hostObj->isInInterruptContext)
9D00D7AC  3C028001   LUI V0, -32767
9D00D7B0  24423DC8   ADDIU V0, V0, 15816
9D00D7B4  90420017   LBU V0, 23(V0)
9D00D7B8  304200FF   ANDI V0, V0, 255
9D00D7BC  54400005   BNEL V0, ZERO, 0x9D00D7D4
9D00D7C0  8E030000   LW V1, 0(S0)
5061:                                {
5062:                                    OSAL_MUTEX_Unlock(&(hostObj->mutexTransferObj));
5063:                                }
5064:                
5065:                                if(*transferHandle == USB_HOST_TRANSFER_HANDLE_INVALID)
9D00D7D0  8E030000   LW V1, 0(S0)
9D00D7D4  2402FFFF   ADDIU V0, ZERO, -1
9D00D7D8  10620019   BEQ V1, V0, 0x9D00D840
9D00D7DC  3C029D01   LUI V0, -25343
5066:                                {
5067:                                    /* This means we did not find a transfer object */
5068:                                    result = USB_HOST_RESULT_REQUEST_BUSY;
9D00D840  0B40361C   J 0x9D00D870
9D00D844  2403FF9C   ADDIU V1, ZERO, -100
5069:                                }
5070:                                else
5071:                                {
5072:                                    /* We have found a transfer object. Initialize it */
5073:                
5074:                                    transferObj->irp.data = (void *)data;
9D00D7E0  AED3000C   SW S3, 12(S6)
5075:                                    transferObj->irp.size = size ;
9D00D7E4  AED10010   SW S1, 16(S6)
5076:                                    transferObj->irp.userData = (uintptr_t)(transferObj);
9D00D7E8  AED6001C   SW S6, 28(S6)
5077:                                    transferObj->irp.callback = _USB_HOST_DataTransferIRPCallback;
9D00D7EC  24425150   ADDIU V0, V0, 20816
9D00D7F0  AEC20020   SW V0, 32(S6)
5078:                                    transferObj->context = context;
9D00D7F4  8FA20040   LW V0, 64(SP)
9D00D7F8  AEC20004   SW V0, 4(S6)
5079:                                    transferObj->interfaceInfoObj = interfaceInfo;
9D00D7FC  AED40040   SW S4, 64(S6)
5080:                
5081:                                    /* Try submitting the IRP */
5082:                                    if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( drvPipeHandle, & (transferObj->irp)))
9D00D800  8E42006C   LW V0, 108(S2)
9D00D804  8C42000C   LW V0, 12(V0)
9D00D808  02A02021   ADDU A0, S5, ZERO
9D00D80C  0040F809   JALR V0
9D00D810  26C50008   ADDIU A1, S6, 8
9D00D814  10400016   BEQ V0, ZERO, 0x9D00D870
9D00D818  24030001   ADDIU V1, ZERO, 1
5083:                                    {
5084:                                        /* If the IRP submit was not successful, then return the
5085:                                         * transferObject to the pool and update the result. */
5086:                
5087:                                        result = USB_HOST_RESULT_FAILURE;
9D00D828  0B40361C   J 0x9D00D870
9D00D82C  2403FFA8   ADDIU V1, ZERO, -88
5088:                                        *transferHandle = USB_HOST_TRANSFER_HANDLE_INVALID;
9D00D81C  2402FFFF   ADDIU V0, ZERO, -1
9D00D820  AE020000   SW V0, 0(S0)
5089:                                        transferObj->inUse = false;
9D00D824  A2C00000   SB ZERO, 0(S6)
5090:                                    }
5091:                                }
5092:                            }
5093:                            else
5094:                            {
5095:                                /* Could not take the mutual exclusion lock*/
5096:                                result = USB_HOST_RESULT_REQUEST_BUSY;
5097:                            }
5098:                        }
5099:                    }
5100:                
5101:                    return result;
5102:                }
9D00D870  00601021   ADDU V0, V1, ZERO
5103:                
5104:                // *****************************************************************************
5105:                /* Function:
5106:                    USB_HOST_PIPE_HANDLE USB_HOST_DevicePipeOpen 
5107:                    (
5108:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
5109:                        USB_ENDPOINT_ADDRESS endpointAddress
5110:                    );
5111:                
5112:                  Summary:
5113:                    Opens a pipe to the specified endpoint.
5114:                
5115:                  Description:
5116:                    This function opens a pipe on the specified endpoint. The pipe parameters
5117:                    will be defined by the endpoint attributes specified in the endpoint
5118:                    descriptor that the attached device reports to the host.
5119:                
5120:                  Remarks:
5121:                    Refer to usb_host_client_driver.h for usage information.
5122:                */
5123:                
5124:                USB_HOST_PIPE_HANDLE USB_HOST_DevicePipeOpen
5125:                (
5126:                    USB_HOST_DEVICE_INTERFACE_HANDLE deviceInterfaceHandle,
5127:                    USB_ENDPOINT_ADDRESS endpointAddress
5128:                )
5129:                {
9D00D48C  27BDFF98   ADDIU SP, SP, -104
9D00D490  AFBF0064   SW RA, 100(SP)
9D00D494  AFB40060   SW S4, 96(SP)
9D00D498  AFB3005C   SW S3, 92(SP)
9D00D49C  AFB20058   SW S2, 88(SP)
9D00D4A0  AFB10054   SW S1, 84(SP)
9D00D4A4  AFB00050   SW S0, 80(SP)
9D00D4A8  00808821   ADDU S1, A0, ZERO
9D00D4AC  30B300FF   ANDI S3, A1, 255
5130:                    uint8_t  interval;
5131:                    uint8_t  pipeNumber;
5132:                    uint32_t deviceIndex;
5133:                    uint8_t  interfaceIndex;
5134:                    uint32_t maxPacketSize;
5135:                
5136:                    USB_HOST_PIPE_HANDLE result;
5137:                    USB_TRANSFER_TYPE transferType;
5138:                    USB_HOST_PIPE_OBJ * pipeObj = NULL;
5139:                    USB_HOST_INTERFACE_DESC_INFO *interfaceInfo;
5140:                    USB_ENDPOINT_DESCRIPTOR * endpointDescriptor;
5141:                    USB_HOST_DEVICE_OBJ  * deviceObj;
5142:                    USB_HOST_ENDPOINT_DESCRIPTOR_QUERY endpointDescQuery;
5143:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY interfaceQuery;
5144:                    USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
5145:                
5146:                    /* Get the index of the device from the interface handle. We need this to
5147:                     * get the device object. */
5148:                    deviceIndex =  USB_HOST_DEVICE_INDEX( deviceInterfaceHandle );
9D00D4B4  308400FF   ANDI A0, A0, 255
5149:                
5150:                    /* Get the index of the interface. We need this to get information about
5151:                     * the endpoint */
5152:                    interfaceIndex =  USB_HOST_INTERFACE_INDEX ( deviceInterfaceHandle );
9D00D4B0  7C833A00   EXT V1, A0, 8, 8
9D00D4E8  A3A3003C   SB V1, 60(SP)
5153:                
5154:                    /* Get the device object because we need the pointer to the HCD pipe open
5155:                     * function. */
5156:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
9D00D4B8  00042900   SLL A1, A0, 4
9D00D4BC  00041180   SLL V0, A0, 6
9D00D4C0  00451023   SUBU V0, V0, A1
9D00D4C4  000290C0   SLL S2, V0, 3
9D00D4C8  00521021   ADDU V0, V0, S2
9D00D4CC  3C128001   LUI S2, -32767
9D00D4D0  26523A18   ADDIU S2, S2, 14872
9D00D4D4  02429021   ADDU S2, S2, V0
5157:                
5158:                    /* Get the interface information object to get the pointer to the interface
5159:                     * descriptor */
5160:                    interfaceInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex]);
9D00D4D8  24620008   ADDIU V0, V1, 8
9D00D4DC  00021140   SLL V0, V0, 5
9D00D4E0  02421021   ADDU V0, S2, V0
5161:                
5162:                    /* Set default value to return in case of error */
5163:                    result = USB_HOST_PIPE_HANDLE_INVALID;
9D00D660  0B40359D   J 0x9D00D674
9D00D664  2410FFFF   ADDIU S0, ZERO, -1
9D00D670  2410FFFF   ADDIU S0, ZERO, -1
5164:                
5165:                    /* We must first find the interface descriptor with the current alternate
5166:                     * setting */
5167:                
5168:                    USB_HOST_DeviceInterfaceQueryContextClear(&interfaceQuery);
5169:                    interfaceQuery.bInterfaceNumber = interfaceIndex;
5170:                    interfaceQuery.bAlternateSetting = interfaceInfo->currentAlternateSetting;
9D00D4EC  9043001C   LBU V1, 28(V0)
9D00D4F0  A3A3003D   SB V1, 61(SP)
5171:                    interfaceQuery.flags = USB_HOST_INTERFACE_QUERY_BY_NUMBER|USB_HOST_INTERFACE_QUERY_ALT_SETTING;
9D00D4F4  24030003   ADDIU V1, ZERO, 3
9D00D4F8  AFA30044   SW V1, 68(SP)
5172:                    interfaceDescriptor = USB_HOST_DeviceGeneralInterfaceDescriptorQuery(interfaceInfo->interfaceDescriptor, &interfaceQuery);
9D00D4FC  8C440004   LW A0, 4(V0)
9D00D500  0F4043A2   JAL USB_HOST_DeviceGeneralInterfaceDescriptorQuery
9D00D504  27A5003C   ADDIU A1, SP, 60
5173:                
5174:                    if(interfaceDescriptor != NULL)
9D00D508  1040005A   BEQ V0, ZERO, 0x9D00D674
9D00D50C  2410FFFF   ADDIU S0, ZERO, -1
5175:                    {
5176:                
5177:                        /* We want to search for the endpoint descriptor so that we can find out the
5178:                         * pipe attributes. Set up the query object to search by endpoint number and
5179:                         * then search for the end point descriptor */
5180:                
5181:                        USB_HOST_DeviceEndpointQueryContextClear(&endpointDescQuery);
5182:                        endpointDescQuery.endpointAddress = endpointAddress;
9D00D514  A3B30028   SB S3, 40(SP)
5183:                        endpointDescQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_ENDPOINT_ADDRESS;
9D00D518  24030001   ADDIU V1, ZERO, 1
9D00D51C  AFA30034   SW V1, 52(SP)
5184:                        endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor,&endpointDescQuery);
9D00D520  00402021   ADDU A0, V0, ZERO
9D00D524  0F403F7E   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D00D528  27A50028   ADDIU A1, SP, 40
5185:                
5186:                        if(deviceObj->inUse) 
9D00D52C  92430000   LBU V1, 0(S2)
9D00D530  50600051   BEQL V1, ZERO, 0x9D00D678
9D00D534  02001021   ADDU V0, S0, ZERO
5187:                        {
5188:                            /* Device object is valid */
5189:                            if((USB_HOST_PNP_IDENTIFIER(deviceInterfaceHandle)) == (USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier)))
9D00D538  00112402   SRL A0, S1, 16
9D00D53C  9643004E   LHU V1, 78(S2)
9D00D540  5483004D   BNEL A0, V1, 0x9D00D678
9D00D544  02001021   ADDU V0, S0, ZERO
5190:                            {
5191:                                /* PlugNPlay identifiers are matching */
5192:                
5193:                                if ( endpointDescriptor != NULL )
9D00D548  10400045   BEQ V0, ZERO, 0x9D00D660
9D00D54C  24030002   ADDIU V1, ZERO, 2
5194:                                {
5195:                                    /* Transfer type */
5196:                                    transferType = endpointDescriptor->transferType;
9D00D550  90460003   LBU A2, 3(V0)
9D00D554  30C60003   ANDI A2, A2, 3
5197:                
5198:                                    /* Interval for periodic transfers */
5199:                                    if ( transferType ==  USB_TRANSFER_TYPE_BULK )
9D00D558  50C30002   BEQL A2, V1, 0x9D00D564
9D00D55C  00004821   ADDU T1, ZERO, ZERO
9D00D560  90490006   LBU T1, 6(V0)
5200:                                    {
5201:                                        /* Bulk endpoints we ignore interval value
5202:                                         * reported by endpoint descriptor */
5203:                                        interval = 0x00;
5204:                                    }
5205:                                    else
5206:                                    {
5207:                                        interval = endpointDescriptor->bInterval;
5208:                                    }
5209:                
5210:                                    /* Endpoint maximum packet size */
5211:                                    maxPacketSize = endpointDescriptor->wMaxPacketSize;
9D00D564  90430004   LBU V1, 4(V0)
9D00D568  90420005   LBU V0, 5(V0)
9D00D56C  00021200   SLL V0, V0, 8
9D00D570  00434025   OR T0, V0, V1
5212:                
5213:                                    /* The pipe open function should never be called in an event handler or
5214:                                     * in an interrupt context. We don't check for interrupt safety here,
5215:                                     * only thread safety. The safety is needed for protected the pipe pool
5216:                                     * */
5217:                                    if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexPipeObj), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
5218:                                    {
5219:                                        for ( pipeNumber = 0 ; pipeNumber < USB_HOST_PIPES_NUMBER ; pipeNumber++)
9D00D5A0  2405000A   ADDIU A1, ZERO, 10
9D00D5F4  1445FFEB   BNE V0, A1, 0x9D00D5A4
9D00D5F8  24630010   ADDIU V1, V1, 16
9D00D5FC  0B40359A   J USB_HOST_DevicePipeOpen::OSAL_MUTEX_Unlock
9D00D600  24030001   ADDIU V1, ZERO, 1
5220:                                        {
5221:                                            if( gUSBHostPipeObj[pipeNumber].inUse == false )
9D00D588  3C028001   LUI V0, -32767
9D00D58C  90423978   LBU V0, 14712(V0)
9D00D590  10400009   BEQ V0, ZERO, 0x9D00D5B8
9D00D594  3C038001   LUI V1, -32767
9D00D598  24633988   ADDIU V1, V1, 14728
9D00D59C  24020001   ADDIU V0, ZERO, 1
9D00D5A4  90640000   LBU A0, 0(V1)
9D00D5A8  14800011   BNE A0, ZERO, 0x9D00D5F0
9D00D5AC  00403821   ADDU A3, V0, ZERO
9D00D5B8  00003821   ADDU A3, ZERO, ZERO
5222:                                            {
5223:                                                pipeObj= & gUSBHostPipeObj[pipeNumber];
9D00D5B0  0B403570   J 0x9D00D5C0
9D00D5B4  00073900   SLL A3, A3, 4
9D00D5BC  00073900   SLL A3, A3, 4
9D00D5C0  3C148001   LUI S4, -32767
9D00D5C4  26943978   ADDIU S4, S4, 14712
9D00D5C8  0287A021   ADDU S4, S4, A3
5224:                                                result = (USB_HOST_PIPE_HANDLE)(pipeObj);
5225:                                                pipeObj->inUse = true;
9D00D5CC  24020001   ADDIU V0, ZERO, 1
9D00D5D0  A2820000   SB V0, 0(S4)
5226:                                                break;
5227:                                            }
5228:                                        }
5229:                
5230:                                        /* Release the mutual exclusion lock */
5231:                                        OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexPipeObj));
5232:                                    }
5233:                                    else
5234:                                    {
5235:                                        /* If the mutual exclusion lock failed for unknown reason, we don't do anything
5236:                                         * here as we will any ways check for a valid handle in result.
5237:                                         * result has an invalid handle at this point */
5238:                                    }
5239:                
5240:                                    if(result != USB_HOST_PIPE_HANDLE_INVALID)
9D00D5DC  2402FFFF   ADDIU V0, ZERO, -1
9D00D5E0  16820008   BNE S4, V0, 0x9D00D604
9D00D5E4  02808021   ADDU S0, S4, ZERO
9D00D5E8  0B40359E   J 0x9D00D678
9D00D5EC  02001021   ADDU V0, S0, ZERO
9D00D5F0  24420001   ADDIU V0, V0, 1
5241:                                    {
5242:                                        /* This means the pipeObj is valid. We can try opening the pipe by
5243:                                         * using the HCD pipe open function */
5244:                
5245:                                        pipeObj->pipeHandle = deviceObj->hcdInterface->hostPipeSetup( deviceObj->hcdHandle,
9D00D604  8E42006C   LW V0, 108(S2)
9D00D608  8E440064   LW A0, 100(S2)
9D00D60C  92450060   LBU A1, 96(S2)
9D00D610  92470074   LBU A3, 116(S2)
9D00D614  92430075   LBU V1, 117(S2)
9D00D618  AFA30010   SW V1, 16(SP)
9D00D61C  AFA60014   SW A2, 20(SP)
9D00D620  AFA90018   SW T1, 24(SP)
9D00D624  AFA8001C   SW T0, 28(SP)
9D00D628  8E430078   LW V1, 120(S2)
9D00D62C  AFA30020   SW V1, 32(SP)
9D00D630  8C42001C   LW V0, 28(V0)
9D00D634  0040F809   JALR V0
9D00D638  02603021   ADDU A2, S3, ZERO
5246:                                                deviceObj->deviceAddress,   /* Address of the device */ 
5247:                                                endpointAddress,            /* Endpoint */
5248:                                                deviceObj->hubAddress,       /* Hub address and port */
5249:                                                deviceObj->devicePort,         
5250:                                                transferType,               /* Pipe type */ 
5251:                                                interval,                   /* bInterval */
5252:                                                maxPacketSize,              /* Pipe size */ 
5253:                                                deviceObj->speed            /* Speed of the pipe */
5254:                                                );     
5255:                
5256:                                        if(pipeObj->pipeHandle == DRV_USB_HOST_PIPE_HANDLE_INVALID)
9D00D63C  2403FFFF   ADDIU V1, ZERO, -1
9D00D640  14430004   BNE V0, V1, 0x9D00D654
9D00D644  AE820008   SW V0, 8(S4)
5257:                                        {
5258:                                            /* The HCD pipe open function failed. Release the pipe object
5259:                                             * back and then update result. */
5260:                
5261:                                            pipeObj->inUse = false;
9D00D648  A2800000   SB ZERO, 0(S4)
9D00D64C  0B40359D   J 0x9D00D674
9D00D650  2410FFFF   ADDIU S0, ZERO, -1
5262:                                            result = USB_HOST_PIPE_HANDLE_INVALID;
5263:                                        }
5264:                                        else
5265:                                        {
5266:                                            /* HCD pipe open function worked. Update the pipe object */
5267:                                            pipeObj->endpointAddress = endpointAddress;
9D00D654  A293000C   SB S3, 12(S4)
5268:                                            pipeObj->interfaceHandle = deviceInterfaceHandle ;
9D00D658  0B40359D   J 0x9D00D674
9D00D65C  AE910004   SW S1, 4(S4)
5269:                
5270:                                        }
5271:                                    }
5272:                                }
5273:                            }
5274:                        }
5275:                    }
5276:                
5277:                    return result;
5278:                }
9D00D674  02001021   ADDU V0, S0, ZERO
5279:                
5280:                // *****************************************************************************
5281:                /* Function:
5282:                    USB_HOST_RESULT USB_HOST_DevicePipeClose 
5283:                    (
5284:                        USB_HOST_PIPE_HANDLE pipeHandle
5285:                    );
5286:                
5287:                  Summary:
5288:                    Closes an existing pipe.
5289:                
5290:                  Description:
5291:                    This function closes an existing pipe. Any transfers that are queued or
5292:                    in-progress on the pipe will be aborted and the transfer complete events
5293:                    will be generated. Once closed, no transfers can be queued on the pipe.
5294:                 
5295:                  Remarks:
5296:                     Refer to usb_host_client_driver.h for usage details.
5297:                */
5298:                
5299:                USB_HOST_RESULT USB_HOST_DevicePipeClose
5300:                (
5301:                    USB_HOST_PIPE_HANDLE pipeHandle
5302:                )
5303:                {
9D014FB4  27BDFFE8   ADDIU SP, SP, -24
9D014FB8  AFBF0014   SW RA, 20(SP)
9D014FBC  AFB00010   SW S0, 16(SP)
5304:                    USB_HOST_RESULT result;
5305:                    USB_HOST_PIPE_OBJ * pipeObj;
5306:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle;
5307:                    USB_HOST_DEVICE_OBJ * deviceObj;
5308:                    int deviceIndex;
5309:                
5310:                    if((pipeHandle == USB_HOST_PIPE_HANDLE_INVALID) || (pipeHandle == 0))
9D014FC0  2482FFFF   ADDIU V0, A0, -1
9D014FC4  2C42FFFE   SLTIU V0, V0, -2
9D014FC8  10400018   BEQ V0, ZERO, 0x9D01502C
9D014FCC  00808021   ADDU S0, A0, ZERO
5311:                    {
5312:                        result = USB_HOST_RESULT_PIPE_HANDLE_INVALID;
5313:                    }
5314:                    else
5315:                    {
5316:                        /* The pipe handle is a pointer to the pipe object */
5317:                        pipeObj = (USB_HOST_PIPE_OBJ *)(pipeHandle);
5318:                
5319:                        /* Get the handle to the interface to which this pipe belongs */
5320:                        interfaceHandle = pipeObj->interfaceHandle;
9D014FD0  8C820004   LW V0, 4(A0)
5321:                
5322:                        /* From the interface handle get the device index and hence the device
5323:                         * object */
5324:                        deviceIndex = USB_HOST_DEVICE_INDEX(interfaceHandle);
9D014FD4  304400FF   ANDI A0, V0, 255
5325:                        deviceObj = &gUSBHostDeviceList[deviceIndex];
9D014FD8  00042900   SLL A1, A0, 4
9D014FDC  00041980   SLL V1, A0, 6
9D014FE0  00651823   SUBU V1, V1, A1
9D014FE4  000320C0   SLL A0, V1, 3
9D014FE8  00641821   ADDU V1, V1, A0
9D014FEC  3C048001   LUI A0, -32767
9D014FF0  24843A18   ADDIU A0, A0, 14872
9D014FF4  00831821   ADDU V1, A0, V1
5326:                
5327:                        if((USB_HOST_PNP_IDENTIFIER(interfaceHandle)) == (USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier)))
9D014FF8  00021402   SRL V0, V0, 16
9D014FFC  9464004E   LHU A0, 78(V1)
9D015000  5444000B   BNEL V0, A0, 0x9D015030
9D015004  2402FFA8   ADDIU V0, ZERO, -88
5328:                        {
5329:                            /* Use the HCD routine to close the pipe and deallocate the pipe
5330:                             * object */
5331:                
5332:                            deviceObj->hcdInterface->hostPipeClose(pipeObj->pipeHandle);
9D015008  8C62006C   LW V0, 108(V1)
9D01500C  8C420020   LW V0, 32(V0)
9D015010  0040F809   JALR V0
9D015014  8E040008   LW A0, 8(S0)
5333:                            pipeObj->inUse = false;
9D015018  A2000000   SB ZERO, 0(S0)
5334:                            pipeObj->pipeHandle = DRV_USB_HOST_PIPE_HANDLE_INVALID;
9D01501C  2402FFFF   ADDIU V0, ZERO, -1
9D015020  AE020008   SW V0, 8(S0)
9D015024  0B40540C   J 0x9D015030
9D015028  24020001   ADDIU V0, ZERO, 1
9D01502C  2402FFA0   ADDIU V0, ZERO, -96
5335:                            result = USB_HOST_RESULT_SUCCESS;
5336:                        }
5337:                        else
5338:                        {
5339:                            result = USB_HOST_RESULT_FAILURE;
5340:                        }
5341:                    }
5342:                
5343:                    return(result);
5344:                }
9D015030  8FBF0014   LW RA, 20(SP)
5345:                
5346:                // *****************************************************************************
5347:                /* Function:
5348:                    USB_HOST_RESULT USB_HOST_DevicePipeHaltClear
5349:                    (
5350:                        USB_HOST_PIPE_HANDLE pipeHandle,
5351:                        USB_HOST_REQUEST_HANDLE * requestHandle,
5352:                        uintptr_t context
5353:                    );
5354:                
5355:                  Summary:
5356:                    Clears the halt condition on a pipe.
5357:                
5358:                  Description:
5359:                    This function clears the halt condition on the specified pipe. This
5360:                    function will cause a CLEAR FEATURE control request to be sent to the
5361:                    device. The completion of the control transfer will be indicated by the
5362:                    USB_HOST_DEVICE_EVENT_DEVICE_HALT_CLEAR_COMPLETE event.
5363:                
5364:                  Remarks:
5365:                    Refer to usb_host_client_driver.h for usage information.
5366:                */
5367:                
5368:                USB_HOST_RESULT USB_HOST_DevicePipeHaltClear
5369:                (
5370:                    USB_HOST_PIPE_HANDLE pipeHandle,
5371:                    USB_HOST_REQUEST_HANDLE * requestHandle,
5372:                    uintptr_t context
5373:                )
5374:                {
9D010D44  27BDFFE0   ADDIU SP, SP, -32
9D010D48  AFBF001C   SW RA, 28(SP)
9D010D4C  AFB10018   SW S1, 24(SP)
9D010D50  AFB00014   SW S0, 20(SP)
5375:                    USB_HOST_RESULT result;
5376:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle;
5377:                    USB_HOST_DEVICE_OBJ * deviceObj;
5378:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj; 
5379:                    USB_HOST_PIPE_OBJ * pipeObj;
5380:                    int deviceIndex;
5381:                
5382:                
5383:                    /* Check if we have a valid pipe */
5384:                    if((USB_HOST_PIPE_HANDLE_INVALID == pipeHandle) || (0 == pipeHandle))
9D010D34  2482FFFF   ADDIU V0, A0, -1
9D010D38  2C42FFFE   SLTIU V0, V0, -2
9D010D3C  50400047   BEQL V0, ZERO, 0x9D010E5C
9D010D40  2405FFA0   ADDIU A1, ZERO, -96
5385:                    {
5386:                        result = USB_HOST_RESULT_PIPE_HANDLE_INVALID;
5387:                    }
5388:                    else
5389:                    {
5390:                        /* Request Handle pointer cannot be NULL */
5391:                        if(requestHandle == NULL)
9D010D54  10A00043   BEQ A1, ZERO, 0x9D010E64
9D010D58  00A08821   ADDU S1, A1, ZERO
5392:                        {
5393:                            result = USB_HOST_RESULT_PARAMETER_INVALID;
9D010E64  0B40439C   J 0x9D010E70
9D010E68  2405FFA3   ADDIU A1, ZERO, -93
5394:                        }
5395:                        else
5396:                        {
5397:                            /* Get the index of the device to which this pipe belongs. This can
5398:                             * be obtained from the interface handle. The interface handle is
5399:                             * stored in the pipe object */
5400:                
5401:                            pipeObj = (USB_HOST_PIPE_OBJ *)(pipeHandle);
5402:                            interfaceHandle = pipeObj->interfaceHandle;
9D010D5C  8C830004   LW V1, 4(A0)
5403:                            deviceIndex = USB_HOST_DEVICE_INDEX(interfaceHandle);
9D010D60  306200FF   ANDI V0, V1, 255
5404:                            deviceObj = &gUSBHostDeviceList[deviceIndex];
9D010D64  00022900   SLL A1, V0, 4
9D010D68  00028180   SLL S0, V0, 6
9D010D6C  02058023   SUBU S0, S0, A1
9D010D70  001010C0   SLL V0, S0, 3
9D010D74  02028021   ADDU S0, S0, V0
9D010D78  3C028001   LUI V0, -32767
9D010D7C  24423A18   ADDIU V0, V0, 14872
9D010D80  00508021   ADDU S0, V0, S0
5405:                
5406:                            /* The interface handle  PNP identifier does not match the device PNP
5407:                             * identifier. The device is not the same */
5408:                            if(USB_HOST_PNP_IDENTIFIER(interfaceHandle) != 
9D010D84  00032C02   SRL A1, V1, 16
9D010D8C  14A20037   BNE A1, V0, 0x9D010E6C
9D010D90  2402FFFF   ADDIU V0, ZERO, -1
5409:                                    USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
9D010D88  9602004E   LHU V0, 78(S0)
5410:                            {
5411:                                result = USB_HOST_RESULT_FAILURE; 
9D010E6C  2405FFA8   ADDIU A1, ZERO, -88
5412:                            }
5413:                            else
5414:                            {
5415:                                /* Set the request handle default to invalid */
5416:                                *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
9D010D94  AE220000   SW V0, 0(S1)
5417:                
5418:                                /* Get a mutual exclusion lock as the the control transfer object is a global resource */
5419:                                if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) 
5420:                                        == OSAL_RESULT_TRUE)
5421:                                {
5422:                                    if(!deviceObj->controlTransferObj.inUse)
9D010DAC  92020004   LBU V0, 4(S0)
9D010DB0  14400005   BNE V0, ZERO, USB_HOST_DevicePipeHaltClear::OSAL_MUTEX_Unlock
9D010DB4  24050001   ADDIU A1, ZERO, 1
5423:                                    {
5424:                                        /* This means that there no control request in progress. We can assign
5425:                                         * request now. The request handle is updated to point to the device
5426:                                         * control transfer object. */
5427:                
5428:                                        deviceObj->controlTransferObj.inUse = true;
9D010DB8  24020001   ADDIU V0, ZERO, 1
9D010DBC  A2020004   SB V0, 4(S0)
5429:                                        *requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
9D010DC0  26020004   ADDIU V0, S0, 4
9D010DC4  AE220000   SW V0, 0(S1)
5430:                                    }
5431:                                    else
5432:                                    {
5433:                                        /* A control transfer is in progress. */
5434:                                        result = USB_HOST_RESULT_REQUEST_BUSY;
5435:                                    }
5436:                
5437:                                    /* Unlock the mutual exclusion lock */
5438:                                    OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
5439:                                }
5440:                                else
5441:                                {
5442:                                    /* The mutual exclusion lock could not be obtained */
5443:                                    result = USB_HOST_RESULT_REQUEST_BUSY;
5444:                                }
5445:                
5446:                                if(*requestHandle != USB_HOST_REQUEST_HANDLE_INVALID)
9D010DD0  8E270000   LW A3, 0(S1)
9D010DD4  2402FFFF   ADDIU V0, ZERO, -1
9D010DD8  10E20025   BEQ A3, V0, 0x9D010E70
9D010DDC  2405FF9C   ADDIU A1, ZERO, -100
5447:                                {
5448:                                    /* Set up the control transfer object. The endpoint halt
5449:                                     * clear request does not have a data stage. */
5450:                                    controlTransferObj = &deviceObj->controlTransferObj;
5451:                                    controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_PIPE_HALT_CLEAR;
9D010DE0  24020001   ADDIU V0, ZERO, 1
9D010DE4  AE020044   SW V0, 68(S0)
9D010DE8  9084000C   LBU A0, 12(A0)
5452:                
5453:                                    /* Create the setup packet */
5454:                                    _USB_HOST_FillSetupPacket(
9D010E08  260200D6   ADDIU V0, S0, 214
5455:                                            &(deviceObj->setupPacket),
5456:                                            ( USB_SETUP_DIRN_HOST_TO_DEVICE |
5457:                                              USB_SETUP_TYPE_STANDARD |
5458:                                              USB_SETUP_RECIPIENT_ENDPOINT ),
5459:                                            USB_REQUEST_CLEAR_FEATURE ,
5460:                                            USB_FEATURE_SELECTOR_ENDPOINT_HALT , pipeObj->endpointAddress  ,0 ) ;
5461:                
5462:                                    controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_PIPE_HALT_CLEAR;
5463:                                    controlTransferObj->controlIRP.data = NULL;
9D010E04  AE000010   SW ZERO, 16(S0)
5464:                                    controlTransferObj->controlIRP.setup = &deviceObj->setupPacket;
9D010E0C  AE02000C   SW V0, 12(S0)
5465:                                    controlTransferObj->controlIRP.size = deviceObj->setupPacket.wLength;
9D010E10  AE000014   SW ZERO, 20(S0)
5466:                                    controlTransferObj->controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
9D010E14  3C029D01   LUI V0, -25343
9D010E18  2442E060   ADDIU V0, V0, -8096
9D010E1C  AE020024   SW V0, 36(S0)
5467:                                    controlTransferObj->controlIRP.userData = interfaceHandle;
9D010E20  AE030020   SW V1, 32(S0)
5468:                                    controlTransferObj->context = context;
9D010E24  AE060008   SW A2, 8(S0)
5469:                                    controlTransferObj->callback = NULL;
9D010E28  AE000048   SW ZERO, 72(S0)
5470:                
5471:                                    if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(controlTransferObj->controlIRP)))
9D010E2C  8E02006C   LW V0, 108(S0)
9D010E30  8C42000C   LW V0, 12(V0)
9D010E34  8E040058   LW A0, 88(S0)
9D010E38  0040F809   JALR V0
9D010E3C  2605000C   ADDIU A1, S0, 12
9D010E40  1040000B   BEQ V0, ZERO, 0x9D010E70
9D010E44  24050001   ADDIU A1, ZERO, 1
5472:                                    {
5473:                                        /* There was a problem while submitting the IRP. Update the result and
5474:                                         * the transfer handle. Return the control transfer object back to the
5475:                                         * device object */
5476:                
5477:                                        result = USB_HOST_RESULT_FAILURE;
5478:                                        controlTransferObj->inUse = false;
9D010E48  A2000004   SB ZERO, 4(S0)
5479:                                        *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
9D010E4C  2402FFFF   ADDIU V0, ZERO, -1
9D010E50  AE220000   SW V0, 0(S1)
9D010E54  0B40439C   J 0x9D010E70
9D010E58  2405FFA8   ADDIU A1, ZERO, -88
5480:                                    }
5481:                                    else
5482:                                    {
5483:                                        result = USB_HOST_RESULT_SUCCESS;
5484:                                    }
5485:                                }
5486:                            }
5487:                        }
5488:                    }
5489:                
5490:                    return(result);
5491:                }
9D010E5C  03E00008   JR RA
9D010E60  00A01021   ADDU V0, A1, ZERO
9D010E70  00A01021   ADDU V0, A1, ZERO
5492:                
5493:                // *****************************************************************************
5494:                /* Function:
5495:                    USB_HOST_RESULT USB_HOST_DeviceRelease
5496:                    (
5497:                        USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
5498:                    );
5499:                
5500:                  Summary:
5501:                    Releases an the device ownership.
5502:                
5503:                  Description:
5504:                    This function allows the client driver to release device level ownership.
5505:                
5506:                  Remarks:
5507:                    Refer to usb_host_client_driver.h for usage information.
5508:                 */
5509:                
5510:                USB_HOST_RESULT USB_HOST_DeviceRelease
5511:                (
5512:                    USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle
5513:                )
5514:                {
5515:                    int deviceIndex;
5516:                    unsigned int pnpIdentifier;
5517:                    USB_HOST_RESULT result;
5518:                    USB_HOST_DEVICE_OBJ * deviceObj;
5519:                    
5520:                    deviceIndex = USB_HOST_DEVICE_INDEX(deviceHandle);
00000004  00000000   NOP
5521:                    pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceHandle);
00000000  00000000   NOP
5522:                    
5523:                    /* Get the device object */
5524:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
00000008  00000000   NOP
5525:                    
5526:                    if(!deviceObj->inUse)
00000028  00000000   NOP
5527:                    {
5528:                        /* This device object is not in use. May have been disconnected */
5529:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
00000058  00000000   NOP
5530:                    }
5531:                    else 
5532:                    {
5533:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
00000034  00000000   NOP
5534:                        {
5535:                            /* This device is not the same that client driver thinks it is */
5536:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
00000060  00000000   NOP
5537:                        }
5538:                        else
5539:                        {
5540:                            if(deviceObj->deviceClientDriver == NULL)
00000040  00000000   NOP
5541:                            {
5542:                                /* This is should not happen */
5543:                                result = USB_HOST_RESULT_DEVICE_UNKNOWN;
5544:                            }
5545:                            else
5546:                            {
5547:                                /* Release the interface */
5548:                                deviceObj->deviceClientDriver = NULL;
0000004C  00000000   NOP
5549:                                result = USB_HOST_RESULT_SUCCESS;
00000050  00000000   NOP
5550:                            }
5551:                        }
5552:                    }    
5553:                        
5554:                    return(result);
5555:                }
00000068  00000000   NOP
5556:                
5557:                // *****************************************************************************
5558:                /* Function:
5559:                    USB_INTERFACE_ASSOCIATION_DESCRIPTOR * USB_HOST_DeviceIADQuery
5560:                    (
5561:                        USB_CONFIGURATION_DESCRIPTOR * configuration
5562:                        USB_HOST_IAD_QUERY * query,
5563:                    );
5564:                
5565:                  Summary:
5566:                    Queries the configuration for the specified IAD.
5567:                
5568:                  Description:
5569:                    This function queries the configuration for the specified IAD and returns a
5570:                    pointer to the interface association descriptor if found. The return pointer
5571:                    will point to the standard interface association descriptor.  The search
5572:                    criteria can specified by using the flags. 
5573:                    
5574:                  Remarks:
5575:                    This function is optional and may not be available on all implementations of
5576:                    the USB Host Layer.
5577:                */
5578:                
5579:                USB_INTERFACE_ASSOCIATION_DESCRIPTOR * USB_HOST_DeviceIADQuery
5580:                (
5581:                    USB_CONFIGURATION_DESCRIPTOR * configuration,
5582:                    USB_HOST_IAD_QUERY * query
5583:                )
5584:                {
9D014770  27BDFFE0   ADDIU SP, SP, -32
9D014774  AFBF001C   SW RA, 28(SP)
9D014778  AFB10018   SW S1, 24(SP)
9D01477C  AFB00014   SW S0, 20(SP)
5585:                    USB_INTERFACE_ASSOCIATION_DESCRIPTOR * result = NULL;
9D0147F8  00008021   ADDU S0, ZERO, ZERO
5586:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
5587:                    uint8_t * search;
5588:                    uint8_t * lastLocation;
5589:                
5590:                    if(configuration == NULL)
9D014780  1080001E   BEQ A0, ZERO, 0x9D0147FC
9D014784  00808021   ADDU S0, A0, ZERO
5591:                    {
5592:                        /* Cannot proceed. Note that result is already NULL */
5593:                    }
5594:                    else
5595:                    {
5596:                        /* Keep track of the last location of this descriptor */
5597:                        search = (uint8_t *)(configuration);
5598:                        lastLocation = (uint8_t *)(_USB_HOST_FindEndOfDescriptor(search));
9D014788  0F4057C4   JAL _USB_HOST_FindEndOfDescriptor
9D01478C  00A08821   ADDU S1, A1, ZERO
5599:                
5600:                        if((query->context != 0) && (query->context < (uintptr_t)(lastLocation)))
9D014790  8E230004   LW V1, 4(S1)
9D014794  50600004   BEQL V1, ZERO, 0x9D0147A8
9D014798  0202182B   SLTU V1, S0, V0
9D01479C  0062202B   SLTU A0, V1, V0
5601:                        {
5602:                            /* This is a continuing search. We start the search from the last
5603:                             * saved location */
5604:                            search = (uint8_t *)(query->context);
9D0147A0  0064800B   MOVN S0, V1, A0
5605:                        }
5606:                
5607:                        while(search < lastLocation)
9D0147A4  0202182B   SLTU V1, S0, V0
9D0147A8  10600013   BEQ V1, ZERO, 0x9D0147F8
9D0147AC  2403000B   ADDIU V1, ZERO, 11
9D0147E4  0202182B   SLTU V1, S0, V0
9D0147E8  5460FFF6   BNEL V1, ZERO, 0x9D0147C4
9D0147EC  92030001   LBU V1, 1(S0)
9D0147F0  0B4051FF   J 0x9D0147FC
9D0147F4  00008021   ADDU S0, ZERO, ZERO
5608:                        {
5609:                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
5610:                            if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE_ASSOCIATION)
9D0147B0  92040001   LBU A0, 1(S0)
9D0147B4  54830009   BNEL A0, V1, 0x9D0147DC
9D0147B8  2404000B   ADDIU A0, ZERO, 11
9D0147C4  54640006   BNEL V1, A0, 0x9D0147E0
9D0147C8  92030000   LBU V1, 0(S0)
5611:                            {
5612:                                /* This means we found an IAD. Update result and stop searching */
5613:                                result = (USB_INTERFACE_ASSOCIATION_DESCRIPTOR *)(search);
5614:                                
5615:                                /* Setup the context to point to the next descriptor else
5616:                                 * we will always loop at this descriptor the next time the 
5617:                                 * search function is called. */
5618:                                query->context = (uintptr_t)(search + descriptorHeader->size);
9D0147BC  0B4051F4   J 0x9D0147D0
9D0147C0  92020000   LBU V0, 0(S0)
9D0147CC  92020000   LBU V0, 0(S0)
9D0147D0  02021021   ADDU V0, S0, V0
5619:                                break;
9D0147D4  0B4051FF   J 0x9D0147FC
9D0147D8  AE220004   SW V0, 4(S1)
5620:                            }
5621:                            else
5622:                            {
5623:                                /* Go to the next descriptor */
5624:                                search += descriptorHeader->size;
9D0147DC  92030000   LBU V1, 0(S0)
9D0147E0  02038021   ADDU S0, S0, V1
5625:                            }
5626:                        }
5627:                    }
5628:                
5629:                    return(result);
5630:                }
9D0147FC  02001021   ADDU V0, S0, ZERO
5631:                
5632:                // *****************************************************************************
5633:                /* Function:
5634:                    void USB_HOST_DeviceIADQueryContextClear
5635:                    (
5636:                        USB_HOST_IAD_QUERY * query
5637:                    );
5638:                
5639:                  Summary:
5640:                    Clear the query object.
5641:                
5642:                  Description:
5643:                    This function clears the query object. Using the query after it has been
5644:                    clear will cause the USB_HOST_DeviceIADQuery() and function to reset the
5645:                    search location to the start of the configuration descriptor.
5646:                
5647:                  Remarks:
5648:                    This function is optional and may not be available on all implementations of
5649:                    the USB Host Layer.
5650:                */
5651:                
5652:                void USB_HOST_DeviceIADQueryContextClear
5653:                (
5654:                    USB_HOST_IAD_QUERY * query
5655:                )
5656:                {
5657:                    if(query != NULL)
00000000  00000000   NOP
5658:                    {
5659:                        query->context = 0;
9D0109F0  AFA00024   SW ZERO, 36(SP)
5660:                    }
5661:                }
5662:                
5663:                // *****************************************************************************
5664:                /* Function:
5665:                    USB_HOST_RESULT USB_HOST_DeviceConfigurationSet 
5666:                    (
5667:                        USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
5668:                        USB_HOST_REQUEST_HANDLE * requestHandle,
5669:                        uint8_t configurationIndex,
5670:                        uintptr_t context
5671:                    );
5672:                
5673:                  Summary:
5674:                    Sets the active configuration for the device.
5675:                
5676:                  Description:
5677:                    This function sets the configuration that the host layer must set for this
5678:                    device. A handle to the request is returned in requestHandle. The completion
5679:                    of this request is indicated by the USB_HOST_DEVICE_EVENT_CONFIGURATION_SET
5680:                    complete event.
5681:                
5682:                  Remarks:
5683:                    Refer to usb_host_client_driver.h for usage details.
5684:                */
5685:                
5686:                USB_HOST_RESULT USB_HOST_DeviceConfigurationSet 
5687:                (
5688:                    USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
5689:                    USB_HOST_REQUEST_HANDLE * requestHandle,
5690:                    uint8_t configurationIndex,
5691:                    uintptr_t context
5692:                )
5693:                {
5694:                    USB_HOST_RESULT result;
5695:                    USB_HOST_DEVICE_OBJ * deviceObj;
5696:                    unsigned int deviceIndex;
5697:                    unsigned int pnpIdentifier;
5698:                
5699:                    if(deviceHandle == USB_HOST_DEVICE_CLIENT_HANDLE_INVALID)
00000000  00000000   NOP
5700:                    {
5701:                        /* Device client handle is not valid */
5702:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
00000098  00000000   NOP
5703:                    }
5704:                    else
5705:                    {
5706:                        /* We have a valid client handle. Get the device index from the client
5707:                         * handle */
5708:                
5709:                        deviceIndex = USB_HOST_DEVICE_INDEX(deviceHandle);
0000000C  00000000   NOP
5710:                        deviceObj = &gUSBHostDeviceList[deviceIndex];
00000010  00000000   NOP
5711:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceHandle);
5712:                
5713:                        if((!deviceObj->inUse) || (pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier)))
00000030  00000000   NOP
5714:                        {
5715:                            /* This device is not valid */
5716:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
000000A0  00000000   NOP
5717:                        }
5718:                        else
5719:                        {
5720:                            /* Check if this is valid configuration. */
5721:                            if(configurationIndex >= deviceObj->nConfiguration)
00000048  00000000   NOP
5722:                            {
5723:                                /* The device does not support this configuration */
5724:                                result = USB_HOST_RESULT_CONFIGURATION_UNKNOWN;
000000B0  00000000   NOP
5725:                            }
5726:                            else
5727:                            {
5728:                                if((!deviceObj->controlTransferObj.inUse) &&
00000058  00000000   NOP
5729:                                        (deviceObj->configurationState == USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG) &&
00000070  00000000   NOP
5730:                                        (deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY))
5731:                                {
5732:                                    /* The configuration can be set */
5733:                                    deviceObj->controlTransferObj.inUse = true;
0000007C  00000000   NOP
5734:                                    deviceObj->controlTransferObj.context = context;
00000080  00000000   NOP
5735:                                    deviceObj->requestedConfigurationNumber = configurationIndex;
00000084  00000000   NOP
5736:                                    deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_START;
00000088  00000000   NOP
5737:                                    result = USB_HOST_RESULT_SUCCESS;
00000090  00000000   NOP
5738:                                }
5739:                                else
5740:                                {
5741:                                    /* The device is not ready for any requests at this point */
5742:                                    result = USB_HOST_RESULT_REQUEST_BUSY;
000000B8  00000000   NOP
5743:                                }
5744:                            }
5745:                        }
5746:                    }
5747:                
5748:                    return(result);
5749:                }
000000C8  00000000   NOP
5750:                
5751:                // *****************************************************************************
5752:                /* Function:
5753:                    USB_INTERFACE_DESCRIPTOR * USB_HOST_DeviceGeneralInterfaceDescriptorQuery
5754:                    (
5755:                        void * descriptor
5756:                        USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query,
5757:                    );
5758:                
5759:                  Summary:
5760:                    Queries the IAD group for the specified query.
5761:                
5762:                  Description:
5763:                    This function will query will search for an interface starting from the
5764:                    location pointed to by the descriptor parameter. This descriptor parameter
5765:                    could be a pointer to an IAD or a interface descriptor.  The return pointer
5766:                    will point to the standard interface descriptor and class specific interface
5767:                    descriptors for that interface. The search criteria can specified by using
5768:                    the flags. 
5769:                    
5770:                    In a case where the interface has more than one alternate settings, the
5771:                    function can be called repetitively to continue the search till the end of the
5772:                    configuration descriptor is reached or till the search fails. The query flag
5773:                    in such should be set to ignore the alternate setting field.  The query
5774:                    object maintains the last point where the search was successful and
5775:                    continues the search from that point onwards. Resetting the query object
5776:                    (through the USB_HOST_DeviceInterfaceQueryContextClear()) function will
5777:                    reset the search object and cause the search to start from the top.
5778:                
5779:                  Remarks:
5780:                    Refer to usb_host_client_driver.h for usage information.
5781:                */
5782:                
5783:                USB_INTERFACE_DESCRIPTOR * USB_HOST_DeviceGeneralInterfaceDescriptorQuery
5784:                (
5785:                    void * descriptor,
5786:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
5787:                )
5788:                {
9D010E88  27BDFFE0   ADDIU SP, SP, -32
9D010E8C  AFBF001C   SW RA, 28(SP)
9D010E90  AFB10018   SW S1, 24(SP)
9D010E94  AFB00014   SW S0, 20(SP)
5789:                    USB_INTERFACE_DESCRIPTOR * result = NULL;
5790:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
5791:                    uint8_t * search;
5792:                    uint8_t * lastLocation;
5793:                    USB_HOST_INTERFACE_QUERY_FLAG matchedCriteria = 0;
5794:                    USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
5795:                
5796:                    if(descriptor != NULL)
9D010E98  10800049   BEQ A0, ZERO, 0x9D010FC0
9D010E9C  00808021   ADDU S0, A0, ZERO
5797:                    {
5798:                        /* We have a non null descritpor. Find where this descriptor ends */
5799:                        search = (uint8_t *)(descriptor);
5800:                        lastLocation = (uint8_t *)(_USB_HOST_FindEndOfDescriptor(search));
9D010EA0  0F4057C4   JAL _USB_HOST_FindEndOfDescriptor
9D010EA4  00A08821   ADDU S1, A1, ZERO
5801:                
5802:                        if((query->context != 0) && (query->context < (uintptr_t)(lastLocation)))
9D010EA8  8E23000C   LW V1, 12(S1)
9D010EAC  50600004   BEQL V1, ZERO, 0x9D010EC0
9D010EB0  0202182B   SLTU V1, S0, V0
9D010EB4  0062202B   SLTU A0, V1, V0
5803:                        {
5804:                            /* This is a continuing search. We start the search from the last
5805:                             * saved location */
5806:                            search = (uint8_t *)(query->context);
9D010EB8  0064800B   MOVN S0, V1, A0
5807:                        }
5808:                
5809:                        while(search < lastLocation)
9D010EBC  0202182B   SLTU V1, S0, V0
9D010EC0  1060003E   BEQ V1, ZERO, 0x9D010FBC
9D010EC4  24050004   ADDIU A1, ZERO, 4
9D010FA8  0202182B   SLTU V1, S0, V0
9D010FAC  5460FFC7   BNEL V1, ZERO, 0x9D010ECC
9D010FB0  92030001   LBU V1, 1(S0)
9D010FB4  0B4043F0   J 0x9D010FC0
9D010FB8  00008021   ADDU S0, ZERO, ZERO
9D010FBC  00008021   ADDU S0, ZERO, ZERO
5810:                        {
5811:                            /* Reset the matching criteria as this is a new search */
5812:                            matchedCriteria = 0;
5813:                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
5814:                            
5815:                            if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE)
9D010EC8  92030001   LBU V1, 1(S0)
9D010ECC  54650035   BNEL V1, A1, 0x9D010FA4
9D010ED0  92030000   LBU V1, 0(S0)
5816:                            {
5817:                                interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(search);
5818:                
5819:                                /* This means we found a interface descriptor. We need to check
5820:                                 * if it meets the criteria */
5821:                
5822:                                if(query->flags == USB_HOST_INTERFACE_QUERY_ANY)
9D010ED4  8E240008   LW A0, 8(S1)
9D010ED8  14800005   BNE A0, ZERO, 0x9D010EF0
9D010EDC  30860001   ANDI A2, A0, 1
5823:                                {
5824:                                    /* This means any interface descriptor is fine. We should
5825:                                     * stop searching. Save the query location in the context */
5826:                
5827:                                    query->context = (uintptr_t)(search + descriptorHeader->size);
9D010EE0  92020000   LBU V0, 0(S0)
9D010EE4  02021021   ADDU V0, S0, V0
5828:                                    result = (USB_INTERFACE_DESCRIPTOR *)(search);
5829:                                    break;
9D010EE8  0B4043F0   J 0x9D010FC0
9D010EEC  AE22000C   SW V0, 12(S1)
5830:                                }
5831:                                else
5832:                                {
5833:                                    /* Need to apply the specified criteria */
5834:                
5835:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_BY_NUMBER)
9D010EF0  10C00005   BEQ A2, ZERO, 0x9D010F08
9D010EF4  00001821   ADDU V1, ZERO, ZERO
5836:                                    {
5837:                                        if(interfaceDescriptor->bInterfaceNumber == query->bInterfaceNumber)
9D010EF8  92060002   LBU A2, 2(S0)
9D010EFC  92230000   LBU V1, 0(S1)
9D010F00  00C31826   XOR V1, A2, V1
9D010F04  2C630001   SLTIU V1, V1, 1
5838:                                        {
5839:                                            /* Matches by number */
5840:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_NUMBER;
5841:                                        }
5842:                                    }
5843:                
5844:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_ALT_SETTING)
9D010F08  30860002   ANDI A2, A0, 2
9D010F0C  10C00007   BEQ A2, ZERO, 0x9D010F2C
9D010F10  30860004   ANDI A2, A0, 4
5845:                                    {
5846:                                        if(interfaceDescriptor->bAlternateSetting == query->bAlternateSetting)
9D010F14  92080003   LBU T0, 3(S0)
9D010F18  92270001   LBU A3, 1(S1)
5847:                                        {
5848:                                            /* Matches by alternate setting */
5849:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_ALT_SETTING;
9D010F1C  34660002   ORI A2, V1, 2
9D010F20  01073826   XOR A3, T0, A3
9D010F24  00C7180A   MOVZ V1, A2, A3
5850:                                        }
5851:                                    }
5852:                
5853:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_BY_CLASS)
9D010F28  30860004   ANDI A2, A0, 4
9D010F2C  10C00007   BEQ A2, ZERO, 0x9D010F4C
9D010F30  30860008   ANDI A2, A0, 8
5854:                                    {
5855:                                        if(interfaceDescriptor->bInterfaceClass == query->bInterfaceClass)
9D010F34  92080005   LBU T0, 5(S0)
9D010F38  92270002   LBU A3, 2(S1)
5856:                                        {
5857:                                            /* Matches by interface class */
5858:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_CLASS;
9D010F3C  34660004   ORI A2, V1, 4
9D010F40  01073826   XOR A3, T0, A3
9D010F44  00C7180A   MOVZ V1, A2, A3
5859:                                        }
5860:                                    }
5861:                
5862:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_BY_SUBCLASS)
9D010F48  30860008   ANDI A2, A0, 8
9D010F4C  10C00007   BEQ A2, ZERO, 0x9D010F6C
9D010F50  30860010   ANDI A2, A0, 16
5863:                                    {
5864:                                        if(interfaceDescriptor->bInterfaceSubClass == query->bInterfaceSubClass)
9D010F54  92080006   LBU T0, 6(S0)
9D010F58  92270003   LBU A3, 3(S1)
5865:                                        {
5866:                                            /* Matches by interface subclass */
5867:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_SUBCLASS;
9D010F5C  34660008   ORI A2, V1, 8
9D010F60  01073826   XOR A3, T0, A3
9D010F64  00C7180A   MOVZ V1, A2, A3
5868:                                        }
5869:                                    }
5870:                
5871:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_BY_PROTOCOL)
9D010F68  30860010   ANDI A2, A0, 16
9D010F6C  10C00005   BEQ A2, ZERO, 0x9D010F84
9D010F70  34660010   ORI A2, V1, 16
5872:                                    {
5873:                                        if(interfaceDescriptor->bInterfaceProtocol == query->bInterfaceProtocol)
9D010F74  92080007   LBU T0, 7(S0)
9D010F78  92270004   LBU A3, 4(S1)
5874:                                        {
5875:                                            /* Matches by interface protocol */
5876:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_PROTOCOL;
9D010F7C  01073826   XOR A3, T0, A3
9D010F80  00C7180A   MOVZ V1, A2, A3
5877:                                        }
5878:                                    }
5879:                
5880:                                    /* Now check if we have met all the criteria */
5881:                
5882:                                    if(matchedCriteria == query->flags)
9D010F84  54640005   BNEL V1, A0, 0x9D010F9C
9D010F88  92030000   LBU V1, 0(S0)
5883:                                    {
5884:                                        /* Yes we have. Save the search location and exit */
5885:                                        query->context = (uintptr_t)(search + descriptorHeader->size);
9D010F8C  92020000   LBU V0, 0(S0)
9D010F90  02021021   ADDU V0, S0, V0
5886:                                        result = (USB_INTERFACE_DESCRIPTOR *)(search);
5887:                                        break;
9D010F94  0B4043F0   J 0x9D010FC0
9D010F98  AE22000C   SW V0, 12(S1)
9D010F9C  0B4043EA   J 0x9D010FA8
9D010FA0  02038021   ADDU S0, S0, V1
5888:                                    }
5889:                                    else
5890:                                    {
5891:                                        /* We did not match the criteria */
5892:                                        search += descriptorHeader->size;
5893:                                    }
5894:                                }
5895:                            }
5896:                            else
5897:                            {
5898:                                /* Go to the next descriptor */
5899:                                search += descriptorHeader->size;
9D010FA4  02038021   ADDU S0, S0, V1
5900:                            }
5901:                        }
5902:                    }
5903:                
5904:                    return(result);
5905:                }
9D010FC0  02001021   ADDU V0, S0, ZERO
5906:                
5907:                // *****************************************************************************
5908:                /* Function:
5909:                    USB_HOST_RESULT USB_HOST_DeviceInterfaceSet
5910:                    (
5911:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
5912:                        USB_HOST_REQUEST_HANDLE * requestHandle,
5913:                        uint8_t alternateSetting,
5914:                        uintptr_t context
5915:                    );
5916:                
5917:                  Summary:
5918:                    Activates an alternate setting for the specified interface.
5919:                
5920:                  Description:
5921:                    This function activates an alternate setting for the specified interface.
5922:                    This will cause the host layer to send a SET INTERFACE request to the
5923:                    device.  The specified interface should have been claimed. The completion of
5924:                    the SET INTERFACE function will be indicated by the
5925:                    USB_HOST_DEVICE_EVENT_SET_INTERFACE_COMPLETE event.
5926:                
5927:                  Remarks:
5928:                    Refer to usb_host_client_driver.h for usage information.
5929:                */
5930:                
5931:                USB_HOST_RESULT USB_HOST_DeviceInterfaceSet
5932:                (
5933:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
5934:                    USB_HOST_REQUEST_HANDLE * requestHandle,
5935:                    uint8_t alternateSetting,
5936:                    uintptr_t context
5937:                )
5938:                {
00000000  00000000   NOP
5939:                    USB_HOST_RESULT result;
5940:                    USB_HOST_DEVICE_OBJ * deviceObj;
5941:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj; 
5942:                    int deviceIndex, interfaceIndex, pnpIdentifier;
5943:                    USB_HOST_INTERFACE_DESC_INFO * interfaceDescInfo;
5944:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY interfaceQueryObject;
5945:                
5946:                    /* Get the device index and then the pointer to the device object */
5947:                
5948:                    deviceIndex = USB_HOST_DEVICE_INDEX(interfaceHandle);
00000024  00000000   NOP
5949:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
00000028  00000000   NOP
5950:                
5951:                    if(!deviceObj->inUse)
00000048  00000000   NOP
5952:                    {
5953:                        /* Device object is not valid anymore */
5954:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
00000174  00000000   NOP
5955:                    }
5956:                    else
5957:                    {
5958:                        /* Check the Plug N Play identifier */
5959:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(interfaceHandle);
00000054  00000000   NOP
5960:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
00000058  00000000   NOP
5961:                        {
5962:                            /* This is not the same device the client driver thinks it is */
5963:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
0000017C  00000000   NOP
5964:                
5965:                        }
5966:                        else
5967:                        {
5968:                            interfaceIndex = USB_HOST_INTERFACE_INDEX(interfaceHandle);
5969:                            interfaceDescInfo = &deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex];
00000064  00000000   NOP
5970:                            if(interfaceDescInfo->interfaceDescriptor == NULL)
00000070  00000000   NOP
5971:                            {
5972:                                /* This means this interface is not valid */
5973:                                result = USB_HOST_RESULT_INTERFACE_UNKNOWN;
00000184  00000000   NOP
5974:                            }
5975:                            else
5976:                            {
5977:                                /* We must search for this interface */
5978:                                USB_HOST_DeviceInterfaceQueryContextClear(&interfaceQueryObject);
5979:                                interfaceQueryObject.bInterfaceNumber = interfaceIndex;
00000084  00000000   NOP
5980:                                interfaceQueryObject.bAlternateSetting = alternateSetting;
00000088  00000000   NOP
5981:                                interfaceQueryObject.flags = USB_HOST_INTERFACE_QUERY_ALT_SETTING|USB_HOST_INTERFACE_QUERY_BY_NUMBER;
0000008C  00000000   NOP
5982:                                if(USB_HOST_DeviceGeneralInterfaceDescriptorQuery(interfaceDescInfo->interfaceDescriptor,
00000094  00000000   NOP
5983:                                            &interfaceQueryObject) == NULL)
5984:                                {
5985:                                    /* This alternate setting does not exist */
5986:                                    result = USB_HOST_RESULT_INTERFACE_UNKNOWN;
0000018C  00000000   NOP
5987:                                }
5988:                                else
5989:                                {
5990:                                    /* Set the request handle default to invalid */
5991:                                    *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
000000A8  00000000   NOP
5992:                
5993:                                    /* Get a mutual exclusion lock as the the control transfer object is a global resource */
5994:                                    if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) 
5995:                                            == OSAL_RESULT_TRUE)
5996:                                    {
5997:                                        if(!deviceObj->controlTransferObj.inUse)
000000C0  00000000   NOP
5998:                                        {
5999:                                            /* This means that there no control request in progress. We can assign
6000:                                             * request now. The request handle is updated to point to the device
6001:                                             * control transfer object. */
6002:                
6003:                                            deviceObj->controlTransferObj.inUse = true;
000000CC  00000000   NOP
6004:                                            *requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
000000D4  00000000   NOP
6005:                                        }
6006:                                        else
6007:                                        {
6008:                                            /* A control transfer is in progress. */
6009:                                            result = USB_HOST_RESULT_REQUEST_BUSY;
6010:                                        }
6011:                
6012:                                        /* Unlock the mutual exclusion lock */
6013:                                        OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
6014:                                    }
6015:                                    else
6016:                                    {
6017:                                        /* The mutual exclusion lock could not be obtained */
6018:                                        result = USB_HOST_RESULT_REQUEST_BUSY;
6019:                                    }
6020:                
6021:                                    if(*requestHandle != USB_HOST_REQUEST_HANDLE_INVALID)
000000E4  00000000   NOP
6022:                                    {
6023:                                        /* Set up the control transfer object. The endpoint halt
6024:                                         * clear request does not have a data stage. */
6025:                                        controlTransferObj = &deviceObj->controlTransferObj;
6026:                                        controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_INTERFACE_SET;
000000F4  00000000   NOP
6027:                                        
6028:                                        /* Remember which alternate setting was requested. This
6029:                                         * will be needed after we get the event */
6030:                                        deviceObj->requestedAlternateSetting = alternateSetting;
000000FC  00000000   NOP
6031:                
6032:                                        _USB_HOST_FillSetupPacket(
00000120  00000000   NOP
6033:                                                &(deviceObj->setupPacket),
6034:                                                ( USB_SETUP_DIRN_HOST_TO_DEVICE |
6035:                                                  USB_SETUP_TYPE_STANDARD |
6036:                                                  USB_SETUP_RECIPIENT_INTERFACE ),
6037:                                                USB_REQUEST_SET_INTERFACE,
6038:                                                alternateSetting , interfaceIndex  ,0 ) ;
6039:                
6040:                                        controlTransferObj->controlIRP.data = NULL;
0000011C  00000000   NOP
6041:                                        controlTransferObj->controlIRP.setup = &deviceObj->setupPacket;
00000124  00000000   NOP
6042:                                        controlTransferObj->controlIRP.size = deviceObj->setupPacket.wLength;
00000128  00000000   NOP
6043:                                        controlTransferObj->controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
0000012C  00000000   NOP
6044:                                        controlTransferObj->controlIRP.userData = interfaceHandle;
00000138  00000000   NOP
6045:                                        controlTransferObj->context = context;
0000013C  00000000   NOP
6046:                                        controlTransferObj->callback = NULL;
00000140  00000000   NOP
6047:                
6048:                                        if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(controlTransferObj->controlIRP)))
00000144  00000000   NOP
6049:                                        {
6050:                                            /* There was a problem while submitting the IRP. Update the result and
6051:                                             * the transfer handle. Return the control transfer object back to the
6052:                                             * device object */
6053:                
6054:                                            result = USB_HOST_RESULT_FAILURE;
6055:                                            controlTransferObj->inUse = false;
00000160  00000000   NOP
6056:                                            *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
00000164  00000000   NOP
6057:                                        }
6058:                                        else
6059:                                        {
6060:                                            result = USB_HOST_RESULT_SUCCESS;
6061:                                        }
6062:                                    }
6063:                                }
6064:                            }
6065:                        }
6066:                    }
6067:                
6068:                    return(result);
6069:                }
00000190  00000000   NOP
6070:                
6071:                // *****************************************************************************
6072:                /* Function:
6073:                    USB_HOST_RESULT USB_HOST_DeviceStringDescriptorGet
6074:                    (
6075:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
6076:                        USB_HOST_DEVICE_STRING stringType,
6077:                        uint16_t languageID,
6078:                        void * stringDescriptor,
6079:                        size_t length,
6080:                        USB_HOST_REQUEST_HANDLE * requestHandle,
6081:                        USB_HOST_STRING_REQUEST_COMPLETE_CALLBACK callback,
6082:                        uintptr_t context
6083:                    );
6084:                
6085:                  Summary:
6086:                    Retrieves specified string descriptor from the device
6087:                
6088:                  Description:
6089:                    This function retrieves the specified string descriptor from the device.
6090:                    This function will cause the host layer to issue a control transfer to the
6091:                    device. When the string descriptor is available, the host layer will call
6092:                    the callback function to let the application know that the request has
6093:                    completed. 
6094:                    
6095:                    The function will return a valid request handle in requestHandle, if the
6096:                    request was successful. This request handle will be returned in the callback
6097:                    function. The size of the stringDescriptor buffer is specified by the length
6098:                    parameter.  Only length number of bytes will be retrieved. The type of
6099:                    device string descriptor to be retrieved is specified by the stringType
6100:                    parameter. The supported language IDs, manufacturer, product and serial
6101:                    number strings can be obtained. While obtaining the supported language IDs,
6102:                    the languageID parameter will be ignored.
6103:                
6104:                  Remarks:
6105:                    None.
6106:                */
6107:                
6108:                USB_HOST_RESULT USB_HOST_DeviceStringDescriptorGet
6109:                (
6110:                    USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
6111:                    USB_HOST_DEVICE_STRING stringType,
6112:                    uint16_t languageID,
6113:                    void * stringDescriptor,
6114:                    size_t length,
6115:                    USB_HOST_REQUEST_HANDLE * requestHandle,
6116:                    USB_HOST_STRING_REQUEST_COMPLETE_CALLBACK callback,
6117:                    uintptr_t context
6118:                )
6119:                {
00000000  00000000   NOP
6120:                    int deviceIndex, pnpIdentifier;
6121:                    USB_HOST_DEVICE_OBJ * deviceObj;
6122:                    USB_HOST_RESULT result;
6123:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj;
6124:                    uint8_t stringIndex;
6125:                
6126:                    /* Get the device index and then the pointer to the device object */
6127:                
6128:                    deviceIndex = USB_HOST_DEVICE_INDEX(deviceObjHandle);
0000001C  00000000   NOP
6129:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
00000020  00000000   NOP
6130:                
6131:                    if(!deviceObj->inUse)
00000040  00000000   NOP
6132:                    {
6133:                        /* Device object is not valid anymore */
6134:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
000001A0  00000000   NOP
6135:                    }
6136:                    else
6137:                    {
6138:                        /* Check the Plug N Play identifier */
6139:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceObjHandle);
0000004C  00000000   NOP
6140:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
00000050  00000000   NOP
6141:                        {
6142:                            /* This is not the same device as the application thinks it is */
6143:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
6144:                        }
6145:                        else
6146:                        {
6147:                            if((stringDescriptor == NULL) || (length == 0) || (requestHandle == NULL) || (callback == NULL))
0000005C  00000000   NOP
6148:                            {
6149:                                /* One of the required parameter is not valid */
6150:                                result = USB_HOST_RESULT_PARAMETER_INVALID;
6151:                            }
6152:                            else
6153:                            {
6154:                                /* Need to check if the device is in a failure state */
6155:                                if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_ERROR)
0000007C  00000000   NOP
6156:                                {
6157:                                    result = USB_HOST_RESULT_FAILURE;
6158:                                }
6159:                                else
6160:                                {
6161:                                    if(deviceObj->deviceState != USB_HOST_DEVICE_STATE_READY)
0000008C  00000000   NOP
6162:                                    {
6163:                                        /* The device must be in a ready state */
6164:                                        result = USB_HOST_RESULT_REQUEST_BUSY;
000001A8  00000000   NOP
6165:                                    }
6166:                                    else
6167:                                    {
6168:                                        /* Map the string type to string index. Set the default
6169:                                         * string index to 0. */
6170:                                        
6171:                                        stringIndex = 0;
6172:                                        switch(stringType)
00000098  00000000   NOP
6173:                                        {
6174:                                            case USB_HOST_DEVICE_STRING_LANG_ID:
6175:                
6176:                                                /* Setting string index to zero will get the
6177:                                                 * the language ID */
6178:                                                stringIndex = 0;
6179:                                                break;
6180:                
6181:                                            case USB_HOST_DEVICE_STRING_MANUFACTURER:
6182:                
6183:                                                /* Set the string index to the manufacture string
6184:                                                   index */
6185:                                                stringIndex = deviceObj->deviceDescriptor.iManufacturer;
6186:                                                break;
000000B8  00000000   NOP
6187:                
6188:                                            case USB_HOST_DEVICE_STRING_PRODUCT:
6189:                
6190:                                                /* Set the string index to the manufacture string
6191:                                                   index */
6192:                                                stringIndex = deviceObj->deviceDescriptor.iProduct;
6193:                                                break;
6194:                
6195:                                            case USB_HOST_DEVICE_STRING_SERIAL_NUMBER:
6196:                
6197:                                                /* Set the string index to the manufacture string
6198:                                                   index */
6199:                                                stringIndex = deviceObj->deviceDescriptor.iSerialNumber;
6200:                                                break;
6201:                
6202:                                            default:
6203:                                                break;
6204:                                        }
6205:                
6206:                                        if((stringIndex == 0) && (stringType != USB_HOST_DEVICE_STRING_LANG_ID))
000000C0  00000000   NOP
000001B8  00000000   NOP
6207:                                        {
6208:                                            /* This means that the device does not support the
6209:                                             * requested string. */
6210:                
6211:                                            result = USB_HOST_RESULT_STRING_DESCRIPTOR_UNSUPPORTED;
000001B0  00000000   NOP
6212:                                        }
6213:                                        else
6214:                                        {
6215:                                            /* Set the request handle default to invalid */
6216:                                            *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
000000C8  00000000   NOP
6217:                
6218:                                            /* Get a mutual exclusion lock as the control transfer object is a global
6219:                                             * resource */
6220:                
6221:                                            if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) 
6222:                                                    == OSAL_RESULT_TRUE)
6223:                                            {
6224:                                                if(!deviceObj->controlTransferObj.inUse)
000000E4  00000000   NOP
6225:                                                {
6226:                                                    /* This means that there no control request in progress. We can assign
6227:                                                     * request now. The request handle is updated to point to the device
6228:                                                     * control transfer object. */
6229:                
6230:                                                    deviceObj->controlTransferObj.inUse = true;
000000F0  00000000   NOP
6231:                                                    *requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
000000F8  00000000   NOP
6232:                                                }
6233:                                                else
6234:                                                {
6235:                                                    /* A control transfer is in progress. */
6236:                                                    result = USB_HOST_RESULT_REQUEST_BUSY;
6237:                                                }
6238:                
6239:                                                /* Unlock the mutual exclusion lock */
6240:                                                OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
6241:                                            }
6242:                                            else
6243:                                            {
6244:                                                /* The mutual exclusion lock could not be obtained */
6245:                                                result = USB_HOST_RESULT_REQUEST_BUSY;
6246:                                            }
6247:                
6248:                                            if(*requestHandle != USB_HOST_REQUEST_HANDLE_INVALID)
00000108  00000000   NOP
6249:                                            {
6250:                                                /* Set up the control transfer object. The request type
6251:                                                 * allows the one control transfer handler to identify the
6252:                                                 * type of the request. In this case this is a string
6253:                                                 * descriptor request.  */
6254:                                                controlTransferObj = &deviceObj->controlTransferObj;
6255:                                                controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_STRING_DESCRIPTOR;
00000118  00000000   NOP
6256:                
6257:                                                _USB_HOST_FillSetupPacket(
00000134  00000000   NOP
00000148  00000000   NOP
6258:                                                        &(deviceObj->setupPacket),
6259:                                                        ( USB_SETUP_DIRN_DEVICE_TO_HOST |
6260:                                                          USB_SETUP_TYPE_STANDARD |
6261:                                                          USB_SETUP_RECIPIENT_DEVICE ),
6262:                                                        USB_REQUEST_GET_DESCRIPTOR,
6263:                                                        ((USB_DESCRIPTOR_STRING << 8)|stringIndex), languageID, length ) ;
6264:                
6265:                                                /* The userData filed in the IRP is set to the device object
6266:                                                 * handle. This will allow the control transfer callback to
6267:                                                 * identify the device which submitted the control
6268:                                                 * transfer. */
6269:                
6270:                                                controlTransferObj->controlIRP.data = stringDescriptor;
00000144  00000000   NOP
6271:                                                controlTransferObj->controlIRP.setup = &deviceObj->setupPacket;
0000014C  00000000   NOP
6272:                                                controlTransferObj->controlIRP.size = deviceObj->setupPacket.wLength;
00000150  00000000   NOP
6273:                                                controlTransferObj->controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
00000154  00000000   NOP
6274:                                                controlTransferObj->controlIRP.userData = deviceObjHandle ;
00000160  00000000   NOP
6275:                                                controlTransferObj->context = context;
00000164  00000000   NOP
6276:                                                controlTransferObj->callback = callback;
0000016C  00000000   NOP
6277:                
6278:                                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(controlTransferObj->controlIRP)))
00000170  00000000   NOP
6279:                                                {
6280:                                                    /* There was a problem while submitting the IRP. Update the result and
6281:                                                     * the transfer handle. Return the control transfer object back to the
6282:                                                     * device object */
6283:                
6284:                                                    result = USB_HOST_RESULT_FAILURE;
6285:                                                    controlTransferObj->inUse = false;
0000018C  00000000   NOP
6286:                                                    *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
00000190  00000000   NOP
6287:                                                }
6288:                                                else
6289:                                                {
6290:                                                    result = USB_HOST_RESULT_SUCCESS;
6291:                                                }
6292:                                            }
6293:                                        }
6294:                                    }
6295:                                }
6296:                            }
6297:                        }
6298:                    }
6299:                    
6300:                    return(result);
6301:                }
000001C0  00000000   NOP
6302:                
6303:                // *****************************************************************************
6304:                /* Function:
6305:                    void USB_HOST_OverCurrentDetected
6306:                    (
6307:                        USB_HOST_DEVICE_OBJ_HANDLE parentDeviceObjHandle,
6308:                        uint8_t port,
6309:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
6310:                    );
6311:                
6312:                  Summary:
6313:                    This function provides indication to the host layer that an over-current
6314:                    event has occurred.
6315:                    
6316:                  Description:
6317:                    This function provides indication to the host layer that an over-current
6318:                    event has occurred. The host layer will in turn forward the event to the
6319:                    application. This function is called exclusively by the root hub or the
6320:                    external hub driver. The root hub or the external driver will de-enumerate
6321:                    this device after the function returns.
6322:                
6323:                  Remarks:
6324:                    This function is optional and may not be available on all implementations of
6325:                    the USB Host Layer. 
6326:                */
6327:                
6328:                void USB_HOST_OverCurrentDetected
6329:                (
6330:                    USB_HOST_DEVICE_OBJ_HANDLE parentDeviceObjHandle,
6331:                    uint8_t port,
6332:                    USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
6333:                )
6334:                {
00000010  00000000   NOP
6335:                    /* This function is called when an overcurrent condition has occurred. The
6336:                     * root hub or the external hub driver would de-enumerate the device after
6337:                     * this function exits. So the only thing we should do is to call the
6338:                     * application event handler and let the application know that the over
6339:                     * current event has occurred. */
6340:                
6341:                    if(gUSBHostObj.hostEventHandler != NULL)
00000000  00000000   NOP
6342:                    {
6343:                        /* In this version of the host layer, we do not send any event data with
6344:                         * this event */
6345:                
6346:                        gUSBHostObj.hostEventHandler(USB_HOST_EVENT_PORT_OVERCURRENT_DETECTED, NULL, gUSBHostObj.context);
00000018  00000000   NOP
6347:                    }
6348:                }
00000028  00000000   NOP
6349:                
6350:                // *****************************************************************************
6351:                /* Function:
6352:                    USB_HOST_RESULT USB_HOST_ConfigurationDescriptorGet
6353:                    (
6354:                        USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
6355:                        USB_HOST_REQUEST_HANDLE * requestHandle
6356:                        uint8_t configurationIndex,
6357:                        void * buffer,
6358:                        size_t size,
6359:                        uintptr_t context
6360:                    );
6361:                
6362:                  Summary:
6363:                    Requests for a configuration descriptor.
6364:                
6365:                  Description:
6366:                    This function places a USB Host request to obtain a device configuration
6367:                    descriptor. The function is non blocking. A pointer to the configuration
6368:                    descriptor data will be available in event data when the
6369:                    USB_HOST_DEVICE_EVENT_CONFIGURATION_DESCRIPTOR_GET_COMPLETE event occurs.
6370:                    The size of the configuration descriptor will be available in the event
6371:                    data.
6372:                
6373:                  Remarks:
6374:                    None.
6375:                */
6376:                
6377:                USB_HOST_RESULT USB_HOST_DeviceConfigurationDescriptorGet
6378:                (
6379:                    USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
6380:                    USB_HOST_REQUEST_HANDLE * requestHandle,
6381:                    uint8_t configurationValue,
6382:                    void * buffer,
6383:                    size_t size,
6384:                    uintptr_t context
6385:                )
6386:                {
00000000  00000000   NOP
6387:                    int deviceIndex, pnpIdentifier;
6388:                    USB_HOST_DEVICE_OBJ * deviceObj;
6389:                    USB_HOST_RESULT result;
6390:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj;
6391:                
6392:                
6393:                    /* Get the device index and then the pointer to the device object */
6394:                
6395:                    deviceIndex = USB_HOST_DEVICE_INDEX(deviceHandle);
00000018  00000000   NOP
6396:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
0000001C  00000000   NOP
6397:                
6398:                    if(!deviceObj->inUse)
0000003C  00000000   NOP
6399:                    {
6400:                        /* Device object is not valid anymore */
6401:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
00000160  00000000   NOP
6402:                    }
6403:                    else
6404:                    {
6405:                        /* Check the Plug N Play identifier */
6406:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceHandle);
00000048  00000000   NOP
6407:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
0000004C  00000000   NOP
6408:                        {
6409:                            /* This is not the same device as the application thinks it is */
6410:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
6411:                        }
6412:                        else
6413:                        {
6414:                            if((size == 0) || (requestHandle == NULL) || (buffer == NULL))
00000058  00000000   NOP
6415:                            {
6416:                                /* One of the required parameter is not valid */
6417:                                result = USB_HOST_RESULT_PARAMETER_INVALID;
6418:                            }
6419:                            else
6420:                            {
6421:                                /* Need to check if the device is in a failure state */
6422:                                if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_ERROR)
00000070  00000000   NOP
6423:                                {
6424:                                    result = USB_HOST_RESULT_FAILURE;
6425:                                }
6426:                                else
6427:                                {
6428:                                    if(deviceObj->deviceState != USB_HOST_DEVICE_STATE_READY)
00000080  00000000   NOP
6429:                                    {
6430:                                        /* The device must be in a ready state */
6431:                                        result = USB_HOST_RESULT_REQUEST_BUSY;
00000168  00000000   NOP
6432:                                    }
6433:                                    else
6434:                                    {     
6435:                                        /* Set the request handle default to invalid */
6436:                                        *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
0000008C  00000000   NOP
6437:                
6438:                                        /* Get a mutual exclusion lock as the control transfer object is a global
6439:                                         * resource */
6440:                
6441:                                        if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) 
6442:                                                == OSAL_RESULT_TRUE)
6443:                                        {
6444:                                            if(!deviceObj->controlTransferObj.inUse)
000000A4  00000000   NOP
6445:                                            {
6446:                                                /* This means that there no control request in progress. We can assign
6447:                                                 * request now. The request handle is updated to point to the device
6448:                                                 * control transfer object. */
6449:                
6450:                                                deviceObj->controlTransferObj.inUse = true;
000000B0  00000000   NOP
6451:                                                *requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
000000B8  00000000   NOP
6452:                                            }
6453:                                            else
6454:                                            {
6455:                                                /* A control transfer is in progress. */
6456:                                                result = USB_HOST_RESULT_REQUEST_BUSY;
6457:                                            }
6458:                
6459:                                            /* Unlock the mutual exclusion lock */
6460:                                            OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
6461:                                        }
6462:                                        else
6463:                                        {
6464:                                            /* The mutual exclusion lock could not be obtained */
6465:                                            result = USB_HOST_RESULT_REQUEST_BUSY;
6466:                                        }
6467:                
6468:                                        if(*requestHandle != USB_HOST_REQUEST_HANDLE_INVALID)
000000C8  00000000   NOP
6469:                                        {
6470:                
6471:                                            /* Create the Setup packet */
6472:                                            _USB_HOST_FillSetupPacket(
000000EC  00000000   NOP
00000108  00000000   NOP
6473:                                                    &(deviceObj->setupPacket),
6474:                                                    ( USB_SETUP_DIRN_DEVICE_TO_HOST |
6475:                                                      USB_SETUP_TYPE_STANDARD |
6476:                                                      USB_SETUP_RECIPIENT_DEVICE ),
6477:                                                    USB_REQUEST_GET_DESCRIPTOR,
6478:                                                    ( USB_DESCRIPTOR_CONFIGURATION << 8 ) + configurationValue , 0 , size ) ;
6479:                
6480:                                            /* Set up the control transfer object. The endpoint halt
6481:                                             * clear request does not have a data stage. */
6482:                                            controlTransferObj = &deviceObj->controlTransferObj;
6483:                                            controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_CONFIGURATION_DESCRIPTOR_GET;
000000FC  00000000   NOP
6484:                
6485:                                            controlTransferObj->controlIRP.data = buffer;
00000104  00000000   NOP
6486:                                            controlTransferObj->controlIRP.setup = &deviceObj->setupPacket;
0000010C  00000000   NOP
6487:                                            controlTransferObj->controlIRP.size = deviceObj->setupPacket.wLength;
00000110  00000000   NOP
6488:                                            controlTransferObj->controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
00000114  00000000   NOP
6489:                                            controlTransferObj->controlIRP.userData = deviceHandle;
00000120  00000000   NOP
6490:                                            controlTransferObj->context = context;
00000124  00000000   NOP
6491:                                            controlTransferObj->callback = NULL;
0000012C  00000000   NOP
6492:                
6493:                                            if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(controlTransferObj->controlIRP)))
00000130  00000000   NOP
6494:                                            {
6495:                                                /* There was a problem while submitting the IRP. Update the result and
6496:                                                 * the transfer handle. Return the control transfer object back to the
6497:                                                 * device object */
6498:                
6499:                                                result = USB_HOST_RESULT_FAILURE;
6500:                                                controlTransferObj->inUse = false;
0000014C  00000000   NOP
6501:                                                *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
00000150  00000000   NOP
6502:                                            }
6503:                                            else
6504:                                            {
6505:                                                result = USB_HOST_RESULT_SUCCESS;
6506:                                            }
6507:                
6508:                                        }
6509:                
6510:                                    }
6511:                                }
6512:                            }
6513:                        }
6514:                    }
6515:                    return result;
6516:                }
0000016C  00000000   NOP
6517:                
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/system/tmr/src/sys_tmr.c
1:                   /*******************************************************************************
2:                     Timer System Service Definition
3:                   
4:                   Company:
5:                   Microchip Technology Inc.
6:                   
7:                   File Name:
8:                   sys_tmr.c
9:                   
10:                  Summary:
11:                  Timer System Service implementation.
12:                  
13:                  Description:
14:                  The Timer System Service provides a simple interface to manage the Timer modules
15:                  on Microchip micro controllers.  This file implements the core interface routines
16:                  for the System Timer Service.
17:                  While building the SYS TMR from source, ALWAYS use this file in the build.
18:                   *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                    Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                    Microchip licenses to you the right to use, modify, copy and distribute
25:                    Software only when embedded on a Microchip microcontroller or digital signal
26:                    controller that is integrated into your product or third party product
27:                    (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                    You should refer to the license agreement accompanying this Software for
30:                    additional information regarding your rights and obligations.
31:                  
32:                    SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                    EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                    MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                    IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                    CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                    OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                    INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                    CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                    SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                    (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                   *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Included Files
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  /*  This section lists the other files that are included in this file.
51:                  */
52:                  
53:                  #include "system/tmr/src/sys_tmr_local.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Variable Definitions
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  
62:                  
63:                  /* System timer instance */
64:                  static SYS_TMR_OBJECT           sSysTmrObject = { 0 };
65:                  
66:                  /* Client object array */
67:                  static SYS_TMR_CLIENT_OBJECT    sClientObjects [ SYS_TMR_MAX_CLIENT_OBJECTS ];
68:                  
69:                  
70:                  // *****************************************************************************
71:                  /* OSAL user protection 
72:                  
73:                  Summary:
74:                      Enforces the user threads protection
75:                  
76:                  Description:
77:                      Protects against multiple users using concurrently the TMR service.
78:                      For efficiency reasons, there is NO PROTECTION for each API call except
79:                      when creating and deleting new timer clients!
80:                      What it means is that:
81:                      - A client timer cannot be used concurrently from multiple threads!
82:                      It's ok to pass a handle from one thread to another as long as
83:                      there's is no access from more than one thread at a time
84:                  
85:                  Remarks:
86:                  
87:                  None.
88:                  */
89:                  
90:                  static __inline__ bool  __attribute__((always_inline))   _UserGblLockCreate(void)
91:                  {
92:                      // create the shared Data Lock
93:                      return OSAL_SEM_Create(&sSysTmrObject.userSem, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE;
94:                  }    
95:                  
96:                  static __inline__ void  __attribute__((always_inline))          _UserGblLockDelete(void)
97:                  {
98:                      OSAL_SEM_Delete(&sSysTmrObject.userSem);
99:                  }    
100:                 
101:                 // locks access to shared resources
102:                 static __inline__ void  __attribute__((always_inline))          _UserGblLock(void)
103:                 {
104:                     // Shared Data Lock
105:                     OSAL_SEM_Pend(&sSysTmrObject.userSem, OSAL_WAIT_FOREVER);
106:                 }    
107:                 
108:                 // unlocks access to shared resources
109:                 static __inline__ void  __attribute__((always_inline))          _UserGblUnlock(void)
110:                 {
111:                     // Shared Data unlock
112:                     OSAL_SEM_Post(&sSysTmrObject.userSem);
113:                 }
114:                 
115:                 // ISR protection
116:                 // when the timer driver delivers the notification in interrupts
117:                 #if (SYS_TMR_INTERRUPT_NOTIFICATION)
118:                 // do not re-schedule while locked the timer ISR
119:                 // this needs to be real quick
120:                 static __inline__ bool __attribute__((always_inline)) _IsrTmrLock(OSAL_CRITSECT_DATA_TYPE* pCritStat)
121:                 {
122:                     *pCritStat = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
123:                     return DRV_TMR_AlarmDisable(sSysTmrObject.driverHandle);
124:                 }
125:                 
126:                 static __inline__ void __attribute__((always_inline)) _IsrTmrUnlock(bool lock, OSAL_CRITSECT_DATA_TYPE critStat)
127:                 {
128:                     DRV_TMR_AlarmEnable(sSysTmrObject.driverHandle, lock);
129:                     OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critStat);
130:                 }
131:                 
132:                 #else   // !(SYS_TMR_INTERRUPT_NOTIFICATION)
133:                 static __inline__ bool __attribute__((always_inline)) _IsrTmrLock(OSAL_CRITSECT_DATA_TYPE* pCritStat)
134:                 {
135:                     return false;
136:                 }
137:                 
138:                 static __inline__ void __attribute__((always_inline)) _IsrTmrUnlock(bool lock, OSAL_CRITSECT_DATA_TYPE critStat)
139:                 {
140:                 }
141:                 
142:                 #endif  // (SYS_TMR_INTERRUPT_NOTIFICATION)
143:                 
144:                 
145:                 static __inline__ void __attribute__((always_inline)) _SYS_TMR_ClientSrvUnlock(void)
146:                 {
147:                     _UserGblUnlock();
148:                 }
149:                 
150:                 
151:                 // access to the object is protected from threads and ISR
152:                 // make it quick
153:                 static __inline__ void __attribute__((always_inline)) _SYS_TMR_ClientDelete(SYS_TMR_CLIENT_OBJECT* pClient)
154:                 {
155:                     pClient->isrEnable = 0;
9D009DC8  A2000001   SB ZERO, 1(S0)
9D012B78  A0400001   SB ZERO, 1(V0)
00000018  00000000   NOP
156:                     pClient->isrState = SYS_TMR_CLIENT_ISR_IDLE;
9D009DCC  A2000002   SB ZERO, 2(S0)
9D012B7C  A0400002   SB ZERO, 2(V0)
0000001C  00000000   NOP
0000008C  00000000   NOP
157:                     pClient->currState = SYS_TMR_CLIENT_FREE;
9D009DD0  0B402778   J 0x9D009DE0
9D009DD4  A2000000   SB ZERO, 0(S0)
9D012B80  A0400000   SB ZERO, 0(V0)
00000020  00000000   NOP
00000058  00000000   NOP
00000090  00000000   NOP
158:                     // do other clean up here
159:                 }
160:                 
161:                 static __inline__ bool __attribute__((always_inline)) _SYS_TMR_ObjectCheck(SYS_MODULE_OBJ object)
162:                 {
163:                     // basic sanity check we're the right object
164:                     return (SYS_TMR_OBJECT*)object == &sSysTmrObject;
165:                 }
166:                 
167:                 static __inline__ bool __attribute__((always_inline)) _SYS_TMR_ReadyCheck(void)
168:                 {
169:                     // basic sanity check the SYS_TMR is in the up and running state
170:                     return sSysTmrObject.status == SYS_STATUS_READY;
9D00FB0C  3C028001   LUI V0, -32767
9D01457C  3C028001   LUI V0, -32767
00000000  00000000   NOP
171:                 }
172:                 
173:                 // check the validity of a client handle and locks the user threads
174:                 // returns a valid pointer if success and _SYS_TMR_ClientSrvUnlock() needs to be called
175:                 // returns 0 if invalid, do NOT call _SYS_TMR_ClientSrvUnlock !
176:                 //
177:                 static SYS_TMR_CLIENT_OBJECT* _SYS_TMR_ClientCheckSrvLock(SYS_TMR_HANDLE handle)
178:                 {
9D014590  27BDFFF8   ADDIU SP, SP, -8
9D014594  AFBF0004   SW RA, 4(SP)
179:                     if(!_SYS_TMR_ReadyCheck())
9D014580  8C454CE0   LW A1, 19680(V0)
9D014584  24030002   ADDIU V1, ZERO, 2
9D014588  14A30024   BNE A1, V1, 0x9D01461C
9D01458C  00001021   ADDU V0, ZERO, ZERO
180:                     {
181:                         return 0;
182:                     }
183:                 
184:                     // lock client access
185:                     _UserGblLock();
186:                     if(handle != 0 && handle != SYS_TMR_HANDLE_INVALID)
9D0145C0  0B405175   J 0x9D0145D4
9D0145C4  2482FFFF   ADDIU V0, A0, -1
9D0145D0  2482FFFF   ADDIU V0, A0, -1
9D0145D4  2C42FFFE   SLTIU V0, V0, -2
9D0145D8  10400004   BEQ V0, ZERO, _SYS_TMR_ClientCheckSrvLock::_UserGblUnlock
9D0145DC  00000000   NOP
187:                     {   // extra sanity check could be added here
188:                         if( ((SYS_TMR_CLIENT_OBJECT*)handle)->currState > 0)
9D0145E0  80830000   LB V1, 0(A0)
9D0145E4  1C60000B   BGTZ V1, 0x9D014614
9D0145E8  00801021   ADDU V0, A0, ZERO
189:                         {
190:                             return (SYS_TMR_CLIENT_OBJECT*)handle;
191:                         }
192:                     }
193:                 
194:                     // not a valid client
195:                     _UserGblUnlock();
196:                     return 0;
9D014610  00001021   ADDU V0, ZERO, ZERO
197:                 }
9D014614  8FBF0004   LW RA, 4(SP)
198:                 
199:                 // *****************************************************************************
200:                 // *****************************************************************************
201:                 // Section: SYS TMR Interface Function Definitions
202:                 // *****************************************************************************
203:                 // *****************************************************************************
204:                 
205:                 // *****************************************************************************
206:                 /* Function:
207:                    SYS_MODULE_OBJ SYS_TMR_Initialize ( const SYS_MODULE_INDEX index,
208:                    const SYS_MODULE_INIT * const init )
209:                 
210:                 Summary:
211:                 Initializes hardware and data for the instance of the Timer module and opens
212:                 the specific module instance.
213:                 
214:                 Description:
215:                 This function initializes hardware for the instance of the Timer module,
216:                 using the specified hardware initialization data. It also initializes any
217:                 internal data structures.
218:                 
219:                 Parameters:
220:                 index           - Index for the instance to be initialized
221:                 
222:                 init            - Pointer to a data structure containing any data necessary
223:                 to initialize the driver. This pointer may be null if no
224:                 data is required because static overrides have been
225:                 provided.
226:                 
227:                 Returns:
228:                 None
229:                 */
230:                 
231:                 SYS_MODULE_OBJ SYS_TMR_Initialize ( const SYS_MODULE_INDEX index,
232:                         const SYS_MODULE_INIT * const init )
233:                 {
9D0137C0  27BDFFE8   ADDIU SP, SP, -24
9D0137C4  AFBF0014   SW RA, 20(SP)
9D0137C8  AFB00010   SW S0, 16(SP)
9D0137CC  00A08021   ADDU S0, A1, ZERO
9D0137D0  3084FFFF   ANDI A0, A0, -1
234:                 
235:                     while(true)
236:                     {
237:                         memset(&sSysTmrObject, 0, sizeof(sSysTmrObject));
9D0137D4  3C028001   LUI V0, -32767
9D0137D8  AC404CD8   SW ZERO, 19672(V0)
9D0137DC  24424CD8   ADDIU V0, V0, 19672
9D0137E0  AC400004   SW ZERO, 4(V0)
9D0137E4  AC400008   SW ZERO, 8(V0)
9D0137E8  AC40000C   SW ZERO, 12(V0)
9D0137EC  AC400010   SW ZERO, 16(V0)
9D0137F0  AC400014   SW ZERO, 20(V0)
9D0137F4  AC400018   SW ZERO, 24(V0)
9D0137F8  AC40001C   SW ZERO, 28(V0)
9D0137FC  AC400020   SW ZERO, 32(V0)
9D013800  AC400024   SW ZERO, 36(V0)
238:                 
239:                         if(init == 0 || index != SYS_TMR_INDEX_0)
9D013804  10A0001A   BEQ A1, ZERO, 0x9D013870
9D013808  AC400028   SW ZERO, 40(V0)
9D01380C  14800019   BNE A0, ZERO, 0x9D013874
9D013810  2403FFFF   ADDIU V1, ZERO, -1
240:                         {
241:                             break;
242:                         }
243:                 
244:                         const SYS_TMR_INIT * sysTmrInit;
245:                         sysTmrInit = ( const SYS_TMR_INIT * ) init;
246:                         // clear the client structures
247:                         memset(sClientObjects, 0, sizeof(sClientObjects));
9D013814  3C048001   LUI A0, -32767
9D013818  24844C74   ADDIU A0, A0, 19572
9D01381C  00002821   ADDU A1, ZERO, ZERO
9D013820  0F405189   JAL memset
9D013824  24060064   ADDIU A2, ZERO, 100
248:                 
249:                         /* Set the status for the state machine to advance */
250:                         sSysTmrObject.drvIndex = sysTmrInit->drvIndex;
9D013828  3C028001   LUI V0, -32767
9D01382C  96030002   LHU V1, 2(S0)
9D013830  A4434CD8   SH V1, 19672(V0)
251:                         sSysTmrObject.sysTickFreq = sysTmrInit->tmrFreq;
9D013834  8E030004   LW V1, 4(S0)
9D013838  24424CD8   ADDIU V0, V0, 19672
9D01383C  AC43000C   SW V1, 12(V0)
252:                 
253:                         if(!_UserGblLockCreate())
254:                         {   // failed to create OSAL protection
255:                             break;
256:                         }
257:                 
258:                         // success; proceed with the initialization
259:                         sSysTmrObject.status = SYS_STATUS_BUSY;
9D01385C  3C028001   LUI V0, -32767
9D013860  24424CD8   ADDIU V0, V0, 19672
9D013864  24030001   ADDIU V1, ZERO, 1
260:                         /* Return timer object */
261:                         return (SYS_MODULE_OBJ)&sSysTmrObject;
9D013868  0B404E20   J 0x9D013880
9D01386C  AC430008   SW V1, 8(V0)
262:                     }
263:                 
264:                     // initialization failed
265:                     sSysTmrObject.status  = SYS_STATUS_ERROR;
9D013870  2403FFFF   ADDIU V1, ZERO, -1
9D013874  3C028001   LUI V0, -32767
9D013878  AC434CE0   SW V1, 19680(V0)
266:                     return SYS_MODULE_OBJ_INVALID;
9D01387C  2402FFFF   ADDIU V0, ZERO, -1
267:                 }
9D013880  8FBF0014   LW RA, 20(SP)
268:                 
269:                 
270:                 // *****************************************************************************
271:                 /* Function:
272:                    void SYS_TMR_Deinitialize ( SYS_MODULE_OBJ object )
273:                 
274:                 Summary:
275:                 De-initializes the specific module instance of the Timer module.
276:                 
277:                 Description:
278:                 De-initializes the specific module instance disabling its operation (and
279:                 any hardware for driver modules). Resets all the internal data
280:                 structures and fields for the specified instance to the default
281:                 settings.
282:                 
283:                 PreCondition:
284:                 The SYS_TMR_Initialize function should have been called before calling
285:                 this function.
286:                 
287:                 Parameters:
288:                 object          - SYS TMR object handle, returned from SYS_TMR_Initialize
289:                 
290:                 Returns:
291:                 None.
292:                 */
293:                 
294:                 void SYS_TMR_Deinitialize ( SYS_MODULE_OBJ object )
295:                 {
00000010  00000000   NOP
000000AC  00000000   NOP
296:                     int ix;
297:                 
298:                     if(!_SYS_TMR_ObjectCheck(object))
00000000  00000000   NOP
299:                     {
300:                         return;
301:                     }
302:                 
303:                     // we're up and running
304:                     // make sure no new clients are accepted
305:                     _UserGblLock();
306:                 
307:                     // now kill all clients
308:                     if ( sSysTmrObject.driverHandle != 0 && sSysTmrObject.driverHandle != DRV_HANDLE_INVALID )
00000040  00000000   NOP
00000050  00000000   NOP
309:                     { 
310:                         DRV_TMR_Close(sSysTmrObject.driverHandle);
00000068  00000000   NOP
311:                         sSysTmrObject.driverHandle = 0;
00000070  00000000   NOP
312:                     }
313:                 
314:                     // release all clients
315:                     SYS_TMR_CLIENT_OBJECT* pClient = sClientObjects + 0;
316:                     for ( ix = 0; ix < sizeof(sClientObjects)/sizeof(*sClientObjects); ix++, pClient++ )
00000094  00000000   NOP
000000B4  00000000   NOP
317:                     {
318:                         pClient->isrEnable = 0;
0000007C  00000000   NOP
319:                         if ( pClient->currState != SYS_TMR_CLIENT_FREE)
00000080  00000000   NOP
320:                         {
321:                             _SYS_TMR_ClientDelete(pClient);
322:                         }
323:                     }
324:                 
325:                     _UserGblLockDelete();
326:                 
327:                     sSysTmrObject.status = SYS_STATUS_UNINITIALIZED;
000000A0  00000000   NOP
328:                 
329:                 } 
000000C0  00000000   NOP
330:                 
331:                 
332:                 // *****************************************************************************
333:                 /* Function:
334:                    SYS_STATUS SYS_TMR_Status ( SYS_MODULE_OBJ object )
335:                 
336:                 Summary:
337:                 Returns status of the specific module instance of the Timer module.
338:                 
339:                 Description:
340:                 This function returns the status of the specific module instance disabling its
341:                 operation (and any hardware for driver modules).
342:                 
343:                 PreCondition:
344:                 The SYS_TMR_Initialize function should have been called before calling
345:                 this function.
346:                 
347:                 Parameters:
348:                 object          - SYS TMR object handle, returned from SYS_TMR_Initialize
349:                 
350:                 Returns:
351:                 SYS_STATUS_READY    Indicates that any previous module operation for the
352:                 specified module has completed
353:                 
354:                 SYS_STATUS_BUSY     Indicates that a previous module operation for the
355:                 specified module has not yet completed
356:                 
357:                 SYS_STATUS_ERROR    Indicates that the specified module is in an error state
358:                 */
359:                 
360:                 SYS_STATUS SYS_TMR_Status ( SYS_MODULE_OBJ object )
361:                 {
362:                     if(!_SYS_TMR_ObjectCheck(object))
00000000  00000000   NOP
363:                     {
364:                         return SYS_STATUS_UNINITIALIZED;
365:                     }
366:                 
367:                     return ( sSysTmrObject.status );
00000010  00000000   NOP
368:                 }
00000018  00000000   NOP
369:                 
370:                 SYS_STATUS SYS_TMR_ModuleStatusGet ( const SYS_MODULE_INDEX index )
371:                 {
00000000  00000000   NOP
372:                     return (index == SYS_TMR_INDEX_0) ? sSysTmrObject.status : SYS_STATUS_UNINITIALIZED;
00000004  00000000   NOP
373:                 }
00000014  00000000   NOP
374:                 
375:                 
376:                 
377:                 // *****************************************************************************
378:                 /* Function:
379:                    void SYS_TMR_Tasks ( SYS_MODULE_OBJ object )
380:                 
381:                 Summary:
382:                 Maintains the system Timer's state machine and implements its ISR.
383:                 
384:                 Description:
385:                 This routine is used to maintain the system Timer's internal state machine and
386:                 implement its ISR for interrupt-driven implementations.
387:                 
388:                 Precondition:
389:                 The SYS_TMR_Initialize function must have been called for the specified Timer
390:                 driver instance.
391:                 
392:                 Parameters:
393:                 object          - SYS TMR object handle, returned from SYS_TMR_Initialize
394:                 
395:                 Returns:
396:                 None.
397:                 */
398:                 
399:                 void SYS_TMR_Tasks ( SYS_MODULE_OBJ object )
400:                 {
9D009BA4  27BDFFC8   ADDIU SP, SP, -56
9D009BA8  AFBF0034   SW RA, 52(SP)
9D009BAC  AFB60030   SW S6, 48(SP)
9D009BB0  AFB5002C   SW S5, 44(SP)
9D009BB4  AFB40028   SW S4, 40(SP)
9D009BB8  AFB30024   SW S3, 36(SP)
9D009BBC  AFB20020   SW S2, 32(SP)
9D009BC0  AFB1001C   SW S1, 28(SP)
401:                     if(!_SYS_TMR_ObjectCheck(object))
9D009BC4  3C028001   LUI V0, -32767
9D009BC8  24424CD8   ADDIU V0, V0, 19672
9D009BCC  144400AB   BNE V0, A0, 0x9D009E7C
9D009BD0  AFB00018   SW S0, 24(SP)
402:                     {
403:                         return;
404:                     }
405:                 
406:                     switch ( sSysTmrObject.status )
9D009BD4  3C028001   LUI V0, -32767
9D009BD8  8C424CE0   LW V0, 19680(V0)
9D009BDC  24030001   ADDIU V1, ZERO, 1
9D009BE0  10430005   BEQ V0, V1, 0x9D009BF8
9D009BE4  24030002   ADDIU V1, ZERO, 2
9D009BE8  10430048   BEQ V0, V1, 0x9D009D0C
9D009BEC  3C028001   LUI V0, -32767
407:                     {
408:                         case SYS_STATUS_BUSY:
409:                             // Performing the initialization
410:                             // Try to open a TMR driver
411:                             sSysTmrObject.driverHandle =  DRV_TMR_Open ( sSysTmrObject.drvIndex, DRV_IO_INTENT_EXCLUSIVE );
9D009BF8  3C108001   LUI S0, -32767
9D009BFC  96044CD8   LHU A0, 19672(S0)
9D009C00  0F4057DC   JAL DRV_TMR_Open
9D009C04  24050008   ADDIU A1, ZERO, 8
9D009C08  26104CD8   ADDIU S0, S0, 19672
412:                 
413:                             if ( sSysTmrObject.driverHandle == DRV_HANDLE_INVALID )
9D009C0C  2403FFFF   ADDIU V1, ZERO, -1
9D009C10  1043009A   BEQ V0, V1, 0x9D009E7C
9D009C14  AE020004   SW V0, 4(S0)
414:                             {   // spin here until the driver is opened
415:                                 break;
416:                             }
417:                 
418:                             // try to set up the service parameters
419:                             if(!_SYS_TMR_Setup(&sSysTmrObject))
420:                             {   // some parameter error occurred
421:                                 DRV_TMR_Close(sSysTmrObject.driverHandle);
9D009E18  3C108001   LUI S0, -32767
9D009E1C  26104CD8   ADDIU S0, S0, 19672
9D009E20  0F40593E   JAL DRV_TMR_Close
9D009E24  8E040004   LW A0, 4(S0)
422:                                 sSysTmrObject.driverHandle = 0;
9D009E28  AE000004   SW ZERO, 4(S0)
423:                                 sSysTmrObject.status  = SYS_STATUS_ERROR;
9D009E2C  2402FFFF   ADDIU V0, ZERO, -1
424:                                 break;
9D009E30  0B40279F   J 0x9D009E7C
9D009E34  AE020008   SW V0, 8(S0)
425:                             }
426:                 
427:                             // success
428:                             /* Set the alarm */
429:                             DRV_TMR_AlarmRegister ( sSysTmrObject.driverHandle, sSysTmrObject.driverPeriod, true,
9D009CDC  8E040004   LW A0, 4(S0)
9D009CE0  3C029D01   LUI V0, -25343
9D009CE4  24426C70   ADDIU V0, V0, 27760
9D009CE8  AFA20010   SW V0, 16(SP)
9D009CEC  24060001   ADDIU A2, ZERO, 1
9D009CF0  0F404623   JAL DRV_TMR_AlarmRegister
9D009CF4  02003821   ADDU A3, S0, ZERO
430:                                                     (uintptr_t)&sSysTmrObject, _SYS_TMR_AlarmCallback );
431:                 
432:                             /* Start the timer */
433:                             DRV_TMR_Start ( sSysTmrObject.driverHandle );
9D009CF8  0F405732   JAL DRV_TMR_Start
9D009CFC  8E040004   LW A0, 4(S0)
434:                 
435:                             /* Status of the state machine is changed to indicate initialization complete */
436:                             sSysTmrObject.status = SYS_STATUS_READY;
9D009D00  24020002   ADDIU V0, ZERO, 2
437:                             break;
9D009D04  0B40279F   J 0x9D009E7C
9D009D08  AE020008   SW V0, 8(S0)
438:                 
439:                         case SYS_STATUS_READY:
440:                 
441:                             /* If there is no activity we need not run the loop */
442:                 #if (SYS_TMR_INTERRUPT_NOTIFICATION)
443:                             // block user access; we may delete clients
444:                             _UserGblLock();
445:                             _SYS_TMR_ProcessIsrClients();
446:                             _UserGblUnlock();
447:                 #else
448:                             if ( sSysTmrObject.alarmReceived == true )
9D009D0C  90424D00   LBU V0, 19712(V0)
9D009D10  1040005B   BEQ V0, ZERO, 0x9D009E80
9D009D14  8FBF0034   LW RA, 52(SP)
449:                             {
450:                                 sSysTmrObject.alarmReceived = false;
9D009D18  3C028001   LUI V0, -32767
9D009D1C  A0404D00   SB ZERO, 19712(V0)
451:                                 // block user access; we may delete clients
452:                                 _UserGblLock();
453:                                 _SYS_TMR_ProcessTmrAlarm();
454:                                 _UserGblUnlock();
455:                             }
456:                 #endif  // (SYS_TMR_INTERRUPT_NOTIFICATION)
457:                             break;
458:                 
459:                         default:    // SYS_STATUS_ERROR, SYS_STATUS_UNINITIALIZED, etc.
460:                             // do nothing
461:                             break;
462:                     }
463:                 
464:                 }
9D009BF0  0B4027A0   J 0x9D009E80
9D009BF4  8FBF0034   LW RA, 52(SP)
9D009E10  0B4027A0   J 0x9D009E80
9D009E14  8FBF0034   LW RA, 52(SP)
9D009E7C  8FBF0034   LW RA, 52(SP)
465:                 
466:                 static bool _SYS_TMR_Setup(SYS_TMR_OBJECT* tmrObject)
467:                 {
468:                     uint32_t    drvFreq, drvPeriod, errorFreq;
469:                     uint32_t    tickFreq, tickUnitCount;
470:                 
471:                     // sanity check, protect against user error
472:                     if(sSysTmrObject.sysTickFreq == 0 || SYS_TMR_UNIT_RESOLUTION < 1000 ||  SYS_TMR_UNIT_RESOLUTION / sSysTmrObject.sysTickFreq < 1 )
9D009C18  3C038001   LUI V1, -32767
473:                     {
474:                         return false;
475:                     }
476:                 
477:                     drvFreq = DRV_TMR_CounterFrequencyGet ( tmrObject->driverHandle );
9D009C3C  0F404CE8   JAL DRV_TMR_CounterFrequencyGet
478:                     // sanity check that we can obtain the requested frequency
479:                     // with the underlying 16 bit timer (period = [2, 0xffff]);
480:                     drvPeriod = drvFreq / tmrObject->sysTickFreq;
9D009C44  3C038001   LUI V1, -32767
481:                 
482:                     if(drvPeriod < 2 || drvPeriod > 0xffff)
9D009C58  24A7FFFE   ADDIU A3, A1, -2
483:                     {   // required freq not within obtainable range
484:                         return false;
485:                     }
486:                     // calculate the actual tick frequency
487:                     tickFreq = drvFreq / drvPeriod;
9D009C6C  0045001B   DIVU V0, A1
488:                     // check we're within requested limits
489:                     if(tickFreq >= tmrObject->sysTickFreq)
9D009C78  0083482B   SLTU T1, A0, V1
490:                     {
491:                         errorFreq = tickFreq - tmrObject->sysTickFreq;
9D009C7C  00833023   SUBU A2, A0, V1
492:                     }
493:                     else
494:                     {
495:                         errorFreq = tmrObject->sysTickFreq - tickFreq;
496:                     }
497:                 
498:                     if((errorFreq * 100) / tmrObject->sysTickFreq > SYS_TMR_FREQUENCY_TOLERANCE)
9D009C88  00073080   SLL A2, A3, 2
499:                     {   // too great an error
500:                         return false;
501:                     }
502:                 
503:                     // calculate the timer units
504:                     tickUnitCount = SYS_TMR_UNIT_RESOLUTION / tickFreq;
9D009CB4  0064001B   DIVU V1, A0
505:                     if(tickUnitCount < 1)
9D009CC0  10600055   BEQ V1, ZERO, 0x9D009E18
506:                     {    // not enough resolution
507:                         return false;
508:                     }
509:                 
510:                     // success
511:                     tmrObject->sysTickFreq = tickFreq;
9D009CC8  26104CD8   ADDIU S0, S0, 19672
512:                     tmrObject->sysTickUnitCount = tickUnitCount;
9D009CD0  AE030010   SW V1, 16(S0)
513:                     tmrObject->driverFreq = drvFreq;
9D009CD4  AE020020   SW V0, 32(S0)
514:                     tmrObject->driverPeriod = drvPeriod;
9D009CD8  AE050024   SW A1, 36(S0)
515:                 
516:                  
517:                     return true;
518:                 }
519:                 
520:                 
521:                 // *****************************************************************************
522:                 /* Function:
523:                    SYS_TMR_HANDLE _SYS_TMR_ClientCreate ( unsigned int periodMs,  
524:                    uintptr_t context, SYS_TMR_CALLBACK callback, SYS_TMR_FLAGS flags )
525:                 
526:                 Summary:
527:                     Creates a new timer client, if possible.
528:                 
529:                 Description:
530:                     It tries to add a new timer client using the requested period in milliseconds.
531:                 
532:                 Parameters:
533:                     periodMs    - alarm time
534:                     context     - client supplied parameter to be passed in the callback
535:                                   not used by the TMR service itself
536:                     callback    - client function to be called when the alarm expired                
537:                     flags       - SYS_TMR_FLAGS object flags 
538:                 
539:                 Returns:
540:                     A valid SYS_TMR_HANDLE if success
541:                     SYS_TMR_HANDLE_INVALID if failed
542:                 */
543:                 
544:                 static SYS_TMR_HANDLE _SYS_TMR_ClientCreate ( uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback, SYS_TMR_FLAGS flags )
545:                 {
9D00FB20  27BDFFE0   ADDIU SP, SP, -32
9D00FB24  AFBF001C   SW RA, 28(SP)
9D00FB28  AFB10018   SW S1, 24(SP)
9D00FB2C  AFB00014   SW S0, 20(SP)
9D00FB30  00804821   ADDU T1, A0, ZERO
9D00FB34  00A05021   ADDU T2, A1, ZERO
9D00FB38  00C05821   ADDU T3, A2, ZERO
9D00FB3C  00E08821   ADDU S1, A3, ZERO
546:                     SYS_TMR_CLIENT_OBJECT *timerObj;
547:                     SYS_TMR_CLIENT_OBJECT *newObj;
548:                     int index;
549:                 
550:                     if(!_SYS_TMR_ReadyCheck())
9D00FB10  8C484CE0   LW T0, 19680(V0)
9D00FB14  24030002   ADDIU V1, ZERO, 2
9D00FB18  15030058   BNE T0, V1, 0x9D00FC7C
9D00FB1C  2402FFFF   ADDIU V0, ZERO, -1
551:                     {
552:                         return SYS_TMR_HANDLE_INVALID;
553:                     }
554:                 
555:                     // lock user access
556:                     _UserGblLock();
557:                 
558:                     newObj = (SYS_TMR_CLIENT_OBJECT*)SYS_TMR_HANDLE_INVALID;
559:                     timerObj = sClientObjects + 0;
9D00FB94  3C108001   LUI S0, -32767
9D00FB98  26104C74   ADDIU S0, S0, 19572
560:                     for ( index = 0; index < sizeof(sClientObjects)/sizeof(*sClientObjects); index++, timerObj++ )
9D00FC18  5603FFDA   BNEL S0, V1, 0x9D00FB84
9D00FC1C  82020000   LB V0, 0(S0)
9D00FC20  2410FFFF   ADDIU S0, ZERO, -1
9D00FC5C  26104C88   ADDIU S0, S0, 19592
9D00FC60  3C038001   LUI V1, -32767
9D00FC64  0B403EE0   J 0x9D00FB80
9D00FC68  24634CD8   ADDIU V1, V1, 19672
561:                     {
562:                         if ( timerObj->currState == SYS_TMR_CLIENT_FREE )
9D00FB68  0B403F14   J 0x9D00FC50
9D00FB6C  3C028001   LUI V0, -32767
9D00FB78  0B403F14   J 0x9D00FC50
9D00FB7C  3C028001   LUI V0, -32767
9D00FB80  82020000   LB V0, 0(S0)
9D00FB84  54400024   BNEL V0, ZERO, 0x9D00FC18
9D00FB88  26100014   ADDIU S0, S0, 20
9D00FC50  80424C74   LB V0, 19572(V0)
9D00FC54  1040FFCF   BEQ V0, ZERO, 0x9D00FB94
9D00FC58  3C108001   LUI S0, -32767
563:                         {   // found free object			
564:                             memset(timerObj, 0x0, sizeof(*timerObj));
9D00FB8C  0B403EE8   J 0x9D00FBA0
9D00FB90  AE000000   SW ZERO, 0(S0)
9D00FB9C  AE000000   SW ZERO, 0(S0)
9D00FBA0  AE000004   SW ZERO, 4(S0)
9D00FBA4  AE000008   SW ZERO, 8(S0)
9D00FBA8  AE00000C   SW ZERO, 12(S0)
9D00FBAC  AE000010   SW ZERO, 16(S0)
565:                             if(_SYS_TMR_ClientParamSet(timerObj, periodMs, context, callback))
9D00FBB0  02002021   ADDU A0, S0, ZERO
9D00FBB4  01202821   ADDU A1, T1, ZERO
9D00FBB8  01403021   ADDU A2, T2, ZERO
9D00FBBC  0F404A4D   JAL _SYS_TMR_ClientParamSet
9D00FBC0  01603821   ADDU A3, T3, ZERO
9D00FBC4  50400017   BEQL V0, ZERO, _SYS_TMR_ClientCreate::_UserGblUnlock
9D00FBC8  2410FFFF   ADDIU S0, ZERO, -1
566:                             {
567:                                 if((flags & SYS_TMR_FLAG_PERIODIC) != 0)
9D00FBCC  32220001   ANDI V0, S1, 1
9D00FBD0  10400006   BEQ V0, ZERO, 0x9D00FBEC
9D00FBD4  32311000   ANDI S1, S1, 4096
568:                                 {
569:                                     timerObj->flags.periodic = true;
9D00FBD8  92020003   LBU V0, 3(S0)
9D00FBDC  24030001   ADDIU V1, ZERO, 1
9D00FBE0  7C620004   INS V0, V1, 0, 1
9D00FBE4  0B403F01   J 0x9D00FC04
9D00FBE8  A2020003   SB V0, 3(S0)
570:                                 }
571:                                 else if((flags & SYS_TMR_FLAG_AUTO_DELETE) != 0)
9D00FBEC  52200006   BEQL S1, ZERO, 0x9D00FC08
9D00FBF0  24020001   ADDIU V0, ZERO, 1
572:                                 {
573:                                     timerObj->flags.auto_del = true;
9D00FBF4  92020003   LBU V0, 3(S0)
9D00FBF8  24030001   ADDIU V1, ZERO, 1
9D00FBFC  7C620844   INS V0, V1, 1, 1
9D00FC00  A2020003   SB V0, 3(S0)
574:                                 }
575:                 
576:                                 // enable the object, seen by the ISR thread
577:                                 timerObj->currState = SYS_TMR_CLIENT_ACTIVE;
9D00FC04  24020001   ADDIU V0, ZERO, 1
9D00FC08  A2020000   SB V0, 0(S0)
578:                                 timerObj->isrState = SYS_TMR_CLIENT_ISR_ACTIVE;
9D00FC0C  A2020002   SB V0, 2(S0)
579:                                 timerObj->isrEnable = 1;
9D00FC10  0B403F09   J _SYS_TMR_ClientCreate::_UserGblUnlock
9D00FC14  A2020001   SB V0, 1(S0)
580:                                 newObj = timerObj;
581:                             }
582:                             // else wrong parameters
583:                             break;
584:                         }
585:                     }
586:                 
587:                     _UserGblUnlock();
588:                 
589:                     return (SYS_TMR_HANDLE)newObj;
9D00FC48  0B403F1B   J 0x9D00FC6C
9D00FC4C  02001021   ADDU V0, S0, ZERO
590:                             
591:                 } 
9D00FC6C  8FBF001C   LW RA, 28(SP)
592:                 
593:                 // Assigns the timing parameters
594:                 static bool _SYS_TMR_ClientParamSet(SYS_TMR_CLIENT_OBJECT *timerObj, uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback)
595:                 {
596:                     uint32_t upError, lowError, error;
597:                     uint32_t unitCount, upUnits, lowUnits;
598:                 
599:                     // sanity check
600:                     if(periodMs == 0 || periodMs >= (0xffffffff / SYS_TMR_UNIT_RESOLUTION))
9D012934  24A2FFFF   ADDIU V0, A1, -1
9D012938  3C030006   LUI V1, 6
9D01293C  34638DB7   ORI V1, V1, -29257
9D012940  0043182B   SLTU V1, V0, V1
9D012944  10600033   BEQ V1, ZERO, 0x9D012A14
9D012948  00001021   ADDU V0, ZERO, ZERO
601:                     {
602:                         return false;
603:                     }
604:                 
605:                     unitCount =  (periodMs * (sSysTmrObject.sysTickFreq * sSysTmrObject.sysTickUnitCount)) / 1000;
9D01294C  3C038001   LUI V1, -32767
9D012950  24634CD8   ADDIU V1, V1, 19672
9D012954  8C620010   LW V0, 16(V1)
9D012958  8C63000C   LW V1, 12(V1)
9D01295C  70431802   MUL V1, V0, V1
9D012960  70651802   MUL V1, V1, A1
9D012964  3C081062   LUI T0, 4194
9D012968  25084DD3   ADDIU T0, T0, 19923
9D01296C  00680019   MULTU 0, V1, T0
9D012970  00001810   MFHI V1
9D012974  00031982   SRL V1, V1, 6
9D012978  0062282B   SLTU A1, V1, V0
9D01297C  0045180B   MOVN V1, V0, A1
606:                     if(unitCount < sSysTmrObject.sysTickUnitCount)
607:                     {   // cannot go lower than that
608:                         unitCount = sSysTmrObject.sysTickUnitCount;
609:                     }
610:                 
611:                     // calculate errors: truncation and round up
612:                     lowUnits = (unitCount / sSysTmrObject.sysTickUnitCount) * sSysTmrObject.sysTickUnitCount;
9D012980  0062001B   DIVU V1, V0
9D012984  004001F4   TEQ V0, ZERO
9D012988  00002812   MFLO A1
9D01298C  70A22802   MUL A1, A1, V0
613:                     lowError = (unitCount >= lowUnits) ? unitCount - lowUnits : lowUnits - unitCount;
9D012990  0065402B   SLTU T0, V1, A1
9D012994  00654823   SUBU T1, V1, A1
9D012998  00A32823   SUBU A1, A1, V1
9D01299C  00A8480B   MOVN T1, A1, T0
9D0129A0  01204021   ADDU T0, T1, ZERO
614:                 
615:                     upUnits = ((unitCount + sSysTmrObject.sysTickUnitCount - 1) / sSysTmrObject.sysTickUnitCount) * sSysTmrObject.sysTickUnitCount;
9D0129A4  2445FFFF   ADDIU A1, V0, -1
9D0129A8  00A32821   ADDU A1, A1, V1
9D0129AC  00A2001B   DIVU A1, V0
9D0129B0  004001F4   TEQ V0, ZERO
9D0129B4  00002812   MFLO A1
9D0129B8  70A21002   MUL V0, A1, V0
616:                     upError = (unitCount >= upUnits) ? unitCount - upUnits : upUnits - unitCount;
9D0129BC  0062282B   SLTU A1, V1, V0
9D0129C0  00624823   SUBU T1, V1, V0
9D0129C4  00431023   SUBU V0, V0, V1
9D0129C8  0125100A   MOVZ V0, T1, A1
617:                 
618:                     error = (upError > lowError) ? lowError : upError;
9D0129CC  0102282B   SLTU A1, T0, V0
9D0129D0  0045400A   MOVZ T0, V0, A1
619:                 
620:                     if((error * 100 / unitCount) > SYS_TMR_CLIENT_TOLERANCE )
9D0129D4  00081080   SLL V0, T0, 2
9D0129D8  00082900   SLL A1, T0, 4
9D0129DC  00451021   ADDU V0, V0, A1
9D0129E0  00022880   SLL A1, V0, 2
9D0129E4  00451021   ADDU V0, V0, A1
9D0129E8  0043001B   DIVU V0, V1
9D0129EC  006001F4   TEQ V1, ZERO
9D0129F0  00002812   MFLO A1
9D0129F4  2CA5000B   SLTIU A1, A1, 11
9D0129F8  10A00006   BEQ A1, ZERO, 0x9D012A14
9D0129FC  00001021   ADDU V0, ZERO, ZERO
621:                     {   // too great an error
622:                         return false;
623:                     }
624:                 
625:                     timerObj->tuRate = timerObj->tuCount =  unitCount;
9D012A00  AC830004   SW V1, 4(A0)
9D012A04  AC830008   SW V1, 8(A0)
626:                     timerObj->context = context;
9D012A08  AC86000C   SW A2, 12(A0)
627:                     timerObj->callback = callback;
9D012A0C  AC870010   SW A3, 16(A0)
628:                 
629:                     return true;
9D012A10  24020001   ADDIU V0, ZERO, 1
630:                 } 
9D012A14  03E00008   JR RA
631:                 
632:                 
633:                 
634:                 
635:                 // delete clients that are marked for delition
636:                 #if (SYS_TMR_INTERRUPT_NOTIFICATION)
637:                 
638:                 // process timer alarm, ISR context
639:                 static void _SYS_TMR_ProcessIsrAlarm(void)
640:                 {
641:                     int ix;
642:                     SYS_TMR_CLIENT_OBJECT* pClient;
643:                 
644:                     // get number of elapsed counts
645:                     uint32_t    nTicks = sSysTmrObject.sysTickCount - sSysTmrObject.sysTickPrevCount; 
646:                     sSysTmrObject.sysTickPrevCount =  sSysTmrObject.sysTickCount;
647:                     uint32_t nUnitsElapsed = (nTicks * sSysTmrObject.sysTickUnitCount);
648:                 
649:                 
650:                     pClient = sClientObjects + 0;
651:                     for ( ix = 0; ix < sizeof(sClientObjects)/sizeof(*sClientObjects); ix++, pClient++ )
652:                     {
653:                         if ( pClient->isrEnable && pClient->isrState == SYS_TMR_CLIENT_ISR_ACTIVE)
654:                         {
655:                             if( (pClient->tuCount -= nUnitsElapsed) <= 0 )
656:                             {   // timeout
657:                                 /* invoke callback routine */
658:                                 if ( pClient->callback != 0 )
659:                                 {
660:                                     pClient->callback ( pClient->context, sSysTmrObject.sysTickCount);
661:                                 }
662:                                 if ( pClient->flags.periodic == true )
663:                                 {   // reload
664:                                     pClient->tuCount += pClient->tuRate;
665:                                 }
666:                                 else if (pClient->callback != 0 && pClient->flags.auto_del == true)
667:                                 {   // client notified; delete this object
668:                                     // mark it to be deleted later on
669:                                     pClient->isrState = SYS_TMR_CLIENT_ISR_MARK_DEL;
670:                                 }
671:                                 else
672:                                 {   // non delete non periodic object; store the timeout condition
673:                                     pClient->isrState = SYS_TMR_CLIENT_ISR_MARK_INACTIVE;
674:                                     pClient->tuCount = 0;
675:                                 }
676:                             }
677:                         }
678:                     }
679:                 
680:                 }
681:                 
682:                 
683:                 static void _SYS_TMR_ProcessIsrClients(void)
684:                 {
685:                     int ix;
686:                     SYS_TMR_CLIENT_OBJECT* pClient;
687:                 
688:                 
689:                     bool isrLock;
690:                     OSAL_CRITSECT_DATA_TYPE critSect;
691:                 
692:                     isrLock = _IsrTmrLock(&critSect);
693:                 
694:                     pClient = sClientObjects + 0;
695:                     for ( ix = 0; ix < sizeof(sClientObjects)/sizeof(*sClientObjects); ix++, pClient++ )
696:                     {
697:                         if ( pClient->isrState == SYS_TMR_CLIENT_ISR_MARK_DEL)
698:                         {
699:                             _SYS_TMR_ClientDelete(pClient);
700:                         }
701:                         else if(pClient->isrState == SYS_TMR_CLIENT_ISR_MARK_INACTIVE)
702:                         {
703:                             pClient->isrEnable = 0;
704:                             pClient->currState = SYS_TMR_CLIENT_INACTIVE;
705:                         }
706:                     }
707:                 
708:                     _IsrTmrUnlock(isrLock, critSect);
709:                 }
710:                 
711:                 #else // !(SYS_TMR_INTERRUPT_NOTIFICATION)
712:                 
713:                 // process timer alarm
714:                 // occurs within TMR thread
715:                 static void _SYS_TMR_ProcessTmrAlarm(void)
716:                 {
717:                     int ix;
718:                     SYS_TMR_CLIENT_OBJECT* pClient;
719:                 
720:                     // get number of elapsed counts
721:                     uint32_t    nTicks = sSysTmrObject.sysTickCount - sSysTmrObject.sysTickPrevCount; 
9D009D48  0B40278E   J SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D009D4C  3C028001   LUI V0, -32767
9D009D58  0B40278E   J SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D009D5C  3C028001   LUI V0, -32767
9D009E38  24424CD8   ADDIU V0, V0, 19672
9D009E3C  8C530014   LW S3, 20(V0)
9D009E40  8C430018   LW V1, 24(V0)
9D009E4C  02639823   SUBU S3, S3, V1
722:                     sSysTmrObject.sysTickPrevCount =  sSysTmrObject.sysTickCount;
9D009E44  8C440014   LW A0, 20(V0)
9D009E48  AC440018   SW A0, 24(V0)
723:                     uint32_t nUnitsElapsed = (nTicks * sSysTmrObject.sysTickUnitCount);
9D009E50  8C420010   LW V0, 16(V0)
9D009E54  72629802   MUL S3, S3, V0
724:                     
725:                 
726:                     pClient = sClientObjects + 0;
9D009E58  3C108001   LUI S0, -32767
9D009E5C  26104C74   ADDIU S0, S0, 19572
727:                     for ( ix = 0; ix < sizeof(sClientObjects)/sizeof(*sClientObjects); ix++, pClient++ )
9D009DE0  26100014   ADDIU S0, S0, 20
9D009DE4  5611FFDF   BNEL S0, S1, 0x9D009D64
9D009DE8  82020000   LB V0, 0(S0)
9D009E70  3C118001   LUI S1, -32767
9D009E74  0B402758   J SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D009E78  26314CD8   ADDIU S1, S1, 19672
728:                     {
729:                         if ( pClient->currState == SYS_TMR_CLIENT_ACTIVE)
9D009D60  82020000   LB V0, 0(S0)
9D009D64  5452001F   BNEL V0, S2, 0x9D009DE4
9D009D68  26100014   ADDIU S0, S0, 20
9D009E60  24120001   ADDIU S2, ZERO, 1
730:                         {
731:                             if( (pClient->tuCount -= nUnitsElapsed) <= 0 )
9D009D6C  8E020004   LW V0, 4(S0)
9D009D70  00531023   SUBU V0, V0, S3
9D009D74  1C40001A   BGTZ V0, 0x9D009DE0
9D009D78  AE020004   SW V0, 4(S0)
732:                             {   // timeout
733:                                 /* invoke callback routine */
734:                                 if ( pClient->callback != 0 )
9D009D7C  8E020010   LW V0, 16(S0)
9D009D80  10400004   BEQ V0, ZERO, 0x9D009D94
9D009D84  26A34CD8   ADDIU V1, S5, 19672
735:                                 {
736:                                     pClient->callback ( pClient->context, sSysTmrObject.sysTickCount);
9D009D88  8C650014   LW A1, 20(V1)
9D009D8C  0040F809   JALR V0
9D009D90  8E04000C   LW A0, 12(S0)
9D009E6C  3C158001   LUI S5, -32767
737:                                 }
738:                                 if ( pClient->flags.periodic == true )
9D009D94  8E020000   LW V0, 0(S0)
9D009D98  00541824   AND V1, V0, S4
9D009D9C  50600006   BEQL V1, ZERO, SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D009DA0  8E030010   LW V1, 16(S0)
9D009E64  3C140100   LUI S4, 256
739:                                 {   // reload
740:                                     pClient->tuCount += pClient->tuRate;
9D009DA4  8E030004   LW V1, 4(S0)
9D009DA8  8E020008   LW V0, 8(S0)
9D009DAC  00621021   ADDU V0, V1, V0
9D009DB0  0B402778   J 0x9D009DE0
9D009DB4  AE020004   SW V0, 4(S0)
741:                                 }
742:                                 else if (pClient->callback != 0 && pClient->flags.auto_del == true)
9D009DB8  10600007   BEQ V1, ZERO, SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D009DBC  7C420640   EXT V0, V0, 25, 1
9D009DC0  50400006   BEQL V0, ZERO, 0x9D009DDC
9D009DC4  A2160000   SB S6, 0(S0)
743:                                 {   // client notified; delete this object
744:                                     _SYS_TMR_ClientDelete(pClient);
745:                                 }
746:                                 else
747:                                 {   // non delete non periodic object; store the timeout condition
748:                                     pClient->currState = SYS_TMR_CLIENT_INACTIVE;
9D009DD8  A2160000   SB S6, 0(S0)
9D009E68  24160002   ADDIU S6, ZERO, 2
749:                                     pClient->tuCount = 0;
9D009DDC  AE000004   SW ZERO, 4(S0)
750:                                 }
751:                             }
752:                         }
753:                     }
754:                 
755:                 }
756:                 
757:                 #endif  // (SYS_TMR_INTERRUPT_NOTIFICATION)
758:                 
759:                 // *****************************************************************************
760:                 // *****************************************************************************
761:                 // Section: SYS TMR Client Setup Routines
762:                 // *****************************************************************************
763:                 // *****************************************************************************
764:                 
765:                 SYS_TMR_HANDLE SYS_TMR_ObjectCreate ( uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback,  SYS_TMR_FLAGS flags)
766:                 {
00000000  00000000   NOP
767:                     return _SYS_TMR_ClientCreate ( periodMs, context, callback, flags );
00000008  00000000   NOP
768:                 }
00000010  00000000   NOP
769:                 
770:                 void SYS_TMR_ObjectDelete ( SYS_TMR_HANDLE handle)
771:                 {
00000000  00000000   NOP
772:                 
773:                     SYS_TMR_CLIENT_OBJECT * timerObj = _SYS_TMR_ClientCheckSrvLock(handle);
00000008  00000000   NOP
774:                 
775:                     if(timerObj)
00000010  00000000   NOP
776:                     {   // valid client; lock other users access   
777:                         _SYS_TMR_ClientDelete(timerObj);
778:                         _SYS_TMR_ClientSrvUnlock();
779:                     }
780:                 
781:                 }
00000048  00000000   NOP
782:                 
783:                 void SYS_TMR_CallbackStop ( SYS_TMR_HANDLE handle )
784:                 {
00000000  00000000   NOP
785:                     SYS_TMR_ObjectDelete(handle);
00000008  00000000   NOP
786:                 } 
00000010  00000000   NOP
787:                 
788:                 
789:                 bool SYS_TMR_ObjectReload ( SYS_TMR_HANDLE handle, uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback)
790:                 {
00000000  00000000   NOP
791:                     SYS_TMR_CLIENT_OBJECT * timerObj = _SYS_TMR_ClientCheckSrvLock(handle);
00000020  00000000   NOP
792:                 
793:                     if(timerObj)
00000028  00000000   NOP
794:                     {   
795:                         timerObj->isrEnable = 0;
00000030  00000000   NOP
796:                         bool res = _SYS_TMR_ClientParamSet(timerObj, periodMs, context, callback);
00000034  00000000   NOP
797:                 
798:                         if(timerObj->isrState == SYS_TMR_CLIENT_ISR_MARK_DEL)
00000048  00000000   NOP
799:                         {   // client is too late
800:                             _SYS_TMR_ClientDelete(timerObj);
801:                             res = false;
0000005C  00000000   NOP
802:                         }
803:                 
804:                         timerObj->isrState = SYS_TMR_CLIENT_ISR_ACTIVE;
00000060  00000000   NOP
805:                         timerObj->isrEnable = 1;
00000064  00000000   NOP
806:                         _SYS_TMR_ClientSrvUnlock();
807:                         return res;
0000008C  00000000   NOP
808:                     }
809:                 
810:                     return false;
00000094  00000000   NOP
811:                 }
00000098  00000000   NOP
812:                 
813:                 uint32_t SYS_TMR_ObjectCountGet ( SYS_TMR_HANDLE handle, uint32_t* pRateMs)
814:                 {
9D012B00  27BDFFE8   ADDIU SP, SP, -24
9D012B04  AFBF0014   SW RA, 20(SP)
9D012B08  AFB00010   SW S0, 16(SP)
815:                     uint32_t obCount;
816:                 
817:                 
818:                     SYS_TMR_CLIENT_OBJECT * timerObj = _SYS_TMR_ClientCheckSrvLock(handle);
9D012B0C  0F40515F   JAL _SYS_TMR_ClientCheckSrvLock
9D012B10  00A08021   ADDU S0, A1, ZERO
819:                 
820:                     if(timerObj)
9D012B14  5040002F   BEQL V0, ZERO, 0x9D012BD4
9D012B18  2402FFFF   ADDIU V0, ZERO, -1
821:                     {   
822:                         if(pRateMs)
9D012B1C  52000010   BEQL S0, ZERO, 0x9D012B60
9D012B20  8C430004   LW V1, 4(V0)
823:                         {   // transform to ms
824:                             *pRateMs = (timerObj->tuRate * 1000) / SYS_TMR_UNIT_RESOLUTION;
9D012B24  8C430008   LW V1, 8(V0)
9D012B28  00032080   SLL A0, V1, 2
9D012B2C  000329C0   SLL A1, V1, 7
9D012B30  00A42023   SUBU A0, A1, A0
9D012B34  00831821   ADDU V1, A0, V1
9D012B38  000318C0   SLL V1, V1, 3
9D012B3C  3C0468DB   LUI A0, 26843
9D012B40  34848BAD   ORI A0, A0, -29779
9D012B44  00640018   MULT 0, V1, A0
9D012B48  00002010   MFHI A0
9D012B4C  00042303   SRA A0, A0, 12
9D012B50  00031FC3   SRA V1, V1, 31
9D012B54  00831823   SUBU V1, A0, V1
9D012B58  AE030000   SW V1, 0(S0)
825:                         }
826:                 
827:                         obCount = timerObj->tuCount;
9D012B5C  8C430004   LW V1, 4(V0)
828:                         if(obCount == 0 && timerObj->flags.auto_del != 0)
9D012B60  14600008   BNE V1, ZERO, SYS_TMR_ObjectCountGet::_SYS_TMR_ClientSrvUnlock
9D012B64  00000000   NOP
9D012B68  8C440000   LW A0, 0(V0)
9D012B6C  7C840640   EXT A0, A0, 25, 1
9D012B70  10800004   BEQ A0, ZERO, SYS_TMR_ObjectCountGet::_SYS_TMR_ClientSrvUnlock
9D012B74  00000000   NOP
829:                         {   // timed out, delete it
830:                             _SYS_TMR_ClientDelete(timerObj);
831:                         }
832:                         _SYS_TMR_ClientSrvUnlock();
833:                         // round up so that don't return 0 if there are still counts
834:                         return (obCount * 1000 + SYS_TMR_UNIT_RESOLUTION - 1) / SYS_TMR_UNIT_RESOLUTION; 
9D012BA8  00031080   SLL V0, V1, 2
9D012BAC  000321C0   SLL A0, V1, 7
9D012BB0  00821023   SUBU V0, A0, V0
9D012BB4  00431821   ADDU V1, V0, V1
9D012BB8  000318C0   SLL V1, V1, 3
9D012BBC  2463270F   ADDIU V1, V1, 9999
9D012BC0  3C02D1B7   LUI V0, -11849
9D012BC4  24421759   ADDIU V0, V0, 5977
9D012BC8  00620019   MULTU 0, V1, V0
9D012BCC  00001010   MFHI V0
9D012BD0  00021342   SRL V0, V0, 13
835:                     }
836:                 
837:                     return -1;
838:                 
839:                 }
9D012BD4  8FBF0014   LW RA, 20(SP)
840:                 
841:                 
842:                 
843:                 SYS_TMR_HANDLE SYS_TMR_CallbackPeriodic ( uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback )
844:                 {
00000000  00000000   NOP
845:                     return _SYS_TMR_ClientCreate ( periodMs, context, callback, SYS_TMR_FLAG_PERIODIC );
00000008  00000000   NOP
846:                 }
00000010  00000000   NOP
847:                 
848:                 
849:                 SYS_TMR_HANDLE SYS_TMR_CallbackSingle ( uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback )
850:                 {
9D017130  27BDFFE8   ADDIU SP, SP, -24
9D017134  AFBF0014   SW RA, 20(SP)
851:                     return _SYS_TMR_ClientCreate ( periodMs, context, callback, SYS_TMR_FLAG_SINGLE | SYS_TMR_FLAG_AUTO_DELETE );
9D017138  0F403EC3   JAL _SYS_TMR_ClientCreate
9D01713C  24071000   ADDIU A3, ZERO, 4096
852:                 }
9D017140  8FBF0014   LW RA, 20(SP)
853:                 
854:                 
855:                 SYS_TMR_HANDLE SYS_TMR_DelayMS ( uint32_t delayMs )
856:                 {
9D016F80  27BDFFE8   ADDIU SP, SP, -24
9D016F84  AFBF0014   SW RA, 20(SP)
857:                     return _SYS_TMR_ClientCreate ( delayMs, 0, 0, SYS_TMR_FLAG_SINGLE | SYS_TMR_FLAG_AUTO_DELETE );
9D016F88  00002821   ADDU A1, ZERO, ZERO
9D016F8C  00003021   ADDU A2, ZERO, ZERO
9D016F90  0F403EC3   JAL _SYS_TMR_ClientCreate
9D016F94  24071000   ADDIU A3, ZERO, 4096
858:                 }
9D016F98  8FBF0014   LW RA, 20(SP)
859:                 
860:                 bool SYS_TMR_DelayStatusGet ( SYS_TMR_HANDLE handle )
861:                 {
9D01704C  27BDFFE8   ADDIU SP, SP, -24
9D017050  AFBF0014   SW RA, 20(SP)
862:                     return SYS_TMR_ObjectCountGet(handle, 0) == 0;
9D017054  0F404AC0   JAL SYS_TMR_ObjectCountGet
9D017058  00002821   ADDU A1, ZERO, ZERO
863:                 }
9D01705C  2C420001   SLTIU V0, V0, 1
864:                 
865:                 
866:                 
867:                 
868:                 // *****************************************************************************
869:                 /* Function:
870:                    static void _SYS_TMR_AlarmCallback ( uintptr_t context, uint32_t alarmCount )
871:                 
872:                 Summary:
873:                     System timer alarm call back function.
874:                 
875:                 Description:
876:                     This function is called by the underlying timer driver
877:                     when the registered alarm time has elapsed
878:                     (i.e. another system tick has occurred).
879:                 
880:                 Precondition:
881:                     None
882:                 
883:                 Parameters:
884:                     context    - callback parameter
885:                     alarmCount - current alarm count
886:                 Returns:
887:                     None.
888:                 
889:                 */
890:                 
891:                 static void _SYS_TMR_AlarmCallback ( uintptr_t context, uint32_t alarmCount )
892:                 {
893:                 
894:                     SYS_TMR_OBJECT* pTmrObj = (SYS_TMR_OBJECT*)context;
895:                 
896:                     if(alarmCount < pTmrObj->sysTickCount)
9D016C70  8C820014   LW V0, 20(A0)
9D016C74  00A2102B   SLTU V0, A1, V0
9D016C78  10400004   BEQ V0, ZERO, 0x9D016C8C
9D016C7C  00000000   NOP
897:                     {   // overflow
898:                         pTmrObj->sysTickCountHigh++;
9D016C80  8C82001C   LW V0, 28(A0)
9D016C84  24420001   ADDIU V0, V0, 1
9D016C88  AC82001C   SW V0, 28(A0)
899:                     }
900:                     // set new count
901:                     pTmrObj->sysTickCount = alarmCount;
9D016C8C  AC850014   SW A1, 20(A0)
902:                 
903:                 #if (SYS_TMR_INTERRUPT_NOTIFICATION)
904:                     _SYS_TMR_ProcessIsrAlarm();
905:                 #else
906:                     pTmrObj->alarmReceived = true;
9D016C90  24020001   ADDIU V0, ZERO, 1
907:                 #endif
908:                 
909:                 } 
910:                 
911:                 
912:                 // for the following functions no lock is performed
913:                 // because they need to be really fast and
914:                 // they are info only anyway
915:                 uint32_t SYS_TMR_TickCountGet ( void )
916:                 {
917:                     return _SYS_TMR_ReadyCheck() ? sSysTmrObject.sysTickCount : 0;
00000004  00000000   NOP
918:                 }
00000020  00000000   NOP
919:                 
920:                 uint64_t SYS_TMR_TickCountGetLong ( void )
921:                 {
922:                     if(!_SYS_TMR_ReadyCheck())
00000004  00000000   NOP
923:                     {
924:                         return 0;
925:                     }
926:                     
927:                     uint64_t  tick1, tick2;
928:                 
929:                     do
930:                     {
931:                         tick1 = (uint64_t)sSysTmrObject.sysTickCountHigh << 32 | sSysTmrObject.sysTickCount;
00000014  00000000   NOP
932:                         tick2 = (uint64_t)sSysTmrObject.sysTickCountHigh << 32 | sSysTmrObject.sysTickCount;
00000024  00000000   NOP
933:                     }
934:                     while(tick1 != tick2);
0000002C  00000000   NOP
935:                 
936:                     return tick2;
937:                 }
00000044  00000000   NOP
938:                 
939:                 uint32_t SYS_TMR_TickCounterFrequencyGet ( void )
940:                 {
941:                     return _SYS_TMR_ReadyCheck() ? sSysTmrObject.sysTickFreq : 0;
00000004  00000000   NOP
942:                 }
0000001C  00000000   NOP
943:                 
944:                 uint32_t SYS_TMR_SystemCountFrequencyGet( void )
945:                 {
946:                     return _SYS_TMR_ReadyCheck() ? sSysTmrObject.driverFreq : 0;
00000004  00000000   NOP
947:                 }
0000001C  00000000   NOP
948:                 
949:                 
950:                 // for this one we need to access the driver
951:                 // we need to make sure the object is valid
952:                 // use a 64 bit values to avoid overflow
953:                 uint64_t SYS_TMR_SystemCountGet( void )
954:                 {
00000014  00000000   NOP
955:                 
956:                     if(!_SYS_TMR_ReadyCheck())
00000004  00000000   NOP
957:                     {
958:                         return 0;
000000C0  00000000   NOP
959:                     }
960:                 
961:                     uint16_t drvCount1, drvCount2;
962:                     union
963:                     {
964:                         uint64_t ull;
965:                         struct
966:                         {
967:                             uint32_t low;
968:                             uint32_t high;
969:                         };
970:                     }sll1, sll2;
971:                 
972:                     do
973:                     {
974:                         drvCount1 = DRV_TMR_CounterValueGet(sSysTmrObject.driverHandle);
00000034  00000000   NOP
975:                         sll1.low = sSysTmrObject.sysTickCount;
00000048  00000000   NOP
976:                         sll1.high = sSysTmrObject.sysTickCountHigh;
0000004C  00000000   NOP
977:                         drvCount2 = DRV_TMR_CounterValueGet(sSysTmrObject.driverHandle);
00000050  00000000   NOP
978:                         sll2.low = sSysTmrObject.sysTickCount;
0000005C  00000000   NOP
979:                         sll2.high = sSysTmrObject.sysTickCountHigh;
00000060  00000000   NOP
980:                     }while(drvCount2 < drvCount1 || sll1.ull != sll2.ull);
00000064  00000000   NOP
981:                 
982:                 
983:                     return (sll1.ull * sSysTmrObject.driverFreq ) / sSysTmrObject.sysTickFreq + drvCount2;
00000084  00000000   NOP
984:                 }
000000C8  00000000   NOP
985:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/system/ports/src/sys_ports_static.c
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_ports_static.c
9:                   
10:                    Summary:
11:                      SYS PORTS static function implementations for the Ports System Service.
12:                  
13:                    Description:
14:                      The Ports System Service provides a simple interface to manage the ports
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Ports System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system ports configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                  
24:                  *******************************************************************************/
25:                  
26:                  //DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                  *******************************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  #include "system_config.h"
52:                  #include "system/ports/sys_ports.h"
53:                  #include "peripheral/devcon/plib_devcon.h"
54:                  #include "peripheral/ports/plib_ports.h"
55:                  #include "peripheral/int/plib_int.h"
56:                  
57:                  /******************************************************************************
58:                    Function:
59:                      SYS_PORTS_Initialize(void)
60:                  
61:                    Summary:
62:                      Initializes Ports System Service
63:                  
64:                    Description:
65:                      This function initializes different port pins/channels to the desired state.
66:                      It also remaps the pins to the desired specific function.
67:                  
68:                    Remarks:
69:                      None.
70:                  */
71:                  void SYS_PORTS_Initialize(void)
72:                  {
9D0100DC  27BDFFF8   ADDIU SP, SP, -8
9D0100E0  AFB00004   SW S0, 4(SP)
73:                      /* PORT A Initialization */
74:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_ODC);
75:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_LAT);
76:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_TRIS ^ 0xFFFF);
77:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_A);
78:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
79:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNEN);
80:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNPU);
81:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNPD);
82:                      
83:                      /* PORT B Initialization */
84:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ODC);
85:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_LAT);
86:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_TRIS ^ 0xFFFF);
87:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_B);
88:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
89:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNEN);
90:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPU);
91:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPD);
92:                      
93:                      /* PORT C Initialization */
94:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_ODC);
95:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_C,  SYS_PORT_C_LAT);
96:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_C,  SYS_PORT_C_TRIS ^ 0xFFFF);
97:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_C);
98:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
99:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_CNEN);
100:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_CNPU);
101:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_C, SYS_PORT_C_CNPD);
102:                     
103:                     /* PORT D Initialization */
104:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_ODC);
105:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_D,  SYS_PORT_D_LAT);
106:                     PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_D,  SYS_PORT_D_TRIS ^ 0xFFFF);
107:                     PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_D);
108:                     PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
109:                     PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_CNEN);
110:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_CNPU);
111:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_D, SYS_PORT_D_CNPD);
112:                     
113:                     /* PORT E Initialization */
114:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_ODC);
115:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_LAT);
116:                     PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_E,  SYS_PORT_E_TRIS ^ 0xFFFF);
117:                     PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_E);
118:                     PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
119:                     PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_CNEN);
120:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_CNPU);
121:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_E, SYS_PORT_E_CNPD);
122:                     
123:                     /* PORT F Initialization */
124:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_ODC);
125:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_F,  SYS_PORT_F_LAT);
126:                     PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_F,  SYS_PORT_F_TRIS ^ 0xFFFF);
127:                     PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_F);
128:                     PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
129:                     PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_CNEN);
130:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_CNPU);
131:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_F, SYS_PORT_F_CNPD);
132:                     
133:                     /* PORT G Initialization */ //USB
134:                     PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_ODC);
135:                     PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_G,  SYS_PORT_G_LAT);
136:                     PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_G,  SYS_PORT_G_TRIS ^ 0xFFFF);
137:                     PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_G);
138:                     PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
139:                     PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_CNEN);
140:                     PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_CNPU);
141:                     PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_G, SYS_PORT_G_CNPD);
142:                 
143:                 
144:                     /* PPS Input Remapping */
145:                 
146:                     /* PPS Output Remapping */
147:                 
148:                     
149:                 }
9D010238  8FB00004   LW S0, 4(SP)
150:                 
151:                 /******************************************************************************
152:                   Function:
153:                     PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
154:                 
155:                   Summary:
156:                     Reads the data from the I/O port.
157:                 
158:                   Description:
159:                     This function reads the data from the I/O port.
160:                 
161:                   Remarks:
162:                     None.
163:                 */
164:                 
165:                 PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
166:                 {
167:                     return PLIB_PORTS_Read( index, channel );
168:                 }
00000010  00000000   NOP
169:                 
170:                 
171:                 /******************************************************************************
172:                   Function:
173:                     void SYS_PORTS_Write( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
174:                                       		PORTS_DATA_TYPE value )
175:                 
176:                   Summary:
177:                     Writes the data from the I/O port.
178:                 
179:                   Description:
180:                     This function writes the data to the I/O port.
181:                 
182:                   Remarks:
183:                     None.
184:                 */
185:                 
186:                 void SYS_PORTS_Write( PORTS_MODULE_ID index,
187:                                       PORTS_CHANNEL channel,
188:                                       PORTS_DATA_TYPE value )
189:                 {
190:                     PLIB_PORTS_Write( index, channel, value );
191:                 }
192:                 
193:                 
194:                 /******************************************************************************
195:                   Function:
196:                     void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
197:                 	                         PORTS_DATA_TYPE value,
198:                                          PORTS_DATA_MASK mask )
199:                 
200:                   Summary:
201:                     Sets the selected digital port/latch based on the mask.
202:                 
203:                   Description:
204:                     This function sets the selected digital port/latch relative to the mask.
205:                 
206:                   Remarks:
207:                     None.
208:                 */
209:                 
210:                 void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
211:                                     PORTS_DATA_TYPE value,
212:                                     PORTS_DATA_MASK mask )
213:                 {
214:                     PLIB_PORTS_Set( index, channel, value, mask );
215:                 }
216:                 
217:                 
218:                 /******************************************************************************
219:                   Function:
220:                     void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
221:                                            PORTS_DATA_MASK clearMask )
222:                 
223:                   Summary:
224:                     Clears the selected digital port.
225:                 
226:                   Description:
227:                     This function clears the selected digital port.
228:                 
229:                   Remarks:
230:                     None.
231:                 */
232:                 
233:                 void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
234:                                            PORTS_DATA_MASK clearMask )
235:                 {
236:                     PLIB_PORTS_Clear ( index, channel, clearMask );
237:                 }
238:                 
239:                 
240:                 /******************************************************************************
241:                   Function:
242:                     void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
243:                 								SYS_PORTS_PIN_DIRECTION pinDir,
244:                 								PORTS_CHANNEL channel,
245:                 								PORTS_DATA_MASK mask )
246:                   Summary:
247:                     Enables the direction for the selected port.
248:                 
249:                   Description:
250:                     This function enables the direction for the selected port.
251:                 
252:                   Remarks:
253:                     None.
254:                 */
255:                 
256:                 void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
257:                                              SYS_PORTS_PIN_DIRECTION pinDir,
258:                                              PORTS_CHANNEL channel,
259:                                              PORTS_DATA_MASK mask )
260:                 {
261:                     if (pinDir == SYS_PORTS_DIRECTION_INPUT)
00000000  00000000   NOP
262:                     {
263:                         PLIB_PORTS_DirectionInputSet(index, channel, mask);
264:                     }
265:                     else
266:                     {
267:                         PLIB_PORTS_DirectionOutputSet(index, channel, mask);
268:                     }
269:                 }
270:                 
271:                 
272:                 /******************************************************************************
273:                   Function:
274:                     PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index,
275:                                                             PORTS_CHANNEL channel )
276:                 
277:                   Summary:
278:                     Reads the port direction for the selected port.
279:                 
280:                   Description:
281:                     This function reads the port direction for the selected port.
282:                 
283:                   Remarks:
284:                     None.
285:                 */
286:                 
287:                 PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
288:                 {
289:                     return PLIB_PORTS_DirectionGet( index, channel );
290:                 }
0000001C  00000000   NOP
291:                 
292:                 
293:                 /******************************************************************************
294:                   Function:
295:                     void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
296:                                            PORTS_DATA_MASK toggleMask )
297:                 
298:                   Summary:
299:                     Toggles the selected digital port pins.
300:                 
301:                   Description:
302:                     This function toggles the selected digital port pins.
303:                 
304:                   Remarks:
305:                     None.
306:                 */
307:                 
308:                 void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
309:                                        PORTS_DATA_MASK toggleMask )
310:                 {
311:                     PLIB_PORTS_Toggle( index, channel, toggleMask );
312:                 }
313:                 
314:                 
315:                 /******************************************************************************
316:                   Function:
317:                     void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
318:                                                      PORTS_DATA_MASK mask )
319:                 
320:                   Summary:
321:                     Enables the open drain functionality for the selected port.
322:                 
323:                   Description:
324:                     This function enables the open drain functionality for the selected port.
325:                 
326:                   Remarks:
327:                     None.
328:                 */
329:                 
330:                 void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
331:                                                 PORTS_DATA_MASK mask )
332:                 {
333:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
334:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
335:                     {
336:                         PLIB_PORTS_OpenDrainEnable( index, channel, mask );
337:                     }
338:                 #endif
339:                 }
340:                 
341:                 
342:                 /******************************************************************************
343:                   Function:
344:                     void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
345:                                                      PORTS_DATA_MASK mask )
346:                 
347:                   Summary:
348:                     Disables the open drain functionality for the selected port.
349:                 
350:                   Description:
351:                     This function disables the open drain functionality for the selected port.
352:                 
353:                   Remarks:
354:                     None.
355:                 */
356:                 
357:                 void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
358:                                                  PORTS_DATA_MASK mask )
359:                 {
360:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
361:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
362:                     {
363:                         PLIB_PORTS_OpenDrainDisable( index, channel, mask );
364:                     }
365:                 #endif
366:                 }
367:                 
368:                 
369:                 // *****************************************************************************
370:                 // *****************************************************************************
371:                 // Section: SYS Change Notification Pins Routines
372:                 // *****************************************************************************
373:                 // *****************************************************************************
374:                 
375:                 /******************************************************************************
376:                   Function:
377:                     void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
378:                 
379:                   Summary:
380:                     Globally enables the change notification.
381:                 
382:                   Description:
383:                     This function globally enables the change notification.
384:                 
385:                   Remarks:
386:                     None.
387:                 */
388:                 
389:                 void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
390:                 {
391:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
392:                     if(PLIB_PORTS_ExistsChangeNotice(index))
393:                     {
394:                         PLIB_PORTS_ChangeNoticeEnable( index );
395:                     }
396:                 #endif
397:                 }
398:                 
399:                 /******************************************************************************
400:                   Function:
401:                     void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
402:                 
403:                   Summary:
404:                     Globally disables the change notification.
405:                 
406:                   Description:
407:                     This function globally disables the change notification.
408:                 
409:                   Remarks:
410:                     None.
411:                 */
412:                 
413:                 void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
414:                 {
415:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
416:                     if(PLIB_PORTS_ExistsChangeNotice(index))
417:                     {
418:                         PLIB_PORTS_ChangeNoticeDisable( index );
419:                     }
420:                 #endif
421:                 }
422:                 
423:                 /******************************************************************************
424:                   Function:
425:                     void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
426:                 
427:                   Summary:
428:                     Globally disables the change notification for the selected port.
429:                 
430:                   Description:
431:                     This function globally disables the change notification for the selected port.
432:                 
433:                   Remarks:
434:                     None.
435:                 */
436:                 
437:                 void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
438:                 {
439:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
440:                     if(PLIB_PORTS_ExistsChangeNotice(index))
441:                     {
442:                         PLIB_PORTS_ChangeNoticeDisable( index );
443:                     }
444:                 #endif
445:                 }
446:                 
447:                 
448:                 /******************************************************************************
449:                   Function:
450:                     void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
451:                                                              PORTS_CHANGE_NOTICE_PIN pinNum,
452:                                                              SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
453:                 
454:                   Summary:
455:                     Enables the change notification for the selected port.
456:                 
457:                   Description:
458:                     This function enables the change notification for the selected port.
459:                 
460:                   Remarks:
461:                     None.
462:                 */
463:                 
464:                 void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
465:                                                          PORTS_CHANGE_NOTICE_PIN pinNum,
466:                                                          SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
467:                 {
468:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
469:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
470:                     {
471:                         switch(value)
472:                         {
473:                             case SYS_PORTS_PULLUP_DISABLE:
474:                                 PLIB_PORTS_ChangeNoticePullUpDisable(index, pinNum);
475:                                 break;
476:                             case SYS_PORTS_PULLUP_ENABLE:
477:                                 PLIB_PORTS_ChangeNoticePullUpEnable(index, pinNum);
478:                                 break;
479:                         }
480:                     }
481:                 #endif
482:                 
483:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
484:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
485:                     {
486:                         PLIB_PORTS_PinChangeNoticeEnable( index, pinNum );
487:                     }
488:                 #endif
489:                 }
490:                 
491:                 
492:                 /******************************************************************************
493:                   Function:
494:                     void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
495:                                                               PORTS_CHANGE_NOTICE_PIN pinNum )
496:                 
497:                   Summary:
498:                     Disables the change notification for the selected port.
499:                 
500:                   Description:
501:                     This function disables the change notification for the selected port.
502:                 
503:                   Remarks:
504:                     None.
505:                 */
506:                 
507:                 void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
508:                                                           PORTS_CHANGE_NOTICE_PIN pinNum )
509:                 {
510:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
511:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
512:                     {
513:                         PLIB_PORTS_PinChangeNoticeDisable( index, pinNum );
514:                     }
515:                 #endif
516:                 }
517:                 
518:                 
519:                 /******************************************************************************
520:                   Function:
521:                     void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
522:                 
523:                   Summary:
524:                     Enables the change notification for the selected port in Sleep or Idle mode.
525:                 
526:                   Description:
527:                     This function enables the change notification for the selected port in Sleep
528:                     or Idle mode.
529:                 
530:                   Remarks:
531:                     None.
532:                 */
533:                 
534:                 void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
535:                 {
536:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
537:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
538:                     {
539:                         PLIB_PORTS_ChangeNoticeInIdleEnable( index );
540:                     }
541:                 #endif
542:                 }
543:                 
544:                 
545:                 // *****************************************************************************
546:                 /* Function:
547:                     void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index)
548:                 
549:                   Summary:
550:                     Disables the change notification for the selected port in Sleep or Idle mode.
551:                 
552:                   Description:
553:                     This function disables the change notification for the selected port in Sleep
554:                     or Idle mode.
555:                 
556:                   Remarks:
557:                     None.
558:                 */
559:                 
560:                 void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index )
561:                 {
562:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
563:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
564:                     {
565:                         PLIB_PORTS_ChangeNoticeInIdleDisable( index );
566:                     }
567:                 #endif
568:                 }
569:                 
570:                 
571:                 // *****************************************************************************
572:                 /* Function:
573:                     void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
574:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
575:                 
576:                   Summary:
577:                     Enables weak pull-up on change notification pin.
578:                 
579:                   Description:
580:                     This function enables weak pull-up on change notification pin.
581:                 
582:                   Remarks:
583:                     None.
584:                 */
585:                 
586:                 void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
587:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
588:                 {
589:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
590:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
591:                     {
592:                         PLIB_PORTS_ChangeNoticePullUpEnable ( index, pinNum );
593:                     }
594:                 #endif
595:                 }
596:                 
597:                 
598:                 // *****************************************************************************
599:                 /* Function:
600:                     void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
601:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
602:                 
603:                   Summary:
604:                     Disables pull-up on input change.
605:                 
606:                   Description:
607:                     This function disables pull-up on input change.
608:                 
609:                   Remarks:
610:                     None.
611:                 */
612:                 
613:                 void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
614:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
615:                 {
616:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
617:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
618:                     {
619:                         PLIB_PORTS_ChangeNoticePullUpDisable ( index, pinNum );
620:                     }
621:                 #endif
622:                 }
623:                 
624:                 
625:                 // *****************************************************************************
626:                 // *****************************************************************************
627:                 // Section: SYS PORT PINS Control Routines
628:                 // *****************************************************************************
629:                 // *****************************************************************************
630:                 
631:                 // *****************************************************************************
632:                 /* Function:
633:                     void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
634:                     								PORTS_PIN_MODE mode)
635:                 
636:                   Summary:
637:                     Enables the selected pin as analog or digital.
638:                 
639:                   Description:
640:                     This function enables the selected pin as analog or digital.
641:                 
642:                  Remarks:
643:                     None.
644:                 */
645:                 
646:                 void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
647:                 								PORTS_PIN_MODE mode)
648:                 {
649:                 #if defined(PLIB_PORTS_ExistsPinMode)
650:                     if(PLIB_PORTS_ExistsPinMode(index))
651:                     {
652:                         PLIB_PORTS_PinModeSelect ( index, pin, mode);
653:                     }
654:                 #endif
655:                 }
656:                 
657:                 
658:                 // *****************************************************************************
659:                 /* Function:
660:                     void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
661:                                               PORTS_CHANNEL channel,
662:                                               PORTS_BIT_POS bitPos
663:                                               bool value )
664:                   Summary:
665:                     Writes the selected digital pin.
666:                 
667:                   Description:
668:                     This function writes the selected digital pin.
669:                 
670:                   Remarks:
671:                     None.
672:                 */
673:                 
674:                 void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
675:                                           PORTS_CHANNEL channel,
676:                                           PORTS_BIT_POS bitPos,
677:                                           bool value )
678:                 {
00000000  00000000   NOP
679:                     PLIB_PORTS_PinWrite ( index, channel, bitPos, value );
680:                 }
681:                 
682:                 
683:                 // *****************************************************************************
684:                 /* Function:
685:                     bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
686:                                              PORTS_CHANNEL channel,
687:                                              PORTS_BIT_POS bitPos )
688:                 
689:                   Summary:
690:                     Reads the selected digital pin.
691:                 
692:                   Description:
693:                     This function reads the selected digital pin.
694:                 
695:                   Remarks:
696:                     None.
697:                 */
698:                 
699:                 bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
700:                                          PORTS_CHANNEL channel,
701:                                          PORTS_BIT_POS bitPos )
702:                 {
703:                     return PLIB_PORTS_PinGet ( index, channel, bitPos );
704:                 }
00000020  00000000   NOP
705:                 
706:                 
707:                 // *****************************************************************************
708:                 /* Function:
709:                     void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
710:                                                PORTS_CHANNEL channel,
711:                                                PORTS_BIT_POS bitPos )
712:                 
713:                   Summary:
714:                     Toggles the selected digital pin.
715:                 
716:                   Description:
717:                     This function toggles the selected digital pin.
718:                 
719:                   Remarks:
720:                     None.
721:                 */
722:                 
723:                 void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
724:                                            PORTS_CHANNEL channel,
725:                                            PORTS_BIT_POS bitPos )
726:                 {
727:                     PLIB_PORTS_PinToggle ( index, channel, bitPos );
728:                 }
729:                 
730:                 
731:                 // *****************************************************************************
732:                 /* Function:
733:                     void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
734:                                            PORTS_CHANNEL channel,
735:                                            PORTS_BIT_POS bitPos )
736:                 
737:                   Summary:
738:                     Sets the selected digital pin/latch.
739:                 
740:                   Description:
741:                     This function sets the selected digital pin/latch.
742:                 
743:                   Remarks:
744:                     None.
745:                 */
746:                 
747:                 void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
748:                                        PORTS_CHANNEL channel,
749:                                        PORTS_BIT_POS bitPos )
750:                 {
751:                     PLIB_PORTS_PinSet( index, channel, bitPos );
752:                 }
753:                 
754:                 
755:                 // *****************************************************************************
756:                 /* Function:
757:                     void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
758:                                               PORTS_CHANNEL channel,
759:                                               PORTS_BIT_POS bitPos )
760:                 
761:                   Summary:
762:                     Clears the selected digital pin.
763:                 
764:                   Description:
765:                     This function clears the selected digital pin.
766:                 
767:                   Remarks:
768:                     None.
769:                 */
770:                 
771:                 void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
772:                                           PORTS_CHANNEL channel,
773:                                           PORTS_BIT_POS bitPos )
774:                 {
775:                     PLIB_PORTS_PinClear ( index, channel, bitPos );
776:                 }
777:                 
778:                 
779:                 // *****************************************************************************
780:                 /* Function:
781:                     void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
782:                                                      SYS_PORTS_PIN_DIRECTION pinDir,
783:                                                      PORTS_CHANNEL channel,
784:                                                      PORTS_BIT_POS bitPos )
785:                   Summary:
786:                     Enables the direction for the selected pin.
787:                 
788:                   Description:
789:                     This function enables the direction for the selected pin.
790:                 
791:                   Remarks:
792:                     None.
793:                 */
794:                 
795:                 void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
796:                                                  SYS_PORTS_PIN_DIRECTION pinDir,
797:                                                  PORTS_CHANNEL channel,
798:                                                  PORTS_BIT_POS bitPos )
799:                 {
800:                     if (pinDir == SYS_PORTS_DIRECTION_OUTPUT)
00000000  00000000   NOP
801:                     {
802:                         PLIB_PORTS_PinDirectionOutputSet(index, channel, bitPos);
803:                     }
804:                     else
805:                     {
806:                         PLIB_PORTS_PinDirectionInputSet(index, channel, bitPos);
807:                     }
808:                 }
809:                 
810:                 
811:                 // *****************************************************************************
812:                 /* Function:
813:                     void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
814:                                                         PORTS_CHANNEL channel,
815:                                                         PORTS_BIT_POS bitPos )
816:                 
817:                   Summary:
818:                     Enables the open-drain functionality for the selected pin.
819:                 
820:                   Description:
821:                     This function enables the open-drain functionality for the selected pin.
822:                 
823:                   Remarks:
824:                     None.
825:                 */
826:                 
827:                 void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
828:                                                     PORTS_CHANNEL channel,
829:                                                     PORTS_BIT_POS bitPos )
830:                 {
831:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
832:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
833:                     {
834:                         PLIB_PORTS_PinOpenDrainEnable ( index, channel, bitPos );
835:                     }
836:                 #endif
837:                 }
838:                 
839:                 
840:                 // *****************************************************************************
841:                 /* Function:
842:                     void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
843:                                                          PORTS_CHANNEL channel,
844:                                                          PORTS_BIT_POS bitPos )
845:                 
846:                   Summary:
847:                     Disables the open-drain functionality for the selected pin.
848:                 
849:                   Description:
850:                     This function disables the open-drain functionality for the selected pin.
851:                 
852:                   Remarks:
853:                     None.
854:                 */
855:                 
856:                 void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
857:                                                      PORTS_CHANNEL channel,
858:                                                      PORTS_BIT_POS bitPos )
859:                 {
860:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
861:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
862:                     {
863:                         PLIB_PORTS_PinOpenDrainDisable ( index, channel, bitPos );
864:                     }
865:                 #endif
866:                 }
867:                 
868:                 
869:                 // *****************************************************************************
870:                 /* Function:
871:                     void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
872:                 							  PORTS_REMAP_INPUT_FUNCTION function,
873:                 							  PORTS_REMAP_INPUT_PIN      remapPin )
874:                 
875:                   Summary:
876:                     Input/Output (I/O) function remapping.
877:                 
878:                   Description:
879:                     This function controls the I/O function remapping.
880:                 
881:                   Precondition:
882:                     None.
883:                 */	
884:                 void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
885:                 						   PORTS_REMAP_INPUT_FUNCTION function,
886:                 						   PORTS_REMAP_INPUT_PIN      remapPin )
887:                 {
888:                 #if defined(PLIB_PORTS_ExistsRemapInput)
889:                     if(PLIB_PORTS_ExistsRemapInput(index))
890:                     {
891:                         PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
892:                         PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
893:                         PLIB_PORTS_RemapInput( index, function, remapPin);
894:                     }
895:                 #endif
896:                 }
897:                 
898:                 // *****************************************************************************
899:                 /* Function:
900:                     void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
901:                                                       PORTS_REMAP_OUTPUT_FUNCTION function,
902:                                                       PORTS_REMAP_OUTPUT_PIN      remapPin )
903:                 
904:                   Summary:
905:                     Input/Output (I/O) function remapping.
906:                 
907:                   Description:
908:                     This function controls the I/O function remapping.
909:                 
910:                   Precondition:
911:                     None.
912:                 */
913:                 void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
914:                 						    PORTS_REMAP_OUTPUT_FUNCTION function,
915:                 						    PORTS_REMAP_OUTPUT_PIN      remapPin )
916:                 {
917:                 #if defined(PLIB_PORTS_ExistsRemapOutput)
918:                     if(PLIB_PORTS_ExistsRemapOutput(index))
919:                     {
920:                         PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
921:                         PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
922:                         PLIB_PORTS_RemapOutput( index, function, remapPin);
923:                     }
924:                 #endif
925:                 }
926:                 
927:                 /*******************************************************************************
928:                  End of File
929:                 */
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int_pic32.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "system/int/sys_int.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Function Definitions
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  /******************************************************************************
53:                  
54:                    Function:
55:                      void SYS_INT_Initialize ( void )
56:                  
57:                    Summary:
58:                      Configures and initializes the interrupt sub-system.
59:                  
60:                    Description:
61:                      This function appropriately configures and initializes the interrupt sub-system
62:                      for the current system design.
63:                  
64:                    Precondition:
65:                      None.
66:                  
67:                    Parameters:
68:                      None.
69:                  
70:                    Returns:
71:                      None.
72:                  
73:                    Example:
74:                    <code>
75:                    SYS_INT_Initialize();
76:                    </code>
77:                  
78:                    Remarks:
79:                      This function is not implemented in the System Interrupt library.  It is
80:                      implemented by the board support package (using the processor-specific
81:                      interrupt peripheral library) because it requires knowledge of the specific
82:                      interrupt requirements for each system.
83:                  */
84:                  
85:                  void SYS_INT_Initialize ( void )
86:                  
87:                  {
88:                      /* enable the multi vector */
89:                      PLIB_INT_MultiVectorSelect( INT_ID_0 );
90:                  }
91:                  
92:                  //*******************************************************************************
93:                  /*  Function:
94:                       SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
95:                  
96:                    Summary:
97:                      Disables interrupts to the processor and return the previois status.
98:                      
99:                    Description:
100:                     This function disables interrupts to the processor at the top level. This
101:                     function can be called to prevent any source from being able to generate an
102:                     interrupt. It returns the processor status (which includes global interrupt
103:                     status and Interrupt Priority status) before disabling the interrupts.
104:                 
105:                   Remarks:
106:                     See sys_int.h file for more details.
107:                 */
108:                 
109:                 SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
110:                 {
00000000  00000000   NOP
111:                     SYS_INT_PROCESSOR_STATUS processorStatus;
112:                 
113:                     /* Save the processor status and then Disable the global interrupt */
114:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
115:                 
116:                     /* return the processor status */
117:                     return processorStatus;
118:                 }
00000010  00000000   NOP
119:                 
120:                 //*******************************************************************************
121:                 /* Function:
122:                     void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
123:                 
124:                   Summary:
125:                     Restores the processor status.
126:                 
127:                   Description:
128:                     This function sets the processor status based on the 32 bit value passed as 
129:                     a parameter. 0th bit of the status is for Master Interrupt status.
130:                 
131:                   Remarks:
132:                     See sys_int.h file for more details.
133:                 */
134:                 
135:                 void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
136:                 {
00000000  00000000   NOP
137:                     PLIB_INT_SetState(INT_ID_0, processorStatus);
138:                 }
00000010  00000000   NOP
139:                 
140:                 // *****************************************************************************
141:                 /*  Disable the generation of interrupts to the CPU
142:                 
143:                   Summary:
144:                      Disables all interrupts
145:                 
146:                   Description:
147:                      This function disables all interrupts.
148:                 
149:                   Remarks:
150:                     This API will be depricated soon. Use "SYS_INT_StatusGetAndDisable" instead.
151:                  */
152:                 
153:                 bool SYS_INT_Disable( void )
154:                 {
9D01702C  27BDFFF8   ADDIU SP, SP, -8
9D017030  AFBF0004   SW RA, 4(SP)
155:                     SYS_INT_PROCESSOR_STATUS processorStatus;
156:                 
157:                     /* Save the processor status and then Disable the global interrupt */
158:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
159:                 
160:                     /* return the interrupt status */
161:                     return (bool)(processorStatus & 0x01);
162:                 }
9D01703C  30420001   ANDI V0, V0, 1
163:                 
164:                 // *****************************************************************************
165:                 /* Function:
166:                     bool SYS_INT_SourceDisable ( INT_SOURCE source )
167:                 
168:                   Summary:
169:                     Disables the interrupt source.
170:                 
171:                   Description:
172:                     This routine disables the given source from generating interrupts the 
173:                     processor when events occur.It returns the interrupt source enable/disable 
174:                 	status before disabling the interrupt source.
175:                 
176:                   Remarks:
177:                     See sys_int.h file for more details.
178:                  */
179:                 
180:                 
181:                 bool SYS_INT_SourceDisable ( INT_SOURCE source )
182:                 {
9D01623C  27BDFFF8   ADDIU SP, SP, -8
9D016240  AFBF0004   SW RA, 4(SP)
183:                     bool intSrcStatus;
184:                     SYS_INT_PROCESSOR_STATUS processorStatus;
185:                 
186:                     /* Save the processor status and then Disable the global interrupt */
187:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
188:                     
189:                     /* get the interrupt status of this source before disable is called */
190:                     intSrcStatus = PLIB_INT_SourceIsEnabled (INT_ID_0 , source);
191:                 
192:                     /* disable the interrupts */
193:                     PLIB_INT_SourceDisable (INT_ID_0 , source);
194:                 
195:                     /* restore the state of CP0 Status register before the disable occurred*/
196:                     PLIB_INT_SetState(INT_ID_0 , processorStatus);
197:                 
198:                     /* return the source status */
199:                     return intSrcStatus;
200:                 }
9D016280  30420001   ANDI V0, V0, 1
201:                 
202:                 
203:                 // *****************************************************************************
204:                 /* Sets the external interrupt trigger type.
205:                 
206:                   Summary:
207:                     Sets the external interrupt trigger type.
208:                 
209:                   Description:
210:                     This function sets the External interrupt trigger type.
211:                 
212:                   Remarks:
213:                     Refer the datasheet to know the external interrupt sources supported.
214:                  */
215:                 
216:                 void SYS_INT_ExternalInterruptTriggerSet ( 	INT_EXTERNAL_SOURCES source,
217:                 										INT_EXTERNAL_EDGE_TRIGGER edgeTrigger )
218:                 {
219:                 	if ( edgeTrigger == INT_EDGE_TRIGGER_RISING )
00000000  00000000   NOP
220:                 	{
221:                 		PLIB_INT_ExternalRisingEdgeSelect ( INT_ID_0, source );
222:                 	}
223:                 	else
224:                 	{
225:                 		PLIB_INT_ExternalFallingEdgeSelect ( INT_ID_0, source );
226:                 	}
227:                 }
228:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/system/fs/src/dynamic/sys_fs_media_manager.c
1:                   /*******************************************************************************
2:                     File System System-Library Interface Implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_fs_media_manager.c
9:                   
10:                    Summary:
11:                      This file contains implementation of SYS FS Media Manager functions. 
12:                  
13:                    Description:
14:                      This file contains implementation of SYS FS Media Manager functions. 
15:                  *******************************************************************************/
16:                  
17:                  //DOM-IGNORE-BEGIN
18:                  /*******************************************************************************
19:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
20:                  
21:                  Microchip licenses to you the right to use, modify, copy and distribute
22:                  Software only when embedded on a Microchip microcontroller or digital signal
23:                  controller that is fsegrated fso your product or third party product (pursuant
24:                  to the sublicense terms in the accompanying license agreement).
25:                  
26:                  You should refer to the license agreement accompanying this Software for
27:                  additional information regarding your rights and obligations.
28:                  
29:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
30:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
31:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
32:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
33:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
34:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
35:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
36:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
37:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
38:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
39:                  *******************************************************************************/
40:                  //DOM-IGNORE-END
41:                  
42:                  #include "system/fs/src/sys_fs_media_manager_local.h"
43:                  #include "system/fs/src/sys_fs_local.h"
44:                  
45:                  const char *gSYSFSVolumeName [] = {
46:                      "nvm",
47:                      "sd",
48:                      "mmcblk",
49:                      "ram",
50:                      "mtd",
51:                  };
52:                  
53:                  /**/
54:                  const uint16_t gPartitionTypeOffset [4] =
55:                  {
56:                      450,
57:                      466,
58:                      482,
59:                      498
60:                  };
61:                  
62:                  // *****************************************************************************
63:                  /* Media object
64:                  
65:                    Summary:
66:                      Defines the media object for each media that should be controlled by media manager
67:                  
68:                    Description:
69:                      This data type defines the media objects that are available on
70:                      the part.
71:                    Remarks:
72:                      None
73:                  */
74:                  
75:                  SYS_FS_MEDIA gSYSFSMediaObject[SYS_FS_MEDIA_NUMBER];
76:                  
77:                  // *****************************************************************************
78:                  /* Volume object
79:                  
80:                    Summary:
81:                      Defines the volume object for each media that should be controlled by media manager
82:                  
83:                    Description:
84:                       Each partition of the media is assigned as a volume using the volume object.
85:                  
86:                    Remarks:
87:                      None
88:                  */
89:                  SYS_FS_VOLUME gSYSFSVolumeObject[SYS_FS_VOLUME_NUMBER];
90:                  // *****************************************************************************
91:                  /* Media Event Handler
92:                  
93:                    Summary:
94:                      Defines the media Event handler that stores the application event handler.
95:                  
96:                    Description:
97:                      This data type defines the media event handler
98:                      the part.
99:                    Remarks:
100:                     None
101:                 */
102:                 extern SYS_FS_EVENT_HANDLER gSYSFSEventHandler;
103:                 
104:                 // *****************************************************************************
105:                 /* Media Page Buffer
106:                 
107:                   Summary:
108:                     Defines the media page buffer to store the data on media.
109:                 
110:                   Description:
111:                     This data type defines the media page buffer.
112:                   Remarks:
113:                     None
114:                 */
115:                 uint8_t __attribute__((coherent, aligned(16))) gSYSFSMediaBlockBuffer[SYS_FS_MEDIA_MANAGER_BUFFER_SIZE] = {0};
116:                 
117:                 // *****************************************************************************
118:                 /* Media Mount Table
119:                 
120:                   Summary:
121:                     Defines the mount table specified by application.
122:                 
123:                   Description:
124:                     This data type defines the mount table that maps device and mount name.
125:                   Remarks:
126:                     None
127:                 */
128:                 extern const SYS_FS_MEDIA_MOUNT_DATA sysfsMountTable[];
129:                 
130:                 // *****************************************************************************
131:                 /* Volume to Partition translation
132:                 
133:                   Summary:
134:                     Defines the volume to partition translation table, used by FAT FS.
135:                 
136:                   Description:
137:                  * The following array was added to enable the "multipartition"
138:                  * feature of FAT FS. This array is already declared in ff.h and
139:                  * the intention was to make as little change on ff.h. Also, type of this
140:                  * array is non-standard since, it is defined in ff.c. The implementation
141:                  * is kept unchanged to maintain compatibility with future releases of FAT FS
142:                 
143:                   Remarks:
144:                     None
145:                 */
146:                 PARTITION VolToPart[SYS_FS_VOLUME_NUMBER];
147:                 
148:                 uint8_t gSYSFSMediaBuffer[SYS_FS_MEDIA_MAX_BLOCK_SIZE] __attribute__((coherent, aligned(16)));
149:                 
150:                 /* Following structure holds the variables for media manager, including the task states */
151:                 SYS_FS_MEDIA_MANAGER_OBJ gSYSFSMediaManagerObj =
152:                 {
153:                     gSYSFSMediaObject,
154:                     gSYSFSVolumeObject,
155:                     sysfsMountTable,
156:                     NULL,
157:                     gSYSFSMediaBuffer,
158:                     0,
159:                     0,
160:                     false
161:                 };
162:                 
163:                 /*****************************************************************************
164:                  * Function:
165:                  * void _SYS_FS_MEDIA_MANAGER_updateVolToPart(uint8_t volNumber, uint8_t pd, uint8_t pt)
166:                  *
167:                  * Description:
168:                  * This function is present to enable the multipartition operation
169:                  * of FAT FS. FAT FS uses the structure VolToPart to know the physical
170:                  * drive media number and partition number of that media, using this
171:                  * structure. This function is used to populate the structure.
172:                  * REFER TO MORE EXPLANATION on SYS_fs_media_manager_local.h
173:                  *
174:                  * Precondition:
175:                  *   None
176:                  *
177:                  * Parameters:
178:                  *   volNumber      - volume number
179:                  *   pd             - physical drive number (media number)
180:                  *   pt             - partition number from that media
181:                  *
182:                  * Returns:
183:                  *   none.
184:                 */
185:                 
186:                 static void _SYS_FS_MEDIA_MANAGER_UpdateVolToPart
187:                 (
188:                     uint8_t volNumber,
189:                     uint8_t pd,
190:                     uint8_t pt
191:                 )
192:                 {
193:                     /* Update the "VolToPart" table for multipartition support on FAT FS */
194:                     /* pd = Physical drive, starting from "zero". This is to be compatible with FAT FS code */
195:                     VolToPart[volNumber].pd = pd;
9D004274  A38280B4   SB V0, -32588(GP)
9D004284  A38280B4   SB V0, -32588(GP)
196:                     /* pt = partition, starting from "one". This is to be compatible with FAT FS code */
197:                     VolToPart[volNumber].pt = pt;
9D00427C  0B4010A3   J 0x9D00428C
9D004280  A38380B5   SB V1, -32587(GP)
9D004288  A38080B5   SB ZERO, -32587(GP)
198:                 }
199:                 
200:                 static void _SYS_FS_MEDIA_MANAGER_HandleMediaDetach
201:                 (
202:                     SYS_FS_MEDIA *mediaObj
203:                 )
204:                 {
9D014A8C  27BDFFE8   ADDIU SP, SP, -24
9D014A90  AFBF0014   SW RA, 20(SP)
9D014A94  AFB00010   SW S0, 16(SP)
205:                     uint8_t volIndex = 0;
206:                     uint8_t index = 0;
207:                     SYS_FS_VOLUME *volumeObj = NULL;
208:                     const SYS_FS_MEDIA_MOUNT_DATA *fsMount = (const SYS_FS_MEDIA_MOUNT_DATA *)&gSYSFSMediaManagerObj.fsMountTable[0];
9D014A98  3C028001   LUI V0, -32767
9D014A9C  24424EAC   ADDIU V0, V0, 20140
9D014AA0  8C500008   LW S0, 8(V0)
209:                 
210:                     for (volIndex = 0; volIndex < SYS_FS_VOLUME_NUMBER; volIndex++)
211:                     {
212:                         volumeObj = &gSYSFSMediaManagerObj.volumeObj[volIndex];
9D014AA4  8C420004   LW V0, 4(V0)
213:                         if ((volumeObj->inUse == false) || (volumeObj->obj != mediaObj))
9D014AA8  90430000   LBU V1, 0(V0)
9D014AAC  1060001A   BEQ V1, ZERO, 0x9D014B18
9D014AB0  8FBF0014   LW RA, 20(SP)
9D014AB4  8C430018   LW V1, 24(V0)
9D014AB8  54640018   BNEL V1, A0, 0x9D014B1C
9D014ABC  8FB00010   LW S0, 16(SP)
214:                         {
215:                             continue;
216:                         }
217:                 
218:                         volumeObj->inUse = false;
9D014AC0  A0400000   SB ZERO, 0(V0)
219:                 
220:                         /* Unmount the media if auto mount feature is enabled */
221:                         if (SYS_FS_AUTOMOUNT_ENABLE == false)
222:                         {
223:                             continue;
224:                         }
225:                 
226:                         for (index = 0; index < SYS_FS_VOLUME_NUMBER; index++)
227:                         {
228:                             /* Find out the mount name from the media mount table */
229:                             if (mediaObj->mediaType != fsMount[index].mediaType)
9D014AC4  8C640018   LW A0, 24(V1)
9D014AC8  8E030008   LW V1, 8(S0)
9D014ACC  14830012   BNE A0, V1, 0x9D014B18
9D014AD0  8FBF0014   LW RA, 20(SP)
230:                             {
231:                                 continue;
232:                             }
233:                 
234:                             if(0 != strcmp((const char *)(volumeObj->volumeName), (const char *)(fsMount[index].devName+5)))
9D014AD4  8E050004   LW A1, 4(S0)
9D014AD8  24440002   ADDIU A0, V0, 2
9D014ADC  0F404748   JAL strcmp
9D014AE0  24A50005   ADDIU A1, A1, 5
9D014AE4  1440000C   BNE V0, ZERO, 0x9D014B18
9D014AE8  8FBF0014   LW RA, 20(SP)
235:                             {
236:                                 continue;
237:                             }
238:                 
239:                             /* If the device is present in the mount table then fetch the mount name
240:                                which is the input for the unmount function */
241:                             if (SYS_FS_RES_SUCCESS != SYS_FS_Unmount(fsMount[index].mountName))
9D014AEC  0F404FA6   JAL SYS_FS_Unmount
9D014AF0  8E040000   LW A0, 0(S0)
9D014AF4  14400008   BNE V0, ZERO, 0x9D014B18
9D014AF8  8FBF0014   LW RA, 20(SP)
242:                             {
243:                                 continue;
244:                             }
245:                 
246:                             if (gSYSFSEventHandler)
9D014AFC  8F828050   LW V0, -32688(GP)
9D014B00  10400005   BEQ V0, ZERO, 0x9D014B18
9D014B04  24040001   ADDIU A0, ZERO, 1
247:                             {
248:                                 gSYSFSEventHandler (SYS_FS_EVENT_UNMOUNT, (void*)fsMount[index].mountName, (uintptr_t)NULL);
9D014B08  8E050000   LW A1, 0(S0)
9D014B0C  0040F809   JALR V0
9D014B10  00003021   ADDU A2, ZERO, ZERO
249:                             }
250:                 
251:                             break;
252:                         }
253:                     }
254:                 }
9D014B14  8FBF0014   LW RA, 20(SP)
255:                 
256:                 static void _SYS_FS_MountVolume 
257:                 (
258:                     SYS_FS_MEDIA_TYPE mediaType,
259:                     const uint8_t *volumeName
260:                 )
261:                 {
262:                     uint8_t volumeIndex = 0;
263:                     const SYS_FS_MEDIA_MOUNT_DATA *fsMount = (const SYS_FS_MEDIA_MOUNT_DATA *)&gSYSFSMediaManagerObj.fsMountTable[0];
9D0042A0  3C028001   LUI V0, -32767
264:                 
265:                     for (volumeIndex = 0; volumeIndex < SYS_FS_VOLUME_NUMBER; volumeIndex++)
266:                     {
267:                         if (mediaType != fsMount[volumeIndex].mediaType)
9D0042A8  8E030018   LW V1, 24(S0)
268:                         {
269:                             continue;
270:                         }
271:                 
272:                         if (strcmp((const char *)volumeName, (const char *)(fsMount[volumeIndex].devName + 5)) != 0)
9D0042B8  8E320004   LW S2, 4(S1)
273:                         {
274:                             continue;
275:                         }
276:                 
277:                         if (SYS_FS_RES_SUCCESS == SYS_FS_Mount(fsMount[volumeIndex].devName, fsMount[volumeIndex].mountName, fsMount[volumeIndex].fsType, 0, NULL))
9D0042D0  8E250000   LW A1, 0(S1)
278:                         {
279:                             if (gSYSFSEventHandler)
9D0042F0  10400004   BEQ V0, ZERO, 0x9D004304
280:                             {
281:                                 gSYSFSEventHandler(SYS_FS_EVENT_MOUNT, (void*)fsMount[volumeIndex].mountName, (uintptr_t)NULL);
9D0042F8  8E250000   LW A1, 0(S1)
282:                             }
283:                         }
284:                 
285:                         break;
286:                     }
287:                 }
288:                 
289:                 static void _SYS_FS_MEDIA_MANAGER_PopulateVolume
290:                 (
291:                     SYS_FS_MEDIA *mediaObj,
292:                     uint8_t isMBR,
293:                     uint8_t partitionMap,
294:                     uint8_t fsType
295:                 )
296:                 {
297:                     uint8_t volumeIndex = 0;
298:                     uint8_t volumeNameLen = 0;
299:                     uint8_t partitionNum = 0;
300:                     uint16_t offset = 0;
301:                 
302:                     SYS_FS_VOLUME *volumeObj = NULL;
303:                     uint8_t *readBuffer = NULL;
304:                 
305:                     volumeObj = &gSYSFSMediaManagerObj.volumeObj[0];
9D0040E4  3C028001   LUI V0, -32767
9D0040E8  24424EAC   ADDIU V0, V0, 20140
9D0040EC  8C520004   LW S2, 4(V0)
306:                     readBuffer = gSYSFSMediaManagerObj.mediaBuffer;
9D0040F0  8C420010   LW V0, 16(V0)
9D0040F4  AFA20018   SW V0, 24(SP)
307:                 
308:                     for (volumeIndex = 0; volumeIndex < SYS_FS_VOLUME_NUMBER; volumeIndex++)
309:                     {
310:                         if (volumeObj->inUse == true) 
9D0040F8  92420000   LBU V0, 0(S2)
9D0040FC  14400082   BNE V0, ZERO, 0x9D004308
9D004100  3C028001   LUI V0, -32767
311:                         {
312:                             volumeObj++;
313:                             continue;
314:                         }
315:                 
316:                         /* Found a free volume */
317:                         mediaObj->numVolumes++;
9D004104  92020004   LBU V0, 4(S0)
9D004108  24420001   ADDIU V0, V0, 1
9D00410C  A2020004   SB V0, 4(S0)
318:                 
319:                         volumeNameLen = strlen(gSYSFSVolumeName[mediaObj->mediaType]);
9D004110  8E020018   LW V0, 24(S0)
9D004114  00021080   SLL V0, V0, 2
9D004118  3C1E8001   LUI S8, -32767
9D00411C  27DE4EC4   ADDIU S8, S8, 20164
9D004120  7FC2F00A   LWX S8, V0(S8)
9D004124  0F4040EB   JAL strlen
9D004128  03C02021   ADDU A0, S8, ZERO
9D00412C  305600FF   ANDI S6, V0, 255
320:                         strncpy (volumeObj->volumeName, gSYSFSVolumeName[mediaObj->mediaType], volumeNameLen);
9D004130  26550002   ADDIU S5, S2, 2
9D004134  305700FF   ANDI S7, V0, 255
9D004138  02A02021   ADDU A0, S5, ZERO
9D00413C  03C02821   ADDU A1, S8, ZERO
9D004140  0F4048E1   JAL strncpy
9D004144  02E03021   ADDU A2, S7, ZERO
321:                 
322:                         /* Store the volume name */
323:                         volumeObj->volumeName[volumeNameLen++] = mediaObj->mediaId;
9D004148  0257B821   ADDU S7, S2, S7
9D00414C  92020002   LBU V0, 2(S0)
9D004150  A2E20002   SB V0, 2(S7)
9D004154  26C20001   ADDIU V0, S6, 1
324:                         volumeObj->volumeName[volumeNameLen++] = mediaObj->numVolumes + '0';
9D004158  304200FF   ANDI V0, V0, 255
9D00415C  02421021   ADDU V0, S2, V0
9D004160  92030004   LBU V1, 4(S0)
9D004164  24630030   ADDIU V1, V1, 48
9D004168  A0430002   SB V1, 2(V0)
9D00416C  26C20002   ADDIU V0, S6, 2
325:                         volumeObj->volumeName[volumeNameLen] = '\0';
9D004170  304200FF   ANDI V0, V0, 255
9D004174  02421021   ADDU V0, S2, V0
9D004178  A0400002   SB ZERO, 2(V0)
326:                 
327:                         volumeObj->obj = mediaObj;
9D00417C  AE500018   SW S0, 24(S2)
328:                         volumeObj->fsType = fsType;
329:                 
330:                         if ('M' == volumeObj->fsType)
9D004180  2402004D   ADDIU V0, ZERO, 77
9D004184  16620006   BNE S3, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D004188  A2530001   SB S3, 1(S2)
331:                         {
332:                             /* MPFS File System */
333:                             volumeObj->numSectors = 0;
9D00418C  AE400014   SW ZERO, 20(S2)
334:                             volumeObj->startSector = 0;
9D004190  AE400010   SW ZERO, 16(S2)
335:                         }
336:                         else
337:                         {
338:                             /* Register Media and Volume mapping with FAT File System */
339:                             /* Register the volumes to partition table only if this device has
340:                              * partition table entry or MBR. Skip if media contains VBR */
341:                             if (partitionMap)
9D0041A0  12200032   BEQ S1, ZERO, 0x9D00426C
9D0041A4  00001821   ADDU V1, ZERO, ZERO
342:                             {
343:                                 if (partitionMap & 0x01)
9D0041A8  32220001   ANDI V0, S1, 1
9D0041AC  1440000F   BNE V0, ZERO, 0x9D0041EC
9D0041B0  240200FF   ADDIU V0, ZERO, 255
344:                                 {
345:                                     partitionNum = 0;
346:                                     partitionMap &= ~0x01;
347:                                 }
348:                                 else if (partitionMap & 0x02)
9D0041B4  32220002   ANDI V0, S1, 2
9D0041B8  304200FF   ANDI V0, V0, 255
9D0041BC  1440000A   BNE V0, ZERO, 0x9D0041E8
9D0041C0  24030001   ADDIU V1, ZERO, 1
349:                                 {
350:                                     partitionNum = 1;
351:                                     partitionMap &= ~0x02;
352:                                 }
353:                                 else if (partitionMap & 0x04)
9D0041C4  32220004   ANDI V0, S1, 4
9D0041C8  304200FF   ANDI V0, V0, 255
9D0041CC  14400006   BNE V0, ZERO, 0x9D0041E8
9D0041D0  24030002   ADDIU V1, ZERO, 2
354:                                 {
355:                                     partitionNum = 2;
356:                                     partitionMap &= ~0x04;
357:                                 }
358:                                 else if (partitionMap & 0x08)
9D0041D4  32230008   ANDI V1, S1, 8
9D0041D8  306300FF   ANDI V1, V1, 255
359:                                 {
360:                                     partitionNum = 3;
9D0041DC  24020003   ADDIU V0, ZERO, 3
9D0041E0  0003100A   MOVZ V0, ZERO, V1
9D0041E4  00401821   ADDU V1, V0, ZERO
361:                                     partitionMap &= ~0x08;
362:                                 }
363:                 
364:                                 if (fsType != 0xFF)
9D0041E8  240200FF   ADDIU V0, ZERO, 255
9D0041EC  1262001F   BEQ S3, V0, 0x9D00426C
9D0041F0  00032040   SLL A0, V1, 1
365:                                 {
366:                                     /* File system type offset */
367:                                     offset = gPartitionTypeOffset[partitionNum];
9D0041F4  3C029D01   LUI V0, -25343
9D0041F8  24426A74   ADDIU V0, V0, 27252
9D0041FC  00821021   ADDU V0, A0, V0
368:                                     volumeObj->fsType = readBuffer[offset];
9D004200  94420000   LHU V0, 0(V0)
9D004204  8FA40018   LW A0, 24(SP)
9D004208  00821021   ADDU V0, A0, V0
9D00420C  90440000   LBU A0, 0(V0)
9D004210  A2440001   SB A0, 1(S2)
369:                 
370:                                     /* Number of sectors */
371:                                     volumeObj->numSectors = ((readBuffer[offset + 11] << 24) + (readBuffer[offset + 10] << 16) + (readBuffer[offset + 9] << 8) + readBuffer[offset + 8]);
9D004214  9045000B   LBU A1, 11(V0)
9D004218  00052E00   SLL A1, A1, 24
9D00421C  9044000A   LBU A0, 10(V0)
9D004220  00042400   SLL A0, A0, 16
9D004224  00A42821   ADDU A1, A1, A0
9D004228  90440009   LBU A0, 9(V0)
9D00422C  00042200   SLL A0, A0, 8
9D004230  00A42821   ADDU A1, A1, A0
9D004234  90440008   LBU A0, 8(V0)
9D004238  00A42021   ADDU A0, A1, A0
9D00423C  AE440014   SW A0, 20(S2)
372:                 
373:                                     /* Start address of the volume */
374:                                     volumeObj->startSector = ((readBuffer[offset + 7] << 24) + (readBuffer[offset + 6] << 16) + (readBuffer[offset + 5] << 8) + readBuffer[offset + 4]);
9D004240  90450007   LBU A1, 7(V0)
9D004244  00052E00   SLL A1, A1, 24
9D004248  90440006   LBU A0, 6(V0)
9D00424C  00042400   SLL A0, A0, 16
9D004250  00A42821   ADDU A1, A1, A0
9D004254  90440005   LBU A0, 5(V0)
9D004258  00042200   SLL A0, A0, 8
9D00425C  00A42021   ADDU A0, A1, A0
9D004260  90420004   LBU V0, 4(V0)
9D004264  00821021   ADDU V0, A0, V0
9D004268  AE420010   SW V0, 16(S2)
375:                                 }
376:                             }
377:                 
378:                             if (isMBR)
9D00426C  12800005   BEQ S4, ZERO, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D004270  92020003   LBU V0, 3(S0)
379:                             {
380:                                 _SYS_FS_MEDIA_MANAGER_UpdateVolToPart (volumeIndex, mediaObj->mediaIndex, partitionNum + 1);
9D004278  24630001   ADDIU V1, V1, 1
381:                             }
382:                             else
383:                             {
384:                                 _SYS_FS_MEDIA_MANAGER_UpdateVolToPart (volumeIndex, mediaObj->mediaIndex, 0);                        
385:                             }
386:                         }
387:                         /* Update the inUse flag to indicate that the volume is now in use.*/
388:                         volumeObj->inUse = true;
9D004194  24020001   ADDIU V0, ZERO, 1
9D004198  0B4010A8   J _SYS_FS_MountVolume
9D00419C  A2420000   SB V0, 0(S2)
9D00428C  24020001   ADDIU V0, ZERO, 1
9D004290  A2420000   SB V0, 0(S2)
389:                 
390:                         /* Mount the Media if Auto mount feature is enable */
391:                         if (SYS_FS_AUTOMOUNT_ENABLE && (fsType != 0xFF))
9D004294  240200FF   ADDIU V0, ZERO, 255
9D004298  1262001B   BEQ S3, V0, 0x9D004308
9D00429C  3C028001   LUI V0, -32767
392:                         {
393:                             _SYS_FS_MountVolume (mediaObj->mediaType, (const uint8_t *)(volumeObj->volumeName));
394:                         }
395:                 
396:                         /* Continue if there is more than one partition on media */
397:                         if (!partitionMap)
398:                         {
399:                             break;
400:                         }
401:                 
402:                         /* Go to the next volume object */
403:                         volumeObj++;
404:                     }
405:                 }
406:                 
407:                 static uint8_t _SYS_FS_MEDIA_MANAGER_FindNextMedia
408:                 (
409:                     SYS_FS_MEDIA *mediaObj,
410:                     uint8_t *index
411:                 )
412:                 {
413:                     uint8_t indexLow = 0;
414:                     
415:                     indexLow = *index;
9D003CD4  24424EAC   ADDIU V0, V0, 20140
9D003CD8  90440014   LBU A0, 20(V0)
416:                     while (*index < SYS_FS_MEDIA_NUMBER)
9D003CDC  14800005   BNE A0, ZERO, 0x9D003CF4
9D003CE0  90E20000   LBU V0, 0(A3)
9D003CEC  0B400F59   J 0x9D003D64
9D003CF0  00001021   ADDU V0, ZERO, ZERO
9D003CF4  00E01821   ADDU V1, A3, ZERO
417:                     {
418:                         if (mediaObj[*index].inUse == true)
9D003CE4  104001B7   BEQ V0, ZERO, 0x9D0043C4
9D003CE8  8FBF0044   LW RA, 68(SP)
419:                         {
420:                             /* Media found. Return the index. */
421:                             indexLow = *index;
422:                             _SYS_FS_MEDIA_MANAGER_UPDATE_MEDIA_INDEX(*index);
423:                             return indexLow;
424:                         }
425:                 
426:                         (*index)++;
427:                     }
428:                 
429:                     if (indexLow == 0)
430:                     {
431:                         /* No media. Reset the media index. */
432:                         *index = 0;
433:                         return 0xFF;
434:                     }
435:                 
436:                     /* No media found in the upper range. Start searching from 0 till *index.
437:                      * */
438:                     indexLow = 0;
439:                     while (indexLow < *index)
9D003D54  5444FFEC   BNEL V0, A0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_FindNextMedia
9D003D58  2463002C   ADDIU V1, V1, 44
440:                     {
441:                         if (mediaObj[indexLow].inUse == true)
9D003CF8  10400014   BEQ V0, ZERO, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_FindNextMedia
9D003CFC  00002821   ADDU A1, ZERO, ZERO
9D003D00  0B400F4B   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_FindNextMedia
9D003D04  00001021   ADDU V0, ZERO, ZERO
9D003D08  90660000   LBU A2, 0(V1)
9D003D0C  54C00003   BNEL A2, ZERO, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_FindNextMedia
9D003D10  24A30002   ADDIU V1, A1, 2
442:                         {
443:                             /* Media found. Return the media index. */
444:                             *index = indexLow;
445:                             _SYS_FS_MEDIA_MANAGER_UPDATE_MEDIA_INDEX(*index);
9D003D1C  306300FF   ANDI V1, V1, 255
9D003D20  38640001   XORI A0, V1, 1
9D003D24  0B400F4C   J 0x9D003D30
9D003D28  0004180A   MOVZ V1, ZERO, A0
9D003D2C  00001821   ADDU V1, ZERO, ZERO
9D003D30  3C048001   LUI A0, -32767
9D003D34  A0834EC0   SB V1, 20160(A0)
446:                             return indexLow;
447:                         }
448:                 
449:                         indexLow++;
9D003D14  0B400F53   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_FindNextMedia
9D003D18  00402821   ADDU A1, V0, ZERO
9D003D4C  24A20001   ADDIU V0, A1, 1
9D003D50  304200FF   ANDI V0, V0, 255
450:                     }
451:                 
452:                     /* No media. */
453:                     return 0xFF;
454:                 }
455:                 
456:                 static bool SYS_FS_MEDIA_MANAGER_IsFSFat
457:                 (
458:                     uint8_t fsType
459:                 )
460:                 {
461:                     switch (fsType)
9D000190  2C820010   SLTIU V0, A0, 16
9D000194  10400018   BEQ V0, ZERO, 0x9D0001F8
9D000198  00042080   SLL A0, A0, 2
9D00019C  3C029D00   LUI V0, -25344
9D0001A0  244201B0   ADDIU V0, V0, 432
9D0001A4  7C44200A   LWX A0, A0(V0)
9D0001A8  00800008   JR A0
9D0001AC  00000000   NOP
462:                     {
463:                         case 0x01: // FAT12
464:                         case 0x04: // FAT16
465:                         case 0x05: // Extended partition
466:                         case 0x06: // FAT16
467:                         case 0x0B: // FAT32
468:                         case 0x0C: // FAT32
469:                         case 0x0E: // FAT16
470:                         case 0x0F: // FAT16
471:                             {
472:                                 return true;
9D0001F0  03E00008   JR RA
9D0001F4  24020001   ADDIU V0, ZERO, 1
473:                             }
474:                         default:
475:                             {
476:                                 return false;
477:                             }
478:                     }
479:                 }
9D0001F8  03E00008   JR RA
480:                 
481:                 static uint8_t _SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
482:                 (
483:                     uint8_t *firstSector,
484:                     uint8_t *numPartition,
485:                     uint8_t *isMBR,
486:                     uint8_t *partitionMap
487:                 )
488:                 {
489:                     uint8_t fsType = 0xFF;
490:                 
491:                     *partitionMap = 0;
9D0040DC  00008821   ADDU S1, ZERO, ZERO
9D004354  00008821   ADDU S1, ZERO, ZERO
9D004364  00008821   ADDU S1, ZERO, ZERO
9D004374  00008821   ADDU S1, ZERO, ZERO
9D004384  00008821   ADDU S1, ZERO, ZERO
9D004394  00008821   ADDU S1, ZERO, ZERO
9D0043A0  00008821   ADDU S1, ZERO, ZERO
492:                     *numPartition = 0;
9D003F78  A2000001   SB ZERO, 1(S0)
493:                 
494:                     /* Check for the Boot Signature */
495:                     if((firstSector[510] == 0x55) && (firstSector[511] == 0xAA))
9D003F7C  924301FE   LBU V1, 510(S2)
9D003F80  24020055   ADDIU V0, ZERO, 85
9D003F84  1462004D   BNE V1, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D003F88  02402021   ADDU A0, S2, ZERO
9D003F8C  924301FF   LBU V1, 511(S2)
9D003F90  240200AA   ADDIU V0, ZERO, 170
9D003F94  1462004A   BNE V1, V0, 0x9D0040C0
9D003F98  3C059D01   LUI A1, -25343
496:                     {
497:                         /* Check if the first sector of the media is Volume Boot Record or the
498:                            Master Boot Record */
499:                         if((0xEB == firstSector[0]) &&
9D003F9C  92430000   LBU V1, 0(S2)
9D003FA0  240200EB   ADDIU V0, ZERO, 235
9D003FA4  14620022   BNE V1, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D003FA8  2403003C   ADDIU V1, ZERO, 60
9D003FB0  10430005   BEQ V0, V1, 0x9D003FC8
9D003FB4  24030058   ADDIU V1, ZERO, 88
500:                                 ((0x3C == firstSector[1]) || (0x58 == firstSector[1]) || (0xFE == firstSector[1])) &&
9D003FAC  92420001   LBU V0, 1(S2)
9D003FB8  10430003   BEQ V0, V1, 0x9D003FC8
9D003FBC  240300FE   ADDIU V1, ZERO, 254
9D003FC0  1443001B   BNE V0, V1, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D003FC4  00000000   NOP
9D003FC8  92430002   LBU V1, 2(S2)
9D003FCC  24020090   ADDIU V0, ZERO, 144
9D003FD0  14620017   BNE V1, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D003FD4  24020001   ADDIU V0, ZERO, 1
501:                                 (0x90 == firstSector[2]))
502:                         {
503:                             /* Volume Boot Record */
504:                             *numPartition = 1;
9D003FD8  A2020001   SB V0, 1(S0)
505:                             *isMBR = 0;
9D004350  0000A021   ADDU S4, ZERO, ZERO
9D004360  0000A021   ADDU S4, ZERO, ZERO
9D004370  0000A021   ADDU S4, ZERO, ZERO
9D004380  0000A021   ADDU S4, ZERO, ZERO
9D004390  0000A021   ADDU S4, ZERO, ZERO
506:                 
507:                             /* The extended BPB contains FAT32 in this field */
508:                             if ((0x46 == firstSector[82]) || (0x41 == firstSector[83]) ||
9D003FDC  92430052   LBU V1, 82(S2)
9D003FE0  24020046   ADDIU V0, ZERO, 70
9D003FE4  106200DA   BEQ V1, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D003FE8  24020041   ADDIU V0, ZERO, 65
9D003FEC  92430053   LBU V1, 83(S2)
9D003FF0  106200DB   BEQ V1, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D003FF4  24020054   ADDIU V0, ZERO, 84
9D003FF8  92430054   LBU V1, 84(S2)
9D003FFC  106200DC   BEQ V1, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D004000  24020046   ADDIU V0, ZERO, 70
509:                                     (0x54 == firstSector[84]))
510:                             {
511:                                 fsType = 0x0B;
9D004358  0B401039   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D00435C  2413000B   ADDIU S3, ZERO, 11
9D004368  0B401039   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D00436C  2413000B   ADDIU S3, ZERO, 11
9D004378  0B401039   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D00437C  2413000B   ADDIU S3, ZERO, 11
512:                             }
513:                             /* The extended BPB contains FAT, FAT12 or FAT16 in these fields */
514:                             else if ((0x46 == firstSector[54]) || (0x41 == firstSector[55]) ||
9D004004  92430036   LBU V1, 54(S2)
9D004008  106200DD   BEQ V1, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D00400C  24020041   ADDIU V0, ZERO, 65
9D004010  92430037   LBU V1, 55(S2)
9D004014  106200DE   BEQ V1, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D004018  24020054   ADDIU V0, ZERO, 84
9D00401C  92430038   LBU V1, 56(S2)
9D004020  106200DF   BEQ V1, V0, SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem
9D004024  0000A021   ADDU S4, ZERO, ZERO
515:                                     (0x54 == firstSector[56]))
516:                             {
517:                                 fsType = 0x06;
9D004388  0B401039   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D00438C  24130006   ADDIU S3, ZERO, 6
9D004398  0B401039   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D00439C  24130006   ADDIU S3, ZERO, 6
9D0043A4  0B401039   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D0043A8  24130006   ADDIU S3, ZERO, 6
518:                             }
519:                         }
520:                         else
521:                         {     
522:                             /* The partition table in the MBR sector has room for four 16-byte
523:                              * entries that each specify the sectors that belong to a
524:                              * partition. The table is in bytes 446 through 509. An entry can
525:                              * begin at byte 446, 462, 478, or 494. */
526:                 
527:                             /* Determine total partitions in the media */
528:                             *isMBR = 1;
529:                             if(SYS_FS_MEDIA_MANAGER_IsFSFat(firstSector[450]))
9D004030  0F400064   JAL SYS_FS_MEDIA_MANAGER_IsFSFat
9D004034  924401C2   LBU A0, 450(S2)
9D004038  10400004   BEQ V0, ZERO, 0x9D00404C
9D00403C  00008821   ADDU S1, ZERO, ZERO
530:                             {
531:                                 *partitionMap |= (1 << 0);
9D004048  24110001   ADDIU S1, ZERO, 1
532:                                 (*numPartition)++;
9D004040  24020001   ADDIU V0, ZERO, 1
9D004044  A2020001   SB V0, 1(S0)
533:                             }
534:                             if(SYS_FS_MEDIA_MANAGER_IsFSFat(firstSector[466]))
9D00404C  0F400064   JAL SYS_FS_MEDIA_MANAGER_IsFSFat
9D004050  924401D2   LBU A0, 466(S2)
9D004054  10400005   BEQ V0, ZERO, 0x9D00406C
9D004058  00000000   NOP
535:                             {
536:                                 *partitionMap |= (1 << 1);
9D00405C  36310002   ORI S1, S1, 2
537:                                 (*numPartition)++;
9D004060  92020001   LBU V0, 1(S0)
9D004064  24420001   ADDIU V0, V0, 1
9D004068  A2020001   SB V0, 1(S0)
538:                             }
539:                             if(SYS_FS_MEDIA_MANAGER_IsFSFat(firstSector[482]))
9D00406C  0F400064   JAL SYS_FS_MEDIA_MANAGER_IsFSFat
9D004070  924401E2   LBU A0, 482(S2)
9D004074  10400005   BEQ V0, ZERO, 0x9D00408C
9D004078  00000000   NOP
540:                             {
541:                                 *partitionMap |= (1 << 2);
9D00407C  36310004   ORI S1, S1, 4
542:                                 (*numPartition)++;
9D004080  92020001   LBU V0, 1(S0)
9D004084  24420001   ADDIU V0, V0, 1
9D004088  A2020001   SB V0, 1(S0)
543:                             }
544:                             if(SYS_FS_MEDIA_MANAGER_IsFSFat(firstSector[498]))
9D00408C  0F400064   JAL SYS_FS_MEDIA_MANAGER_IsFSFat
9D004090  924401F2   LBU A0, 498(S2)
9D004094  10400005   BEQ V0, ZERO, 0x9D0040AC
9D004098  00000000   NOP
545:                             {
546:                                 *partitionMap |= (1 << 3);
9D00409C  36310008   ORI S1, S1, 8
547:                                 (*numPartition)++;
9D0040A0  92020001   LBU V0, 1(S0)
9D0040A4  24420001   ADDIU V0, V0, 1
9D0040A8  A2020001   SB V0, 1(S0)
548:                             }
549:                 
550:                             /* Found at least one valid partition. Assign a non 0xFF value to
551:                              * indicate that atleast one of the partitions has a valid file
552:                              * system. */
553:                             if (*partitionMap)
9D0040AC  162000BF   BNE S1, ZERO, 0x9D0043AC
9D0040B0  24140001   ADDIU S4, ZERO, 1
554:                             {
555:                                 fsType = 1;
9D0043AC  0B401039   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D0043B0  24130001   ADDIU S3, ZERO, 1
556:                             }
557:                         }
558:                     }
559:                     else if (0 == memcmp(firstSector, "MPFS", 4))
9D0040BC  3C059D01   LUI A1, -25343
9D0040C0  24A56A6C   ADDIU A1, A1, 27244
9D0040C4  0F4052EF   JAL memcmp
9D0040C8  24060004   ADDIU A2, ZERO, 4
9D0040CC  144000B9   BNE V0, ZERO, 0x9D0043B4
9D0040D0  0000A021   ADDU S4, ZERO, ZERO
560:                     {
561:                         /* No partitions in MPFS, hence, go to other state */
562:                         /* allocate a new volume to each partition */
563:                         (*numPartition) = 1;
9D0040D4  24020001   ADDIU V0, ZERO, 1
9D0040D8  A2020001   SB V0, 1(S0)
564:                         /* This is 0x4D which also mean file system Primary QNX POSIX volume on disk */
565:                         /* Need to find an unused value from the partition type*/
566:                         fsType = 'M';
9D0040E0  2413004D   ADDIU S3, ZERO, 77
567:                     }
568:                     else /* If MBR is not detected, make media as unsupported */
569:                     {
570:                         /* File system either not present or not supported */
571:                         fsType = 0xFF;
572:                     }
573:                 
574:                     return fsType;
575:                 }
576:                 
577:                 SYS_FS_MEDIA_HANDLE SYS_FS_MEDIA_MANAGER_Register
578:                 (
579:                     SYS_MODULE_OBJ obj,
580:                     SYS_MODULE_INDEX index,
581:                     const SYS_FS_MEDIA_FUNCTIONS *mediaFunctions,
582:                     SYS_FS_MEDIA_TYPE mediaType
583:                 )
584:                 {
585:                     uint8_t mediaIndex = 0;
586:                     uint8_t mediaId = 'a';
587:                 
588:                     SYS_FS_MEDIA *mediaObj = NULL;
589:                 
590:                     mediaObj = &gSYSFSMediaManagerObj.mediaObj[0];
9D015EB0  3C028001   LUI V0, -32767
9D015EB4  8C424EAC   LW V0, 20140(V0)
591:                     for (mediaIndex = 0; mediaIndex < SYS_FS_MEDIA_NUMBER; mediaIndex++)
592:                     {
593:                          if ((mediaObj->inUse) && (mediaType == mediaObj->mediaType))
9D015EB8  90430000   LBU V1, 0(V0)
9D015EBC  10600003   BEQ V1, ZERO, 0x9D015ECC
9D015EC0  30A5FFFF   ANDI A1, A1, -1
594:                          {
595:                              /* For every type of media, increment the mediaID as a, b, c... */
596:                              mediaId++;
597:                          }
598:                          mediaObj++;
599:                     }
600:                 
601:                     mediaObj = &gSYSFSMediaManagerObj.mediaObj[0];
602:                     /* Start with 0th disk and find a disk which is free */
603:                     for (mediaIndex = 0; mediaIndex < SYS_FS_MEDIA_NUMBER; mediaIndex++)
604:                     {
605:                         if (mediaObj->inUse == false)
606:                         {
607:                             mediaObj->inUse = true;
9D015ECC  24030001   ADDIU V1, ZERO, 1
9D015ED0  A0430000   SB V1, 0(V0)
608:                 
609:                             mediaObj->driverFunctions = mediaFunctions;
9D015ED4  AC460008   SW A2, 8(V0)
610:                             mediaObj->driverObj = obj;
9D015ED8  AC440010   SW A0, 16(V0)
611:                             mediaObj->driverIndex = index;
9D015EDC  A4450006   SH A1, 6(V0)
612:                             mediaObj->driverHandle = DRV_HANDLE_INVALID;
9D015EE0  2403FFFF   ADDIU V1, ZERO, -1
9D015EE4  AC430014   SW V1, 20(V0)
613:                 
614:                             mediaObj->mediaState = SYS_FS_MEDIA_STATE_REGISTERED;
9D015EE8  24030001   ADDIU V1, ZERO, 1
9D015EEC  AC43000C   SW V1, 12(V0)
615:                             mediaObj->mediaType = mediaType;
9D015EF0  AC470018   SW A3, 24(V0)
616:                 
617:                             mediaObj->numPartitions = 0;
9D015EF4  A0400001   SB ZERO, 1(V0)
618:                             mediaObj->numVolumes = 0;
9D015EF8  A0400004   SB ZERO, 4(V0)
619:                 
620:                             mediaObj->mediaIndex = mediaIndex;
9D015EFC  A0400003   SB ZERO, 3(V0)
621:                             mediaObj->mediaId = mediaId;
9D015F00  24030061   ADDIU V1, ZERO, 97
9D015F04  A0430002   SB V1, 2(V0)
622:                             mediaObj->attachStatus = SYS_FS_MEDIA_DETACHED;
623:                 
624:                             return (SYS_FS_MEDIA_HANDLE)mediaObj;
625:                         }
626:                 
627:                         mediaObj++;
628:                     }
629:                 
630:                     return SYS_FS_MEDIA_HANDLE_INVALID;
9D015EC4  03E00008   JR RA
9D015EC8  2402FFFF   ADDIU V0, ZERO, -1
631:                 }
9D015F08  03E00008   JR RA
632:                 
633:                 void SYS_FS_MEDIA_MANAGER_DeRegister
634:                 (
635:                     SYS_FS_MEDIA_HANDLE handle
636:                 )
637:                 {
638:                     SYS_FS_MEDIA *mediaObj = (SYS_FS_MEDIA *)handle;
639:                 
640:                     if (handle == SYS_FS_MEDIA_HANDLE_INVALID)
9D0171D8  2402FFFF   ADDIU V0, ZERO, -1
9D0171DC  10820002   BEQ A0, V0, 0x9D0171E8
9D0171E0  24020001   ADDIU V0, ZERO, 1
641:                     {
642:                         return;
643:                     }
644:                 
645:                     mediaObj->isMediaDisconnected = true;
9D0171E4  A0820005   SB V0, 5(A0)
646:                 }
647:                 
648:                 SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE SYS_FS_MEDIA_MANAGER_SectorRead
649:                 (
650:                     uint16_t diskNum,
651:                     uint8_t *dataBuffer,
652:                     uint32_t sector,
653:                     uint32_t numSectors
654:                 )
655:                 {
9D014814  3084FFFF   ANDI A0, A0, -1
9D014820  27BDFFE0   ADDIU SP, SP, -32
9D014824  AFBF001C   SW RA, 28(SP)
9D014828  AFB00018   SW S0, 24(SP)
9D01482C  00A04021   ADDU T0, A1, ZERO
656:                     SYS_FS_MEDIA *mediaObj = NULL;
657:                     uint32_t blocksPerSector = 0;
658:                     uint32_t mediaReadBlockSize = 0;
659:                 
660:                     if (diskNum >= SYS_FS_MEDIA_NUMBER)
9D014818  14800024   BNE A0, ZERO, 0x9D0148AC
9D01481C  2402FFFF   ADDIU V0, ZERO, -1
661:                     {
662:                         SYS_ASSERT(false, "Invalid Disk");
663:                         return SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
664:                     }
665:                 
666:                     mediaObj = &gSYSFSMediaManagerObj.mediaObj[diskNum];
9D014830  3C028001   LUI V0, -32767
9D014834  8C504EAC   LW S0, 20140(V0)
667:                 
668:                     if (mediaObj->driverHandle == DRV_HANDLE_INVALID)
9D014838  8E040014   LW A0, 20(S0)
9D01483C  2405FFFF   ADDIU A1, ZERO, -1
9D014840  10850017   BEQ A0, A1, 0x9D0148A0
9D014844  2402FFFF   ADDIU V0, ZERO, -1
669:                     {
670:                         return SYS_FS_MEDIA_HANDLE_INVALID;
671:                     }
672:                 
673:                     mediaReadBlockSize = mediaObj->mediaGeometry->geometryTable[0].blockSize;
9D014848  8E020028   LW V0, 40(S0)
9D01484C  8C420010   LW V0, 16(V0)
9D014850  8C420000   LW V0, 0(V0)
674:                 
675:                     if (mediaReadBlockSize < 512)
9D014854  2C450200   SLTIU A1, V0, 512
9D014858  10A00007   BEQ A1, ZERO, 0x9D014878
9D01485C  00C01821   ADDU V1, A2, ZERO
676:                     {
677:                         /* Find the number of blocks per sector */
678:                         blocksPerSector = 512 / mediaReadBlockSize;
9D014860  24050200   ADDIU A1, ZERO, 512
9D014864  00A2001B   DIVU A1, V0
9D014868  004001F4   TEQ V0, ZERO
9D01486C  00001012   MFLO V0
679:                         /* Perform sector to block translation */
680:                         sector *= blocksPerSector; 
9D014870  70C21802   MUL V1, A2, V0
681:                         numSectors *= blocksPerSector; 
9D014874  70E23802   MUL A3, A3, V0
682:                     }
683:                     else
684:                     {
685:                         /* TODO: Handle cases where the block size is greater than 512 bytes.
686:                          * */
687:                     }
688:                 
689:                     mediaObj->commandStatus = SYS_FS_MEDIA_COMMAND_IN_PROGRESS;
9D014878  24020002   ADDIU V0, ZERO, 2
9D01487C  AE020024   SW V0, 36(S0)
690:                     mediaObj->driverFunctions->sectorRead (mediaObj->driverHandle, &(mediaObj->commandHandle), dataBuffer, sector, numSectors);
9D014880  8E020008   LW V0, 8(S0)
9D014884  AFA70010   SW A3, 16(SP)
9D014888  8C420008   LW V0, 8(V0)
9D01488C  2605001C   ADDIU A1, S0, 28
9D014890  01003021   ADDU A2, T0, ZERO
9D014894  0040F809   JALR V0
9D014898  00603821   ADDU A3, V1, ZERO
691:                 
692:                     return (mediaObj->commandHandle);
9D01489C  8E02001C   LW V0, 28(S0)
693:                 }
9D0148A0  8FBF001C   LW RA, 28(SP)
694:                 
695:                 SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE SYS_FS_MEDIA_MANAGER_Read
696:                 (
697:                     uint16_t diskNum,
698:                     uint8_t *destination,
699:                     uint8_t *source,
700:                     const uint32_t nBytes
701:                 )
702:                 {
00000000  00000000   NOP
0000000C  00000000   NOP
703:                     SYS_FS_MEDIA *mediaObj = NULL;
704:                     uint32_t startAddress = 0;
705:                     uint32_t address = 0;
706:                 
707:                     if (diskNum >= SYS_FS_MEDIA_NUMBER)
00000004  00000000   NOP
708:                     {
709:                         SYS_ASSERT(false, "Invalid Disk");
710:                         return SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
711:                     }
712:                 
713:                     mediaObj = &gSYSFSMediaManagerObj.mediaObj[diskNum];
00000024  00000000   NOP
714:                 
715:                     if (mediaObj->driverHandle == DRV_HANDLE_INVALID)
0000002C  00000000   NOP
716:                     {
717:                         return SYS_FS_MEDIA_HANDLE_INVALID;
718:                     }
719:                 
720:                     startAddress = mediaObj->driverFunctions->addressGet(mediaObj->driverHandle);
00000044  00000000   NOP
721:                     address = (uint32_t)source - (uint32_t)startAddress;
722:                 
723:                     mediaObj->commandStatus = SYS_FS_MEDIA_COMMAND_IN_PROGRESS;
00000054  00000000   NOP
724:                     mediaObj->driverFunctions->Read(mediaObj->driverHandle, &(mediaObj->commandHandle), destination, address, nBytes);
0000005C  00000000   NOP
725:                 
726:                     return (mediaObj->commandHandle);
0000007C  00000000   NOP
727:                 }
00000080  00000000   NOP
728:                 
729:                 SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE SYS_FS_MEDIA_MANAGER_SectorWrite
730:                 (
731:                     uint16_t diskNum,
732:                     uint32_t sector,
733:                     uint8_t *dataBuffer,
734:                     uint32_t numSectors
735:                 )
736:                 {
9D00A74C  3084FFFF   ANDI A0, A0, -1
9D00A758  27BDFFB0   ADDIU SP, SP, -80
9D00A75C  AFBF004C   SW RA, 76(SP)
9D00A760  AFBE0048   SW S8, 72(SP)
9D00A764  AFB70044   SW S7, 68(SP)
9D00A768  AFB60040   SW S6, 64(SP)
9D00A76C  AFB5003C   SW S5, 60(SP)
9D00A770  AFB40038   SW S4, 56(SP)
9D00A774  AFB30034   SW S3, 52(SP)
9D00A778  AFB20030   SW S2, 48(SP)
9D00A77C  AFB1002C   SW S1, 44(SP)
9D00A780  AFB00028   SW S0, 40(SP)
737:                     SYS_FS_MEDIA *mediaObj = NULL;
738:                     uint8_t *data = dataBuffer;
9D00A994  02C0F021   ADDU S8, S6, ZERO
739:                     uint32_t sectorOffsetInBlock = 0;
740:                     uint32_t memoryBlock = 0;
9D00A998  AFA00020   SW ZERO, 32(SP)
741:                     uint32_t sectorsPerBlock = 0;
742:                     uint32_t numSectorsToWrite = 0;
743:                     uint32_t mediaWriteBlockSize = 0;
744:                     uint32_t blocksPerSector = 0;
745:                 
746:                     if(diskNum >= SYS_FS_VOLUME_NUMBER)
9D00A750  148000AB   BNE A0, ZERO, 0x9D00AA00
9D00A754  2402FFFF   ADDIU V0, ZERO, -1
747:                     {
748:                         SYS_ASSERT(false, "Invalid Disk");
749:                         return SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
750:                     }
751:                 
752:                     mediaObj = &gSYSFSMediaManagerObj.mediaObj[diskNum];
9D00A784  3C028001   LUI V0, -32767
9D00A788  8C504EAC   LW S0, 20140(V0)
753:                 
754:                     if (mediaObj->driverHandle == DRV_HANDLE_INVALID)
9D00A78C  8E040014   LW A0, 20(S0)
9D00A790  2403FFFF   ADDIU V1, ZERO, -1
9D00A794  1083008F   BEQ A0, V1, 0x9D00A9D4
9D00A798  2402FFFF   ADDIU V0, ZERO, -1
9D00A79C  00A09821   ADDU S3, A1, ZERO
9D00A7A0  00C0B021   ADDU S6, A2, ZERO
755:                     {
756:                         return SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
757:                     }
758:                 
759:                     mediaWriteBlockSize = mediaObj->mediaGeometry->geometryTable[1].blockSize;
9D00A7A4  8E020028   LW V0, 40(S0)
9D00A7A8  8C420010   LW V0, 16(V0)
9D00A7AC  8C420008   LW V0, 8(V0)
9D00A7B0  AFA20024   SW V0, 36(SP)
760:                 
761:                     if (mediaWriteBlockSize > 512)
9D00A7B4  2C420201   SLTIU V0, V0, 513
9D00A7B8  14400008   BNE V0, ZERO, 0x9D00A7DC
9D00A7BC  00E08821   ADDU S1, A3, ZERO
762:                     {
763:                         sectorsPerBlock = mediaWriteBlockSize / 512;
9D00A7C0  8FA20024   LW V0, 36(SP)
9D00A7C4  0002AA42   SRL S5, V0, 9
764:                     }
765:                     else if (mediaWriteBlockSize == 512)
9D00A7DC  24020200   ADDIU V0, ZERO, 512
9D00A7E0  8FA30024   LW V1, 36(SP)
9D00A7E4  50620009   BEQL V1, V0, 0x9D00A80C
9D00A7E8  24020002   ADDIU V0, ZERO, 2
766:                     {
767:                         sectorsPerBlock = 1;
768:                         blocksPerSector = 1;
769:                     }
770:                     else
771:                     {
772:                         blocksPerSector = 512 / mediaWriteBlockSize;
9D00A7EC  0043001B   DIVU V0, V1
9D00A7F0  006001F4   TEQ V1, ZERO
9D00A7F4  00001012   MFLO V0
773:                         sector *= blocksPerSector;
9D00A7F8  70A29802   MUL S3, A1, V0
774:                         numSectors *= blocksPerSector;
9D00A7FC  70E28802   MUL S1, A3, V0
775:                     }
776:                 
777:                     if ((sectorsPerBlock == 1) || (blocksPerSector > 0))
9D00A7C8  24020001   ADDIU V0, ZERO, 1
9D00A7CC  16A2001A   BNE S5, V0, 0x9D00A838
9D00A7D0  24030001   ADDIU V1, ZERO, 1
9D00A800  1040000C   BEQ V0, ZERO, 0x9D00A834
9D00A804  0000A821   ADDU S5, ZERO, ZERO
778:                     {
779:                         mediaObj->commandStatus = SYS_FS_MEDIA_COMMAND_IN_PROGRESS;
9D00A7D4  0B402A03   J 0x9D00A80C
9D00A7D8  24020002   ADDIU V0, ZERO, 2
9D00A808  24020002   ADDIU V0, ZERO, 2
9D00A80C  AE020024   SW V0, 36(S0)
780:                         mediaObj->driverFunctions->sectorWrite (mediaObj->driverHandle, &(mediaObj->commandHandle), dataBuffer, sector, numSectors);
9D00A810  8E020008   LW V0, 8(S0)
9D00A814  AFB10010   SW S1, 16(SP)
9D00A818  8C42000C   LW V0, 12(V0)
9D00A81C  2605001C   ADDIU A1, S0, 28
9D00A820  02C03021   ADDU A2, S6, ZERO
9D00A824  0040F809   JALR V0
9D00A828  02603821   ADDU A3, S3, ZERO
781:                         return (mediaObj->commandHandle);
9D00A82C  0B402A75   J 0x9D00A9D4
9D00A830  8E02001C   LW V0, 28(S0)
782:                     }
783:                     else
784:                     {
785:                         /* Mute the event notification */
786:                         gSYSFSMediaManagerObj.muteEventNotification = true;
9D00A834  24030001   ADDIU V1, ZERO, 1
9D00A838  3C028001   LUI V0, -32767
787:                 
788:                         while (numSectors > 0)
9D00A83C  12200055   BEQ S1, ZERO, 0x9D00A994
9D00A840  A0434EC2   SB V1, 20162(V0)
9D00A984  1620FFB5   BNE S1, ZERO, 0x9D00A85C
9D00A988  02D2B021   ADDU S6, S6, S2
9D00A98C  0B402A68   J 0x9D00A9A0
9D00A990  3C028001   LUI V0, -32767
789:                         {
790:                             /* Find the memory block for the starting sector */
791:                             memoryBlock = sector / sectorsPerBlock;
9D00A85C  0275001B   DIVU S3, S5
9D00A860  02A001F4   TEQ S5, ZERO
9D00A864  0000F010   MFHI S8
9D00A868  0000B812   MFLO S7
9D00A86C  AFB70020   SW S7, 32(SP)
792:                 
793:                             /* Find the number of sectors to be updated in this block. */
794:                             sectorOffsetInBlock = (sector % sectorsPerBlock);
795:                             numSectorsToWrite = (sectorsPerBlock - sectorOffsetInBlock);
9D00A870  02BE1023   SUBU V0, S5, S8
9D00A874  0222902B   SLTU S2, S1, V0
9D00A878  0232100B   MOVN V0, S1, S2
796:                 
797:                             if (numSectors < numSectorsToWrite)
798:                             {
799:                                 numSectorsToWrite = numSectors;
800:                             }
801:                 
802:                             if (numSectorsToWrite != sectorsPerBlock)
9D00A87C  12A20023   BEQ S5, V0, 0x9D00A90C
9D00A880  00409021   ADDU S2, V0, ZERO
803:                             {
804:                                 /* Read the memory block from the media. Update the media data. */
805:                                 mediaObj->commandStatus = SYS_FS_MEDIA_COMMAND_IN_PROGRESS;
9D00A844  24140002   ADDIU S4, ZERO, 2
9D00A884  AE140024   SW S4, 36(S0)
806:                 
807:                                 mediaObj->driverFunctions->sectorRead(mediaObj->driverHandle, &(mediaObj->commandHandle), gSYSFSMediaBlockBuffer, memoryBlock * mediaWriteBlockSize, SYS_FS_MEDIA_MANAGER_BUFFER_SIZE);
9D00A848  2602001C   ADDIU V0, S0, 28
9D00A84C  AFA2001C   SW V0, 28(SP)
9D00A850  3C02A001   LUI V0, -24575
9D00A854  24422ED0   ADDIU V0, V0, 11984
9D00A858  AFA20018   SW V0, 24(SP)
9D00A888  8E020008   LW V0, 8(S0)
9D00A88C  8E040014   LW A0, 20(S0)
9D00A890  24030800   ADDIU V1, ZERO, 2048
9D00A894  AFA30010   SW V1, 16(SP)
9D00A898  8C420008   LW V0, 8(V0)
9D00A89C  8FA5001C   LW A1, 28(SP)
9D00A8A0  8FA60018   LW A2, 24(SP)
9D00A8A4  8FA30024   LW V1, 36(SP)
9D00A8A8  0040F809   JALR V0
9D00A8AC  72E33802   MUL A3, S7, V1
808:                 
809:                                 while (mediaObj->commandStatus == SYS_FS_MEDIA_COMMAND_IN_PROGRESS)
9D00A8B0  0B402A34   J 0x9D00A8D0
9D00A8B4  8E020024   LW V0, 36(S0)
9D00A8CC  8E020024   LW V0, 36(S0)
9D00A8D0  5054FFF9   BEQL V0, S4, 0x9D00A8B8
9D00A8D4  8E020008   LW V0, 8(S0)
810:                                 {
811:                                     if(mediaObj->driverFunctions->tasks != NULL)
9D00A8B8  8C42002C   LW V0, 44(V0)
9D00A8BC  5040FFFE   BEQL V0, ZERO, 0x9D00A8B8
9D00A8C0  8E020008   LW V0, 8(S0)
812:                                     {
813:                                         mediaObj->driverFunctions->tasks(mediaObj->driverObj);
9D00A8C4  0040F809   JALR V0
9D00A8C8  8E040010   LW A0, 16(S0)
814:                                     }
815:                                 }
816:                 
817:                                 if (mediaObj->commandStatus != SYS_FS_MEDIA_COMMAND_COMPLETED)
9D00A8D8  50400005   BEQL V0, ZERO, 0x9D00A8F0
9D00A8DC  001E2240   SLL A0, S8, 9
818:                                 {
819:                                     /* Unmute the event notification */
820:                                     gSYSFSMediaManagerObj.muteEventNotification = false;
9D00A8E0  3C028001   LUI V0, -32767
9D00A8E4  A0404EC2   SB ZERO, 20162(V0)
821:                 
822:                                     /* Media read operation failed. */
823:                                     return SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
9D00A8E8  0B402A75   J 0x9D00A9D4
9D00A8EC  2402FFFF   ADDIU V0, ZERO, -1
824:                                 }
825:                 
826:                                 /* Multiply by the sector size */
827:                                 sectorOffsetInBlock <<= 9;
828:                                 memcpy ((void *)&gSYSFSMediaBlockBuffer[sectorOffsetInBlock], (const void *)dataBuffer, numSectorsToWrite << 9);
9D00A8F0  8FA50018   LW A1, 24(SP)
9D00A8F4  00A42021   ADDU A0, A1, A0
9D00A8F8  02C02821   ADDU A1, S6, ZERO
9D00A8FC  0F404091   JAL memcpy
9D00A900  00123240   SLL A2, S2, 9
9D00A904  0B402A44   J 0x9D00A910
9D00A908  8FBE0018   LW S8, 24(SP)
9D00A90C  02C0F021   ADDU S8, S6, ZERO
829:                 
830:                                 data = gSYSFSMediaBlockBuffer;
831:                             }
832:                             else
833:                             {
834:                                 /* Since the whole block is being updated, there is no need to
835:                                  * perform a read-modify-write operation of the block. */
836:                                 data = dataBuffer;
837:                             }
838:                 
839:                             if ((numSectors - numSectorsToWrite) == 0)
9D00A910  12320022   BEQ S1, S2, 0x9D00A99C
9D00A914  24030001   ADDIU V1, ZERO, 1
840:                             {
841:                                 /* This is the last write operation. */
842:                                 break;
843:                             }
844:                 
845:                             /* Write the block to the media */
846:                             mediaObj->commandStatus = SYS_FS_MEDIA_COMMAND_IN_PROGRESS;
9D00A918  AE140024   SW S4, 36(S0)
847:                             mediaObj->driverFunctions->sectorWrite (mediaObj->driverHandle, &(mediaObj->commandHandle), data, memoryBlock, 1);
9D00A91C  8E020008   LW V0, 8(S0)
9D00A920  8E040014   LW A0, 20(S0)
9D00A924  AFA30010   SW V1, 16(SP)
9D00A928  8C42000C   LW V0, 12(V0)
9D00A92C  8FA5001C   LW A1, 28(SP)
9D00A930  03C03021   ADDU A2, S8, ZERO
9D00A934  0040F809   JALR V0
9D00A938  02E03821   ADDU A3, S7, ZERO
848:                             while (mediaObj->commandStatus == SYS_FS_MEDIA_COMMAND_IN_PROGRESS)
9D00A93C  0B402A57   J 0x9D00A95C
9D00A940  8E020024   LW V0, 36(S0)
9D00A958  8E020024   LW V0, 36(S0)
9D00A95C  5054FFF9   BEQL V0, S4, 0x9D00A944
9D00A960  8E020008   LW V0, 8(S0)
849:                             {
850:                                 if(mediaObj->driverFunctions->tasks != NULL)
9D00A944  8C42002C   LW V0, 44(V0)
9D00A948  5040FFFE   BEQL V0, ZERO, 0x9D00A944
9D00A94C  8E020008   LW V0, 8(S0)
851:                                 {
852:                                     mediaObj->driverFunctions->tasks(mediaObj->driverObj);
9D00A950  0040F809   JALR V0
9D00A954  8E040010   LW A0, 16(S0)
853:                                 }
854:                             }
855:                 
856:                             if (mediaObj->commandStatus != SYS_FS_MEDIA_COMMAND_COMPLETED)
9D00A964  10400005   BEQ V0, ZERO, 0x9D00A97C
9D00A968  02328823   SUBU S1, S1, S2
857:                             {
858:                                 /* Unmute the event notification */
859:                                 gSYSFSMediaManagerObj.muteEventNotification = false;
9D00A96C  3C028001   LUI V0, -32767
9D00A970  A0404EC2   SB ZERO, 20162(V0)
860:                 
861:                                 /* Media write operation failed. */
862:                                 return SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
9D00A974  0B402A75   J 0x9D00A9D4
9D00A978  2402FFFF   ADDIU V0, ZERO, -1
863:                             }
864:                 
865:                             /* Update the number of block still to be written, sector address
866:                              * and the buffer pointer */
867:                             numSectors -= numSectorsToWrite;
868:                             sector += numSectorsToWrite;
9D00A97C  02729821   ADDU S3, S3, S2
869:                             dataBuffer += (numSectorsToWrite << 9);
9D00A980  00129240   SLL S2, S2, 9
870:                         }
871:                     }
872:                 
873:                     /* Unmute the event notification */
874:                     gSYSFSMediaManagerObj.muteEventNotification = false;
9D00A99C  3C028001   LUI V0, -32767
9D00A9A0  A0404EC2   SB ZERO, 20162(V0)
875:                 
876:                     mediaObj->commandStatus = SYS_FS_MEDIA_COMMAND_IN_PROGRESS;
9D00A9A4  24020002   ADDIU V0, ZERO, 2
9D00A9A8  AE020024   SW V0, 36(S0)
877:                     mediaObj->driverFunctions->sectorWrite (mediaObj->driverHandle, &(mediaObj->commandHandle), data, memoryBlock, 1);
9D00A9AC  8E020008   LW V0, 8(S0)
9D00A9B0  8E040014   LW A0, 20(S0)
9D00A9B4  24030001   ADDIU V1, ZERO, 1
9D00A9B8  AFA30010   SW V1, 16(SP)
9D00A9BC  8C42000C   LW V0, 12(V0)
9D00A9C0  2605001C   ADDIU A1, S0, 28
9D00A9C4  03C03021   ADDU A2, S8, ZERO
9D00A9C8  0040F809   JALR V0
9D00A9CC  8FA70020   LW A3, 32(SP)
878:                 
879:                     return (mediaObj->commandHandle);
9D00A9D0  8E02001C   LW V0, 28(S0)
880:                 }
9D00A9D4  8FBF004C   LW RA, 76(SP)
881:                 
882:                 uintptr_t SYS_FS_MEDIA_MANAGER_AddressGet
883:                 (
884:                     uint16_t diskNum
885:                 )
886:                 {
00000000  00000000   NOP
0000000C  00000000   NOP
887:                     SYS_FS_MEDIA *mediaObj = NULL;
888:                 
889:                     if (diskNum >= SYS_FS_MEDIA_NUMBER)
00000004  00000000   NOP
890:                     {
891:                         SYS_ASSERT(false, "Invalid Disk");
892:                         return 0;
893:                     }
894:                 
895:                     mediaObj = &gSYSFSMediaManagerObj.mediaObj[diskNum];
00000014  00000000   NOP
896:                     return (mediaObj->driverFunctions->addressGet(mediaObj->driverHandle));
0000001C  00000000   NOP
897:                 }
0000002C  00000000   NOP
898:                 
899:                 SYS_FS_MEDIA_COMMAND_STATUS SYS_FS_MEDIA_MANAGER_CommandStatusGet
900:                 (
901:                     uint16_t diskNum,
902:                     SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE commandHandle
903:                 )
904:                 {
00000000  00000000   NOP
00000020  00000000   NOP
905:                     SYS_FS_MEDIA *mediaObj = NULL;
906:                 
907:                     if (diskNum >= SYS_FS_MEDIA_NUMBER)
00000004  00000000   NOP
908:                     {
909:                         SYS_ASSERT(false, "Invalid Disk");
910:                         return SYS_FS_MEDIA_COMMAND_UNKNOWN;
00000040  00000000   NOP
911:                     }
912:                 
913:                     mediaObj = &gSYSFSMediaManagerObj.mediaObj[diskNum];
0000000C  00000000   NOP
914:                 
915:                     if (mediaObj->driverHandle == DRV_HANDLE_INVALID)
00000014  00000000   NOP
916:                     {
917:                         return SYS_FS_MEDIA_COMMAND_UNKNOWN;
00000048  00000000   NOP
918:                     }
919:                 
920:                     return (mediaObj->driverFunctions->commandStatusGet(mediaObj->driverHandle, commandHandle));
00000028  00000000   NOP
921:                 }
00000050  00000000   NOP
922:                 
923:                 bool SYS_FS_MEDIA_MANAGER_MediaStatusGet
924:                 (
925:                     const char *volumeName
926:                 )
927:                 {
9D014008  27BDFFE0   ADDIU SP, SP, -32
9D01400C  AFBF001C   SW RA, 28(SP)
9D014010  AFB10018   SW S1, 24(SP)
9D014014  AFB00014   SW S0, 20(SP)
928:                     SYS_FS_VOLUME * volumeObj =  NULL;
929:                     uint8_t volumeIndex = 0;
930:                 
931:                     for (volumeIndex = 0; volumeIndex < SYS_FS_VOLUME_NUMBER; volumeIndex++)
932:                     {
933:                         volumeObj = &gSYSFSMediaManagerObj.volumeObj[volumeIndex];
9D014018  3C028001   LUI V0, -32767
9D01401C  8C504EB0   LW S0, 20144(V0)
934:                         if (volumeObj->inUse == true)
9D014020  92030000   LBU V1, 0(S0)
9D014024  10600020   BEQ V1, ZERO, 0x9D0140A8
9D014028  00601021   ADDU V0, V1, ZERO
9D01402C  00808821   ADDU S1, A0, ZERO
935:                         {
936:                             if (strncmp("/dev/", volumeName, 5))
9D014030  3C049D01   LUI A0, -25343
9D014034  24846A64   ADDIU A0, A0, 27236
9D014038  02202821   ADDU A1, S1, ZERO
9D01403C  0F404B6A   JAL strncmp
9D014040  24060005   ADDIU A2, ZERO, 5
9D014044  1040000D   BEQ V0, ZERO, 0x9D01407C
9D014048  26240005   ADDIU A0, S1, 5
937:                             {
938:                                 if (strcmp((const char*)(volumeName), (const char *)volumeObj->volumeName) == 0)
9D01404C  02202021   ADDU A0, S1, ZERO
9D014050  0F404748   JAL strcmp
9D014054  26050002   ADDIU A1, S0, 2
9D014058  14400012   BNE V0, ZERO, 0x9D0140A4
9D01405C  00001821   ADDU V1, ZERO, ZERO
939:                                 {
940:                                     return (volumeObj->obj->driverFunctions->mediaStatusGet(volumeObj->obj->driverHandle));
9D014060  8E020018   LW V0, 24(S0)
9D014064  8C430008   LW V1, 8(V0)
9D014068  8C630000   LW V1, 0(V1)
9D01406C  0060F809   JALR V1
9D014070  8C440014   LW A0, 20(V0)
9D014074  0B405029   J 0x9D0140A4
9D014078  00401821   ADDU V1, V0, ZERO
941:                                 }
942:                             }
943:                             else
944:                             {
945:                                 if (strcmp((const char*)(volumeName + 5), (const char *)volumeObj->volumeName) == 0)
9D01407C  0F404748   JAL strcmp
9D014080  26050002   ADDIU A1, S0, 2
9D014084  14400007   BNE V0, ZERO, 0x9D0140A4
9D014088  00001821   ADDU V1, ZERO, ZERO
946:                                 {
947:                                     return (volumeObj->obj->driverFunctions->mediaStatusGet(volumeObj->obj->driverHandle));                    
9D01408C  8E020018   LW V0, 24(S0)
9D014090  8C430008   LW V1, 8(V0)
9D014094  8C630000   LW V1, 0(V1)
9D014098  0060F809   JALR V1
9D01409C  8C440014   LW A0, 20(V0)
9D0140A0  00401821   ADDU V1, V0, ZERO
948:                                 }
949:                             }
950:                         }
951:                     }
952:                 
953:                     return SYS_FS_MEDIA_DETACHED;
954:                 }
9D0140A4  00601021   ADDU V0, V1, ZERO
955:                 
956:                 bool SYS_FS_MEDIA_MANAGER_VolumePropertyGet
957:                 (
958:                     const char *volumeName,
959:                     SYS_FS_VOLUME_PROPERTY *property
960:                 )
961:                 {
9D014CE8  27BDFFE0   ADDIU SP, SP, -32
9D014CEC  AFBF001C   SW RA, 28(SP)
9D014CF0  AFB20018   SW S2, 24(SP)
9D014CF4  AFB10014   SW S1, 20(SP)
9D014CF8  AFB00010   SW S0, 16(SP)
962:                     SYS_FS_VOLUME *volumeObj = NULL;
963:                     uint8_t volumeIndex = 0;
964:                 
965:                     for (volumeIndex = 0; volumeIndex < SYS_FS_VOLUME_NUMBER; volumeIndex++)
966:                     {
967:                         volumeObj = &gSYSFSMediaManagerObj.volumeObj[volumeIndex];
9D014CFC  3C028001   LUI V0, -32767
9D014D00  8C514EB0   LW S1, 20144(V0)
968:                 
969:                         if (volumeObj->inUse == true)
9D014D04  92300000   LBU S0, 0(S1)
9D014D08  12000015   BEQ S0, ZERO, 0x9D014D60
9D014D0C  02001021   ADDU V0, S0, ZERO
9D014D10  00A09021   ADDU S2, A1, ZERO
970:                         {
971:                             if (strcmp((const char*)(volumeName + 5), (const char *)volumeObj->volumeName) == 0)
9D014D14  24840005   ADDIU A0, A0, 5
9D014D18  0F404748   JAL strcmp
9D014D1C  26250002   ADDIU A1, S1, 2
9D014D20  5440000E   BNEL V0, ZERO, 0x9D014D5C
9D014D24  00008021   ADDU S0, ZERO, ZERO
972:                             {
973:                                 if (volumeObj->fsType == 'M')
9D014D28  92240001   LBU A0, 1(S1)
9D014D2C  2402004D   ADDIU V0, ZERO, 77
9D014D30  14820003   BNE A0, V0, 0x9D014D40
9D014D34  24020002   ADDIU V0, ZERO, 2
9D014D38  0B405356   J 0x9D014D58
9D014D3C  AE420004   SW V0, 4(S2)
974:                                 {
975:                                     /* MPFS File System */
976:                                     property->fsType = MPFS2;
977:                                 }
978:                                 else if (SYS_FS_MEDIA_MANAGER_IsFSFat (volumeObj->fsType))
9D014D40  0F400064   JAL SYS_FS_MEDIA_MANAGER_IsFSFat
9D014D44  00000000   NOP
9D014D48  50400003   BEQL V0, ZERO, 0x9D014D58
9D014D4C  AE400004   SW ZERO, 4(S2)
979:                                 {
980:                                     /* FAT File System */
981:                                     property->fsType = FAT;
9D014D50  24020001   ADDIU V0, ZERO, 1
9D014D54  AE420004   SW V0, 4(S2)
9D014D58  AE400000   SW ZERO, 0(S2)
982:                                 }
983:                                 else
984:                                 {
985:                                     /* Unsupported file system or no file system */
986:                                     property->fsType = UNSUPPORTED_FS;
987:                                 }
988:                 
989:                                 property->volNumber = volumeIndex;
990:                                 return true;
991:                             }
992:                         }
993:                     }
994:                 
995:                     return false;
996:                 }
9D014D5C  02001021   ADDU V0, S0, ZERO
997:                 
998:                 void SYS_FS_MEDIA_MANAGER_RegisterTransferHandler
999:                 (
1000:                    const void *eventHandler
1001:                )
1002:                {
1003:                    gSYSFSMediaManagerObj.eventHandler = eventHandler;
9D017314  3C028001   LUI V0, -32767
1004:                }
1005:                
1006:                void SYS_FS_MEDIA_MANAGER_EventHandler
1007:                (
1008:                    SYS_FS_MEDIA_BLOCK_EVENT event,
1009:                    SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE commandHandle,
1010:                    uintptr_t context
1011:                )
1012:                {
9D015E90  27BDFFE8   ADDIU SP, SP, -24
9D015E94  AFBF0014   SW RA, 20(SP)
1013:                    switch(event)
9D015E50  10800005   BEQ A0, ZERO, 0x9D015E68
9D015E54  24020001   ADDIU V0, ZERO, 1
9D015E58  50820005   BEQL A0, V0, 0x9D015E70
9D015E5C  2402FFFF   ADDIU V0, ZERO, -1
1014:                    {
1015:                        case SYS_FS_MEDIA_EVENT_BLOCK_COMMAND_COMPLETE:
1016:                            ((SYS_FS_MEDIA*)context)->commandStatus = SYS_FS_MEDIA_COMMAND_COMPLETED;
1017:                            break;
9D015E68  0B40579D   J 0x9D015E74
9D015E6C  ACC00024   SW ZERO, 36(A2)
1018:                        case SYS_FS_MEDIA_EVENT_BLOCK_COMMAND_ERROR:
1019:                            ((SYS_FS_MEDIA*)context)->commandStatus = SYS_FS_MEDIA_COMMAND_UNKNOWN;
9D015E70  ACC20024   SW V0, 36(A2)
1020:                            break;
1021:                        default:
1022:                            break;
1023:                    }
1024:                
1025:                    if ((gSYSFSMediaManagerObj.eventHandler != NULL) && (gSYSFSMediaManagerObj.muteEventNotification == false))
9D015E60  0B40579E   J 0x9D015E78
9D015E64  3C028001   LUI V0, -32767
9D015E74  3C028001   LUI V0, -32767
9D015E78  8C424EB8   LW V0, 20152(V0)
9D015E7C  1040000A   BEQ V0, ZERO, 0x9D015EA8
9D015E80  3C038001   LUI V1, -32767
9D015E84  90634EC2   LBU V1, 20162(V1)
9D015E88  14600007   BNE V1, ZERO, 0x9D015EA8
9D015E8C  00000000   NOP
1026:                    {
1027:                        gSYSFSMediaManagerObj.eventHandler (event, (void *)commandHandle, context);
9D015E98  0040F809   JALR V0
9D015E9C  00000000   NOP
1028:                    }
1029:                }
9D015EA0  8FBF0014   LW RA, 20(SP)
1030:                
1031:                SYS_FS_MEDIA_GEOMETRY * SYS_FS_MEDIA_MANAGER_GetMediaGeometry
1032:                (
1033:                    uint16_t diskNum
1034:                )
1035:                {
9D0168F0  3084FFFF   ANDI A0, A0, -1
1036:                    SYS_FS_MEDIA *mediaObj = NULL;
1037:                
1038:                    if (diskNum >= SYS_FS_MEDIA_NUMBER)
9D0168F4  14800008   BNE A0, ZERO, 0x9D016918
9D0168F8  00000000   NOP
1039:                    {
1040:                        SYS_ASSERT(false, "Invalid Disk");
1041:                        return NULL;
9D016918  03E00008   JR RA
9D01691C  00001021   ADDU V0, ZERO, ZERO
1042:                    }
1043:                
1044:                    mediaObj = &gSYSFSMediaManagerObj.mediaObj[diskNum];
9D0168FC  3C028001   LUI V0, -32767
9D016900  8C424EAC   LW V0, 20140(V0)
1045:                
1046:                    if (mediaObj->attachStatus == SYS_FS_MEDIA_DETACHED)
9D016904  8C430020   LW V1, 32(V0)
9D016908  10600005   BEQ V1, ZERO, 0x9D016920
9D01690C  00000000   NOP
1047:                    {
1048:                        return NULL;
1049:                    }
1050:                
1051:                    return mediaObj->mediaGeometry;
9D016910  03E00008   JR RA
9D016914  8C420028   LW V0, 40(V0)
1052:                }
9D016920  03E00008   JR RA
1053:                
1054:                void SYS_FS_MEDIA_MANAGER_TransferTask
1055:                (
1056:                    uint8_t mediaIndex
1057:                )
1058:                {
9D016380  308400FF   ANDI A0, A0, 255
9D0163AC  27BDFFE8   ADDIU SP, SP, -24
9D0163B0  AFBF0014   SW RA, 20(SP)
1059:                    SYS_FS_MEDIA *mediaObj;
1060:                
1061:                    if (mediaIndex >= SYS_FS_MEDIA_NUMBER)
9D016384  1480000F   BNE A0, ZERO, 0x9D0163C4
9D016388  3C028001   LUI V0, -32767
1062:                    {
1063:                        return;
1064:                    }
1065:                    
1066:                    mediaObj = &gSYSFSMediaManagerObj.mediaObj[mediaIndex];
9D01638C  8C424EAC   LW V0, 20140(V0)
1067:                
1068:                    if (mediaObj->inUse == false)
9D016390  90430000   LBU V1, 0(V0)
9D016394  1060000B   BEQ V1, ZERO, 0x9D0163C4
9D016398  00000000   NOP
1069:                    {
1070:                        return;
1071:                    }
1072:                
1073:                    if (mediaObj->driverFunctions->tasks != NULL)
9D01639C  8C430008   LW V1, 8(V0)
9D0163A0  8C63002C   LW V1, 44(V1)
9D0163A4  10600007   BEQ V1, ZERO, 0x9D0163C4
9D0163A8  00000000   NOP
1074:                    {
1075:                        mediaObj->driverFunctions->tasks(mediaObj->driverObj);
9D0163B4  0060F809   JALR V1
9D0163B8  8C440010   LW A0, 16(V0)
1076:                    }
1077:                }
9D0163BC  8FBF0014   LW RA, 20(SP)
1078:                
1079:                void SYS_FS_MEDIA_MANAGER_Tasks
1080:                (
1081:                    void
1082:                )
1083:                {
9D003CA0  27BDFFB8   ADDIU SP, SP, -72
9D003CA4  AFBF0044   SW RA, 68(SP)
9D003CA8  AFBE0040   SW S8, 64(SP)
9D003CAC  AFB7003C   SW S7, 60(SP)
9D003CB0  AFB60038   SW S6, 56(SP)
9D003CB4  AFB50034   SW S5, 52(SP)
9D003CB8  AFB40030   SW S4, 48(SP)
9D003CBC  AFB3002C   SW S3, 44(SP)
9D003CC0  AFB20028   SW S2, 40(SP)
9D003CC4  AFB10024   SW S1, 36(SP)
9D003CC8  AFB00020   SW S0, 32(SP)
1084:                    uint8_t mediaIndex = 0;
1085:                    uint8_t fsType = 0xFF;
1086:                    uint8_t partitionMap = 0;
1087:                    uint8_t isMBR = 0;
1088:                    uint32_t numSectors = 0;
1089:                    uint32_t mediaReadBlockSize = 0;
1090:                
1091:                    SYS_FS_MEDIA *mediaObj = NULL;
1092:                
1093:                    /* Find the next media to be processed */
1094:                    mediaIndex = _SYS_FS_MEDIA_MANAGER_FindNextMedia (&gSYSFSMediaManagerObj.mediaObj[0], &gSYSFSMediaManagerObj.mediaIndex);
9D003CCC  3C028001   LUI V0, -32767
9D003CD0  8C474EAC   LW A3, 20140(V0)
1095:                    if (mediaIndex == 0xFF)
9D003D38  240300FF   ADDIU V1, ZERO, 255
9D003D3C  104301A0   BEQ V0, V1, 0x9D0043C0
9D003D40  00021880   SLL V1, V0, 2
1096:                    {
1097:                        /* No media attached. Do nothing. */
1098:                        return;
1099:                    }
1100:                
1101:                    mediaObj = &gSYSFSMediaManagerObj.mediaObj[mediaIndex];
9D003D44  0B400F5B   J 0x9D003D6C
9D003D48  00028100   SLL S0, V0, 4
9D003D64  00021880   SLL V1, V0, 2
9D003D68  00028100   SLL S0, V0, 4
9D003D6C  02038023   SUBU S0, S0, V1
9D003D70  02021023   SUBU V0, S0, V0
9D003D74  00028080   SLL S0, V0, 2
9D003D78  00F08021   ADDU S0, A3, S0
1102:                
1103:                    if (mediaObj->isMediaDisconnected == true)
9D003D7C  92030005   LBU V1, 5(S0)
9D003D80  24020001   ADDIU V0, ZERO, 1
9D003D84  54620003   BNEL V1, V0, 0x9D003D94
9D003D88  8E02000C   LW V0, 12(S0)
1104:                    {
1105:                        /* If media driver has de-registered then switch to the DEREGISTERED
1106:                         * state and handle the media detach. */
1107:                        mediaObj->mediaState = SYS_FS_MEDIA_STATE_DEREGISTERED;
9D003D8C  0B4010C6   J 0x9D004318
9D003D90  AE00000C   SW ZERO, 12(S0)
1108:                    }
1109:                
1110:                    switch (mediaObj->mediaState)
9D003D94  2C420005   SLTIU V0, V0, 5
9D003D98  10400189   BEQ V0, ZERO, 0x9D0043C0
9D003D9C  3C029D00   LUI V0, -25344
9D003DA0  8E03000C   LW V1, 12(S0)
9D003DA4  00031880   SLL V1, V1, 2
9D003DA8  24423DB8   ADDIU V0, V0, 15800
9D003DAC  7C43100A   LWX V0, V1(V0)
9D003DB0  00400008   JR V0
9D003DB4  00000000   NOP
1111:                    {
1112:                        case SYS_FS_MEDIA_STATE_REGISTERED:
1113:                            {
1114:                                /* Initial state. Open the media driver. */
1115:                                mediaObj->driverHandle = mediaObj->driverFunctions->open(mediaObj->driverIndex, DRV_IO_INTENT_READWRITE);
9D003DCC  8E020008   LW V0, 8(S0)
9D003DD0  8C420024   LW V0, 36(V0)
9D003DD4  96040006   LHU A0, 6(S0)
9D003DD8  0040F809   JALR V0
9D003DDC  24050003   ADDIU A1, ZERO, 3
1116:                                if (mediaObj->driverHandle != DRV_HANDLE_INVALID)
9D003DE0  2403FFFF   ADDIU V1, ZERO, -1
9D003DE4  10430176   BEQ V0, V1, 0x9D0043C0
9D003DE8  AE020014   SW V0, 20(S0)
1117:                                {
1118:                                    /* Media driver open successful. Register an event handler for
1119:                                     * the media driver events. */
1120:                                    mediaObj->driverFunctions->eventHandlerset(mediaObj->driverHandle, SYS_FS_MEDIA_MANAGER_EventHandler, (uintptr_t)mediaObj);
9D003DEC  8E030008   LW V1, 8(S0)
9D003DF0  8C630010   LW V1, 16(V1)
9D003DF4  00402021   ADDU A0, V0, ZERO
9D003DF8  3C059D01   LUI A1, -25343
9D003DFC  24A55E50   ADDIU A1, A1, 24144
9D003E00  0060F809   JALR V1
9D003E04  02003021   ADDU A2, S0, ZERO
1121:                
1122:                                    /* Transition to the next state. */
1123:                                    mediaObj->mediaState = SYS_FS_MEDIA_CHECK_ATTACH_STATUS;
9D003E08  24020002   ADDIU V0, ZERO, 2
9D003E0C  0B4010F0   J 0x9D0043C0
9D003E10  AE02000C   SW V0, 12(S0)
1124:                                }
1125:                                else
1126:                                {
1127:                                    /* Media driver open failed. Stay in the same state and
1128:                                     * retry. */
1129:                                }
1130:                
1131:                                break;
1132:                            }
1133:                
1134:                        case SYS_FS_MEDIA_CHECK_ATTACH_STATUS:
1135:                            {
1136:                                /* Check if the Media is attached. */
1137:                                if (mediaObj->driverFunctions->mediaStatusGet(mediaObj->driverHandle) == true)
9D003E14  8E020008   LW V0, 8(S0)
9D003E18  8C420000   LW V0, 0(V0)
9D003E1C  0040F809   JALR V0
9D003E20  8E040014   LW A0, 20(S0)
9D003E24  5040000E   BEQL V0, ZERO, 0x9D003E60
9D003E28  8E030020   LW V1, 32(S0)
1138:                                {
1139:                                    if (mediaObj->attachStatus == SYS_FS_MEDIA_DETACHED)
9D003E2C  8E020020   LW V0, 32(S0)
9D003E30  14400009   BNE V0, ZERO, 0x9D003E58
9D003E34  24020001   ADDIU V0, ZERO, 1
1140:                                    {
1141:                                        /* The media was earlier detached. But now it is
1142:                                         * attached. Read the media geometry. */
1143:                                        mediaObj->mediaGeometry = mediaObj->driverFunctions->mediaGeometryGet(mediaObj->driverHandle);
9D003E38  8E020008   LW V0, 8(S0)
9D003E3C  8C420004   LW V0, 4(V0)
9D003E40  0040F809   JALR V0
9D003E44  8E040014   LW A0, 20(S0)
9D003E48  AE020028   SW V0, 40(S0)
1144:                
1145:                                        /* Transition to the next state to kick start the
1146:                                         * analysis of the FS on the media. */
1147:                                        mediaObj->mediaState = SYS_FS_MEDIA_READ_FIRST_SECTOR;
9D003E4C  24020003   ADDIU V0, ZERO, 3
9D003E50  AE02000C   SW V0, 12(S0)
1148:                                    }
1149:                
1150:                                    /* Update the media status */
1151:                                    mediaObj->attachStatus = SYS_FS_MEDIA_ATTACHED;
9D003E54  24020001   ADDIU V0, ZERO, 1
9D003E58  0B4010F0   J 0x9D0043C0
9D003E5C  AE020020   SW V0, 32(S0)
1152:                                }
1153:                                else
1154:                                {
1155:                                    if (mediaObj->attachStatus == SYS_FS_MEDIA_ATTACHED)
9D003E60  24020001   ADDIU V0, ZERO, 1
9D003E64  54620156   BNEL V1, V0, 0x9D0043C0
9D003E68  AE000020   SW ZERO, 32(S0)
1156:                                    {
1157:                                        /* The media was earlier attached. But now it is
1158:                                         * detached. Handle the media detach. */
1159:                                        _SYS_FS_MEDIA_MANAGER_HandleMediaDetach (mediaObj);
9D003E6C  0F4052A3   JAL _SYS_FS_MEDIA_MANAGER_HandleMediaDetach
9D003E70  02002021   ADDU A0, S0, ZERO
1160:                
1161:                                        /* Reset the media's number of volumes field */
1162:                                        mediaObj->numVolumes = 0;
9D003E74  A2000004   SB ZERO, 4(S0)
1163:                                    }
1164:                
1165:                                    /* Update the media status */
1166:                                    mediaObj->attachStatus = SYS_FS_MEDIA_DETACHED;
9D003E78  0B4010F0   J 0x9D0043C0
9D003E7C  AE000020   SW ZERO, 32(S0)
1167:                
1168:                                    /* Stay in the same state */
1169:                                }
1170:                
1171:                                break;
1172:                            }
1173:                
1174:                        case SYS_FS_MEDIA_READ_FIRST_SECTOR:
1175:                            {
1176:                                if (gSYSFSMediaManagerObj.bufferInUse == true)
9D003E80  3C028001   LUI V0, -32767
9D003E84  90434EC1   LBU V1, 20161(V0)
9D003E88  24020001   ADDIU V0, ZERO, 1
9D003E8C  1062014C   BEQ V1, V0, 0x9D0043C0
9D003E90  24030001   ADDIU V1, ZERO, 1
1177:                                {
1178:                                    /* Stay in the same state till the buffer becomes free. */
1179:                                    break;
1180:                                }
1181:                
1182:                                gSYSFSMediaManagerObj.bufferInUse = true;
9D003E94  3C028001   LUI V0, -32767
9D003E98  A0434EC1   SB V1, 20161(V0)
1183:                
1184:                                numSectors = 1;
1185:                
1186:                                mediaReadBlockSize = mediaObj->mediaGeometry->geometryTable[0].blockSize;
9D003E9C  8E020028   LW V0, 40(S0)
9D003EA0  8C420010   LW V0, 16(V0)
9D003EA4  8C420000   LW V0, 0(V0)
1187:                
1188:                                if (mediaReadBlockSize < 512)
9D003EA8  2C430200   SLTIU V1, V0, 512
9D003EAC  10600005   BEQ V1, ZERO, 0x9D003EC4
9D003EB0  24120001   ADDIU S2, ZERO, 1
1189:                                {
1190:                                    /* Perform sector to block translation */
1191:                                    numSectors *= (512 / mediaReadBlockSize);
9D003EB4  24120200   ADDIU S2, ZERO, 512
9D003EB8  0242001B   DIVU S2, V0
9D003EBC  004001F4   TEQ V0, ZERO
9D003EC0  00009012   MFLO S2
1192:                                }
1193:                
1194:                                memset (gSYSFSMediaManagerObj.mediaBuffer, 0, SYS_FS_MEDIA_MAX_BLOCK_SIZE);
9D003EC4  3C118001   LUI S1, -32767
9D003EC8  26314EAC   ADDIU S1, S1, 20140
9D003ECC  8E240010   LW A0, 16(S1)
9D003ED0  00002821   ADDU A1, ZERO, ZERO
9D003ED4  0F405189   JAL memset
9D003ED8  24060200   ADDIU A2, ZERO, 512
1195:                
1196:                                /* Update the command status */
1197:                                mediaObj->commandStatus = SYS_FS_MEDIA_COMMAND_IN_PROGRESS;
9D003EDC  24020002   ADDIU V0, ZERO, 2
9D003EE0  AE020024   SW V0, 36(S0)
1198:                
1199:                                /* Read the first sector of the media */
1200:                                mediaObj->driverFunctions->sectorRead(mediaObj->driverHandle, &(mediaObj->commandHandle), gSYSFSMediaManagerObj.mediaBuffer, 0, numSectors);
9D003EE4  8E020008   LW V0, 8(S0)
9D003EE8  8E040014   LW A0, 20(S0)
9D003EEC  8E260010   LW A2, 16(S1)
9D003EF0  AFB20010   SW S2, 16(SP)
9D003EF4  8C420008   LW V0, 8(V0)
9D003EF8  2605001C   ADDIU A1, S0, 28
9D003EFC  0040F809   JALR V0
9D003F00  00003821   ADDU A3, ZERO, ZERO
1201:                
1202:                                if (mediaObj->commandHandle != SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID)
9D003F04  8E03001C   LW V1, 28(S0)
9D003F08  2402FFFF   ADDIU V0, ZERO, -1
9D003F0C  10620003   BEQ V1, V0, 0x9D003F1C
9D003F10  24020004   ADDIU V0, ZERO, 4
9D003F14  0B4010F0   J 0x9D0043C0
9D003F18  AE02000C   SW V0, 12(S0)
1203:                                {
1204:                                    mediaObj->mediaState = SYS_FS_MEDIA_ANALYZE_FS;
1205:                                }
1206:                                else
1207:                                {
1208:                                    /* Failed to queue the Media read operation. Retry the
1209:                                     * operation. Clear the buffer in use flag. */
1210:                                    gSYSFSMediaManagerObj.bufferInUse = false;
9D003F1C  3C028001   LUI V0, -32767
9D003F20  0B4010F0   J 0x9D0043C0
9D003F24  A0404EC1   SB ZERO, 20161(V0)
1211:                                }
1212:                
1213:                                break;
1214:                            }
1215:                
1216:                        case SYS_FS_MEDIA_ANALYZE_FS:
1217:                            {
1218:                                if (SYS_FS_MEDIA_COMMAND_IN_PROGRESS == mediaObj->commandStatus)
9D003F28  8E020024   LW V0, 36(S0)
9D003F2C  24030002   ADDIU V1, ZERO, 2
9D003F30  14430009   BNE V0, V1, 0x9D003F58
9D003F34  00000000   NOP
1219:                                {
1220:                                    /* The request is not complete yet. Stay in the same state.
1221:                                     * */
1222:                                    if(mediaObj->driverFunctions->tasks != NULL)
9D003F38  8E020008   LW V0, 8(S0)
9D003F3C  8C42002C   LW V0, 44(V0)
9D003F40  50400120   BEQL V0, ZERO, 0x9D0043C4
9D003F44  8FBF0044   LW RA, 68(SP)
1223:                                    {
1224:                                        mediaObj->driverFunctions->tasks(mediaObj->driverObj);
9D003F48  0040F809   JALR V0
9D003F4C  8E040010   LW A0, 16(S0)
1225:                                    }
1226:                                    break;
1227:                                }
1228:                
1229:                                if (mediaObj->commandStatus != SYS_FS_MEDIA_COMMAND_COMPLETED)
9D003F58  10400005   BEQ V0, ZERO, 0x9D003F70
9D003F5C  3C028001   LUI V0, -32767
1230:                                {
1231:                                    /* Clear the buffer in use flag. */
1232:                                    gSYSFSMediaManagerObj.bufferInUse = false;
9D003F60  A0404EC1   SB ZERO, 20161(V0)
1233:                
1234:                                    /* Media read operation has failed. Retry the read
1235:                                     * operation. */
1236:                                    mediaObj->mediaState = SYS_FS_MEDIA_READ_FIRST_SECTOR;
9D003F64  24020003   ADDIU V0, ZERO, 3
1237:                
1238:                                    break;
9D003F68  0B4010F0   J 0x9D0043C0
9D003F6C  AE02000C   SW V0, 12(S0)
1239:                                }
1240:                
1241:                                fsType = _SYS_FS_MEDIA_MANAGER_AnalyzeFileSystem(gSYSFSMediaManagerObj.mediaBuffer, &mediaObj->numPartitions, &isMBR, &partitionMap);
9D003F70  3C028001   LUI V0, -32767
9D003F74  8C524EBC   LW S2, 20156(V0)
1242:                
1243:                                if (fsType == 0xFF)
1244:                                {
1245:                                    /* File system not found or found an unsupported file
1246:                                     * system. Allocate a volume so as to allow for formatting
1247:                                     * of the disk. */
1248:                                    if (isMBR)
1249:                                    {
1250:                                        partitionMap = 0x01;
9D004028  0B4010EE   J 0x9D0043B8
9D00402C  02808821   ADDU S1, S4, ZERO
9D0040B4  0B4010EE   J 0x9D0043B8
9D0040B8  02808821   ADDU S1, S4, ZERO
9D0043B4  02808821   ADDU S1, S4, ZERO
9D0043B8  0B401039   J SYS_FS_MEDIA_MANAGER_Tasks::_SYS_FS_MEDIA_MANAGER_PopulateVolume
9D0043BC  241300FF   ADDIU S3, ZERO, 255
1251:                                    }
1252:                                    else
1253:                                    {
1254:                                        partitionMap = 0x00;
1255:                                    }
1256:                                }
1257:                
1258:                                _SYS_FS_MEDIA_MANAGER_PopulateVolume (mediaObj, isMBR, partitionMap, fsType);
1259:                
1260:                                /* Clear the buffer in use flag. */
1261:                                gSYSFSMediaManagerObj.bufferInUse = false;
9D004304  3C028001   LUI V0, -32767
9D004308  A0404EC1   SB ZERO, 20161(V0)
1262:                
1263:                                /* Transition state to check for media attach/detach */
1264:                                mediaObj->mediaState = SYS_FS_MEDIA_CHECK_ATTACH_STATUS;
9D00430C  24020002   ADDIU V0, ZERO, 2
1265:                
1266:                                break;
9D004310  0B4010F0   J 0x9D0043C0
9D004314  AE02000C   SW V0, 12(S0)
1267:                            }
1268:                
1269:                        case SYS_FS_MEDIA_STATE_DEREGISTERED:
1270:                            {
1271:                                if (mediaObj->attachStatus == SYS_FS_MEDIA_ATTACHED)
9D004318  8E030020   LW V1, 32(S0)
9D00431C  24020001   ADDIU V0, ZERO, 1
9D004320  54620004   BNEL V1, V0, 0x9D004334
9D004324  A2000000   SB ZERO, 0(S0)
1272:                                {
1273:                                    /* The media was earlier attached. But now it is
1274:                                     * detached. Handle the media detach. */
1275:                                    _SYS_FS_MEDIA_MANAGER_HandleMediaDetach (mediaObj);
9D004328  0F4052A3   JAL _SYS_FS_MEDIA_MANAGER_HandleMediaDetach
9D00432C  02002021   ADDU A0, S0, ZERO
1276:                                }
1277:                
1278:                                mediaObj->inUse = false;
9D004330  A2000000   SB ZERO, 0(S0)
1279:                                mediaObj->attachStatus = SYS_FS_MEDIA_DETACHED;
9D004334  AE000020   SW ZERO, 32(S0)
1280:                                mediaObj->isMediaDisconnected = false;
9D004338  A2000005   SB ZERO, 5(S0)
1281:                                mediaObj->mediaId = 0;
9D00433C  A2000002   SB ZERO, 2(S0)
1282:                                mediaObj->mediaIndex = 0;
9D004340  A2000003   SB ZERO, 3(S0)
1283:                                mediaObj->numPartitions = 0;
9D004344  A2000001   SB ZERO, 1(S0)
1284:                                mediaObj->numVolumes = 0;
1285:                                break;
9D004348  0B4010F0   J 0x9D0043C0
9D00434C  A2000004   SB ZERO, 4(S0)
1286:                            }
1287:                
1288:                        default:
1289:                            break;
1290:                    }
1291:                }
9D003D5C  0B4010F1   J 0x9D0043C4
9D003D60  8FBF0044   LW RA, 68(SP)
9D003F50  0B4010F1   J 0x9D0043C4
9D003F54  8FBF0044   LW RA, 68(SP)
9D0043C0  8FBF0044   LW RA, 68(SP)
1292:                
1293:                
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/system/fs/src/dynamic/sys_fs.c
1:                   /*******************************************************************************
2:                     File System System-Library Interface Implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_fs.c
9:                   
10:                    Summary:
11:                      This file contains implementation of SYS_FS functions.
12:                  
13:                    Description:
14:                      This file contains implementation of SYS_FS functions.
15:                  *******************************************************************************/
16:                  
17:                  //DOM-IGNORE-BEGIN
18:                  /*******************************************************************************
19:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
20:                  
21:                  Microchip licenses to you the right to use, modify, copy and distribute
22:                  Software only when embedded on a Microchip microcontroller or digital signal
23:                  controller that is fsegrated fso your product or third party product
24:                  (pursuant to the sublicense terms in the accompanying license agreement).
25:                  
26:                  You should refer to the license agreement accompanying this Software for
27:                  additional information regarding your rights and obligations.
28:                  
29:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
30:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
31:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
32:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
33:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
34:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
35:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
36:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
37:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
38:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
39:                  *******************************************************************************/
40:                  //DOM-IGNORE-END
41:                  
42:                  
43:                  #include "system/fs/src/sys_fs_local.h"
44:                  #include "system/fs/sys_fs_media_manager.h"
45:                  #include <stdarg.h>
46:                  #include <string.h>
47:                  
48:                  // *****************************************************************************
49:                  /* Registration table for each native file system
50:                  
51:                    Summary:
52:                      Defines the registration table for each native file system.
53:                  
54:                    Description:
55:                      Defines the registration table for each native file system.
56:                  
57:                    Remarks:
58:                      None
59:                  */
60:                  SYS_FS_REGISTRATION_TABLE gSYSFSObj[SYS_FS_MAX_FILE_SYSTEM_TYPE];
61:                  
62:                  // *****************************************************************************
63:                  /* Mount point
64:                  
65:                    Summary:
66:                      Defines the mount point required for mounting each volume.
67:                  
68:                    Description:
69:                      Defines the mount point required for mounting each volume.
70:                  
71:                    Remarks:
72:                      None
73:                  */
74:                  SYS_FS_MOUNT_POINT gSYSFSMountPoint[SYS_FS_VOLUME_NUMBER];
75:                  
76:                  // *****************************************************************************
77:                  /* Current Mount point
78:                  
79:                    Summary:
80:                      Defines the mount point currently being used.
81:                  
82:                    Description:
83:                      Defines the mount point which will be used as default, in case the application
84:                      do not specify the full path name along with the drive name.
85:                  
86:                    Remarks:
87:                      None
88:                  */
89:                  SYS_FS_CURRENT_MOUNT_POINT  gSYSFSCurrentMountPoint;
90:                  
91:                  // *****************************************************************************
92:                  /* File object
93:                  
94:                    Summary:
95:                      Defines the File object for each file opened.
96:                  
97:                    Description:
98:                      Defines the File object for each file opened on the system.
99:                  
100:                   Remarks:
101:                     None
102:                 */
103:                 SYS_FS_OBJ gSYSFSFileObj[SYS_FS_MAX_FILES];
104:                 
105:                 // *****************************************************************************
106:                 /* Directory object
107:                 
108:                   Summary:
109:                     Defines the Directory object for each directory opened.
110:                 
111:                   Description:
112:                     Defines the Directorye object for each directory opened on the system.
113:                 
114:                   Remarks:
115:                     None
116:                 */
117:                 SYS_FS_DIR_OBJ  gSYSFSDirObj[SYS_FS_MAX_FILES];
118:                 // *****************************************************************************
119:                 /* File System Event Handler
120:                 
121:                   Summary:
122:                     Defines the File system Event handler that stores the application event handler.
123:                 
124:                   Description:
125:                     This data type defines the file system event handler
126:                     the part.
127:                   Remarks:
128:                     None
129:                 */
130:                 SYS_FS_EVENT_HANDLER gSYSFSEventHandler = NULL;
131:                 
132:                 /* File system object instance mutex */
133:                 OSAL_MUTEX_DECLARE(mutexFileSystemObj);
134:                 /* File system object instance mutex */
135:                 OSAL_MUTEX_DECLARE(mutexDirObj);
136:                 /* Variable to hold the error value */
137:                 SYS_FS_ERROR errorValue;
138:                 
139:                 //******************************************************************************
140:                 /*Function:
141:                     SYS_FS_RESULT SYS_FS_Initialize(const void* initData)
142:                 
143:                     Summary:
144:                         Initializes the Abstration Layer
145:                 
146:                     Description:
147:                         Initializes the abstraction Layer and sets up the necessary parameters
148:                 
149:                     Precondition:
150:                         This is the first function to be called during initialization of SYS FS.
151:                 		Calling other functions from SYS FS without initializing the SYS FS will
152:                 		cause un-predictable behavior.
153:                 
154:                     Parameters:
155:                         initData	-	The Set of initialization parameters
156:                 
157:                     Returns:
158:                         If Success: SYS_FS_RES_SUCCESS
159:                         If Failure: SYS_FS_RES_FAILURE
160:                             Sets error code which can be retrieved with SYS_FS_Error
161:                 
162:                 ***************************************************************************/
163:                 SYS_FS_RESULT SYS_FS_Initialize(const void* initData)
164:                 {
9D014F28  27BDFFE0   ADDIU SP, SP, -32
9D014F2C  AFBF001C   SW RA, 28(SP)
9D014F30  AFB10018   SW S1, 24(SP)
9D014F34  AFB00014   SW S0, 20(SP)
9D014F38  00808821   ADDU S1, A0, ZERO
165:                     SYS_FS_REGISTRATION_TABLE *inData = ( SYS_FS_REGISTRATION_TABLE *)initData;
166:                     uint8_t index;
167:                     
168:                     for( index = 0; index != SYS_FS_MAX_FILES; index++ )
169:                     {
170:                         gSYSFSFileObj[index].inUse = false;
9D014F3C  3C108000   LUI S0, -32768
9D014F40  A20007CC   SB ZERO, 1996(S0)
171:                         gSYSFSFileObj[index].mountPoint = NULL;
9D014F44  261007CC   ADDIU S0, S0, 1996
9D014F48  AE000004   SW ZERO, 4(S0)
172:                         gSYSFSFileObj[index].nativeFSFileObj = (uintptr_t)NULL;
9D014F4C  AE000008   SW ZERO, 8(S0)
173:                         memset(gSYSFSFileObj[index].fileName, 0, FAT_FS_MAX_LFN);
9D014F50  3C048000   LUI A0, -32768
9D014F54  248407D8   ADDIU A0, A0, 2008
9D014F58  00002821   ADDU A1, ZERO, ZERO
9D014F5C  0F405189   JAL memset
9D014F60  240600FF   ADDIU A2, ZERO, 255
174:                         gSYSFSFileObj[index].errorValue = SYS_FS_ERROR_OK;
9D014F64  AE00010C   SW ZERO, 268(S0)
175:                 
176:                         gSYSFSDirObj[index].inUse = false;
9D014F68  3C028000   LUI V0, -32768
9D014F6C  A04008DC   SB ZERO, 2268(V0)
177:                         gSYSFSDirObj[index].mountPoint = NULL;
9D014F70  244208DC   ADDIU V0, V0, 2268
9D014F74  AC400004   SW ZERO, 4(V0)
178:                         gSYSFSDirObj[index].nativeFSDirObj = (uintptr_t)NULL;
9D014F78  AC400008   SW ZERO, 8(V0)
179:                         gSYSFSDirObj[index].errorValue = SYS_FS_ERROR_OK;
9D014F7C  AC40000C   SW ZERO, 12(V0)
180:                     }
181:                     
182:                     for( index = 0; index != SYS_FS_MAX_FILE_SYSTEM_TYPE; index++ )
183:                     {
184:                         gSYSFSObj[index].nativeFileSystemType = inData->nativeFileSystemType;
9D014F80  8E220000   LW V0, 0(S1)
9D014F84  AF828098   SW V0, -32616(GP)
185:                         gSYSFSObj[index].nativeFileSystemFunctions = inData->nativeFileSystemFunctions;
9D014F88  8E220004   LW V0, 4(S1)
9D014F8C  AF82809C   SW V0, -32612(GP)
186:                         inData++;
187:                     }
188:                    /* Create mutex forFile system object */
189:                     if(OSAL_MUTEX_Create(&mutexFileSystemObj) != OSAL_RESULT_TRUE)
190:                     {
191:                         return SYS_FS_RES_FAILURE;
192:                     }
193:                      /* Create mutex forFile system object */
194:                     if(OSAL_MUTEX_Create(&mutexDirObj) != OSAL_RESULT_TRUE)
195:                     {
196:                         return SYS_FS_RES_FAILURE;
197:                     }
198:                 
199:                     return SYS_FS_RES_SUCCESS;
200:                 }
9D014F9C  00001021   ADDU V0, ZERO, ZERO
201:                 
202:                 //******************************************************************************
203:                 /*Function:
204:                     void SYS_FS_EventHandlerSet(const void* eventHandler, const uintptr_t context)
205:                 
206:                     Summary:
207:                         Sets the Mount/Unmount Event Handler 
208:                 
209:                     Description:
210:                         Interface to set the event handler, event handler would get invoked on
211:                         Media Mount or Unmount Event.
212:                     Precondition:
213:                         This interface is used to set the event handler when the Auto Mount 
214:                         feature of File System is Enable.
215:                 
216:                     Parameters:
217:                         eventHandler	-	Event Handler for Mount/Unmount Events
218:                         context         -   Pointer to the context
219:                 
220:                     Returns:
221:                         None
222:                 
223:                 ***************************************************************************/
224:                 void SYS_FS_EventHandlerSet
225:                 (
226:                     const void * eventHandler,
227:                     const uintptr_t context
228:                 )
229:                 {
230:                     /* Set the event handler received from application when it is not NULL*/
231:                     /* Context parameter is not used for now */
232:                     if (eventHandler != NULL)
9D0172CC  54800001   BNEL A0, ZERO, 0x9D0172D4
233:                     {
234:                         /* Set the event handler */
235:                         gSYSFSEventHandler = eventHandler;
236:                     }
237:                 }
238:                 //******************************************************************************
239:                 /*Function:
240:                     SYS_FS_RESULT SYS_FS_Mount(const char *devName, const char *mountName,
241:                 	SYS_FS_FILE_SYSTEM_TYPE filesystemtype, unsigned long mountflags, const void *data);
242:                 
243:                     Summary:
244:                         Mount filesystems
245:                 
246:                     Description:
247:                         Attaches the filesystem specified by source to a specified media.
248:                 
249:                     Precondition:
250:                         The "devName" for the media has to be known. The convention that is
251:                 		followed in Harmony file system is: -
252:                 
253:                 		For NVM			- "nvm"<media number><volume number>
254:                 		For SD card		- "mmcblk"<media number><volume number>
255:                 		For MSD			- "sd"<media number><volume number>
256:                 
257:                 		<media number> 	- a, b, c... depending upon number of media of certain type
258:                 						  connected.
259:                 	    <volume number>	- 1, 2, 3... depending upon number of partitions in that
260:                 						  media.
261:                 
262:                     Parameters:
263:                         devName 		- The device name (name of media) which needs to be mounted
264:                         mountName 		- Mount name for the device to be mounted
265:                         filesystemtype 	- native file system type
266:                         mountflags 		- mounting control flags. This parameter is kept for future
267:                 						  expansion. Hence, always pass zero.
268:                         data 			- The data argument is interpreted by the different file systems.
269:                 					      This parameter is kept for future expansion. Hence, always
270:                 						  pass NULL.
271:                 
272:                     Returns:
273:                         If Success: SYS_FS_RES_SUCCESS
274:                         If Failure: SYS_FS_RES_FAILURE
275:                             Sets error code which can be retrieved with SYS_FS_Error
276:                 ***************************************************************************/
277:                 SYS_FS_RESULT SYS_FS_Mount
278:                 (
279:                     const char *devName,
280:                     const char *mountName,
281:                     SYS_FS_FILE_SYSTEM_TYPE filesystemtype,
282:                     unsigned long mountflags,
283:                     const void *data
284:                  )
285:                 {
9D00F98C  27BDFFD0   ADDIU SP, SP, -48
9D00F990  AFBF002C   SW RA, 44(SP)
9D00F994  AFB30028   SW S3, 40(SP)
9D00F998  AFB20024   SW S2, 36(SP)
9D00F99C  AFB10020   SW S1, 32(SP)
9D00F9A0  AFB0001C   SW S0, 28(SP)
9D00F9A4  00809021   ADDU S2, A0, ZERO
9D00F9A8  00A09821   ADDU S3, A1, ZERO
9D00F9AC  00C08821   ADDU S1, A2, ZERO
286:                     int fileStatus = -1;
287:                     SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *)NULL;
288:                     uint8_t mountPoint = 0;
289:                     SYS_FS_VOLUME_PROPERTY volProperty  = {};
9D00F9B0  AFA00010   SW ZERO, 16(SP)
290:                     uint8_t index = 0;
291:                 
292:                     /* First check if the media is attached or not */
293:                     if(SYS_FS_MEDIA_MANAGER_MediaStatusGet(devName) != true)
9D00F9B4  0F405002   JAL SYS_FS_MEDIA_MANAGER_MediaStatusGet
9D00F9B8  AFA00014   SW ZERO, 20(SP)
9D00F9BC  54400005   BNEL V0, ZERO, 0x9D00F9D4
9D00F9C0  AF8080AC   SW ZERO, -32596(GP)
294:                             
295:                     {
296:                         errorValue = SYS_FS_ERROR_NOT_READY;
9D00F9C4  24020003   ADDIU V0, ZERO, 3
9D00F9C8  AF8280AC   SW V0, -32596(GP)
297:                         /* The media name specified is not attached */
298:                         return SYS_FS_RES_FAILURE;
9D00F9CC  0B403EBC   J 0x9D00FAF0
9D00F9D0  2402FFFF   ADDIU V0, ZERO, -1
299:                     }
300:                     /* Clear the error value when mount is sucessful */
301:                     errorValue = SYS_FS_ERROR_OK;
302:                         /* Verify if the requested file system is supported by SYS_FS */
303:                     for( index = 0; index != SYS_FS_MAX_FILE_SYSTEM_TYPE; index++ )
304:                     {
305:                         if(gSYSFSObj[index].nativeFileSystemType == filesystemtype)
9D00F9D4  8F908098   LW S0, -32616(GP)
9D00F9D8  56110043   BNEL S0, S1, 0x9D00FAE8
9D00F9DC  24020015   ADDIU V0, ZERO, 21
306:                             break;  /* Now, index, holds the element number for the requested file system */
307:                     }
308:                 
309:                     /* If the requested file system type is not supported by SYS_FS */
310:                     if(index >= SYS_FS_MAX_FILE_SYSTEM_TYPE)
311:                     {
312:                         errorValue = SYS_FS_ERROR_FS_NOT_SUPPORTED;
9D00FAE8  AF8280AC   SW V0, -32596(GP)
313:                         return SYS_FS_RES_FAILURE;
9D00FAEC  2402FFFF   ADDIU V0, ZERO, -1
314:                     }
315:                     // Start with 0th disk and find a disk which is available (not in use)
316:                     for(mountPoint = 0; mountPoint != SYS_FS_VOLUME_NUMBER; mountPoint++)
317:                     {
318:                         if(!gSYSFSMountPoint[mountPoint].inUse) // not in use, hence this is available
9D00F9E0  0B403EB5   J 0x9D00FAD4
9D00F9E4  3C028000   LUI V0, -32768
9D00FAD4  904208EC   LBU V0, 2284(V0)
9D00FAD8  1440FFE5   BNE V0, ZERO, 0x9D00FA70
9D00FADC  24020014   ADDIU V0, ZERO, 20
319:                         {
320:                             if(true == SYS_FS_MEDIA_MANAGER_VolumePropertyGet(devName, &volProperty))
9D00F9E8  0F40533A   JAL SYS_FS_MEDIA_MANAGER_VolumePropertyGet
9D00F9EC  27A50010   ADDIU A1, SP, 16
9D00F9F0  1040000A   BEQ V0, ZERO, 0x9D00FA1C
9D00F9F4  24020001   ADDIU V0, ZERO, 1
9D00FAE0  0B403E7A   J 0x9D00F9E8
9D00FAE4  02402021   ADDU A0, S2, ZERO
321:                             {
322:                                 if ((volProperty.fsType != filesystemtype) && (volProperty.fsType != UNSUPPORTED_FS))
9D00F9F8  8FA20014   LW V0, 20(SP)
9D00F9FC  5050000A   BEQL V0, S0, 0x9D00FA28
9D00FA00  3C028000   LUI V0, -32768
9D00FA04  50400008   BEQL V0, ZERO, 0x9D00FA28
9D00FA08  3C028000   LUI V0, -32768
323:                                 {
324:                                      errorValue = SYS_FS_ERROR_FS_NOT_MATCH_WITH_VOLUME;
9D00FA0C  24020016   ADDIU V0, ZERO, 22
9D00FA10  AF8280AC   SW V0, -32596(GP)
325:                                      return SYS_FS_RES_FAILURE;
9D00FA14  0B403EBC   J 0x9D00FAF0
9D00FA18  2402FFFF   ADDIU V0, ZERO, -1
326:                                 }
327:                             }
328:                             else
329:                             {
330:                                  errorValue = SYS_FS_ERROR_DISK_ERR;
9D00FA1C  AF8280AC   SW V0, -32596(GP)
331:                                  return SYS_FS_RES_FAILURE;
9D00FA20  0B403EBC   J 0x9D00FAF0
9D00FA24  2402FFFF   ADDIU V0, ZERO, -1
332:                             }
333:                             disk = &gSYSFSMountPoint[mountPoint];
334:                 
335:                             disk->inUse = true;
9D00FA28  24030001   ADDIU V1, ZERO, 1
9D00FA2C  A04308EC   SB V1, 2284(V0)
336:                             disk->fsType = filesystemtype;
9D00FA30  244208EC   ADDIU V0, V0, 2284
9D00FA34  AC500004   SW S0, 4(V0)
337:                             disk->fsFunctions = gSYSFSObj[index].nativeFileSystemFunctions;
9D00FA38  8F84809C   LW A0, -32612(GP)
9D00FA3C  AC440008   SW A0, 8(V0)
338:                             disk->mountName = (mountName + 5);  // Save only mountName. Do not save "/mnt/"
9D00FA40  26730005   ADDIU S3, S3, 5
9D00FA44  AC53000C   SW S3, 12(V0)
339:                             disk->diskNumber = volProperty.volNumber;
9D00FA48  8FA40010   LW A0, 16(SP)
9D00FA4C  A0440010   SB A0, 16(V0)
340:                           /* Create mutex for this Mount/volume */
341:                             if(OSAL_MUTEX_Create(&(disk->mutexDiskVolume)) != OSAL_RESULT_TRUE)
342:                             {
343:                                 return SYS_FS_RES_FAILURE;
344:                             }
345:                             break;
346:                         }
347:                     }
348:                 
349:                     if(mountPoint >= SYS_FS_VOLUME_NUMBER)
350:                     {
351:                         SYS_ASSERT(false, "Invalid Disk");
352:                         errorValue = SYS_FS_ERROR_NOT_ENOUGH_FREE_VOLUME;
9D00FA70  AF8280AC   SW V0, -32596(GP)
353:                         return SYS_FS_RES_FAILURE;
9D00FA74  0B403EBC   J 0x9D00FAF0
9D00FA78  2402FFFF   ADDIU V0, ZERO, -1
354:                     }
355:                     /* Put the recently assigned disk as the current disk */
356:                     gSYSFSCurrentMountPoint.inUse = true;
9D00FA54  A38380A4   SB V1, -32604(GP)
357:                     gSYSFSCurrentMountPoint.currentDisk = disk;
9D00FA58  AF8280A8   SW V0, -32600(GP)
358:                 
359:                     if(disk->fsType == FAT)
9D00FA5C  24020001   ADDIU V0, ZERO, 1
9D00FA60  5602000C   BNEL S0, V0, 0x9D00FA94
9D00FA64  3C028000   LUI V0, -32768
9D00FA68  0B403E9F   J 0x9D00FA7C
9D00FA6C  3C028000   LUI V0, -32768
360:                     {
361:                         disk->fsFunctions->chdrive(disk->diskNumber);
9D00FA7C  244208EC   ADDIU V0, V0, 2284
9D00FA80  8C430008   LW V1, 8(V0)
9D00FA84  8C630048   LW V1, 72(V1)
9D00FA88  0060F809   JALR V1
9D00FA8C  90440010   LBU A0, 16(V0)
362:                     }
363:                 
364:                     /* Check, if the mount function in native FS is NULL or not */
365:                     if(disk->fsFunctions->mount == NULL)
9D00FA90  3C028000   LUI V0, -32768
9D00FA94  8C4208F4   LW V0, 2292(V0)
9D00FA98  8C420000   LW V0, 0(V0)
9D00FA9C  14400005   BNE V0, ZERO, 0x9D00FAB4
9D00FAA0  3C038000   LUI V1, -32768
366:                     {
367:                         errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
9D00FAA4  24020017   ADDIU V0, ZERO, 23
9D00FAA8  AF8280AC   SW V0, -32596(GP)
368:                         return SYS_FS_RES_FAILURE;
9D00FAAC  0B403EBC   J 0x9D00FAF0
9D00FAB0  2402FFFF   ADDIU V0, ZERO, -1
369:                     }
370:                 
371:                     fileStatus = disk->fsFunctions->mount(disk->diskNumber);
9D00FAB4  0040F809   JALR V0
9D00FAB8  906408FC   LBU A0, 2300(V1)
9D00FABC  00401821   ADDU V1, V0, ZERO
372:                 
373:                     if(fileStatus == 0)
9D00FAC0  1060000B   BEQ V1, ZERO, 0x9D00FAF0
9D00FAC4  00001021   ADDU V0, ZERO, ZERO
374:                     {
375:                         return SYS_FS_RES_SUCCESS;
376:                     }
377:                     else
378:                     {
379:                         errorValue = fileStatus;
9D00FAC8  AF8380AC   SW V1, -32596(GP)
380:                         return SYS_FS_RES_FAILURE;
9D00FACC  0B403EBC   J 0x9D00FAF0
9D00FAD0  2402FFFF   ADDIU V0, ZERO, -1
381:                     }
382:                 }
9D00FAF0  8FBF002C   LW RA, 44(SP)
383:                 
384:                 
385:                 //******************************************************************************
386:                 /*Function:
387:                     SYS_FS_RESULT _SYS_FS_DiskGet(const char *path, SYS_FS_MOUNT_POINT **disk)
388:                 
389:                     Summary:
390:                         Retrives the disk from the name of the disk.
391:                 
392:                     Description:
393:                         Retrives the disk from the name of the disk.
394:                 
395:                     Precondition:
396:                         Atlesat, one disk has to be mounted before this funcion could be set.
397:                 
398:                 
399:                     Parameters:
400:                         path            - Path for the file/ directory.
401:                 
402:                         disk     	- pointer of type SYS_FS_MOUNT_POINT.
403:                 
404:                 
405:                     Returns:
406:                         If Success	-	SYS_FS_RES_SUCCESS
407:                 
408:                         If Failure	-	SYS_FS_RES_FAILURE
409:                 
410:                 		The reason for failure could be retrieved with SYS_FS_Error
411:                   Remarks:
412:                 	None
413:                 ***************************************************************************/
414:                 SYS_FS_RESULT _SYS_FS_DiskGet(const char *path, SYS_FS_MOUNT_POINT **disk)
415:                 {
9D013DE0  27BDFFE0   ADDIU SP, SP, -32
9D013DE4  AFBF001C   SW RA, 28(SP)
9D013DE8  AFB20018   SW S2, 24(SP)
9D013DEC  AFB10014   SW S1, 20(SP)
9D013DF0  AFB00010   SW S0, 16(SP)
9D013DF4  00808821   ADDU S1, A0, ZERO
9D013DF8  00A08021   ADDU S0, A1, ZERO
416:                     uint8_t diskIndex;
417:                     SYS_FS_MOUNT_POINT *diskMounted = (SYS_FS_MOUNT_POINT *)NULL;
418:                 
419:                     if (strncmp((const char*)path, (const char *)"/mnt/", 5) == 0)
9D013DFC  3C059D01   LUI A1, -25343
9D013E00  24A57388   ADDIU A1, A1, 29576
9D013E04  0F404B6A   JAL strncmp
9D013E08  24060005   ADDIU A2, ZERO, 5
9D013E0C  14400012   BNE V0, ZERO, 0x9D013E58
9D013E10  938380A4   LBU V1, -32604(GP)
420:                     {
421:                         // Start with 0th disk and find a disk which is available (not in use)
422:                         for(diskIndex = 0; diskIndex != SYS_FS_VOLUME_NUMBER; diskIndex++)
423:                         {
424:                             diskMounted = &gSYSFSMountPoint[diskIndex];
9D013E70  3C028000   LUI V0, -32768
9D013E74  244208EC   ADDIU V0, V0, 2284
425:                             if(diskMounted->inUse == true)
9D013E14  3C028000   LUI V0, -32768
9D013E18  904208EC   LBU V0, 2284(V0)
9D013E1C  1040000B   BEQ V0, ZERO, 0x9D013E4C
9D013E20  24020006   ADDIU V0, ZERO, 6
426:                             {
427:                                 // Find the element from "gSYSFSMediaDiskObject" which has matching "mountName"
428:                                 // I did not use "strcmp" as not sure if its implementation is re-entrant or not
429:                                 // ignore the first 5 chars --> "/mnt/"
430:                 
431:                                 if(0 == strncmp((path + 5),diskMounted->mountName,strlen(diskMounted->mountName)))
9D013E24  3C028000   LUI V0, -32768
9D013E28  8C5208F8   LW S2, 2296(V0)
9D013E2C  0F4040EB   JAL strlen
9D013E30  02402021   ADDU A0, S2, ZERO
9D013E34  26240005   ADDIU A0, S1, 5
9D013E38  02402821   ADDU A1, S2, ZERO
9D013E3C  0F404B6A   JAL strncmp
9D013E40  00403021   ADDU A2, V0, ZERO
9D013E44  1040000A   BEQ V0, ZERO, 0x9D013E70
9D013E48  24020006   ADDIU V0, ZERO, 6
432:                                 {
433:                                     //we have got the "disk" with required name
434:                                     break;
435:                                 }
436:                             }
437:                         }
438:                 
439:                         if(diskIndex >= SYS_FS_VOLUME_NUMBER)
440:                         {
441:                             SYS_ASSERT(false, "Invalid Disk");
442:                             errorValue = SYS_FS_ERROR_INVALID_NAME;
9D013E4C  AF8280AC   SW V0, -32596(GP)
443:                             return SYS_FS_RES_FAILURE;
9D013E50  0B404FA0   J 0x9D013E80
9D013E54  2402FFFF   ADDIU V0, ZERO, -1
444:                         }
445:                 
446:                     }
447:                     else
448:                     {   /* Since drive name is not expecitely mentioned, take the default current drive */
449:                         if(gSYSFSCurrentMountPoint.inUse == false)
9D013E58  14600007   BNE V1, ZERO, 0x9D013E78
9D013E5C  8F8280A8   LW V0, -32600(GP)
450:                         {
451:                             SYS_ASSERT(false, "Invalid mount point. Was the disk mounted?");
452:                             errorValue = SYS_FS_ERROR_NO_FILESYSTEM;
9D013E60  2402000D   ADDIU V0, ZERO, 13
9D013E64  AF8280AC   SW V0, -32596(GP)
453:                             return SYS_FS_RES_FAILURE;
9D013E68  0B404FA0   J 0x9D013E80
9D013E6C  2402FFFF   ADDIU V0, ZERO, -1
454:                         }
455:                 
456:                         diskMounted = gSYSFSCurrentMountPoint.currentDisk;
457:                     }
458:                 
459:                     *disk = diskMounted;
9D013E78  AE020000   SW V0, 0(S0)
460:                 
461:                     return SYS_FS_RES_SUCCESS;
9D013E7C  00001021   ADDU V0, ZERO, ZERO
462:                 }
9D013E80  8FBF001C   LW RA, 28(SP)
463:                 //******************************************************************************
464:                 /*Function:
465:                     bool _SYS_FS_DiskNumberAppend(const char *path, uint8_t diskNumber, uint8_t *buffer, uint32_t len)
466:                 
467:                     Summary:
468:                         Appends the disk number to the begining of the file name.
469:                 
470:                     Description:
471:                         Appends the disk number to the begining of the file name. This is required for
472:                         the native FAT FS working.
473:                 
474:                     Precondition:
475:                         Atlesat, one disk has to be mounted before this funcion could be set.
476:                 
477:                 
478:                     Parameters:
479:                         path            - Path for the file/ directory.
480:                 
481:                         disk     	- pointer of type SYS_FS_MOUNT_POINT.
482:                 
483:                 
484:                     Returns:
485:                         True - If the append operation was successful.
486:                         False - If the append oepration was unsuccessful.
487:                 
488:                 		The reason for failure could be retrieved with SYS_FS_Error
489:                   Remarks:
490:                     None
491:                 ***************************************************************************/
492:                 bool _SYS_FS_DiskNumberAppend
493:                 (
494:                     const char *path, 
495:                     uint8_t diskNumber, 
496:                     uint8_t *buffer
497:                 )
498:                 {
9D012070  27BDFFD8   ADDIU SP, SP, -40
9D012074  AFBF0024   SW RA, 36(SP)
9D012078  AFB30020   SW S3, 32(SP)
9D01207C  AFB2001C   SW S2, 28(SP)
9D012080  AFB10018   SW S1, 24(SP)
9D012084  AFB00014   SW S0, 20(SP)
9D012088  00808821   ADDU S1, A0, ZERO
9D01208C  00C09021   ADDU S2, A2, ZERO
499:                     const char *ptr;
500:                     uint32_t len = 0;
501:                 
502:                     ptr = path;
503:                     len = strlen(path);
9D012090  0F4040EB   JAL strlen
9D012094  30B300FF   ANDI S3, A1, 255
9D012098  00408021   ADDU S0, V0, ZERO
504:                 
505:                     if (strncmp(path, "/mnt/", 5) == 0)
9D01209C  02202021   ADDU A0, S1, ZERO
9D0120A0  3C059D01   LUI A1, -25343
9D0120A4  24A57388   ADDIU A1, A1, 29576
9D0120A8  0F404B6A   JAL strncmp
9D0120AC  24060005   ADDIU A2, ZERO, 5
9D0120B0  54400012   BNEL V0, ZERO, 0x9D0120FC
9D0120B4  26060003   ADDIU A2, S0, 3
506:                     {
507:                         /* Ignore the first 5 chars --> "/mnt/" */
508:                         ptr = (path + 5);
509:                         len = len - 5;
9D0120B8  2610FFFB   ADDIU S0, S0, -5
510:                 
511:                         /* Compare until the beginning of the path name is reached.
512:                            Ex: path name = "/mnt/mydrive1/test/file.txt" where test is a
513:                            subdirectory and file.txt a file under the sub directory test. Move
514:                            the pointer to point to /test/file.txt
515:                         */
516:                         while ((len) && (*ptr != '/'))
9D0120BC  12000024   BEQ S0, ZERO, 0x9D012150
9D0120C0  26220005   ADDIU V0, S1, 5
9D0120C4  82240005   LB A0, 5(S1)
9D0120C8  2403002F   ADDIU V1, ZERO, 47
9D0120CC  10830009   BEQ A0, V1, 0x9D0120F4
9D0120D0  2407002F   ADDIU A3, ZERO, 47
9D0120D8  1200001D   BEQ S0, ZERO, 0x9D012150
9D0120DC  24420001   ADDIU V0, V0, 1
9D0120E0  80430000   LB V1, 0(V0)
9D0120E4  5467FFFC   BNEL V1, A3, 0x9D0120D8
9D0120E8  2610FFFF   ADDIU S0, S0, -1
9D0120EC  0B40483E   J 0x9D0120F8
9D0120F0  00408821   ADDU S1, V0, ZERO
9D0120F4  00408821   ADDU S1, V0, ZERO
517:                         {
518:                             len--;
9D0120D4  2610FFFF   ADDIU S0, S0, -1
519:                             ptr++;
520:                         }
521:                     }
522:                 
523:                     if ((len + 3) > SYS_FS_PATH_LEN_WITH_DISK_NUM)
9D0120F8  26060003   ADDIU A2, S0, 3
9D0120FC  2CC30103   SLTIU V1, A2, 259
9D012100  10600016   BEQ V1, ZERO, 0x9D01215C
9D012104  00001021   ADDU V0, ZERO, ZERO
9D012150  26060003   ADDIU A2, S0, 3
9D012154  0B404842   J 0x9D012108
9D012158  00408821   ADDU S1, V0, ZERO
524:                     {
525:                         return false;
526:                     }
527:                 
528:                     memset(buffer, 0, len + 3);
9D012108  02402021   ADDU A0, S2, ZERO
9D01210C  0F405189   JAL memset
9D012110  00002821   ADDU A1, ZERO, ZERO
529:                 
530:                      /* Append "0:" before the file name. This is required for different disks
531:                       * */
532:                     *buffer++ = diskNumber + '0';
9D012114  26730030   ADDIU S3, S3, 48
9D012118  A2530000   SB S3, 0(S2)
533:                     *buffer++ = ':';
9D01211C  26530002   ADDIU S3, S2, 2
9D012120  2402003A   ADDIU V0, ZERO, 58
534:                 
535:                     if (len)
9D012124  12000006   BEQ S0, ZERO, 0x9D012140
9D012128  A2420001   SB V0, 1(S2)
536:                     {
537:                         strncpy((char *)buffer, (const char *)ptr, len);
9D01212C  02602021   ADDU A0, S3, ZERO
9D012130  02202821   ADDU A1, S1, ZERO
9D012134  0F4048E1   JAL strncpy
9D012138  02003021   ADDU A2, S0, ZERO
538:                         len ++;
9D01213C  26100001   ADDIU S0, S0, 1
539:                     }
540:                 
541:                     buffer[len] = '\0';
9D012140  02708021   ADDU S0, S3, S0
9D012144  A2000000   SB ZERO, 0(S0)
542:                 
543:                     return true;
9D012148  0B404857   J 0x9D01215C
9D01214C  24020001   ADDIU V0, ZERO, 1
544:                 }
9D01215C  8FBF0024   LW RA, 36(SP)
545:                 
546:                 //******************************************************************************
547:                 /*Function:
548:                     bool _SYS_FS_StringWildCardCompare(const char * ptr1, const char *ptr2)
549:                 
550:                     Summary:
551:                     Compares the 2 file names with wild character.
552:                 
553:                     Description:
554:                         Compares the 2 file names with wild character. This is required for
555:                         file search of a directory.
556:                 
557:                     Precondition:
558:                         Atlesat, one disk has to be mounted before this funcion could be set.
559:                 
560:                 
561:                     Parameters:
562:                         ptr1            - First file name. This can have wild characters (*, ?).
563:                 
564:                         ptr2     	- Second file name. This should be complete file name.
565:                                           No wild char should be passed here.
566:                 
567:                 
568:                     Returns:
569:                         If comparison is success	-	true
570:                 
571:                         If comparison is failure	-	false
572:                 
573:                   Remarks:
574:                 	None
575:                 ***************************************************************************/
576:                 bool _SYS_FS_StringWildCardCompare(const char * ptr1, const char *ptr2)
577:                 {
00000000  00000000   NOP
578:                     /* Now, do comparison */
579:                     do
580:                     {
581:                         if((*ptr1 != '?') && (*ptr1 != '*') && (*ptr1 != *ptr2))
00000004  00000000   NOP
582:                         {
583:                             return false;
584:                         }
585:                         else
586:                         {
587:                            if(*ptr1 == '*')
588:                             {
589:                                 ptr1++;
590:                                 if(*ptr1 == '\0')
00000034  00000000   NOP
591:                                     return true;
000000A0  00000000   NOP
592:                                 else if(*ptr1 == '?')
0000003C  00000000   NOP
593:                                     continue;
594:                                 else
595:                                 {
596:                                     // Find the same character in second string as well
597:                                     while((*ptr1 != *ptr2) && (*ptr2 != '\0'))
00000044  00000000   NOP
598:                                     {
599:                                         ptr2++;
600:                                     }
601:                                     if(*ptr2 == '\0')
00000074  00000000   NOP
602:                                         return false;
000000A8  00000000   NOP
603:                                 }
604:                             }
605:                             else
606:                             {
607:                                 ptr1++;
608:                                 ptr2++;
00000084  00000000   NOP
609:                             }
610:                         }
611:                     }while(*ptr1 != '\0');
00000088  00000000   NOP
612:                 
613:                     if((*ptr1 == '\0') && (*ptr2 == '\0'))
00000094  00000000   NOP
614:                     {
615:                         return true;
616:                     }
617:                     return false;
618:                 }
619:                 
620:                 //******************************************************************************
621:                 /* Function:
622:                     SYS_FS_HANDLE SYS_FS_FileOpen
623:                     (
624:                         const char* fname, 
625:                         SYS_FS_FILE_OPEN_ATTRIBUTES attributes
626:                     );
627:                 
628:                   Summary:
629:                      Opens a file
630:                 
631:                   Description:
632:                      This function opens a file with the requested attributes.
633:                 
634:                   Precondition:
635:                     Prior to opening a file, the name of the volume on which the file resides
636:                     should be known and the volume should be mounted. 
637:                 
638:                   Parameters:
639:                     fname         - The name of the file to be opened along with the path.
640:                                     The fname format is as follows:
641:                                     "/mnt/volumeName/dirName/fileName" where 
642:                                     volumeName - name of the volume/drive
643:                                     dirName - name of the directory under which the file is
644:                                               located 
645:                                     fileName - name of the file to be opened
646:                                       
647:                                     The "/mnt/volumeName" portion from the fName can be omitted
648:                                     if the SYS_FS_CurrentDriveSet () has been invoked to set
649:                                     the current drive/volume.
650:                 
651:                     attributes    - Access mode of the file, of type
652:                                     SYS_FS_FILE_OPEN_ATTRIBUTES
653:                 
654:                   Returns:
655:                         If Success: Valid handle will be returned
656:                         If Failure: returned handle will be SYS_FS_HANDLE_INVALID
657:                 
658:                   Remarks:
659:                 	None
660:                 */
661:                 
662:                 SYS_FS_HANDLE SYS_FS_FileOpen
663:                 (
664:                     const char *fname,
665:                     SYS_FS_FILE_OPEN_ATTRIBUTES attributes
666:                 )
667:                 {
9D00B6F4  27BDFED8   ADDIU SP, SP, -296
9D00B6F8  AFBF0124   SW RA, 292(SP)
9D00B6FC  AFB10120   SW S1, 288(SP)
9D00B700  AFB0011C   SW S0, 284(SP)
9D00B704  00808021   ADDU S0, A0, ZERO
9D00B708  00A08821   ADDU S1, A1, ZERO
668:                     int fileStatus = SYS_FS_ERROR_NOT_READY;
669:                     uint32_t j = 0;
670:                     SYS_FS_OBJ * obj = (SYS_FS_OBJ *)NULL;
671:                     uint8_t pathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
9D00B70C  27A40010   ADDIU A0, SP, 16
9D00B710  00002821   ADDU A1, ZERO, ZERO
9D00B714  0F405189   JAL memset
9D00B718  24060102   ADDIU A2, ZERO, 258
672:                     const uint8_t *Temp  = (const uint8_t *)NULL;
673:                     SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
9D00B71C  AFA00114   SW ZERO, 276(SP)
674:                     uint8_t mode = 0;
675:                 
676:                     /* Get disk number */
677:                     if(_SYS_FS_DiskGet(fname, &disk) == SYS_FS_RES_FAILURE)
9D00B720  02002021   ADDU A0, S0, ZERO
9D00B724  0F404F78   JAL _SYS_FS_DiskGet
9D00B728  27A50114   ADDIU A1, SP, 276
9D00B72C  2404FFFF   ADDIU A0, ZERO, -1
9D00B730  10440084   BEQ V0, A0, 0x9D00B944
9D00B734  2403FFFF   ADDIU V1, ZERO, -1
678:                     {
679:                         // reason or cause of error is alredy present in "errorValue" variable
680:                         return SYS_FS_HANDLE_INVALID;
681:                     }
682:                 
683:                     /* Now, get the file name with disk number appended in front like this "0:file.txt" */
684:                     if (_SYS_FS_DiskNumberAppend(fname, (uint8_t)disk->diskNumber, pathWithDiskNo) == false)
9D00B738  02002021   ADDU A0, S0, ZERO
9D00B73C  8FA20114   LW V0, 276(SP)
9D00B740  90450010   LBU A1, 16(V0)
9D00B744  0F40481C   JAL _SYS_FS_DiskNumberAppend
9D00B748  27A60010   ADDIU A2, SP, 16
9D00B74C  14400004   BNE V0, ZERO, 0x9D00B760
9D00B750  24020006   ADDIU V0, ZERO, 6
685:                     {
686:                         errorValue = SYS_FS_ERROR_INVALID_NAME;
9D00B754  AF8280AC   SW V0, -32596(GP)
687:                         return SYS_FS_HANDLE_INVALID;
9D00B758  0B402E51   J 0x9D00B944
9D00B75C  2403FFFF   ADDIU V1, ZERO, -1
688:                     }
689:                 
690:                     /* For MPFS file system, opening a file is possible only in "READ" mode */
691:                     if((disk->fsType == MPFS2) && (attributes != SYS_FS_FILE_OPEN_READ))
9D00B760  8FA80114   LW T0, 276(SP)
9D00B764  8D030004   LW V1, 4(T0)
9D00B768  24020002   ADDIU V0, ZERO, 2
9D00B76C  54620007   BNEL V1, V0, 0x9D00B78C
9D00B770  938380A0   LBU V1, -32608(GP)
9D00B774  12200004   BEQ S1, ZERO, SYS_FS_FileOpen::OSAL_MUTEX_Lock
9D00B778  24020007   ADDIU V0, ZERO, 7
692:                     {
693:                         errorValue = SYS_FS_ERROR_DENIED;
9D00B77C  AF8280AC   SW V0, -32596(GP)
694:                         return SYS_FS_HANDLE_INVALID;
9D00B780  0B402E51   J 0x9D00B944
9D00B784  2403FFFF   ADDIU V1, ZERO, -1
695:                     }
696:                 
697:                     obj = NULL;
698:                     /* Mutex Lock needed here since File Open can be called
699:                     simultaneously from two different tasks */
700:                     if(OSAL_MUTEX_Lock(&mutexFileSystemObj, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
701:                     {
702:                         for(j = 0; j < SYS_FS_MAX_FILES; j ++)
703:                         {
704:                             if(gSYSFSFileObj[j].inUse == false)
9D00B798  3C028000   LUI V0, -32768
9D00B79C  904207CC   LBU V0, 1996(V0)
9D00B7A0  14400066   BNE V0, ZERO, 0x9D00B93C
9D00B7A4  24020001   ADDIU V0, ZERO, 1
705:                             {
706:                                 gSYSFSFileObj[j].inUse = true;
9D00B7A8  3C038000   LUI V1, -32768
9D00B7AC  A06207CC   SB V0, 1996(V1)
707:                                 gSYSFSFileObj[j].mountPoint = disk;
9D00B7B0  246307CC   ADDIU V1, V1, 1996
9D00B7B4  AC680004   SW T0, 4(V1)
708:                                 obj = &gSYSFSFileObj[j];
709:                                 break;
710:                             }
711:                         }
712:                         OSAL_ASSERT((OSAL_MUTEX_Unlock(&mutexFileSystemObj)),"Unable to unlock mutex");
713:                     }
714:                 
715:                     /* If the object is NULL, then we dont have a free
716:                      * file system object */
717:                 
718:                     if(obj == NULL)
719:                     {
720:                         errorValue = SYS_FS_ERROR_TOO_MANY_OPEN_FILES;
9D00B7EC  24020012   ADDIU V0, ZERO, 18
9D00B7F0  AF8280AC   SW V0, -32596(GP)
721:                         return(SYS_FS_HANDLE_INVALID);
9D00B7F4  0B402E51   J 0x9D00B944
9D00B7F8  2403FFFF   ADDIU V1, ZERO, -1
722:                     }
723:                 
724:                     /* Save the file name for future use */
725:                     Temp = &pathWithDiskNo[3];   // ignore the "0:/"
9D00B7C0  38E7002F   XORI A3, A3, 47
9D00B7C4  27A30012   ADDIU V1, SP, 18
9D00B7C8  27A20013   ADDIU V0, SP, 19
9D00B7CC  0067100B   MOVN V0, V1, A3
9D00B7D0  00403821   ADDU A3, V0, ZERO
726:                     if (pathWithDiskNo[2] != '/')
9D00B7BC  93A70012   LBU A3, 18(SP)
727:                         Temp = &pathWithDiskNo[2];   // ignore the "0:"
728:                 
729:                     for(j = 0;  j < FAT_FS_MAX_LFN; j ++)
9D00B80C  24420001   ADDIU V0, V0, 1
9D00B810  5445FFFB   BNEL V0, A1, 0x9D00B800
9D00B814  7CE2198A   LBUX V1, V0(A3)
9D00B928  24020001   ADDIU V0, ZERO, 1
9D00B92C  3C068000   LUI A2, -32768
9D00B930  24C607CC   ADDIU A2, A2, 1996
9D00B934  0B402DFF   J 0x9D00B7FC
9D00B938  240500FF   ADDIU A1, ZERO, 255
730:                     {
731:                         obj->fileName[j] = *Temp;
9D00B7D4  90420000   LBU V0, 0(V0)
9D00B7D8  3C038000   LUI V1, -32768
9D00B7FC  7CE2198A   LBUX V1, V0(A3)
9D00B800  00C22021   ADDU A0, A2, V0
732:                         if(*Temp++ == '\0')
9D00B7DC  14400052   BNE V0, ZERO, 0x9D00B928
9D00B7E0  A06207D8   SB V0, 2008(V1)
9D00B804  10600004   BEQ V1, ZERO, 0x9D00B818
9D00B808  A083000C   SB V1, 12(A0)
733:                             break;
734:                     }
735:                 
736:                     /* Now, call the real file open function */
737:                 
738:                     if(disk->fsFunctions->open == NULL)
9D00B7E4  0B402E07   J 0x9D00B81C
9D00B7E8  8D030008   LW V1, 8(T0)
9D00B818  8D030008   LW V1, 8(T0)
9D00B81C  8C620008   LW V0, 8(V1)
9D00B820  14400007   BNE V0, ZERO, 0x9D00B840
9D00B824  2E220006   SLTIU V0, S1, 6
739:                     {
740:                         errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
9D00B828  24020017   ADDIU V0, ZERO, 23
9D00B82C  AF8280AC   SW V0, -32596(GP)
741:                         obj->inUse = false;
9D00B830  3C028000   LUI V0, -32768
9D00B834  A04007CC   SB ZERO, 1996(V0)
742:                         return (SYS_FS_HANDLE_INVALID);
9D00B838  0B402E51   J 0x9D00B944
9D00B83C  2403FFFF   ADDIU V1, ZERO, -1
743:                     }
744:                     /* Convert the SYS_FS file open attributes to FAT FS attributes */
745:                     switch(attributes)
9D00B840  10400014   BEQ V0, ZERO, 0x9D00B894
9D00B844  00112080   SLL A0, S1, 2
9D00B848  3C029D01   LUI V0, -25343
9D00B84C  2442B85C   ADDIU V0, V0, -18340
9D00B850  7C44100A   LWX V0, A0(V0)
9D00B854  00400008   JR V0
9D00B858  00000000   NOP
746:                     {
747:                         case SYS_FS_FILE_OPEN_READ:
748:                             mode = FA_READ;
9D00B874  0B402E28   J SYS_FS_FileOpen::OSAL_MUTEX_Lock
9D00B878  24060001   ADDIU A2, ZERO, 1
749:                             break;
750:                         case SYS_FS_FILE_OPEN_WRITE:
751:                              mode = FA_WRITE | FA_OPEN_ALWAYS;
9D00B89C  24060012   ADDIU A2, ZERO, 18
752:                             break;
753:                         case SYS_FS_FILE_OPEN_APPEND:
754:                             mode = FA_WRITE | FA_OPEN_ALWAYS;
755:                             break;
756:                         case SYS_FS_FILE_OPEN_READ_PLUS:
757:                             mode = FA_READ | FA_WRITE;
758:                             break;
9D00B87C  0B402E28   J SYS_FS_FileOpen::OSAL_MUTEX_Lock
9D00B880  24060003   ADDIU A2, ZERO, 3
759:                         case SYS_FS_FILE_OPEN_WRITE_PLUS:
760:                             mode = FA_READ | FA_WRITE | FA_OPEN_ALWAYS;
761:                             break;
9D00B884  0B402E28   J SYS_FS_FileOpen::OSAL_MUTEX_Lock
9D00B888  24060013   ADDIU A2, ZERO, 19
762:                         case SYS_FS_FILE_OPEN_APPEND_PLUS:
763:                             mode = FA_READ | FA_WRITE | FA_OPEN_ALWAYS;
764:                             break;
9D00B88C  0B402E28   J SYS_FS_FileOpen::OSAL_MUTEX_Lock
9D00B890  24060013   ADDIU A2, ZERO, 19
765:                         default:
766:                             mode = FA__ERROR;
767:                             break;
9D00B894  0B402E28   J SYS_FS_FileOpen::OSAL_MUTEX_Lock
9D00B898  24060080   ADDIU A2, ZERO, 128
768:                     }
769:                 
770:                     if (OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
771:                     {
772:                         fileStatus = disk->fsFunctions->open((uintptr_t)&obj->nativeFSFileObj, (const char *)pathWithDiskNo, mode);
9D00B8B4  8C620008   LW V0, 8(V1)
9D00B8B8  3C048000   LUI A0, -32768
9D00B8BC  248407D4   ADDIU A0, A0, 2004
9D00B8C0  0040F809   JALR V0
9D00B8C4  27A50010   ADDIU A1, SP, 16
773:                         OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
774:                     }
775:                 
776:                     if (fileStatus != 0)
9D00B8D0  10400003   BEQ V0, ZERO, 0x9D00B8E0
9D00B8D4  A0640011   SB A0, 17(V1)
777:                     {
778:                 	    /* File open failed. */
779:                         errorValue = fileStatus;
9D00B8D8  0B402E44   J 0x9D00B910
9D00B8DC  AF8280AC   SW V0, -32596(GP)
780:                     }
781:                     else
782:                     {
783:                         if ((SYS_FS_FILE_OPEN_APPEND == attributes) || (SYS_FS_FILE_OPEN_APPEND_PLUS == attributes))
9D00B8E0  24020002   ADDIU V0, ZERO, 2
9D00B8E4  12220003   BEQ S1, V0, 0x9D00B8F4
9D00B8E8  24020005   ADDIU V0, ZERO, 5
9D00B8EC  1622000C   BNE S1, V0, 0x9D00B920
9D00B8F0  3C038000   LUI V1, -32768
784:                         {
785:                             fileStatus = SYS_FS_FileSeek((SYS_FS_HANDLE)obj, 0, SYS_FS_SEEK_END);
9D00B8F4  3C048000   LUI A0, -32768
9D00B8F8  248407CC   ADDIU A0, A0, 1996
9D00B8FC  00002821   ADDU A1, ZERO, ZERO
9D00B900  0F403FDB   JAL SYS_FS_FileSeek
9D00B904  24060002   ADDIU A2, ZERO, 2
786:                         }
787:                     }
788:                 
789:                     if (fileStatus != 0)
9D00B908  50400005   BEQL V0, ZERO, 0x9D00B920
9D00B90C  3C038000   LUI V1, -32768
790:                     {
791:                 	    /* File open/seek failed. */
792:                         obj->inUse = false;
9D00B910  3C028000   LUI V0, -32768
9D00B914  A04007CC   SB ZERO, 1996(V0)
793:                         return (SYS_FS_HANDLE_INVALID);
9D00B918  0B402E51   J 0x9D00B944
9D00B91C  2403FFFF   ADDIU V1, ZERO, -1
794:                     }
795:                 
796:                     return ((SYS_FS_HANDLE)obj);
9D00B920  0B402E51   J 0x9D00B944
9D00B924  246307CC   ADDIU V1, V1, 1996
797:                 }
9D00B944  00601021   ADDU V0, V1, ZERO
798:                 
799:                 //******************************************************************************
800:                 /*Function:
801:                     bool SYS_FS_FileNameGet(SYS_FS_HANDLE handle, uint8_t* cName, uint16_t wLen)
802:                 
803:                     Summary:
804:                         Reads the file name.
805:                 
806:                     Description:
807:                         Reads the file name of a file that is already open.
808:                 
809:                     Precondition:
810:                         The file handle referenced by handle is already open.
811:                 
812:                     Parameters:
813:                         handle 	- file handle obtaind during file Open.
814:                  	cName - where to store the name of the file.
815:                 	wLen - the maximum length of data to store in cName.
816:                 
817:                     Returns:
818:                 		If Success	-
819:                 
820:                 			The file name was successfully located	- true
821:                 
822:                         	If Failure
823:                                         The file handle provided is not currently open	- false
824:                 
825:                 		The reason for failure could be retrieved with SYS_FS_Error
826:                 
827:                   Remarks:
828:                 	None
829:                 ***************************************************************************/
830:                 bool SYS_FS_FileNameGet(SYS_FS_HANDLE handle, uint8_t* cName, uint16_t wLen)
831:                 {
832:                     SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
833:                     uint32_t j;
834:                 
835:                     if(handle == SYS_FS_HANDLE_INVALID)
00000000  00000000   NOP
836:                     {
837:                         errorValue = SYS_FS_ERROR_INVALID_OBJECT;
0000000C  00000000   NOP
838:                         return false;
00000014  00000000   NOP
839:                     }
840:                 
841:                     if(obj->inUse == false)
0000001C  00000000   NOP
842:                     {
843:                         errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000028  00000000   NOP
844:                         return false;
0000002C  00000000   NOP
845:                     }
846:                 
847:                     if(wLen > FAT_FS_MAX_LFN)
848:                     {
849:                         wLen = FAT_FS_MAX_LFN;
850:                     }
851:                 
852:                     for(j = 0;  j < wLen; j ++)
00000040  00000000   NOP
00000060  00000000   NOP
00000080  00000000   NOP
853:                     {
854:                         cName[j] = obj->fileName[j];
0000004C  00000000   NOP
0000006C  00000000   NOP
855:                         /* break, in case end of string reached */
856:                         if(obj->fileName[j] == '\0')
00000054  00000000   NOP
00000074  00000000   NOP
857:                             break;
858:                     }
859:                 
860:                     return true;
861:                 
862:                 }
0000008C  00000000   NOP
863:                 
864:                 //******************************************************************************
865:                 /*Function:
866:                     SYS_FS_RESULT SYS_FS_Unmount(const char *mountName);
867:                 
868:                 
869:                     Summary:
870:                         unmount filesystems
871:                 
872:                     Description:
873:                         remove the attachment of the (topmost) filesystem mounted on target
874:                 
875:                     Precondition:
876:                         none
877:                 
878:                     Parameters:
879:                         mountName - Mount name for the device to be mounted
880:                 
881:                     Returns:
882:                         If Success: SYS_FS_RES_SUCCESS
883:                         If Failure: SYS_FS_RES_FAILURE
884:                             Sets error code which can be retrieved with SYS_FS_Error
885:                 ***************************************************************************/
886:                 SYS_FS_RESULT SYS_FS_Unmount(const char *fname)
887:                 {
9D013E98  27BDFFE0   ADDIU SP, SP, -32
9D013E9C  AFBF001C   SW RA, 28(SP)
888:                     int fileStatus = -1;
889:                     SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
9D013EA0  AFA00010   SW ZERO, 16(SP)
890:                     uint32_t index = 0;
891:                 
892:                     /* Get disk number */
893:                     if(_SYS_FS_DiskGet(fname, &disk) == SYS_FS_RES_FAILURE)
9D013EA4  0F404F78   JAL _SYS_FS_DiskGet
9D013EA8  27A50010   ADDIU A1, SP, 16
9D013EAC  2403FFFF   ADDIU V1, ZERO, -1
9D013EB0  10430023   BEQ V0, V1, 0x9D013F40
9D013EB4  8FA30010   LW V1, 16(SP)
894:                     {
895:                         // reason or cause of error is alredy present in "errorValue" variable
896:                         return SYS_FS_RES_FAILURE;
9D013F40  2402FFFF   ADDIU V0, ZERO, -1
897:                     }
898:                 
899:                     /* Now, call the real file mount function */
900:                     if(disk->fsFunctions->unmount == NULL)
9D013EB8  8C620008   LW V0, 8(V1)
9D013EBC  8C420004   LW V0, 4(V0)
9D013EC0  14400005   BNE V0, ZERO, 0x9D013ED8
9D013EC4  00000000   NOP
901:                     {
902:                         errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
9D013EC8  24020017   ADDIU V0, ZERO, 23
9D013ECC  AF8280AC   SW V0, -32596(GP)
903:                         return SYS_FS_RES_FAILURE;
9D013ED0  0B404FD1   J 0x9D013F44
9D013ED4  2402FFFF   ADDIU V0, ZERO, -1
904:                     }
905:                 
906:                     fileStatus = disk->fsFunctions->unmount(disk->diskNumber);
9D013ED8  0040F809   JALR V0
9D013EDC  90640010   LBU A0, 16(V1)
907:                 
908:                     if(fileStatus == 0)
9D013EE0  14400014   BNE V0, ZERO, 0x9D013F34
9D013EE4  3C038000   LUI V1, -32768
909:                     {
910:                         for( index = 0; index != SYS_FS_MAX_FILES; index++ )
911:                         {
912:                             if(gSYSFSFileObj[index].mountPoint == disk)
9D013EE8  8FA20010   LW V0, 16(SP)
9D013EEC  8C6307D0   LW V1, 2000(V1)
9D013EF0  14620004   BNE V1, V0, 0x9D013F04
9D013EF4  3C038000   LUI V1, -32768
913:                             {
914:                                 gSYSFSFileObj[index].inUse = false;
9D013EF8  3C038000   LUI V1, -32768
9D013EFC  A06007CC   SB ZERO, 1996(V1)
915:                             }
916:                             if(gSYSFSDirObj[index].mountPoint == disk)
9D013F00  3C038000   LUI V1, -32768
9D013F04  8C6308E0   LW V1, 2272(V1)
9D013F08  54430004   BNEL V0, V1, 0x9D013F1C
9D013F0C  8FA20010   LW V0, 16(SP)
917:                             {
918:                                 gSYSFSDirObj[index].inUse = false;
9D013F10  3C028000   LUI V0, -32768
9D013F14  A04008DC   SB ZERO, 2268(V0)
919:                             }            
920:                         }       
921:                         disk->inUse = 0;
9D013F18  8FA20010   LW V0, 16(SP)
9D013F1C  A0400000   SB ZERO, 0(V0)
922:                         disk->mountName = NULL;
9D013F20  8FA20010   LW V0, 16(SP)
9D013F24  AC40000C   SW ZERO, 12(V0)
923:                         disk->fsFunctions = NULL;
9D013F28  AC400008   SW ZERO, 8(V0)
924:                         
925:                         OSAL_MUTEX_Delete(&disk->mutexDiskVolume);
926:                         
927:                         return SYS_FS_RES_SUCCESS;
9D013F2C  0B404FD1   J 0x9D013F44
9D013F30  00001021   ADDU V0, ZERO, ZERO
928:                     }
929:                     else
930:                     {
931:                         errorValue = fileStatus;
9D013F34  AF8280AC   SW V0, -32596(GP)
932:                         return SYS_FS_RES_FAILURE;
9D013F38  0B404FD1   J 0x9D013F44
9D013F3C  2402FFFF   ADDIU V0, ZERO, -1
933:                     }
934:                 
935:                 }
9D013F44  8FBF001C   LW RA, 28(SP)
936:                 
937:                 //******************************************************************************
938:                 /* Function:
939:                 	size_t SYS_FS_FileRead(SYS_FS_HANDLE handle, void *buf, size_t nbyte)
940:                 
941:                 
942:                   Summary:
943:                      Read specified bytes from a file
944:                 
945:                   Description:
946:                 	The SYS_FS_FileRead() function shall attempt to read nbyte bytes from the file associated with
947:                 	the open file handle into the buffer pointed to by buf.
948:                 
949:                   Precondition:
950:                     A valid file handle must be obtained before reading a file.
951:                 
952:                   Parameters:
953:                         handle			- File handle obtained during file open.
954:                 		buf				- Pointer to buffer in which data is read into.
955:                 		nbyte			- No of bytes to be read
956:                 
957:                 
958:                   Returns:
959:                         If Success: The number of bytes read (0 or positive number)
960:                         If Failure: -1
961:                 
962:                   Remarks:
963:                 	None
964:                 */
965:                 size_t SYS_FS_FileRead
966:                 (
967:                     SYS_FS_HANDLE handle,
968:                     void *buffer,
969:                     size_t nbyte
970:                  )
971:                 {
00000000  00000000   NOP
972:                     int fileStatus = -1;
973:                     SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
974:                     uint32_t nosOfDataRead = 0;
975:                 
976:                     if(handle == SYS_FS_HANDLE_INVALID)
00000010  00000000   NOP
977:                     {
978:                         errorValue = SYS_FS_ERROR_INVALID_OBJECT;
0000001C  00000000   NOP
979:                         return -1;
00000024  00000000   NOP
980:                     }
981:                 
982:                     if(obj->inUse == 0)
0000002C  00000000   NOP
983:                     {
984:                         errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000038  00000000   NOP
985:                         return -1;
0000003C  00000000   NOP
986:                     }
987:                 
988:                     /* Now, call the real file open function */
989:                 
990:                     if(obj->mountPoint->fsFunctions->read == NULL)
00000044  00000000   NOP
991:                     {
992:                         obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000058  00000000   NOP
993:                         return -1;
00000060  00000000   NOP
994:                     }
995:                     /* Protect the read from simultaneous access */
996:                     if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
997:                     {
998:                         fileStatus = 	obj->mountPoint->fsFunctions->read(obj->nativeFSFileObj, buffer,
00000078  00000000   NOP
999:                             nbyte, &nosOfDataRead);
1000:                
1001:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
00000090  00000000   NOP
1002:                    }
1003:                
1004:                    if(fileStatus == 0)
00000098  00000000   NOP
1005:                    {
1006:                        return nosOfDataRead;
000000A0  00000000   NOP
1007:                    }
1008:                    else
1009:                    {
1010:                        obj->errorValue = fileStatus;
000000A8  00000000   NOP
1011:                        return -1;
000000AC  00000000   NOP
1012:                    }
1013:                }
000000B0  00000000   NOP
1014:                
1015:                //******************************************************************************
1016:                /* Function:
1017:                	size_t SYS_FS_FileWrite(SYS_FS_HANDLE handle, const void *buf, size_t nbyte)
1018:                
1019:                  Summary:
1020:                     Write on the file
1021:                
1022:                  Description:
1023:                	The SYS_FS_FileWrite() function shall attempt to write nbyte bytes from the buffer pointed to by buf to
1024:                	the file associated with the open file handle.
1025:                
1026:                  Precondition:
1027:                    A valid file handle must be obtained before reading a file.
1028:                
1029:                  Parameters:
1030:                        handle			- File handle obtained during file open.
1031:                		buf				- Pointer to buffer from which data is to be written
1032:                		nbyte			- No of bytes to be written
1033:                
1034:                
1035:                  Returns:
1036:                        If Success: The number of bytes written (0 or positive number)
1037:                        If Failure: -1
1038:                
1039:                  Remarks:
1040:                	None
1041:                */
1042:                size_t SYS_FS_FileWrite( SYS_FS_HANDLE handle, const void *buffer, size_t nbyte)
1043:                {
9D013BAC  27BDFFE0   ADDIU SP, SP, -32
9D013BB0  AFBF001C   SW RA, 28(SP)
9D013BB4  AFB00018   SW S0, 24(SP)
9D013BB8  00808021   ADDU S0, A0, ZERO
1044:                    int fileStatus = -1;
1045:                    SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
1046:                    uint32_t nosOfDataWritten = 0;
1047:                
1048:                    if(handle == SYS_FS_HANDLE_INVALID){
9D013BBC  2402FFFF   ADDIU V0, ZERO, -1
9D013BC0  14820005   BNE A0, V0, 0x9D013BD8
9D013BC4  AFA00010   SW ZERO, 16(SP)
1049:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
9D013BC8  24020009   ADDIU V0, ZERO, 9
9D013BCC  AF8280AC   SW V0, -32596(GP)
1050:                        return -1;
9D013BD0  0B404F17   J 0x9D013C5C
9D013BD4  2402FFFF   ADDIU V0, ZERO, -1
1051:                    }
1052:                
1053:                    if(obj->inUse == 0){
9D013BD8  90820000   LBU V0, 0(A0)
9D013BDC  14400004   BNE V0, ZERO, 0x9D013BF0
9D013BE0  24020009   ADDIU V0, ZERO, 9
1054:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
9D013BE4  AF8280AC   SW V0, -32596(GP)
1055:                        return -1;
9D013BE8  0B404F17   J 0x9D013C5C
9D013BEC  2402FFFF   ADDIU V0, ZERO, -1
1056:                    }
1057:                
1058:                    /* Now, call the real file open function */
1059:                    if(obj->mountPoint->fsFunctions->write == NULL){
9D013BF0  8C830004   LW V1, 4(A0)
9D013BF4  8C620008   LW V0, 8(V1)
9D013BF8  8C420010   LW V0, 16(V0)
9D013BFC  54400005   BNEL V0, ZERO, SYS_FS_FileWrite::OSAL_MUTEX_Lock
9D013C00  90670011   LBU A3, 17(V1)
1060:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
9D013C04  24020017   ADDIU V0, ZERO, 23
9D013C08  AC82010C   SW V0, 268(A0)
1061:                        return -1;
9D013C0C  0B404F17   J 0x9D013C5C
9D013C10  2402FFFF   ADDIU V0, ZERO, -1
1062:                    }
1063:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE){
1064:                        fileStatus = obj->mountPoint->fsFunctions->write(obj->nativeFSFileObj, buffer, nbyte, &nosOfDataWritten);
9D013C24  8E020004   LW V0, 4(S0)
9D013C28  8C420008   LW V0, 8(V0)
9D013C2C  8C420010   LW V0, 16(V0)
9D013C30  8E040008   LW A0, 8(S0)
9D013C34  0040F809   JALR V0
9D013C38  27A70010   ADDIU A3, SP, 16
1065:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
9D013C3C  8E030004   LW V1, 4(S0)
1066:                    }
1067:                
1068:                    if(fileStatus == 0)
9D013C44  14400003   BNE V0, ZERO, 0x9D013C54
9D013C48  A0640011   SB A0, 17(V1)
1069:                    {
1070:                        return nosOfDataWritten;
9D013C4C  0B404F17   J 0x9D013C5C
9D013C50  8FA20010   LW V0, 16(SP)
1071:                    }
1072:                    else
1073:                    {
1074:                        obj->errorValue = fileStatus;
9D013C54  AE02010C   SW V0, 268(S0)
1075:                        return -1;
9D013C58  2402FFFF   ADDIU V0, ZERO, -1
1076:                    }
1077:                }
9D013C5C  8FBF001C   LW RA, 28(SP)
1078:                
1079:                //******************************************************************************
1080:                /* Function:
1081:                	int SYS_FS_FileSeek(SYS_FS_HANDLE handle, int offset, SYS_FS_FILE_SEEK_CONTROL whence)
1082:                
1083:                  Summary:
1084:                     Move the read/write file pointer
1085:                
1086:                  Description:
1087:                	The SYS_FS_FileSeek() function shall set the file offset for the open file description associated with
1088:                	the file handle, as follows:
1089:                
1090:                    If whence is SYS_FS_SEEK_SET, the file offset shall be set to offset bytes from the begining.
1091:                    If whence is SYS_FS_SEEK_CUR, the file offset shall be set to its current location plus offset.
1092:                    If whence is SYS_FS_SEEK_END, the file offset shall be set to the size of the file plus offset.
1093:                
1094:                	The behavior of SYS_FS_FileSeek() on devices which are incapable of seeking is implementation-defined.
1095:                	The value of the file offset associated with such a device is undefined.
1096:                
1097:                  Precondition:
1098:                    None.
1099:                
1100:                  Parameters:
1101:                    handle				- A valid file handle
1102:                	offset				- The number of bytes which act as file offset
1103:                	whence				- File seek control input
1104:                
1105:                  Returns:
1106:                        If Success: The number of bytes written (0 or positive number)
1107:                        If Failure: -1
1108:                
1109:                  Remarks:
1110:                	None
1111:                */
1112:                int32_t SYS_FS_FileSeek
1113:                (
1114:                    SYS_FS_HANDLE handle,
1115:                    int32_t offset,
1116:                    SYS_FS_FILE_SEEK_CONTROL whence
1117:                 )
1118:                {
9D00FF6C  27BDFFE0   ADDIU SP, SP, -32
9D00FF70  AFBF001C   SW RA, 28(SP)
9D00FF74  AFB10018   SW S1, 24(SP)
9D00FF78  AFB00014   SW S0, 20(SP)
1119:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
9D01001C  0B404029   J 0x9D0100A4
9D010020  24020003   ADDIU V0, ZERO, 3
1120:                    SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
1121:                    long tell = 0;
1122:                    uint32_t size = 0;
1123:                    int temp;
1124:                
1125:                    if(handle == SYS_FS_HANDLE_INVALID)
9D00FF7C  2402FFFF   ADDIU V0, ZERO, -1
9D00FF80  14820005   BNE A0, V0, 0x9D00FF98
9D00FF84  00808021   ADDU S0, A0, ZERO
1126:                    {
1127:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
9D00FF88  24020009   ADDIU V0, ZERO, 9
9D00FF8C  AF8280AC   SW V0, -32596(GP)
1128:                        return -1;
9D00FF90  0B404032   J 0x9D0100C8
9D00FF94  2402FFFF   ADDIU V0, ZERO, -1
1129:                    }
1130:                
1131:                    if(obj->inUse == 0)
9D00FF98  90820000   LBU V0, 0(A0)
9D00FF9C  54400005   BNEL V0, ZERO, 0x9D00FFB4
9D00FFA0  8C840004   LW A0, 4(A0)
1132:                    {
1133:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
9D00FFA4  24020009   ADDIU V0, ZERO, 9
9D00FFA8  AF8280AC   SW V0, -32596(GP)
1134:                        return -1;
9D00FFAC  0B404032   J 0x9D0100C8
9D00FFB0  2402FFFF   ADDIU V0, ZERO, -1
1135:                    }
1136:                
1137:                    if((obj->mountPoint->fsFunctions->seek == NULL) || (obj->mountPoint->fsFunctions->tell == NULL) ||
9D00FFB4  8C830008   LW V1, 8(A0)
9D00FFB8  8C620018   LW V0, 24(V1)
9D00FFBC  10400008   BEQ V0, ZERO, 0x9D00FFE0
9D00FFC0  24020017   ADDIU V0, ZERO, 23
9D00FFC4  8C62001C   LW V0, 28(V1)
9D00FFC8  10400005   BEQ V0, ZERO, 0x9D00FFE0
9D00FFCC  24020017   ADDIU V0, ZERO, 23
9D00FFD0  8C620024   LW V0, 36(V1)
9D00FFD4  14400005   BNE V0, ZERO, SYS_FS_FileSeek::OSAL_MUTEX_Lock
9D00FFD8  00A08821   ADDU S1, A1, ZERO
1138:                            (obj->mountPoint->fsFunctions->size == NULL))
1139:                    {
1140:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
9D00FFDC  24020017   ADDIU V0, ZERO, 23
9D00FFE0  AE02010C   SW V0, 268(S0)
1141:                        return -1;
9D00FFE4  0B404032   J 0x9D0100C8
9D00FFE8  2402FFFF   ADDIU V0, ZERO, -1
1142:                    }
1143:                
1144:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1145:                    {
1146:                        switch (whence)
9D00FFFC  24020001   ADDIU V0, ZERO, 1
9D010000  10C2000F   BEQ A2, V0, 0x9D010040
9D010004  A0800011   SB ZERO, 17(A0)
9D010008  50C00006   BEQL A2, ZERO, 0x9D010024
9D01000C  8E020004   LW V0, 4(S0)
9D010010  24020002   ADDIU V0, ZERO, 2
9D010014  50C20017   BEQL A2, V0, 0x9D010074
9D010018  8E020004   LW V0, 4(S0)
1147:                        {
1148:                            case SYS_FS_SEEK_SET:
1149:                                fileStatus = obj->mountPoint->fsFunctions->seek(obj->nativeFSFileObj, offset);
9D010024  8C420008   LW V0, 8(V0)
9D010028  8C420018   LW V0, 24(V0)
9D01002C  8E040008   LW A0, 8(S0)
9D010030  0040F809   JALR V0
9D010034  02202821   ADDU A1, S1, ZERO
1150:                                break;
9D010038  0B40402A   J SYS_FS_FileSeek::OSAL_MUTEX_Unlock
9D01003C  8E030004   LW V1, 4(S0)
1151:                            case SYS_FS_SEEK_CUR:
1152:                                tell = obj->mountPoint->fsFunctions->tell(obj->nativeFSFileObj);
9D010040  8E020004   LW V0, 4(S0)
9D010044  8C420008   LW V0, 8(V0)
9D010048  8C42001C   LW V0, 28(V0)
9D01004C  0040F809   JALR V0
9D010050  8E040008   LW A0, 8(S0)
1153:                                temp = (offset + tell);
1154:                                fileStatus = obj->mountPoint->fsFunctions->seek(obj->nativeFSFileObj, temp);
9D010054  8E030004   LW V1, 4(S0)
9D010058  8C630008   LW V1, 8(V1)
9D01005C  8C630018   LW V1, 24(V1)
9D010060  8E040008   LW A0, 8(S0)
9D010064  0060F809   JALR V1
9D010068  02222821   ADDU A1, S1, V0
1155:                                break;
9D01006C  0B40402A   J SYS_FS_FileSeek::OSAL_MUTEX_Unlock
9D010070  8E030004   LW V1, 4(S0)
1156:                            case SYS_FS_SEEK_END:
1157:                                size = obj->mountPoint->fsFunctions->size(obj->nativeFSFileObj);
9D010074  8C420008   LW V0, 8(V0)
9D010078  8C420024   LW V0, 36(V0)
9D01007C  0040F809   JALR V0
9D010080  8E040008   LW A0, 8(S0)
1158:                                temp = (offset + size);
1159:                                fileStatus = obj->mountPoint->fsFunctions->seek(obj->nativeFSFileObj, temp);
9D010084  8E030004   LW V1, 4(S0)
9D010088  8C630008   LW V1, 8(V1)
9D01008C  8C630018   LW V1, 24(V1)
9D010090  8E040008   LW A0, 8(S0)
9D010094  0060F809   JALR V1
9D010098  00512821   ADDU A1, V0, S1
1160:                                break;
9D01009C  0B40402A   J SYS_FS_FileSeek::OSAL_MUTEX_Unlock
9D0100A0  8E030004   LW V1, 4(S0)
1161:                        }
1162:                
1163:                       OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
9D0100A4  8E030004   LW V1, 4(S0)
1164:                    }
1165:                
1166:                
1167:                    if(fileStatus == 0)
9D0100AC  14400004   BNE V0, ZERO, 0x9D0100C0
9D0100B0  A0640011   SB A0, 17(V1)
1168:                    {
1169:                        /* This is success value, but required in special case, where requested offset was (-1) */
1170:                        obj->errorValue = SYS_FS_ERROR_OK;
9D0100B4  AE00010C   SW ZERO, 268(S0)
1171:                        return offset;
9D0100B8  0B404032   J 0x9D0100C8
9D0100BC  02201021   ADDU V0, S1, ZERO
1172:                    }
1173:                    else
1174:                    {
1175:                        obj->errorValue = fileStatus;
9D0100C0  AE02010C   SW V0, 268(S0)
1176:                        return -1;
9D0100C4  2402FFFF   ADDIU V0, ZERO, -1
1177:                    }
1178:                }
9D0100C8  8FBF001C   LW RA, 28(SP)
1179:                
1180:                //******************************************************************************
1181:                /*Function:
1182:                    int32_t SYS_FS_FileTell(SYS_FS_HANDLE handle)
1183:                
1184:                    Summary:
1185:                        Obtains the file pointer position
1186:                
1187:                    Description:
1188:                        Obtains the current value of the file position indicator for the
1189:                        handle pointed to by handle.
1190:                
1191:                    Precondition:
1192:                        none
1193:                
1194:                    Parameters:
1195:                        handle - File handle
1196:                
1197:                    Returns:
1198:                        If Success: current offset
1199:                        If Failure:  -1
1200:                            Sets error code which can be retrieved with SYS_FS_FileError
1201:                
1202:                  Remarks:
1203:                	None
1204:                
1205:                ***************************************************************************/
1206:                int32_t SYS_FS_FileTell
1207:                (
1208:                    SYS_FS_HANDLE handle
1209:                 )
1210:                {
00000000  00000000   NOP
1211:                    SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
1212:                    long status = -1;
1213:                
1214:                    if(handle == SYS_FS_HANDLE_INVALID)
00000004  00000000   NOP
1215:                    {
1216:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000010  00000000   NOP
1217:                        return -1;
00000018  00000000   NOP
1218:                    }
1219:                
1220:                    if(obj->inUse == 0)
00000020  00000000   NOP
1221:                    {
1222:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
0000002C  00000000   NOP
1223:                        return -1;
00000034  00000000   NOP
1224:                    }
1225:                
1226:                    if(obj->mountPoint->fsFunctions->tell == NULL)
0000003C  00000000   NOP
1227:                    {
1228:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
0000004C  00000000   NOP
1229:                        return -1;
00000054  00000000   NOP
1230:                    }
1231:                
1232:                    status = obj->mountPoint->fsFunctions->tell(obj->nativeFSFileObj);
0000005C  00000000   NOP
1233:                
1234:                    return status;
1235:                }
00000064  00000000   NOP
1236:                
1237:                //******************************************************************************
1238:                /*Function:
1239:                    int32_t SYS_FS_FileSize( SYS_FS_HANDLE handle )
1240:                
1241:                    Summary:
1242:                    Returns the size of the file
1243:                
1244:                    Description:
1245:                        Returns the size of the file as pointed by the handle.
1246:                
1247:                    Precondition:
1248:                        none
1249:                
1250:                    Parameters:
1251:                        handle - File handle
1252:                
1253:                    Returns:
1254:                        If Success: file size
1255:                        If Failure: -1
1256:                			Sets error code which can be retrieved with SYS_FS_FileError
1257:                
1258:                  Remarks:
1259:                	None
1260:                ***************************************************************************/
1261:                int32_t SYS_FS_FileSize
1262:                (
1263:                    SYS_FS_HANDLE handle
1264:                 )
1265:                {
00000000  00000000   NOP
1266:                    SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
1267:                    long status = -1;
1268:                
1269:                    if(handle == SYS_FS_HANDLE_INVALID)
00000004  00000000   NOP
1270:                    {
1271:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000010  00000000   NOP
1272:                        return -1;
00000018  00000000   NOP
1273:                    }
1274:                
1275:                    if(obj->inUse == 0)
00000020  00000000   NOP
1276:                    {
1277:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
0000002C  00000000   NOP
1278:                        return -1;
00000034  00000000   NOP
1279:                    }
1280:                
1281:                    if(obj->mountPoint->fsFunctions->size == NULL)
0000003C  00000000   NOP
1282:                    {
1283:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
0000004C  00000000   NOP
1284:                        return -1;
00000054  00000000   NOP
1285:                    }
1286:                
1287:                    status = obj->mountPoint->fsFunctions->size(obj->nativeFSFileObj);
0000005C  00000000   NOP
1288:                
1289:                    return status;
1290:                }
00000064  00000000   NOP
1291:                
1292:                //******************************************************************************
1293:                /*Function:
1294:                    bool SYS_FS_FileEOF(SYS_FS_HANDLE handle)
1295:                
1296:                    Summary:
1297:                        check handle status
1298:                
1299:                    Description:
1300:                        Checks weather or not the file position indicator is at the end of
1301:                        the file.
1302:                
1303:                    Precondition:
1304:                        none
1305:                
1306:                    Parameters:
1307:                        handle - file handle
1308:                
1309:                    Returns:
1310:                		When file pointer not reached the end of file:	false
1311:                		When file pointer reached the end of file:		true
1312:                		When failure:						false
1313:                			Sets error code which can be retrieved with SYS_FS_FileError
1314:                  Remarks:
1315:                	None
1316:                ***************************************************************************/
1317:                bool SYS_FS_FileEOF
1318:                (
1319:                    SYS_FS_HANDLE handle
1320:                 )
1321:                {
00000000  00000000   NOP
1322:                    SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
1323:                    volatile bool status = -1;
00000010  00000000   NOP
1324:                
1325:                    if(handle == SYS_FS_HANDLE_INVALID)
00000018  00000000   NOP
1326:                    {
1327:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000024  00000000   NOP
1328:                        return -1;
0000002C  00000000   NOP
1329:                    }
1330:                
1331:                    if(obj->inUse == 0)
00000034  00000000   NOP
1332:                    {
1333:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
0000003C  00000000   NOP
1334:                        return false;
00000040  00000000   NOP
1335:                    }
1336:                
1337:                    if(obj->mountPoint->fsFunctions->eof == NULL)
00000048  00000000   NOP
1338:                    {
1339:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000058  00000000   NOP
1340:                        return false;
00000060  00000000   NOP
1341:                    }
1342:                
1343:                    status = obj->mountPoint->fsFunctions->eof(obj->nativeFSFileObj);
00000068  00000000   NOP
1344:                
1345:                    /* This is success value, but required in special case, where requested offset was (-1) */
1346:                    obj->errorValue = SYS_FS_ERROR_OK;
00000074  00000000   NOP
1347:                    return (bool)status;
00000078  00000000   NOP
1348:                }
00000080  00000000   NOP
1349:                
1350:                //******************************************************************************
1351:                /* Function:
1352:                	SYS_FS_RESULT SYS_FS_FileStat(const char* path, SYS_FS_FSTAT *buf)
1353:                
1354:                  Summary:
1355:                     Get file status
1356:                
1357:                  Description:
1358:                	The SYS_FS_FileStat() function shall obtain information about a file associated
1359:                	with the file name, and shall write it to the area pointed to by buf.
1360:                
1361:                	The buf argument is a pointer to a SYS_FS_FSTAT structure,into which information
1362:                	is placed concerning the file.
1363:                
1364:                	This function can read the status of file irrespective of a file is opened or not.
1365:                
1366:                  Precondition:
1367:                    None.
1368:                
1369:                  Parameters:
1370:                    path      	     			- Path to the file
1371:                	buf							- pointer to SYS_FS_FSTAT variable
1372:                
1373:                  Returns:
1374:                        If Success: SYS_FS_RES_SUCCESS
1375:                        If Failure: SYS_FS_RES_FAILURE
1376:                
1377:                  Remarks:
1378:                	None
1379:                */
1380:                
1381:                SYS_FS_RESULT SYS_FS_FileStat
1382:                (
1383:                    const char *fname,
1384:                    SYS_FS_FSTAT *buf
1385:                )
1386:                {
00000000  00000000   NOP
1387:                    int fileStatus = -1;
1388:                    uint8_t pathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
00000018  00000000   NOP
1389:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000028  00000000   NOP
1390:                
1391:                    /* Get disk number */
1392:                    /* There is possibility of data corruption inside _SYS_FS_DiskGet()\
1393:                     * If the unmount API is called from another task when gSYSFSMountPoint
1394:                     * is being accessed by one task. This can be a restriction for application
1395:                     */
1396:                    if(_SYS_FS_DiskGet(fname, &disk) == SYS_FS_RES_FAILURE)
0000002C  00000000   NOP
1397:                    {
1398:                        // reason or cause of error is alredy present in "errorValue" variable
1399:                        return SYS_FS_RES_FAILURE;
000000D0  00000000   NOP
1400:                    }
1401:                
1402:                    /* Now, get the file name with disk number appended in front like this "0:file.txt" */
1403:                    if (_SYS_FS_DiskNumberAppend(fname, (uint8_t)disk->diskNumber, pathWithDiskNo) == false)
00000044  00000000   NOP
1404:                    {
1405:                        errorValue = SYS_FS_ERROR_INVALID_NAME;
0000005C  00000000   NOP
1406:                        return SYS_FS_RES_FAILURE;
00000064  00000000   NOP
1407:                    }
1408:                
1409:                    if(disk->fsFunctions->fstat == NULL)
0000006C  00000000   NOP
1410:                    {
1411:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
0000007C  00000000   NOP
1412:                        return SYS_FS_RES_FAILURE;
00000084  00000000   NOP
1413:                    }
1414:                
1415:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1416:                    {
1417:                        fileStatus = disk->fsFunctions->fstat((const char *)pathWithDiskNo, (uintptr_t)buf);
0000009C  00000000   NOP
1418:                
1419:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
1420:                    }
1421:                    if(fileStatus == 0)
000000BC  00000000   NOP
1422:                    {
1423:                        return SYS_FS_RES_SUCCESS;
1424:                    }
1425:                    else
1426:                    {
1427:                        errorValue = fileStatus;
000000C4  00000000   NOP
1428:                        return SYS_FS_RES_FAILURE;
000000C8  00000000   NOP
1429:                    }
1430:                }
000000D4  00000000   NOP
1431:                
1432:                //******************************************************************************
1433:                /* Function:
1434:                	SYS_FS_RESULT SYS_FS_FileClose(SYS_FS_HANDLE handle);
1435:                
1436:                  Summary:
1437:                     Close a file descriptor
1438:                
1439:                  Description:
1440:                	The SYS_FS_FileClose() function closes an opened file
1441:                
1442:                  Precondition:
1443:                    None.
1444:                
1445:                  Parameters:
1446:                    handle			- A valid handle, which was obtained while opening the file.
1447:                
1448:                  Returns:
1449:                        If Success: SYS_FS_RES_SUCCESS
1450:                        If Failure: SYS_FS_RES_FAILURE
1451:                
1452:                  Remarks:
1453:                	None
1454:                */
1455:                SYS_FS_RESULT SYS_FS_FileClose
1456:                (
1457:                 SYS_FS_HANDLE handle
1458:                 )
1459:                {
9D013F50  27BDFFE8   ADDIU SP, SP, -24
9D013F54  AFBF0014   SW RA, 20(SP)
9D013F58  AFB00010   SW S0, 16(SP)
1460:                    int fileStatus = -1;;
1461:                    SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
1462:                
1463:                    if(handle == SYS_FS_HANDLE_INVALID)
9D013F5C  2402FFFF   ADDIU V0, ZERO, -1
9D013F60  14820005   BNE A0, V0, 0x9D013F78
9D013F64  00808021   ADDU S0, A0, ZERO
1464:                    {
1465:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
9D013F68  24020009   ADDIU V0, ZERO, 9
9D013F6C  AF8280AC   SW V0, -32596(GP)
1466:                        return SYS_FS_RES_FAILURE;
9D013F70  0B404FFE   J 0x9D013FF8
9D013F74  2402FFFF   ADDIU V0, ZERO, -1
1467:                    }
1468:                
1469:                    if(obj->inUse == false)
9D013F78  90820000   LBU V0, 0(A0)
9D013F7C  54400005   BNEL V0, ZERO, 0x9D013F94
9D013F80  8C830004   LW V1, 4(A0)
1470:                    {
1471:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
9D013F84  24020009   ADDIU V0, ZERO, 9
9D013F88  AF8280AC   SW V0, -32596(GP)
1472:                        SYS_ASSERT(false,"File object is not in use");
1473:                        return SYS_FS_RES_FAILURE;
9D013F8C  0B404FFE   J 0x9D013FF8
9D013F90  2402FFFF   ADDIU V0, ZERO, -1
1474:                    }
1475:                
1476:                    if(obj->mountPoint->fsFunctions->close == NULL)
9D013F94  8C620008   LW V0, 8(V1)
9D013F98  8C420014   LW V0, 20(V0)
9D013F9C  54400005   BNEL V0, ZERO, SYS_FS_FileClose::OSAL_MUTEX_Lock
9D013FA0  90650011   LBU A1, 17(V1)
1477:                    {
1478:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
9D013FA4  24020017   ADDIU V0, ZERO, 23
9D013FA8  AC82010C   SW V0, 268(A0)
1479:                        return SYS_FS_RES_FAILURE;
9D013FAC  0B404FFE   J 0x9D013FF8
9D013FB0  2402FFFF   ADDIU V0, ZERO, -1
1480:                    }
1481:                
1482:                    /* Now, call the real file open function */
1483:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1484:                    {
1485:                        fileStatus = obj->mountPoint->fsFunctions->close(obj->nativeFSFileObj);
9D013FC4  8E020004   LW V0, 4(S0)
9D013FC8  8C420008   LW V0, 8(V0)
9D013FCC  8C420014   LW V0, 20(V0)
9D013FD0  0040F809   JALR V0
9D013FD4  8E040008   LW A0, 8(S0)
1486:                
1487:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
9D013FD8  8E030004   LW V1, 4(S0)
1488:                    }
1489:                    if(fileStatus == 0)
9D013FE0  14400003   BNE V0, ZERO, 0x9D013FF0
9D013FE4  A0640011   SB A0, 17(V1)
1490:                    {
1491:                        /* Return the SYS_FS file system object. */
1492:                        obj->inUse = false;
1493:                        return SYS_FS_RES_SUCCESS;
9D013FE8  0B404FFE   J 0x9D013FF8
9D013FEC  A2000000   SB ZERO, 0(S0)
1494:                    }
1495:                    else
1496:                    {
1497:                        obj->errorValue = fileStatus;
9D013FF0  AE02010C   SW V0, 268(S0)
1498:                        return SYS_FS_RES_FAILURE;
9D013FF4  2402FFFF   ADDIU V0, ZERO, -1
1499:                    }
1500:                
1501:                    /* Do the following in disk un-mount only */
1502:                    //	sysFsObject[mountPoint].inUse = 0;
1503:                }
9D013FF8  8FBF0014   LW RA, 20(SP)
1504:                
1505:                //******************************************************************************
1506:                /*Function:
1507:                    SYS_FS_ERROR SYS_FS_Error(void)
1508:                
1509:                    Summary:
1510:                        check the type of error
1511:                
1512:                    Description:
1513:                        When a file system operation fails, the application can know the exact
1514:                        reason of failure by calling the SYS_FS_Error. This function only reports
1515:                        the errors which are not file (or file handle) specific. For example, for
1516:                        functions such as SYS_FS_Mount and SYS_FS_FileOpen, which do not take handle,
1517:                        any errors happening inside such function calls could be reported using
1518:                        SYS_FS_Error function. Even for functions, which take handle as its input
1519:                        parameters, the SYS_FS_Error function can be used to report the type of
1520:                        error for cases where the passed handle itself is invalid.
1521:                
1522:                    Precondition:
1523:                        none
1524:                
1525:                    Parameters:
1526:                        none
1527:                
1528:                    Returns:
1529:                		Error code of type SYS_FS_ERROR
1530:                
1531:                  Remarks:
1532:                	None
1533:                ***************************************************************************/
1534:                SYS_FS_ERROR SYS_FS_Error(void)
1535:                {
1536:                    return errorValue;
1537:                }
1538:                
1539:                //******************************************************************************
1540:                /*Function:
1541:                    SYS_FS_ERROR SYS_FS_FileError(SYS_FS_HANDLE handle)
1542:                
1543:                    Summary:
1544:                        check the type of file specific error
1545:                
1546:                    Description:
1547:                        For file system functions which accepts valid handle, any error happening
1548:                        in those functions could be retrived with SYS_FS_FileError. This function
1549:                        returns errors which are file specific.
1550:                
1551:                        Please note that if an invalid handle is passed to a file system function,
1552:                        in such a case, SYS_FS_FileError will not return the correct type of error,
1553:                        as the handle was invalid. Hence it would be prudent to check the errors
1554:                        using the SYS_FS_Error function.
1555:                
1556:                    Precondition:
1557:                        This function has to be called immediately after a failure is observed while doing
1558:                        a file operation. Any subsequent failure will overwrite the cause
1559:                        of pervious failure.
1560:                
1561:                    Parameters:
1562:                        handle      -   A valid file handle
1563:                
1564:                    Returns:
1565:                		Error code of type SYS_FS_ERROR
1566:                
1567:                  Remarks:
1568:                	None
1569:                ***************************************************************************/
1570:                SYS_FS_ERROR SYS_FS_FileError(SYS_FS_HANDLE handle)
1571:                {
1572:                    SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
1573:                
1574:                    if(handle == SYS_FS_HANDLE_INVALID)
00000000  00000000   NOP
1575:                    {
1576:                        return SYS_FS_ERROR_INVALID_OBJECT;
1577:                    }
1578:                
1579:                    if(obj->inUse == false)
0000000C  00000000   NOP
1580:                    {
1581:                        return SYS_FS_ERROR_INVALID_OBJECT;
1582:                    }
1583:                
1584:                    return obj->errorValue;
1585:                }
00000018  00000000   NOP
1586:                // *****************************************************************************
1587:                /* Function:
1588:                    void SYS_FS_Tasks ( void )
1589:                
1590:                  Summary:
1591:                    Tasks for the sys_fs layer
1592:                
1593:                  Description:
1594:                    This routine is used to run the varioius tasks and functionalities of sys_fs
1595:                    layer.
1596:                
1597:                  Precondition:
1598:                    The SYS_FS_Initialize routine must have been called before running the tasks.
1599:                
1600:                  Parameters:
1601:                    None.
1602:                
1603:                  Returns:
1604:                    None
1605:                */
1606:                
1607:                void SYS_FS_Tasks ( void )
1608:                {
9D0170A4  27BDFFE8   ADDIU SP, SP, -24
9D0170A8  AFBF0014   SW RA, 20(SP)
1609:                    /* Task routine for media manager */
1610:                    SYS_FS_MEDIA_MANAGER_Tasks();
9D0170AC  0F400F28   JAL SYS_FS_MEDIA_MANAGER_Tasks
9D0170B0  00000000   NOP
1611:                }
9D0170B4  8FBF0014   LW RA, 20(SP)
1612:                //******************************************************************************
1613:                /*Function:
1614:                    SYS_FS_RESULT SYS_FS_DirectoryMake(const char* path)
1615:                
1616:                    Summary:
1617:                        Make directory
1618:                
1619:                    Description:
1620:                        Make a new directory as per the specified path.
1621:                
1622:                    Precondition:
1623:                        The disk has to be mounted before a directory could be made.
1624:                
1625:                    Parameters:
1626:                        path 	- A path for making the directory.
1627:                
1628:                    Returns:
1629:                        If Success	-	SYS_FS_RES_SUCCESS
1630:                
1631:                        If Failure	-	SYS_FS_RES_FAILURE
1632:                
1633:                		The reason for failure could be retrieved with SYS_FS_Error
1634:                  Remarks:
1635:                	None
1636:                ***************************************************************************/
1637:                SYS_FS_RESULT SYS_FS_DirectoryMake(const char* path)
1638:                {
00000000  00000000   NOP
1639:                    volatile int fileStatus = SYS_FS_ERROR_NOT_READY;
00000010  00000000   NOP
1640:                    uint8_t pathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
00000018  00000000   NOP
1641:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *)NULL;;
00000028  00000000   NOP
1642:                
1643:                
1644:                    /* Get disk number */
1645:                    if(_SYS_FS_DiskGet(path, &disk) == SYS_FS_RES_FAILURE)
0000002C  00000000   NOP
1646:                    {
1647:                        // reason or cause of error is alredy present in "errorValue" variable
1648:                        return SYS_FS_RES_FAILURE;
000000F0  00000000   NOP
1649:                    }
1650:                
1651:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
1652:                    if(disk->fsType == MPFS2)
00000044  00000000   NOP
1653:                    {
1654:                        errorValue = SYS_FS_ERROR_DENIED;
00000054  00000000   NOP
1655:                        return SYS_FS_RES_FAILURE;
0000005C  00000000   NOP
1656:                    }
1657:                
1658:                    /* Now, get the file name with disk number appended in front like this "0:file.txt" */
1659:                    if (_SYS_FS_DiskNumberAppend(path, (uint8_t)disk->diskNumber, pathWithDiskNo) == false)
00000064  00000000   NOP
1660:                    {
1661:                        errorValue = SYS_FS_ERROR_INVALID_NAME;
00000078  00000000   NOP
1662:                        return SYS_FS_RES_FAILURE;
00000080  00000000   NOP
1663:                    }
1664:                
1665:                    if(disk->fsFunctions->mkdir == NULL)
00000088  00000000   NOP
1666:                    {
1667:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000098  00000000   NOP
1668:                        return SYS_FS_RES_FAILURE;
000000A0  00000000   NOP
1669:                    }
1670:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1671:                    {
1672:                        fileStatus = disk->fsFunctions->mkdir((const char *)pathWithDiskNo);
000000B8  00000000   NOP
1673:                
1674:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
1675:                    }
1676:                
1677:                    if(fileStatus == 0)
000000D4  00000000   NOP
1678:                    {
1679:                        return SYS_FS_RES_SUCCESS;
1680:                    }
1681:                    else
1682:                    {
1683:                        errorValue = fileStatus;
000000E0  00000000   NOP
1684:                        return SYS_FS_RES_FAILURE;
000000E8  00000000   NOP
1685:                    }
1686:                }
000000F4  00000000   NOP
1687:                //******************************************************************************
1688:                /*Function:
1689:                    SYS_FS_RESULT SYS_FS_DirectoryChange(const char* path)
1690:                
1691:                    Summary:
1692:                        Change directory
1693:                
1694:                    Description:
1695:                        Change the present directory to a new directory.
1696:                
1697:                    Precondition:
1698:                        The disk has to be mounted before a directory could be made.
1699:                        The directory to be changed has to present.
1700:                
1701:                    Parameters:
1702:                        path 	- A path for changing the directory.
1703:                
1704:                    Returns:
1705:                        If Success	-	SYS_FS_RES_SUCCESS
1706:                
1707:                        If Failure	-	SYS_FS_RES_FAILURE
1708:                
1709:                		The reason for failure could be retrieved with SYS_FS_Error
1710:                  Remarks:
1711:                	None
1712:                ***************************************************************************/
1713:                SYS_FS_RESULT SYS_FS_DirectoryChange(const char* path)
1714:                {
00000000  00000000   NOP
1715:                    volatile int fileStatus = SYS_FS_ERROR_NOT_READY;
00000010  00000000   NOP
1716:                    uint8_t pathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
00000018  00000000   NOP
1717:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000028  00000000   NOP
1718:                
1719:                    /* Get disk number */
1720:                    if(_SYS_FS_DiskGet(path, &disk) == SYS_FS_RES_FAILURE)
0000002C  00000000   NOP
1721:                    {
1722:                        // reason or cause of error is alredy present in "errorValue" variable
1723:                        return SYS_FS_RES_FAILURE;
000000F0  00000000   NOP
1724:                    }
1725:                
1726:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
1727:                    if(disk->fsType == MPFS2)
00000044  00000000   NOP
1728:                    {
1729:                        errorValue = SYS_FS_ERROR_DENIED;
00000054  00000000   NOP
1730:                        return SYS_FS_RES_FAILURE;
0000005C  00000000   NOP
1731:                    }
1732:                
1733:                    /* Now, get the file name with disk number appended in front like this "0:file.txt" */
1734:                    if(_SYS_FS_DiskNumberAppend(path, (uint8_t)disk->diskNumber, pathWithDiskNo) == false)
00000064  00000000   NOP
1735:                    {
1736:                        errorValue = SYS_FS_ERROR_INVALID_NAME;
00000078  00000000   NOP
1737:                        return SYS_FS_RES_FAILURE;
00000080  00000000   NOP
1738:                    }
1739:                
1740:                    if(disk->fsFunctions->chdir == NULL)
00000088  00000000   NOP
1741:                    {
1742:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000098  00000000   NOP
1743:                        return SYS_FS_RES_FAILURE;
000000A0  00000000   NOP
1744:                    }
1745:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1746:                    {
1747:                        fileStatus = disk->fsFunctions->chdir((const char *)pathWithDiskNo);
000000B8  00000000   NOP
1748:                
1749:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
1750:                    }
1751:                
1752:                    if(fileStatus == 0)
000000D4  00000000   NOP
1753:                    {
1754:                        return SYS_FS_RES_SUCCESS;
1755:                    }
1756:                    else
1757:                    {
1758:                        errorValue = fileStatus;
000000E0  00000000   NOP
1759:                        return SYS_FS_RES_FAILURE;
000000E8  00000000   NOP
1760:                    }
1761:                }
000000F4  00000000   NOP
1762:                //******************************************************************************
1763:                /*Function:
1764:                    SYS_FS_RESULT SYS_FS_FileDirectoryRemove(const char* path)
1765:                
1766:                    Summary:
1767:                        Remove a file or directory
1768:                
1769:                    Description:
1770:                        Remove a file or directory as specified by the path.
1771:                
1772:                    Precondition:
1773:                        - The disk has to be mounted before a directory could be removed.
1774:                        - The file or directory to be removed has to present.
1775:                        - The file/sub-directory must not have read-only attribute (AM_RDO),
1776:                          or the function will be rejected with FR_DENIED.
1777:                        - The sub-directory must be empty and must not be current directory,
1778:                          or the function will be rejected with FR_DENIED.
1779:                        - The file/sub-directory must not be opened.
1780:                
1781:                    Parameters:
1782:                        path 	- A path for removing the file or directory.
1783:                
1784:                    Returns:
1785:                        If Success	-	SYS_FS_RES_SUCCESS
1786:                
1787:                        If Failure	-	SYS_FS_RES_FAILURE
1788:                
1789:                		The reason for failure could be retrieved with SYS_FS_Error
1790:                  Remarks:
1791:                	None
1792:                ***************************************************************************/
1793:                SYS_FS_RESULT SYS_FS_FileDirectoryRemove(const char* path)
1794:                {
00000000  00000000   NOP
1795:                    volatile int fileStatus = SYS_FS_ERROR_NOT_READY;
00000010  00000000   NOP
1796:                    uint8_t pathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
00000018  00000000   NOP
1797:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000028  00000000   NOP
1798:                
1799:                    /* Get disk number */
1800:                    if(_SYS_FS_DiskGet(path, &disk) == SYS_FS_RES_FAILURE)
0000002C  00000000   NOP
1801:                    {
1802:                        // reason or cause of error is alredy present in "errorValue" variable
1803:                        return SYS_FS_RES_FAILURE;
000000F0  00000000   NOP
1804:                    }
1805:                
1806:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
1807:                    if(disk->fsType == MPFS2)
00000044  00000000   NOP
1808:                    {
1809:                        errorValue = SYS_FS_ERROR_DENIED;
00000054  00000000   NOP
1810:                        return SYS_FS_RES_FAILURE;
0000005C  00000000   NOP
1811:                    }
1812:                
1813:                    /* Now, get the file name with disk number appended in front like this "0:file.txt" */
1814:                    if (_SYS_FS_DiskNumberAppend(path, (uint8_t)disk->diskNumber, pathWithDiskNo) == false)
00000064  00000000   NOP
1815:                    {
1816:                        errorValue = SYS_FS_ERROR_INVALID_NAME;
00000078  00000000   NOP
1817:                        return SYS_FS_RES_FAILURE;
00000080  00000000   NOP
1818:                    }
1819:                
1820:                    if(disk->fsFunctions->remove == NULL)
00000088  00000000   NOP
1821:                    {
1822:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000098  00000000   NOP
1823:                        return SYS_FS_RES_FAILURE;
000000A0  00000000   NOP
1824:                    }
1825:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1826:                    {
1827:                        fileStatus = disk->fsFunctions->remove((const char *)pathWithDiskNo);
000000B8  00000000   NOP
1828:                
1829:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
1830:                    }
1831:                    if(fileStatus == 0)
000000D4  00000000   NOP
1832:                    {
1833:                        return SYS_FS_RES_SUCCESS;
1834:                    }
1835:                    else
1836:                    {
1837:                        errorValue = fileStatus;
000000E0  00000000   NOP
1838:                        return SYS_FS_RES_FAILURE;
000000E8  00000000   NOP
1839:                    }
1840:                }
000000F4  00000000   NOP
1841:                //******************************************************************************
1842:                /*Function:
1843:                    SYS_FS_RESULT SYS_FS_CurrentDriveGet(char* buffer)
1844:                
1845:                    Summary:
1846:                        Get current drive
1847:                
1848:                    Description:
1849:                        Get the present drive being used and put the name of drive into the buffer.
1850:                
1851:                    Precondition:
1852:                        The disk has to be mounted before this funcion could be set.
1853:                
1854:                
1855:                    Parameters:
1856:                        Pointer to buffer which will hold the name of present drive being used.
1857:                
1858:                    Returns:
1859:                        If Success	-	SYS_FS_RES_SUCCESS
1860:                
1861:                        If Failure	-	SYS_FS_RES_FAILURE
1862:                
1863:                		The reason for failure could be retrieved with SYS_FS_Error
1864:                
1865:                    Remarks:
1866:                	None
1867:                ***************************************************************************/
1868:                SYS_FS_RESULT SYS_FS_CurrentDriveGet(char* buffer)
1869:                {
00000000  00000000   NOP
1870:                    const char *ptr = gSYSFSCurrentMountPoint.currentDisk->mountName;
00000008  00000000   NOP
1871:                    char *localBuffer = "/mnt/";
1872:                
1873:                    if(gSYSFSCurrentMountPoint.inUse == false)
00000010  00000000   NOP
1874:                    {
1875:                        errorValue = SYS_FS_ERROR_NO_FILESYSTEM;
0000001C  00000000   NOP
1876:                        return SYS_FS_RES_FAILURE;
00000024  00000000   NOP
1877:                    }
1878:                    strcpy(buffer, localBuffer);
0000002C  00000000   NOP
1879:                    strcat(buffer, ptr);
00000048  00000000   NOP
1880:                
1881:                    return SYS_FS_RES_SUCCESS;
00000050  00000000   NOP
1882:                
1883:                }
00000054  00000000   NOP
1884:                //******************************************************************************
1885:                /*Function:
1886:                    SYS_FS_RESULT SYS_FS_CurrentDriveSet(const char* path)
1887:                
1888:                    Summary:
1889:                        Set directory
1890:                
1891:                    Description:
1892:                        Set the present directory to the one as specified by the path.
1893:                
1894:                    Precondition:
1895:                        The disk has to be mounted before it could be set.
1896:                
1897:                
1898:                    Parameters:
1899:                        path 	- A path for the drive to be set.
1900:                
1901:                    Returns:
1902:                        If Success	-	SYS_FS_RES_SUCCESS
1903:                
1904:                        If Failure	-	SYS_FS_RES_FAILURE
1905:                
1906:                		The reason for failure could be retrieved with SYS_FS_Error
1907:                    Remarks:
1908:                	None
1909:                ***************************************************************************/
1910:                SYS_FS_RESULT SYS_FS_CurrentDriveSet(const char* path)
1911:                {
00000000  00000000   NOP
1912:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000008  00000000   NOP
1913:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
1914:                
1915:                    /* Get disk number */
1916:                    if(_SYS_FS_DiskGet(path, &disk) == SYS_FS_RES_FAILURE)
0000000C  00000000   NOP
1917:                    {
1918:                        // reason or cause of error is alredy present in "errorValue" variable
1919:                        return SYS_FS_RES_FAILURE;
00000098  00000000   NOP
1920:                    }
1921:                
1922:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
1923:                    if(disk->fsType == MPFS2)
00000020  00000000   NOP
1924:                    {
1925:                        gSYSFSCurrentMountPoint.currentDisk = disk;
00000030  00000000   NOP
1926:                        return SYS_FS_RES_SUCCESS;
00000034  00000000   NOP
1927:                    }
1928:                
1929:                    if(gSYSFSCurrentMountPoint.inUse == false)
0000003C  00000000   NOP
1930:                    {
1931:                        SYS_ASSERT(false, "Invalid mount point. Was the disk mounted?");
1932:                        errorValue = SYS_FS_ERROR_NO_FILESYSTEM;
00000044  00000000   NOP
1933:                        return SYS_FS_RES_FAILURE;
0000004C  00000000   NOP
1934:                   }
1935:                
1936:                   if(disk->fsFunctions->chdrive == NULL)
00000054  00000000   NOP
1937:                   {
1938:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000060  00000000   NOP
1939:                        return SYS_FS_RES_FAILURE;
00000068  00000000   NOP
1940:                   }
1941:                
1942:                   fileStatus = disk->fsFunctions->chdrive(disk->diskNumber);
00000070  00000000   NOP
1943:                
1944:                    if(fileStatus == 0)
00000078  00000000   NOP
1945:                    {
1946:                        gSYSFSCurrentMountPoint.currentDisk = disk;
00000080  00000000   NOP
1947:                        return SYS_FS_RES_SUCCESS;
00000088  00000000   NOP
1948:                    }
1949:                    else
1950:                    {
1951:                        errorValue = fileStatus;
1952:                        return SYS_FS_RES_FAILURE;
00000090  00000000   NOP
1953:                    }
1954:                }
0000009C  00000000   NOP
1955:                
1956:                //******************************************************************************
1957:                /*Function:
1958:                    SYS_FS_RESULT SYS_FS_DriveLabelGet(const char* drive, char *buff, uint32_t *sn)
1959:                
1960:                    Summary:
1961:                        Get drive label
1962:                
1963:                    Description:
1964:                        Get the label for the drive specified. If no drive is specified, then the label
1965:                        for the current drive is obtained.
1966:                
1967:                    Precondition:
1968:                        Atlesat, one disk has to be mounted before this funcion could be set.
1969:                
1970:                
1971:                    Parameters:
1972:                        drive           -       Pointer to buffer which will hold the name of
1973:                                                drive being for which, the label is requested. If
1974:                                                this string is NULL, then then label of the current
1975:                                                drive is obtained by using this function.
1976:                        buff            -       Buffer which will hold the string of label.
1977:                        sn              -       Serial number of the drive. If this information is
1978:                                                not needed, it can be set as NULL.
1979:                
1980:                    Returns:
1981:                        If Success	-	SYS_FS_RES_SUCCESS
1982:                
1983:                        If Failure	-	SYS_FS_RES_FAILURE
1984:                
1985:                		The reason for failure could be retrieved with SYS_FS_Error
1986:                  Remarks:
1987:                	None
1988:                ***************************************************************************/
1989:                SYS_FS_RESULT SYS_FS_DriveLabelGet(const char* drive, char *buff, uint32_t *sn)
1990:                {
00000000  00000000   NOP
1991:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
1992:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000018  00000000   NOP
1993:                    uint8_t pathWithDiskNo[3] = {};
0000001C  00000000   NOP
1994:                
1995:                    if(drive != NULL)
00000020  00000000   NOP
1996:                    {
1997:                        /* Get disk number */
1998:                        if(_SYS_FS_DiskGet(drive, &disk) == SYS_FS_RES_FAILURE)
00000028  00000000   NOP
1999:                        {
2000:                            // reason or cause of error is alredy present in "errorValue" variable
2001:                            return SYS_FS_RES_FAILURE;
2002:                        }
2003:                    }
2004:                    else    /* if(drive == NULL */
2005:                    {
2006:                        if(gSYSFSCurrentMountPoint.inUse == false)
00000044  00000000   NOP
2007:                        {
2008:                            SYS_ASSERT(false, "Invalid mount point. Was the disk mounted?");
2009:                            errorValue = SYS_FS_ERROR_NO_FILESYSTEM;
00000050  00000000   NOP
2010:                            return SYS_FS_RES_FAILURE;
00000058  00000000   NOP
2011:                        }
2012:                
2013:                        disk = gSYSFSCurrentMountPoint.currentDisk;
00000060  00000000   NOP
2014:                
2015:                    }
2016:                
2017:                    /* For MPFS file system, label name is not supported */
2018:                    if(disk->fsType == MPFS2)
00000064  00000000   NOP
2019:                    {
2020:                        errorValue = SYS_FS_ERROR_DENIED;
00000078  00000000   NOP
2021:                        return SYS_FS_RES_FAILURE;
00000080  00000000   NOP
2022:                    }
2023:                
2024:                    /* Append "0:" before the file name. This is required
2025:                     * for different disks */
2026:                    pathWithDiskNo[0] = (uint8_t)disk->diskNumber + '0';
00000088  00000000   NOP
2027:                    pathWithDiskNo[1] = ':';
00000090  00000000   NOP
2028:                    pathWithDiskNo[2] = '\0';
00000098  00000000   NOP
2029:                
2030:                    if(disk->fsFunctions->getlabel == NULL)
0000009C  00000000   NOP
2031:                    {
2032:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
000000AC  00000000   NOP
2033:                        return SYS_FS_RES_FAILURE;
000000B4  00000000   NOP
2034:                    }
2035:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
2036:                    {
2037:                        fileStatus = disk->fsFunctions->getlabel((const char *)pathWithDiskNo, buff, sn);
000000CC  00000000   NOP
2038:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
2039:                    }
2040:                
2041:                    if(fileStatus == 0)
000000F0  00000000   NOP
2042:                    {
2043:                        return SYS_FS_RES_SUCCESS;
2044:                    }
2045:                    else
2046:                    {
2047:                        errorValue = fileStatus;
000000F8  00000000   NOP
2048:                        return SYS_FS_RES_FAILURE;
2049:                    }
2050:                
2051:                }
00000100  00000000   NOP
2052:                
2053:                //******************************************************************************
2054:                /*Function:
2055:                    SYS_FS_RESULT SYS_FS_DriveLabelSet(const char* drive, const char *label)
2056:                
2057:                    Summary:
2058:                        Set drive label
2059:                
2060:                    Description:
2061:                        Set the label for the drive specified. If no drive is specified, then the label
2062:                        for the current drive is set.
2063:                
2064:                    Precondition:
2065:                        Atlesat, one disk has to be mounted before this funcion could be set.
2066:                
2067:                
2068:                    Parameters:
2069:                        drive           -       Pointer to string which holds the name of
2070:                                                drive being for which, the label is to be set. If
2071:                                                this string is NULL, then then label of the current
2072:                                                drive is set by using this function.
2073:                        label           -       Pointer to string which contains the label to be set.
2074:                
2075:                    Returns:
2076:                        If Success	-	SYS_FS_RES_SUCCESS
2077:                
2078:                        If Failure	-	SYS_FS_RES_FAILURE
2079:                
2080:                		The reason for failure could be retrieved with SYS_FS_Error
2081:                
2082:                  Remarks:
2083:                	None
2084:                ***************************************************************************/
2085:                SYS_FS_RESULT SYS_FS_DriveLabelSet(const char *drive, const char *label)
2086:                {
00000000  00000000   NOP
2087:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
2088:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000018  00000000   NOP
2089:                    char pathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
0000001C  00000000   NOP
2090:                
2091:                    if(label == NULL)
0000002C  00000000   NOP
2092:                    {
2093:                        errorValue = SYS_FS_ERROR_DENIED;
00000034  00000000   NOP
2094:                        return SYS_FS_RES_FAILURE;
00000038  00000000   NOP
2095:                    }
2096:                
2097:                    if(drive != NULL)
00000040  00000000   NOP
2098:                    {
2099:                        /* Get disk number */
2100:                        if(_SYS_FS_DiskGet(drive, &disk) == SYS_FS_RES_FAILURE)
00000048  00000000   NOP
2101:                        {
2102:                            // reason or cause of error is alredy present in "errorValue" variable
2103:                            return SYS_FS_RES_FAILURE;
2104:                        }
2105:                    }
2106:                    else    /* if(drive == NULL */
2107:                    {
2108:                        if(gSYSFSCurrentMountPoint.inUse == false)
00000064  00000000   NOP
2109:                        {
2110:                            SYS_ASSERT(false, "Invalid mount point. Was the disk mounted?");
2111:                            errorValue = SYS_FS_ERROR_NO_FILESYSTEM;
00000070  00000000   NOP
2112:                            return SYS_FS_RES_FAILURE;
00000078  00000000   NOP
2113:                        }
2114:                
2115:                        disk = gSYSFSCurrentMountPoint.currentDisk;
00000080  00000000   NOP
2116:                    }
2117:                
2118:                    /* For MPFS file system, label name is not supported */
2119:                    if(disk->fsType == MPFS2)
00000084  00000000   NOP
2120:                    {
2121:                        errorValue = SYS_FS_ERROR_DENIED;
00000098  00000000   NOP
2122:                        return SYS_FS_RES_FAILURE;
000000A0  00000000   NOP
2123:                    }
2124:                
2125:                    /* Append "0:" before the file name. This is required
2126:                     * for different disks */
2127:                    pathWithDiskNo[0] = (uint8_t)disk->diskNumber + '0';
000000A8  00000000   NOP
2128:                    pathWithDiskNo[1] = ':';
000000B0  00000000   NOP
2129:                
2130:                    /* Form the name with the drive letter */
2131:                    strcpy((char *)&pathWithDiskNo[2], (const char *)label);
000000B8  00000000   NOP
2132:                
2133:                
2134:                    if(disk->fsFunctions->setlabel == NULL)
000000C4  00000000   NOP
2135:                    {
2136:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
000000D4  00000000   NOP
2137:                        return SYS_FS_RES_FAILURE;
000000DC  00000000   NOP
2138:                    }
2139:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
2140:                    {
2141:                        fileStatus = disk->fsFunctions->setlabel((const char *)pathWithDiskNo);
000000F4  00000000   NOP
2142:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
2143:                    }
2144:                    if(fileStatus == 0)
00000110  00000000   NOP
2145:                    {
2146:                        return SYS_FS_RES_SUCCESS;
2147:                    }
2148:                    else
2149:                    {
2150:                        errorValue = fileStatus;
00000118  00000000   NOP
2151:                        return SYS_FS_RES_FAILURE;
2152:                    }
2153:                }
00000120  00000000   NOP
2154:                //******************************************************************************
2155:                /*Function:
2156:                    SYS_FS_RESULT SYS_FS_FileTruncate( SYS_FS_HANDLE handle )
2157:                
2158:                    Summary:
2159:                        Truncate a file
2160:                
2161:                    Description:
2162:                        The function truncates the file size to the current file read/write pointer.
2163:                        This function has no effect if the file read/write pointer is already pointing
2164:                        end of the file.
2165:                
2166:                    Precondition:
2167:                        A valid handle of a file has to be passed as input to the function.
2168:                         The file has to be opened in a mode where write to file is possible
2169:                        (such as read plus or write mode).
2170:                
2171:                    Parameters:
2172:                        handle           -      A valid handle which was obtained while opening the file.
2173:                
2174:                    Returns:
2175:                        If Success	-	SYS_FS_RES_SUCCESS
2176:                
2177:                        If Failure	-	SYS_FS_RES_FAILURE
2178:                
2179:                		The reason for failure could be retrieved with SYS_FS_Error
2180:                  Remarks:
2181:                	None
2182:                ***************************************************************************/
2183:                SYS_FS_RESULT SYS_FS_FileTruncate( SYS_FS_HANDLE handle )
2184:                {
00000000  00000000   NOP
2185:                    int fileStatus = -1;
2186:                    SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
2187:                
2188:                    if(handle == SYS_FS_HANDLE_INVALID)
0000000C  00000000   NOP
2189:                    {
2190:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000018  00000000   NOP
2191:                        return SYS_FS_RES_FAILURE;
00000020  00000000   NOP
2192:                    }
2193:                
2194:                    if(obj->inUse == false)
00000028  00000000   NOP
2195:                    {
2196:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000034  00000000   NOP
2197:                        return SYS_FS_RES_FAILURE;
0000003C  00000000   NOP
2198:                    }
2199:                
2200:                    /* Now, call the real file open function */
2201:                    if(obj->mountPoint->fsFunctions->truncate == NULL)
00000044  00000000   NOP
2202:                    {
2203:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000054  00000000   NOP
2204:                        return SYS_FS_RES_FAILURE;
0000005C  00000000   NOP
2205:                    }
2206:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER)
2207:                                                                        == OSAL_RESULT_TRUE)
2208:                    {
2209:                        fileStatus = obj->mountPoint->fsFunctions->truncate(obj->nativeFSFileObj);
00000074  00000000   NOP
2210:                
2211:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
0000008C  00000000   NOP
2212:                    }
2213:                
2214:                    if(fileStatus == 0)
00000098  00000000   NOP
2215:                    {
2216:                        return SYS_FS_RES_SUCCESS;
2217:                    }
2218:                    else
2219:                    {
2220:                        obj->errorValue = fileStatus;
000000A0  00000000   NOP
2221:                        return SYS_FS_RES_FAILURE;
000000A4  00000000   NOP
2222:                    }
2223:                }
000000A8  00000000   NOP
2224:                
2225:                //******************************************************************************
2226:                /*Function:
2227:                    SYS_FS_RESULT SYS_FS_CurrentWorkingDirectoryGet(char *buff, uint32_t len)
2228:                
2229:                    Summary:
2230:                    Get the current working directory
2231:                
2232:                    Description:
2233:                        Get the current working directory path along with the working drive.
2234:                
2235:                    Precondition:
2236:                        Atlesat, one disk has to be mounted before this funcion could be set.
2237:                
2238:                
2239:                    Parameters:
2240:                        buff            -       Pointer to a buffer which will contain the name
2241:                                                of the current working directory and drive, once
2242:                                                the function completes.
2243:                
2244:                        len           -         Size of the buffer.
2245:                
2246:                    Returns:
2247:                        If Success	-	SYS_FS_RES_SUCCESS
2248:                
2249:                        If Failure	-	SYS_FS_RES_FAILURE
2250:                
2251:                		The reason for failure could be retrieved with SYS_FS_Error
2252:                
2253:                  Remarks:
2254:                	None
2255:                ***************************************************************************/
2256:                SYS_FS_RESULT SYS_FS_CurrentWorkingDirectoryGet(char *buffer, uint32_t len)
2257:                {
00000000  00000000   NOP
2258:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *)NULL;
2259:                    int fileStatus = -1;
2260:                    char directoryHolder[FAT_FS_MAX_LFN] = {};
0000001C  00000000   NOP
2261:                    char *ptr = (char *)NULL, *tempBuffer = (char *)NULL;
2262:                    const char *mntName = (const char *)NULL;
2263:                
2264:                    tempBuffer = buffer;
2265:                
2266:                    if(gSYSFSCurrentMountPoint.inUse == false)
0000002C  00000000   NOP
2267:                    {
2268:                        errorValue = SYS_FS_ERROR_NO_FILESYSTEM;
00000038  00000000   NOP
2269:                        return SYS_FS_RES_FAILURE;
00000040  00000000   NOP
2270:                    }
2271:                
2272:                    /* This is the current drive in sys_fs. For this current
2273:                       drive, get the current working directory */
2274:                    disk = gSYSFSCurrentMountPoint.currentDisk;
2275:                
2276:                
2277:                    /* For MPFS file system, label name is not supported */
2278:                    if(disk->fsType == MPFS2)
00000048  00000000   NOP
2279:                    {
2280:                        errorValue = SYS_FS_ERROR_DENIED;
00000058  00000000   NOP
2281:                        return SYS_FS_RES_FAILURE;
00000060  00000000   NOP
2282:                    }
2283:                
2284:                    /* Now, call the real file open function */
2285:                    if(disk->fsFunctions->currWD == NULL)
00000068  00000000   NOP
2286:                    {
2287:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000074  00000000   NOP
2288:                        return SYS_FS_RES_FAILURE;
0000007C  00000000   NOP
2289:                    }
2290:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER)
2291:                                                                        == OSAL_RESULT_TRUE)
2292:                    {
2293:                        fileStatus = disk->fsFunctions->currWD(buffer, len);
00000094  00000000   NOP
2294:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
2295:                    }
2296:                
2297:                    if(fileStatus == 0) /* If function call was success */
000000A8  00000000   NOP
2298:                    {
2299:                        /* Check if the first value of the returned buffer is a ASCII for digit */
2300:                        if((*buffer >= '0') && (*buffer <= '9'))
000000B0  00000000   NOP
2301:                        {
2302:                            /* verify if the current drive in native file system matches with
2303:                               the current drive in sys_fs layer */
2304:                            if(disk->diskNumber == (*buffer - '0'))
000000DC  00000000   NOP
2305:                            {
2306:                                buffer++;  // to ignore the drive number
2307:                                buffer++;  // to ignore the ":"
2308:                
2309:                                /* store the current working directory name in a temp buffer */
2310:                                ptr = &directoryHolder[0];
000000F4  00000000   NOP
00000118  00000000   NOP
2311:                
2312:                                while(*buffer != '\0')
000000E8  00000000   NOP
00000104  00000000   NOP
2313:                                {
2314:                                    *ptr++  = *buffer++;
000000F8  00000000   NOP
2315:                                }
2316:                                *ptr = '\0';
0000011C  00000000   NOP
2317:                                buffer = tempBuffer;
2318:                
2319:                                *buffer++ = '/';
00000120  00000000   NOP
2320:                                *buffer++ = 'm';
00000128  00000000   NOP
2321:                                *buffer++ = 'n';
00000130  00000000   NOP
2322:                                *buffer++ = 't';
00000138  00000000   NOP
2323:                                *buffer++ = '/';
00000140  00000000   NOP
2324:                
2325:                                len = len - 5;  /* for "/mnt/" */
2326:                
2327:                                mntName = disk->mountName;
00000148  00000000   NOP
2328:                
2329:                                while(*mntName != '\0')
0000014C  00000000   NOP
00000164  00000000   NOP
2330:                                {
2331:                                    *buffer++ = *mntName++;
00000158  00000000   NOP
2332:                                    len--;
2333:                                }
2334:                                /* Now, add the current working directory name which is stored in temp buffer */
2335:                                ptr = &directoryHolder[0];
2336:                
2337:                                while(*ptr != '\0')
00000170  00000000   NOP
0000018C  00000000   NOP
2338:                                {
2339:                                    *buffer++  = *ptr++;
00000180  00000000   NOP
2340:                                    len--;
2341:                                }
2342:                
2343:                                /* Fill up remaining unused area of buffer with NULL */
2344:                                while(len != 0)
00000198  00000000   NOP
000001A4  00000000   NOP
2345:                                {
2346:                                    *buffer++ = '\0';
000001A0  00000000   NOP
2347:                                    len--;
2348:                                }
2349:                            }
2350:                            else
2351:                            {
2352:                                errorValue = SYS_FS_ERROR_INVALID_NAME;
000001B4  00000000   NOP
2353:                                return SYS_FS_RES_FAILURE;
000001B8  00000000   NOP
2354:                            }
2355:                        }
2356:                        else /* If first value of the returned buffer is a not an ASCII for digit */
2357:                        {
2358:                            /* Must be becuse, the application as 1 volume and hence, the
2359:                             return name of current directory from native file system does
2360:                             not have the drive name explecitely mentioned. We will add it
2361:                             from the sys_fs layer as below */
2362:                
2363:                            /* store the current working directory name in a temp buffer */
2364:                            ptr = &directoryHolder[0];
2365:                
2366:                            while(*buffer != '\0')
000000C8  00000000   NOP
000001CC  00000000   NOP
2367:                            {
2368:                                *ptr++  = *buffer++;
000001C0  00000000   NOP
2369:                            }
2370:                            *ptr = '\0';
000000D4  00000000   NOP
000001D8  00000000   NOP
2371:                            buffer = tempBuffer;
2372:                
2373:                
2374:                            *buffer++ = '/';
000001DC  00000000   NOP
2375:                            *buffer++ = 'm';
000001E4  00000000   NOP
2376:                            *buffer++ = 'n';
000001EC  00000000   NOP
2377:                            *buffer++ = 't';
000001F4  00000000   NOP
2378:                            *buffer++ = '/';
000001FC  00000000   NOP
2379:                
2380:                            len = len - 5;  /* for "/mnt/" */
2381:                
2382:                            mntName = disk->mountName;
00000204  00000000   NOP
2383:                
2384:                            while(*mntName != '\0')
00000208  00000000   NOP
00000220  00000000   NOP
2385:                            {
2386:                                *buffer++ = *mntName++;
00000214  00000000   NOP
2387:                                len--;
2388:                            }
2389:                            /* Now, add the current working directory name which is stored in temp buffer */
2390:                            ptr = &directoryHolder[0];
2391:                
2392:                            while(*ptr != '\0')
0000022C  00000000   NOP
00000248  00000000   NOP
2393:                            {
2394:                                *buffer++  = *ptr++;
0000023C  00000000   NOP
2395:                                len--;
2396:                            }
2397:                
2398:                            /* Fill up remaining unused area of buffer with NULL */
2399:                            while(len != 0)
00000254  00000000   NOP
00000260  00000000   NOP
2400:                            {
2401:                                *buffer++ = '\0';
0000025C  00000000   NOP
2402:                                len--;
2403:                            }
2404:                        }
2405:                
2406:                        return SYS_FS_RES_SUCCESS;
0000027C  00000000   NOP
2407:                    }
2408:                    else
2409:                    {
2410:                        errorValue = fileStatus;
00000270  00000000   NOP
2411:                        return SYS_FS_RES_FAILURE;
00000274  00000000   NOP
2412:                    }
2413:                }
00000284  00000000   NOP
2414:                
2415:                //******************************************************************************
2416:                /*Function:
2417:                    SYS_FS_RESULT SYS_FS_FileDirectoryModeSet(const char* path, SYS_FS_FILE_DIR_ATTR attr,
2418:                        SYS_FS_FILE_DIR_ATTR mask);
2419:                
2420:                    Summary:
2421:                        Mode set for file/ directory.
2422:                
2423:                    Description:
2424:                        Sets the mode for a file or directory from the spcified list of attributes.
2425:                
2426:                    Precondition:
2427:                        Atlesat, one disk has to be mounted before this funcion could be set.
2428:                        The file/ directory for this the mode is set, has to be present.
2429:                
2430:                
2431:                    Parameters:
2432:                        path 	- A path for the file/ directory, for which the mode is to
2433:                                  be set.
2434:                
2435:                        attr     - Attribute flags to be set in one or more combination of
2436:                                   the type SYS_FS_FILE_DIR_ATTR. The specified flags are
2437:                                   set and others are cleard.
2438:                
2439:                        mask     - Attribute mask  of type SYS_FS_FILE_DIR_ATTR that specifies
2440:                                   which attribute is changed. The specified aattributes are set
2441:                                   or cleard.
2442:                
2443:                    Returns:
2444:                        If Success	-	SYS_FS_RES_SUCCESS
2445:                
2446:                        If Failure	-	SYS_FS_RES_FAILURE
2447:                
2448:                		The reason for failure could be retrieved with SYS_FS_Error
2449:                
2450:                  Remarks:
2451:                	None
2452:                ***************************************************************************/
2453:                SYS_FS_RESULT SYS_FS_FileDirectoryModeSet(const char* fname, SYS_FS_FILE_DIR_ATTR attr,
2454:                        SYS_FS_FILE_DIR_ATTR mask)
2455:                {
00000000  00000000   NOP
2456:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
2457:                    uint8_t pathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
00000020  00000000   NOP
2458:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000030  00000000   NOP
2459:                
2460:                    /* Get disk number */
2461:                    if(_SYS_FS_DiskGet(fname, &disk) == SYS_FS_RES_FAILURE)
00000034  00000000   NOP
2462:                    {
2463:                        // reason or cause of error is alredy present in "errorValue" variable
2464:                        return SYS_FS_RES_FAILURE;
000000F8  00000000   NOP
2465:                    }
2466:                
2467:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
2468:                    if(disk->fsType == MPFS2)
0000004C  00000000   NOP
2469:                    {
2470:                        errorValue = SYS_FS_ERROR_DENIED;
0000005C  00000000   NOP
2471:                        return SYS_FS_RES_FAILURE;
00000064  00000000   NOP
2472:                    }
2473:                
2474:                    /* Now, get the file name with disk number appended in front like this "0:file.txt" */
2475:                    if (_SYS_FS_DiskNumberAppend(fname, (uint8_t)disk->diskNumber, pathWithDiskNo) == false)
0000006C  00000000   NOP
2476:                    {
2477:                        errorValue = SYS_FS_ERROR_INVALID_NAME;
00000080  00000000   NOP
2478:                        return SYS_FS_RES_FAILURE;
00000088  00000000   NOP
2479:                    }
2480:                
2481:                    /* Now, call the real file open function */
2482:                
2483:                    if(disk->fsFunctions->chmode == NULL)
00000090  00000000   NOP
2484:                    {
2485:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
000000A0  00000000   NOP
2486:                        return (SYS_FS_RES_FAILURE);
000000A8  00000000   NOP
2487:                    }
2488:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER)
2489:                                                                        == OSAL_RESULT_TRUE)
2490:                    {
2491:                        fileStatus = disk->fsFunctions->chmode((const char *)pathWithDiskNo, attr, mask);
000000C0  00000000   NOP
2492:                
2493:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
2494:                    }
2495:                
2496:                    if(fileStatus == 0)
000000E4  00000000   NOP
2497:                    {
2498:                        return(SYS_FS_RES_SUCCESS);
2499:                    }
2500:                    else
2501:                    {
2502:                        errorValue = fileStatus;
000000EC  00000000   NOP
2503:                        return(SYS_FS_RES_FAILURE);
000000F0  00000000   NOP
2504:                    }
2505:                }
000000FC  00000000   NOP
2506:                
2507:                //******************************************************************************
2508:                /*Function:
2509:                    SYS_FS_RESULT SYS_FS_FileDirectoryTimeSet(const char* path, SYS_FS_TIME *time)
2510:                
2511:                    Summary:
2512:                        Time set for file/ directory.
2513:                
2514:                    Description:
2515:                        Sets or change the time for a file or directory.
2516:                
2517:                    Precondition:
2518:                        Atlesat, one disk has to be mounted before this funcion could be set.
2519:                        The file/ directory for which time has to be set, has to be present.
2520:                
2521:                
2522:                    Parameters:
2523:                        path 	- A path for the file/ directory, for which the mode is to
2524:                                  be set.
2525:                
2526:                        ptr     - Pointer to structure of type SYS_FS_TIME, which contains the
2527:                                  time data already set in.
2528:                
2529:                
2530:                    Returns:
2531:                        If Success	-	SYS_FS_RES_SUCCESS
2532:                
2533:                        If Failure	-	SYS_FS_RES_FAILURE
2534:                
2535:                		The reason for failure could be retrieved with SYS_FS_Error
2536:                
2537:                  Remarks:
2538:                	None
2539:                ***************************************************************************/
2540:                SYS_FS_RESULT SYS_FS_FileDirectoryTimeSet(const char* fname, SYS_FS_TIME *time)
2541:                {
00000000  00000000   NOP
2542:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
2543:                    uint8_t pathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
00000018  00000000   NOP
2544:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000028  00000000   NOP
2545:                    SYS_FS_FSTAT stat = {};
0000002C  00000000   NOP
2546:                
2547:                    /* Get disk number */
2548:                    if(_SYS_FS_DiskGet(fname, &disk) == SYS_FS_RES_FAILURE)
0000004C  00000000   NOP
2549:                    {
2550:                        // reason or cause of error is alredy present in "errorValue" variable
2551:                        return SYS_FS_RES_FAILURE;
0000011C  00000000   NOP
2552:                    }
2553:                
2554:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
2555:                    if(disk->fsType == MPFS2)
00000064  00000000   NOP
2556:                    {
2557:                        errorValue = SYS_FS_ERROR_DENIED;
00000074  00000000   NOP
2558:                        return SYS_FS_RES_FAILURE;
0000007C  00000000   NOP
2559:                    }
2560:                
2561:                    /* Now, get the file name with disk number appended in front like this "0:file.txt" */
2562:                    if (_SYS_FS_DiskNumberAppend(fname, (uint8_t)disk->diskNumber, pathWithDiskNo) == false)
00000084  00000000   NOP
2563:                    {
2564:                        errorValue = SYS_FS_ERROR_INVALID_NAME;
00000098  00000000   NOP
2565:                        return SYS_FS_RES_FAILURE;
000000A0  00000000   NOP
2566:                    }
2567:                
2568:                    /* Now, transfer the time from elements of "SYS_FS_TIME" to elements of "SYS_FS_FSTAT" */
2569:                    stat.fdate = time->timeDate.date;
000000A8  00000000   NOP
2570:                    stat.ftime = time->timeDate.time;
000000AC  00000000   NOP
2571:                
2572:                    /* Now, call the real file open function */
2573:                
2574:                    if(disk->fsFunctions->chtime == NULL)
000000B4  00000000   NOP
2575:                    {
2576:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
000000C8  00000000   NOP
2577:                        return (SYS_FS_RES_FAILURE);
000000D0  00000000   NOP
2578:                    }
2579:                
2580:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER)
2581:                                                                        == OSAL_RESULT_TRUE)
2582:                    {
2583:                        fileStatus = disk->fsFunctions->chtime((const char *)pathWithDiskNo, (uintptr_t)&stat);
000000E8  00000000   NOP
2584:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
2585:                    }
2586:                
2587:                    if(fileStatus == 0)
00000108  00000000   NOP
2588:                    {
2589:                        return(SYS_FS_RES_SUCCESS);
2590:                    }
2591:                    else
2592:                    {
2593:                        errorValue = fileStatus;
00000110  00000000   NOP
2594:                        return(SYS_FS_RES_FAILURE);
00000114  00000000   NOP
2595:                    }
2596:                }
00000120  00000000   NOP
2597:                
2598:                //******************************************************************************
2599:                /*Function:
2600:                    SYS_FS_RESULT SYS_FS_FileDirectoryRenameMove(const char *oldPath, const char *newPath)
2601:                
2602:                    Summary:
2603:                        Rename or move a file/ directory.
2604:                
2605:                    Description:
2606:                        Renames or moves a file or directory.
2607:                
2608:                    Precondition:
2609:                        Atlesat, one disk has to be mounted before this funcion could be set.
2610:                        The file/ directory which has to be renamed/ moved, has to be present.
2611:                
2612:                        This function cannot move files/ directory from one drive to another.
2613:                        Do not rename/ move files which are open.
2614:                
2615:                    Parameters:
2616:                        oldPath 	- Path for the file/ directory, which has to be renamed/ moved.
2617:                
2618:                        newPath 	- New Path for the file/ directory.
2619:                
2620:                
2621:                    Returns:
2622:                        If Success	-	SYS_FS_RES_SUCCESS
2623:                
2624:                        If Failure	-	SYS_FS_RES_FAILURE
2625:                
2626:                		The reason for failure could be retrieved with SYS_FS_Error
2627:                  Remarks:
2628:                        This function cannot move files/ directory from one drive to another.
2629:                        Do not rename/ move files which are open.
2630:                ***************************************************************************/
2631:                SYS_FS_RESULT SYS_FS_FileDirectoryRenameMove(const char *oldPath, const char *newPath)
2632:                {
00000000  00000000   NOP
2633:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
2634:                    uint8_t oldPathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
00000018  00000000   NOP
2635:                    uint8_t newPathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
00000028  00000000   NOP
2636:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000038  00000000   NOP
2637:                
2638:                    /* Get disk number */
2639:                    if(_SYS_FS_DiskGet(oldPath, &disk) == SYS_FS_RES_FAILURE)
0000003C  00000000   NOP
2640:                    {
2641:                        // reason or cause of error is alredy present in "errorValue" variable
2642:                        return SYS_FS_RES_FAILURE;
00000154  00000000   NOP
2643:                    }
2644:                
2645:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
2646:                    if(disk->fsType == MPFS2)
00000054  00000000   NOP
2647:                    {
2648:                        errorValue = SYS_FS_ERROR_DENIED;
00000064  00000000   NOP
2649:                        return SYS_FS_RES_FAILURE;
0000006C  00000000   NOP
2650:                    }
2651:                
2652:                    /* Now, get the file name with disk number appended in front like this "0:file.txt" */
2653:                    if (_SYS_FS_DiskNumberAppend(oldPath, (uint8_t)disk->diskNumber, oldPathWithDiskNo) == false)
00000074  00000000   NOP
2654:                    {
2655:                        errorValue = SYS_FS_ERROR_INVALID_NAME;
00000088  00000000   NOP
2656:                        return SYS_FS_RES_FAILURE;
00000090  00000000   NOP
2657:                    }
2658:                
2659:                    /***********************************************************************************/
2660:                    /**************************NOW, repeat the above steps for other new path***********/
2661:                    /***********************************************************************************/
2662:                    /* Get disk number */
2663:                    if(_SYS_FS_DiskGet(newPath, &disk) == SYS_FS_RES_FAILURE)
00000098  00000000   NOP
2664:                    {
2665:                        // reason or cause of error is alredy present in "errorValue" variable
2666:                        return SYS_FS_RES_FAILURE;
0000015C  00000000   NOP
2667:                    }
2668:                
2669:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
2670:                    if(disk->fsType == MPFS2)
000000AC  00000000   NOP
2671:                    {
2672:                        errorValue = SYS_FS_ERROR_DENIED;
000000BC  00000000   NOP
2673:                        return SYS_FS_RES_FAILURE;
000000C4  00000000   NOP
2674:                    }
2675:                
2676:                    /* Now, get the file name with disk number appended in front like this "0:file.txt" */
2677:                    if (_SYS_FS_DiskNumberAppend(newPath, (uint8_t)disk->diskNumber, newPathWithDiskNo) == false)
000000CC  00000000   NOP
2678:                    {
2679:                        errorValue = SYS_FS_ERROR_INVALID_NAME;
000000E0  00000000   NOP
2680:                        return SYS_FS_RES_FAILURE;
000000E8  00000000   NOP
2681:                    }
2682:                
2683:                    /* Now, call the real file open function */
2684:                    if(disk->fsFunctions->rename == NULL)
000000F0  00000000   NOP
2685:                    {
2686:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000100  00000000   NOP
2687:                        return (SYS_FS_RES_FAILURE);
00000108  00000000   NOP
2688:                    }
2689:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER)
2690:                                                                        == OSAL_RESULT_TRUE)
2691:                    {
2692:                         /* This function does not take disk number (like "0:"). Hence use from index "2" onwards */
2693:                        fileStatus = disk->fsFunctions->rename((const char *)&oldPathWithDiskNo[2], (const char *)&newPathWithDiskNo[2]);
00000120  00000000   NOP
2694:                        OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
2695:                
2696:                    }
2697:                    if(fileStatus == 0)
00000140  00000000   NOP
2698:                    {
2699:                        return(SYS_FS_RES_SUCCESS);
2700:                    }
2701:                    else
2702:                    {
2703:                        errorValue = fileStatus;
00000148  00000000   NOP
2704:                        return(SYS_FS_RES_FAILURE);
0000014C  00000000   NOP
2705:                    }
2706:                }
00000160  00000000   NOP
2707:                
2708:                //******************************************************************************
2709:                /*Function:
2710:                    SYS_FS_RESULT SYS_FS_FileSync( SYS_FS_HANDLE handle )
2711:                
2712:                    Summary:
2713:                        File flush.
2714:                
2715:                    Description:
2716:                        The function flushes the cached information of a writing file.
2717:                        The SYS_FS_FileSync() function performs the same process as SYS_FS_FileClose()
2718:                        function but the file is left opened and can continue read/write/seek operations
2719:                        to the file.
2720:                
2721:                    Precondition:
2722:                        Atlesat, one disk has to be mounted before this funcion could be set.
2723:                        The file which has to be flushed, has to be present and should have been opened
2724:                        in write mode.
2725:                
2726:                
2727:                    Parameters:
2728:                        handle         -       Handle for the file received when the file was opened.
2729:                
2730:                
2731:                    Returns:
2732:                        If Success	-	SYS_FS_RES_SUCCESS
2733:                
2734:                        If Failure	-	SYS_FS_RES_FAILURE
2735:                
2736:                		The reason for failure could be retrieved with SYS_FS_Error
2737:                  Remarks:
2738:                        None.
2739:                ***************************************************************************/
2740:                SYS_FS_RESULT SYS_FS_FileSync( SYS_FS_HANDLE handle )
2741:                {
00000000  00000000   NOP
2742:                   int fileStatus = -1;
2743:                   SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
2744:                
2745:                    if(handle == SYS_FS_HANDLE_INVALID)
0000000C  00000000   NOP
2746:                    {
2747:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000018  00000000   NOP
2748:                        return SYS_FS_RES_FAILURE;
00000020  00000000   NOP
2749:                    }
2750:                
2751:                    if(obj->inUse == 0)
00000028  00000000   NOP
2752:                    {
2753:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000034  00000000   NOP
2754:                        return SYS_FS_RES_FAILURE;
0000003C  00000000   NOP
2755:                    }
2756:                
2757:                    /* Now, call the real file open function */
2758:                
2759:                    if(obj->mountPoint->fsFunctions->sync == NULL)
00000044  00000000   NOP
2760:                    {
2761:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000054  00000000   NOP
2762:                        return -1;
0000005C  00000000   NOP
2763:                    }
2764:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER)
2765:                                                                        == OSAL_RESULT_TRUE)
2766:                    {
2767:                
2768:                        fileStatus = obj->mountPoint->fsFunctions->sync(obj->nativeFSFileObj);
00000074  00000000   NOP
2769:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
0000008C  00000000   NOP
2770:                    }
2771:                
2772:                    if(fileStatus == 0)
00000098  00000000   NOP
2773:                    {
2774:                        return SYS_FS_RES_SUCCESS;
2775:                    }
2776:                    else
2777:                    {
2778:                        obj->errorValue = fileStatus;
000000A0  00000000   NOP
2779:                        return SYS_FS_RES_FAILURE;
000000A4  00000000   NOP
2780:                    }
2781:                }
000000A8  00000000   NOP
2782:                
2783:                //******************************************************************************
2784:                /*Function:
2785:                    SYS_FS_RESULT SYS_FS_FileStringGet( SYS_FS_HANDLE handle, char* buff, uint32_t len )
2786:                
2787:                    Summary:
2788:                        String read.
2789:                
2790:                    Description:
2791:                        The function reads a string of specified length from the file into a buffer.
2792:                        The read operation continues until a '\n' is stored, reached end of the file
2793:                        or the buffer is filled with len - 1 characters. The read string is terminated
2794:                        with a '\0'.
2795:                
2796:                    Precondition:
2797:                        Atlesat, one disk has to be mounted before this funcion could be set.
2798:                        The file from which a string has to be read, has to be present and should have
2799:                        been opened.
2800:                
2801:                
2802:                    Parameters:
2803:                        handle         -       Handle for the file received when the file was opened.
2804:                        buff           -       Buffer to read string.
2805:                        len            -       length of string to be read.
2806:                
2807:                
2808:                    Returns:
2809:                        If Success	-	SYS_FS_RES_SUCCESS
2810:                
2811:                        If Failure	-	SYS_FS_RES_FAILURE
2812:                
2813:                		The reason for failure could be retrieved with SYS_FS_Error
2814:                  Remarks:
2815:                        None.
2816:                ***************************************************************************/
2817:                SYS_FS_RESULT SYS_FS_FileStringGet( SYS_FS_HANDLE handle, char* buff, uint32_t len )
2818:                {
00000000  00000000   NOP
2819:                   int fileStatus = SYS_FS_ERROR_NOT_READY;
2820:                   SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
2821:                   char *ptr = NULL;
2822:                
2823:                    if(handle == SYS_FS_HANDLE_INVALID)
00000010  00000000   NOP
2824:                    {
2825:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
0000001C  00000000   NOP
2826:                        return SYS_FS_RES_FAILURE;
00000024  00000000   NOP
2827:                    }
2828:                
2829:                    if(obj->inUse == 0)
0000002C  00000000   NOP
2830:                    {
2831:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000038  00000000   NOP
2832:                        return SYS_FS_RES_FAILURE;
00000040  00000000   NOP
2833:                    }
2834:                
2835:                    /* Now, call the real file open function */
2836:                
2837:                    if(obj->mountPoint->fsFunctions->getstrn == NULL)
00000048  00000000   NOP
2838:                    {
2839:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000058  00000000   NOP
2840:                        return -1;
00000060  00000000   NOP
2841:                    }
2842:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER)
2843:                                                                        == OSAL_RESULT_TRUE)
2844:                    {
2845:                
2846:                        ptr = obj->mountPoint->fsFunctions->getstrn(buff, len, obj->nativeFSFileObj);
0000007C  00000000   NOP
2847:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
0000009C  00000000   NOP
2848:                    }
2849:                
2850:                    if(buff == ptr)
000000A8  00000000   NOP
2851:                    {
2852:                        return SYS_FS_RES_SUCCESS;
2853:                    }
2854:                    else //if(ptr == NULL)
2855:                    {
2856:                        obj->errorValue = fileStatus;
000000B0  00000000   NOP
2857:                        return SYS_FS_RES_FAILURE;
000000B8  00000000   NOP
2858:                    }
2859:                }
000000BC  00000000   NOP
2860:                
2861:                //******************************************************************************
2862:                /*Function:
2863:                    SYS_FS_RESULT SYS_FS_FileCharacterPut( SYS_FS_HANDLE handle, char data )
2864:                
2865:                    Summary:
2866:                        Character write.
2867:                
2868:                    Description:
2869:                        The function writes a character into a file.
2870:                        When the function failed due to disk full or any error, SYS_FS_RES_FAILURE
2871:                        will be returned.
2872:                
2873:                    Precondition:
2874:                        Atlesat, one disk has to be mounted before this funcion could be set.
2875:                        The file into which a character has to be written, has to be present and
2876:                        should have been opened.
2877:                
2878:                
2879:                    Parameters:
2880:                        handle         -       Handle for the file received when the file was opened.
2881:                        data           -       A character to be written to the file.
2882:                
2883:                
2884:                    Returns:
2885:                        If Success	-	SYS_FS_RES_SUCCESS
2886:                
2887:                        If Failure	-	SYS_FS_RES_FAILURE
2888:                
2889:                		The reason for failure could be retrieved with SYS_FS_Error
2890:                  Remarks:
2891:                        None.
2892:                ***************************************************************************/
2893:                SYS_FS_RESULT SYS_FS_FileCharacterPut( SYS_FS_HANDLE handle, char data )
2894:                {
00000000  00000000   NOP
2895:                   int fileStatus = SYS_FS_ERROR_NOT_READY;
2896:                   SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
2897:                   int res = 0;
2898:                
2899:                    if(handle == SYS_FS_HANDLE_INVALID)
00000010  00000000   NOP
2900:                    {
2901:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
0000001C  00000000   NOP
2902:                        return SYS_FS_RES_FAILURE;
00000024  00000000   NOP
2903:                    }
2904:                
2905:                    if(obj->inUse == 0)
0000002C  00000000   NOP
2906:                    {
2907:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000038  00000000   NOP
2908:                        return SYS_FS_RES_FAILURE;
00000040  00000000   NOP
2909:                    }
2910:                
2911:                    /* Now, call the real file open function */
2912:                
2913:                    if(obj->mountPoint->fsFunctions->putchr == NULL)
00000048  00000000   NOP
2914:                    {
2915:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000058  00000000   NOP
2916:                        return -1;
00000060  00000000   NOP
2917:                    }
2918:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
2919:                    {
2920:                        res = obj->mountPoint->fsFunctions->putchr(data, obj->nativeFSFileObj);
00000078  00000000   NOP
2921:                
2922:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
0000008C  00000000   NOP
2923:                    }
2924:                
2925:                    if(res == 1)
00000098  00000000   NOP
2926:                    {
2927:                        return SYS_FS_RES_SUCCESS;
2928:                    }
2929:                    else
2930:                    {
2931:                        obj->errorValue = fileStatus;
000000A4  00000000   NOP
2932:                        return SYS_FS_RES_FAILURE;
000000AC  00000000   NOP
2933:                    }
2934:                }
000000B0  00000000   NOP
2935:                
2936:                //******************************************************************************
2937:                /*Function:
2938:                    SYS_FS_RESULT SYS_FS_FileStringPut( SYS_FS_HANDLE handle, const char *string )
2939:                
2940:                    Summary:
2941:                        String write.
2942:                
2943:                    Description:
2944:                        The function writes a string into a file.
2945:                        When the function succeeded, it returns SYS_FS_RES_SUCCESS.
2946:                        When the write operation is aborted due to disk full or any error a
2947:                        SYS_FS_RES_FAILURE is returned.
2948:                
2949:                    Precondition:
2950:                        Atlesat, one disk has to be mounted before this funcion could be set.
2951:                        The file into which a string has to be written, has to be present and
2952:                        should have been opened.
2953:                
2954:                
2955:                    Parameters:
2956:                        handle         -       Handle for the file received when the file was opened.
2957:                        string         -       Pointer to string which has to be written into file.
2958:                
2959:                
2960:                    Returns:
2961:                        If Success	-	SYS_FS_RES_SUCCESS
2962:                
2963:                        If Failure	-	SYS_FS_RES_FAILURE
2964:                
2965:                		The reason for failure could be retrieved with SYS_FS_Error
2966:                  Remarks:
2967:                        None.
2968:                ***************************************************************************/
2969:                SYS_FS_RESULT SYS_FS_FileStringPut( SYS_FS_HANDLE handle, const char *string )
2970:                {
00000000  00000000   NOP
2971:                   int fileStatus = SYS_FS_ERROR_NOT_READY;
2972:                   SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
2973:                   int res = 0;
2974:                
2975:                    if(handle == SYS_FS_HANDLE_INVALID)
0000000C  00000000   NOP
2976:                    {
2977:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000018  00000000   NOP
2978:                        return SYS_FS_RES_FAILURE;
00000020  00000000   NOP
2979:                    }
2980:                
2981:                    if(obj->inUse == 0)
00000028  00000000   NOP
2982:                    {
2983:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000034  00000000   NOP
2984:                        return SYS_FS_RES_FAILURE;
0000003C  00000000   NOP
2985:                    }
2986:                
2987:                    /* Now, call the real file open function */
2988:                
2989:                    if(obj->mountPoint->fsFunctions->putstrn == NULL)
00000044  00000000   NOP
2990:                    {
2991:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000054  00000000   NOP
2992:                        return -1;
0000005C  00000000   NOP
2993:                    }
2994:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
2995:                    {
2996:                        res = obj->mountPoint->fsFunctions->putstrn(string, obj->nativeFSFileObj);
00000074  00000000   NOP
2997:                
2998:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
0000008C  00000000   NOP
2999:                    }
3000:                
3001:                    if(res == EOF)
00000098  00000000   NOP
3002:                    {
3003:                        obj->errorValue = fileStatus;
000000A4  00000000   NOP
3004:                        return SYS_FS_RES_FAILURE;
000000AC  00000000   NOP
3005:                    }
3006:                    else
3007:                    {
3008:                        return SYS_FS_RES_SUCCESS;
3009:                    }
3010:                }
000000B0  00000000   NOP
3011:                
3012:                //******************************************************************************
3013:                /*Function:
3014:                    SYS_FS_RESULT SYS_FS_FilePrintf( SYS_FS_HANDLE handle, const char *string, ... )
3015:                
3016:                    Summary:
3017:                        Formatted string write.
3018:                
3019:                    Description:
3020:                        The function writes a formatted string into a file.
3021:                        When the function succeeded, it returns SYS_FS_RES_SUCCESS.
3022:                        When the write operation is aborted due to disk full or any error a
3023:                        SYS_FS_RES_FAILURE is returned.
3024:                
3025:                    Precondition:
3026:                        Atlesat, one disk has to be mounted before this funcion could be set.
3027:                        The file into which a string has to be written, has to be present and
3028:                        should have been opened.
3029:                
3030:                
3031:                    Parameters:
3032:                        handle         -       Handle for the file received when the file was opened.
3033:                        string         -       Pointer to string which has to be written into file.
3034:                
3035:                
3036:                    Returns:
3037:                        If Success	-	SYS_FS_RES_SUCCESS
3038:                
3039:                        If Failure	-	SYS_FS_RES_FAILURE
3040:                
3041:                		The reason for failure could be retrieved with SYS_FS_Error
3042:                  Remarks:
3043:                        None.
3044:                ***************************************************************************/
3045:                SYS_FS_RESULT SYS_FS_FilePrintf( SYS_FS_HANDLE handle, const char *string, ... )
3046:                {
00000000  00000000   NOP
3047:                   int fileStatus = SYS_FS_ERROR_NOT_READY;
3048:                   SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
3049:                   int res;
3050:                   va_list ap;
3051:                   const char *ptr;
3052:                
3053:                
3054:                    if(handle == SYS_FS_HANDLE_INVALID)
00000014  00000000   NOP
3055:                    {
3056:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000020  00000000   NOP
3057:                        return SYS_FS_RES_FAILURE;
00000028  00000000   NOP
3058:                    }
3059:                
3060:                    if(obj->inUse == 0)
00000030  00000000   NOP
3061:                    {
3062:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
0000003C  00000000   NOP
3063:                        return SYS_FS_RES_FAILURE;
00000044  00000000   NOP
3064:                    }
3065:                
3066:                    /* Now, call the real file open function */
3067:                
3068:                    if(obj->mountPoint->fsFunctions->formattedprint == NULL)
0000004C  00000000   NOP
3069:                    {
3070:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
0000005C  00000000   NOP
3071:                        return -1;
00000064  00000000   NOP
3072:                    }
3073:                
3074:                    va_start (ap, string);
0000006C  00000000   NOP
3075:                    ptr = va_arg(ap, const char*);
3076:                    res = obj->mountPoint->fsFunctions->formattedprint(obj->nativeFSFileObj, string, ptr);
00000070  00000000   NOP
3077:                    va_end (ap);
3078:                
3079:                    if(res == EOF)
00000088  00000000   NOP
3080:                    {
3081:                        obj->errorValue = fileStatus;
00000094  00000000   NOP
3082:                        return SYS_FS_RES_FAILURE;
0000009C  00000000   NOP
3083:                    }
3084:                    else
3085:                    {
3086:                        return SYS_FS_RES_SUCCESS;
3087:                    }
3088:                }
000000A0  00000000   NOP
3089:                
3090:                //******************************************************************************
3091:                /*Function:
3092:                    bool SYS_FS_FileTestError(SYS_FS_HANDLE handle);
3093:                
3094:                    Summary:
3095:                        Check for errors in the file
3096:                
3097:                    Description:
3098:                        Checks whether or not the file has any errors.
3099:                
3100:                    Precondition:
3101:                        A valid file handle must be obtained before passing to the function
3102:                
3103:                    Parameters:
3104:                        handle 	- file handle obtaind during file Open.
3105:                
3106:                    Returns:
3107:                		If Success	-
3108:                
3109:                			When file has an error	- true
3110:                
3111:                			When file has no errors	- false
3112:                
3113:                                        If Failure		- true
3114:                  Remarks:
3115:                	None
3116:                ***************************************************************************/
3117:                bool SYS_FS_FileTestError(SYS_FS_HANDLE handle)
3118:                {
00000000  00000000   NOP
3119:                    SYS_FS_OBJ *obj = (SYS_FS_OBJ *)handle;
3120:                    volatile bool status = false;
00000010  00000000   NOP
3121:                
3122:                    if(handle == SYS_FS_HANDLE_INVALID)
00000014  00000000   NOP
3123:                    {
3124:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000020  00000000   NOP
3125:                        return true;
00000028  00000000   NOP
3126:                    }
3127:                
3128:                    if(obj->inUse == 0)
00000030  00000000   NOP
3129:                    {
3130:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000038  00000000   NOP
3131:                        return true;
00000040  00000000   NOP
3132:                    }
3133:                
3134:                    if(obj->mountPoint->fsFunctions->testerror == NULL)
00000048  00000000   NOP
3135:                    {
3136:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000058  00000000   NOP
3137:                        return true;
0000005C  00000000   NOP
3138:                    }
3139:                
3140:                    status = obj->mountPoint->fsFunctions->testerror(obj->nativeFSFileObj);
00000064  00000000   NOP
3141:                
3142:                    /* This is success value, but required in special case, where requested offset was (-1) */
3143:                    obj->errorValue = SYS_FS_ERROR_OK;
00000070  00000000   NOP
3144:                
3145:                    return (bool)status;
00000074  00000000   NOP
3146:                }
0000007C  00000000   NOP
3147:                
3148:                //******************************************************************************
3149:                /*Function:
3150:                        SYS_FS_RESULT SYS_FS_DriveFormat(const char* drive, SYS_FS_FORMAT fmt, uint32_t clusterSize)
3151:                
3152:                    Summary:
3153:                        Format a drive
3154:                
3155:                    Description:
3156:                        Formats a logic drive (create a FAT file system on the logical drive), as per the format specified.
3157:                
3158:                        If the logical drive that has to be formatted has been bound to any partition (1-4) by
3159:                        multiple partition feature, the FAT volume is created into the specified partition. In
3160:                        this case, the second argument fmt is ignored. The physical drive must have been
3161:                        partitioned prior to use this function.
3162:                
3163:                    Precondition:
3164:                        Atlesat, one drive has to be mounted before this funcion could be set.
3165:                
3166:                
3167:                    Parameters:
3168:                        drive           -       Pointer to buffer which will hold the name of
3169:                                                drive being for which, the label is requested. If
3170:                                                this string is NULL, then then label of the current
3171:                                                drive is obtained by using this function.It is important
3172:                                                to end the drive name with a "/".
3173:                        fmt             -       Format into which the disk has to be formatted. It could
3174:                                                be of the type SYS_FS_FORMAT.
3175:                        clusterSize     -       Cluster size. The value must be sector (size * n), where
3176:                                                n is 1 to 128 and power of 2. When a zero is given, the
3177:                                                cluster size is determined depends on the volume size.
3178:                
3179:                    Returns:
3180:                        If Success	-	SYS_FS_RES_SUCCESS
3181:                
3182:                        If Failure	-	SYS_FS_RES_FAILURE
3183:                
3184:                		The reason for failure could be retrieved with SYS_FS_Error
3185:                  Remarks:
3186:                	None
3187:                ***************************************************************************/
3188:                SYS_FS_RESULT SYS_FS_DriveFormat(const char* drive, SYS_FS_FORMAT fmt, uint32_t clusterSize)
3189:                {
00000000  00000000   NOP
3190:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
3191:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000018  00000000   NOP
3192:                
3193:                    /* Get disk number */
3194:                    if(_SYS_FS_DiskGet(drive, &disk) == SYS_FS_RES_FAILURE)
0000001C  00000000   NOP
3195:                    {
3196:                        // reason or cause of error is alredy present in "errorValue" variable
3197:                        return SYS_FS_RES_FAILURE;
00000090  00000000   NOP
3198:                    }
3199:                
3200:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
3201:                    if(disk->fsType == MPFS2)
00000030  00000000   NOP
3202:                    {
3203:                        errorValue = SYS_FS_ERROR_DENIED;
00000040  00000000   NOP
3204:                        return SYS_FS_RES_FAILURE;
00000048  00000000   NOP
3205:                    }
3206:                
3207:                    /* Now, call the real file open function */
3208:                    if(disk->fsFunctions->formatDisk == NULL)
00000050  00000000   NOP
3209:                    {
3210:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
0000005C  00000000   NOP
3211:                        return (SYS_FS_RES_FAILURE);
00000064  00000000   NOP
3212:                    }
3213:                
3214:                    fileStatus = disk->fsFunctions->formatDisk((uint8_t)disk->diskNumber, fmt, clusterSize);
0000006C  00000000   NOP
3215:                
3216:                
3217:                    if(fileStatus == 0)
0000007C  00000000   NOP
3218:                    {
3219:                        return(SYS_FS_RES_SUCCESS);
3220:                    }
3221:                    else
3222:                    {
3223:                        errorValue = fileStatus;
00000084  00000000   NOP
3224:                        return(SYS_FS_RES_FAILURE);
00000088  00000000   NOP
3225:                    }
3226:                }
00000094  00000000   NOP
3227:                
3228:                //******************************************************************************
3229:                /* Function:
3230:                	SYS_FS_HANDLE SYS_FS_DirOpen(const char* path)
3231:                
3232:                  Summary:
3233:                     Open a directory
3234:                
3235:                  Description:
3236:                	The SYS_FS_DirOpen opens the requested directory.
3237:                
3238:                  Precondition:
3239:                    Prior to opening a file, the name of the volume on which the
3240:                	directory resides should be known. Also, that volume should be already mounted.
3241:                
3242:                  Parameters:
3243:                    path      	     			- Path to the directory along with the volume name. The string of
3244:                                                          volume and directory name has to be preceeded by "/mnt/". Also,
3245:                                                          the volume name and directory name has to be separated by a
3246:                                                          slash "/".
3247:                
3248:                  Returns:
3249:                	If Success					- Valid handle will be returned
3250:                
3251:                	If Failure 					- Returned handle will be SYS_FS_HANDLE_INVALID
3252:                
3253:                	The reason for failure could be retrieved with SYS_FS_Error
3254:                
3255:                  Remarks:
3256:                	None
3257:                */
3258:                
3259:                SYS_FS_HANDLE SYS_FS_DirOpen(const char* path)
3260:                {
00000000  00000000   NOP
3261:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
3262:                    uint8_t pathWithDiskNo[SYS_FS_PATH_LEN_WITH_DISK_NUM] = {};
00000010  00000000   NOP
3263:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000020  00000000   NOP
3264:                    uint32_t j = 0;
3265:                    SYS_FS_DIR_OBJ * obj = (SYS_FS_DIR_OBJ *) NULL;
3266:                
3267:                    /* Get disk number */
3268:                    if(_SYS_FS_DiskGet(path, &disk) == SYS_FS_RES_FAILURE)
00000024  00000000   NOP
3269:                    {
3270:                        // reason or cause of error is alredy present in "errorValue" variable
3271:                        return SYS_FS_HANDLE_INVALID;
3272:                    }
3273:                
3274:                    /* Now, get the file name with disk number appended in front like this "0:file.txt" */
3275:                    if (_SYS_FS_DiskNumberAppend(path, (uint8_t)disk->diskNumber, pathWithDiskNo) == false)
0000003C  00000000   NOP
3276:                    {
3277:                        errorValue = SYS_FS_ERROR_INVALID_NAME;
00000058  00000000   NOP
3278:                        return SYS_FS_HANDLE_INVALID;
0000005C  00000000   NOP
3279:                    }
3280:                
3281:                    obj = NULL;
3282:                
3283:                    if(OSAL_MUTEX_Lock((OSAL_MUTEX_HANDLE_TYPE *)&mutexDirObj, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
3284:                    {
3285:                        /* The data should be protected from simulateous access */
3286:                        for(j = 0; j < SYS_FS_MAX_FILES; j ++)
3287:                        {
3288:                            if(gSYSFSDirObj[j].inUse == false)
00000074  00000000   NOP
3289:                            {
3290:                                gSYSFSDirObj[j].inUse = true;
00000084  00000000   NOP
3291:                                gSYSFSDirObj[j].mountPoint = disk;
0000008C  00000000   NOP
3292:                                obj = &gSYSFSDirObj[j];
3293:                                break;
3294:                            }
3295:                        }
3296:                        OSAL_MUTEX_Unlock(&mutexDirObj);
3297:                    }
3298:                
3299:                    /* If the object is NULL, then we dont have a free
3300:                     * file system object */
3301:                
3302:                    if(obj == NULL)
3303:                    {
3304:                        errorValue = SYS_FS_ERROR_TOO_MANY_OPEN_FILES;
000000B4  00000000   NOP
3305:                        return(SYS_FS_HANDLE_INVALID);
000000BC  00000000   NOP
3306:                    }
3307:                
3308:                    /* Now, call the real file open function */
3309:                    if(disk->fsFunctions->openDir == NULL)
0000009C  00000000   NOP
3310:                    {
3311:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
000000C4  00000000   NOP
3312:                        obj->inUse = false;
000000C8  00000000   NOP
3313:                        return (SYS_FS_HANDLE_INVALID);
000000D0  00000000   NOP
3314:                    }
3315:                
3316:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
000000D8  00000000   NOP
3317:                    {
3318:                        /* Convert the SYS_FS file open attributes to FAT FS attributes */
3319:                        fileStatus =disk->fsFunctions->openDir((uintptr_t)&obj->nativeFSDirObj,
000000F0  00000000   NOP
3320:                                                                        (const char *)pathWithDiskNo);
3321:                
3322:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
3323:                    }
3324:                
3325:                    if(fileStatus == 0)
00000114  00000000   NOP
3326:                    {
3327:                        return((SYS_FS_HANDLE)obj);
0000011C  00000000   NOP
3328:                    }
3329:                    else
3330:                    {
3331:                        errorValue = fileStatus;
00000128  00000000   NOP
3332:                        obj->inUse = false;
0000012C  00000000   NOP
3333:                        return(SYS_FS_HANDLE_INVALID);
00000134  00000000   NOP
3334:                    }
3335:                }
00000144  00000000   NOP
3336:                
3337:                //******************************************************************************
3338:                /* Function:
3339:                	SYS_FS_RESULT SYS_FS_DirRead(SYS_FS_HANDLE handle, SYS_FS_FSTAT stat)
3340:                
3341:                
3342:                  Summary:
3343:                     Read specified directory
3344:                
3345:                  Description:
3346:                	The SYS_FS_DirRead() function shall attempt to read the files and directories
3347:                        specified in the open directory.
3348:                
3349:                  Precondition:
3350:                    A valid directory handle must be obtained before reading a directory.
3351:                
3352:                  Parameters:
3353:                        handle			- directory handle obtained during directory open.
3354:                
3355:                        stat                    - Empty structure of type SYS_FS_FSTAT, where the properties
3356:                                                  of the open directory will be populated after the SYS_FS_DirRead()
3357:                                                  function returns successfully.
3358:                                                  If LFN is used, then the "lfname" member of the
3359:                                                  SYS_FS_FSTAT structure should be initialized with address of
3360:                                                  suitable buffer. Also, the "lfsize" should be initialized with
3361:                                                  the size of buffer.
3362:                                                  Once the function returns, the buffer whose address is held in "lfname"
3363:                                                  will have the file name (long file name).
3364:                
3365:                
3366:                
3367:                  Returns:
3368:                        If Success	-	SYS_FS_RES_SUCCESS
3369:                
3370:                        If Failure	-	SYS_FS_RES_FAILURE
3371:                
3372:                	The reason for failure could be retrieved with SYS_FS_Error
3373:                
3374:                  Remarks:
3375:                	None
3376:                */
3377:                
3378:                SYS_FS_RESULT SYS_FS_DirRead(SYS_FS_HANDLE handle, SYS_FS_FSTAT *stat)
3379:                {
00000000  00000000   NOP
3380:                    int fileStatus = -1;
3381:                    SYS_FS_DIR_OBJ *obj = (SYS_FS_DIR_OBJ *)handle;
3382:                
3383:                    if(handle == SYS_FS_HANDLE_INVALID)
0000000C  00000000   NOP
3384:                    {
3385:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000018  00000000   NOP
3386:                        return SYS_FS_RES_FAILURE;
00000020  00000000   NOP
3387:                    }
3388:                
3389:                    if(obj->inUse == 0)
00000028  00000000   NOP
3390:                    {
3391:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000034  00000000   NOP
3392:                        return SYS_FS_RES_FAILURE;
0000003C  00000000   NOP
3393:                    }
3394:                
3395:                    /* Now, call the real file open function */
3396:                
3397:                    if(obj->mountPoint->fsFunctions->readDir == NULL)
00000044  00000000   NOP
3398:                    {
3399:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000054  00000000   NOP
3400:                        return SYS_FS_RES_FAILURE;
0000005C  00000000   NOP
3401:                    }
3402:                    if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
3403:                    {
3404:                        fileStatus = obj->mountPoint->fsFunctions->readDir(obj->nativeFSDirObj, (uintptr_t)stat);
00000074  00000000   NOP
3405:                
3406:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
0000008C  00000000   NOP
3407:                    }
3408:                
3409:                    if(fileStatus == 0)
00000098  00000000   NOP
3410:                    {
3411:                        return SYS_FS_RES_SUCCESS;
3412:                    }
3413:                    else
3414:                    {
3415:                        obj->errorValue = fileStatus;
000000A0  00000000   NOP
3416:                        return SYS_FS_RES_FAILURE;
000000A4  00000000   NOP
3417:                    }
3418:                }
000000A8  00000000   NOP
3419:                
3420:                //******************************************************************************
3421:                /* Function:
3422:                	SYS_FS_RESULT SYS_FS_DirRewind(SYS_FS_HANDLE handle)
3423:                
3424:                
3425:                  Summary:
3426:                     Read specified directory
3427:                
3428:                  Description:
3429:                	The SYS_FS_DirRewind() function shall attempt to rewind the directory to the
3430:                        start. Once a seach or directory read is completed, the rewind function is
3431:                        used to begin searching the directory from the start.
3432:                
3433:                  Precondition:
3434:                    A valid directory handle must be obtained before reading a directory.
3435:                
3436:                  Parameters:
3437:                        handle			- directory handle obtained during directory open.
3438:                
3439:                  Returns:
3440:                        If Success	-	SYS_FS_RES_SUCCESS
3441:                
3442:                        If Failure	-	SYS_FS_RES_FAILURE
3443:                
3444:                	The reason for failure could be retrieved with SYS_FS_Error
3445:                
3446:                  Remarks:
3447:                	None
3448:                */
3449:                
3450:                SYS_FS_RESULT SYS_FS_DirRewind(SYS_FS_HANDLE handle)
3451:                {
00000000  00000000   NOP
3452:                    int fileStatus = -1;
3453:                    SYS_FS_DIR_OBJ *obj = (SYS_FS_DIR_OBJ *)handle;
3454:                
3455:                    if(handle == SYS_FS_HANDLE_INVALID)
0000000C  00000000   NOP
3456:                    {
3457:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000018  00000000   NOP
3458:                        return SYS_FS_RES_FAILURE;
00000020  00000000   NOP
3459:                    }
3460:                
3461:                    if(obj->inUse == 0)
00000028  00000000   NOP
3462:                    {
3463:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000034  00000000   NOP
3464:                        return SYS_FS_RES_FAILURE;
0000003C  00000000   NOP
3465:                    }
3466:                
3467:                    /* Now, call the real file open function */
3468:                
3469:                    if(obj->mountPoint->fsFunctions->readDir == NULL)
00000044  00000000   NOP
3470:                    {
3471:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000054  00000000   NOP
3472:                        return SYS_FS_RES_FAILURE;
0000005C  00000000   NOP
3473:                    }
3474:                        if(OSAL_MUTEX_Lock(&(obj->mountPoint->mutexDiskVolume), OSAL_WAIT_FOREVER)
3475:                                                                        == OSAL_RESULT_TRUE)
3476:                    {
3477:                
3478:                        fileStatus = obj->mountPoint->fsFunctions->readDir(obj->nativeFSDirObj, (uintptr_t)NULL);
00000074  00000000   NOP
3479:                        OSAL_MUTEX_Unlock(&(obj->mountPoint->mutexDiskVolume));
00000090  00000000   NOP
3480:                    }
3481:                
3482:                
3483:                    if(fileStatus == 0)
0000009C  00000000   NOP
3484:                    {
3485:                        return SYS_FS_RES_SUCCESS;
3486:                    }
3487:                    else
3488:                    {
3489:                        obj->errorValue = fileStatus;
000000A4  00000000   NOP
3490:                        return SYS_FS_RES_FAILURE;
000000A8  00000000   NOP
3491:                    }
3492:                }
000000AC  00000000   NOP
3493:                
3494:                //******************************************************************************
3495:                /* Function:
3496:                	SYS_FS_RESULT SYS_FS_DirSearch(SYS_FS_HANDLE handle, const char * name, SYS_FS_FILE_DIR_ATTR attr, SYS_FS_FSTAT *stat)
3497:                
3498:                
3499:                  Summary:
3500:                        Find a file/ directory
3501:                
3502:                  Description:
3503:                	Find a file or directory as specified by the name. The type of name is specified
3504:                        by attr variable, which if of type SYS_FS_FILE_DIR_ATTR.
3505:                
3506:                  Precondition:
3507:                    A valid directory handle must be obtained before reading a directory.
3508:                
3509:                  Parameters:
3510:                        handle			- directory handle obtained during directory open.
3511:                
3512:                        name                    - name of file or directory needed to be opened.
3513:                                                  The file name can have wild card entries as mentioned below: -
3514:                                                - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*)
3515:                                                - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T)
3516:                
3517:                        attr                    - Attribute of the name of type SYS_FS_FILE_DIR_ATTR. This
3518:                                                  attribute specifies whether the name is for a file or a
3519:                                                  directory. Also, other attribute types could be spcified.
3520:                
3521:                        stat                    - Empty structure of type SYS_FS_FSTAT, where the properties
3522:                                                  of the open directory will be populated after the SYS_FS_DirRead()
3523:                                                  function returns successfully.
3524:                                                  If LFN is used, then the "lfname" member of the
3525:                                                  SYS_FS_FSTAT structure should be initialized with address of
3526:                                                  suitable buffer. Also, the "lfsize" should be initialized with
3527:                                                  the size of buffer.
3528:                                                  Once the function returns, the buffer whose address is held in "lfname"
3529:                                                  will have the file name (long file name)
3530:                
3531:                
3532:                
3533:                  Returns:
3534:                        If spcified file/ directory found	-	SYS_FS_RES_SUCCESS
3535:                
3536:                        If spcified file/ directory not found	-	SYS_FS_RES_FAILURE
3537:                
3538:                	The reason for failure could be retrieved with SYS_FS_Error
3539:                
3540:                  Remarks:
3541:                	None
3542:                */
3543:                
3544:                SYS_FS_RESULT SYS_FS_DirSearch(SYS_FS_HANDLE handle, const char * name, SYS_FS_FILE_DIR_ATTR attr, SYS_FS_FSTAT *stat)
3545:                {
00000000  00000000   NOP
3546:                    int fileStatus = -1;
3547:                
3548:                    while(1)
3549:                    {
3550:                        fileStatus = SYS_FS_DirRead(handle, stat);
00000030  00000000   NOP
000000D0  00000000   NOP
3551:                
3552:                        if(fileStatus != 0)
0000003C  00000000   NOP
3553:                        {
3554:                            errorValue = fileStatus;
00000044  00000000   NOP
3555:                            return SYS_FS_RES_FAILURE;
00000048  00000000   NOP
3556:                        }
3557:                        /* If we have come to end of directory */
3558:                        if((*stat->lfname == '\0') && (*stat->fname == '\0'))
00000050  00000000   NOP
3559:                        {
3560:                            errorValue = SYS_FS_ERROR_NO_FILE;
00000068  00000000   NOP
3561:                            return SYS_FS_RES_FAILURE;
00000070  00000000   NOP
3562:                        }
3563:                
3564:                        /* Firstly, match the file attribute with the requested attribute */
3565:                        if(stat->fattrib & attr)
000000B0  00000000   NOP
3566:                        {
3567:                            if(*stat->lfname != '\0')
3568:                            {
3569:                                /* File name is LFN */
3570:                                if(_SYS_FS_StringWildCardCompare(name, stat->lfname) == true)
00000078  00000000   NOP
3571:                                {
3572:                                    return SYS_FS_RES_SUCCESS;
3573:                                }
3574:                            }
3575:                            else
3576:                            {
3577:                                /* File name fits in 8.3 format */
3578:                                if(_SYS_FS_StringWildCardCompare(name, stat->fname) == true)
0000002C  00000000   NOP
00000090  00000000   NOP
3579:                                {
3580:                                    return SYS_FS_RES_SUCCESS;
3581:                                }
3582:                            }
3583:                        }
3584:                    }
3585:                
3586:                    errorValue = SYS_FS_ERROR_NO_FILE;
3587:                    return SYS_FS_RES_FAILURE;
3588:                }
000000A8  00000000   NOP
000000D8  00000000   NOP
3589:                
3590:                //******************************************************************************
3591:                /* Function:
3592:                	SYS_FS_RESULT SYS_FS_DirClose(SYS_FS_HANDLE handle)
3593:                
3594:                
3595:                  Summary:
3596:                     Close an opened directory
3597:                
3598:                  Description:
3599:                	The SYS_FS_DirClose() function closes a directory which was earlier opened
3600:                        with the function SYS_FS_DirOpen(). Internally, this function just clears
3601:                        the allocated objects, so that they can be reused.
3602:                
3603:                  Precondition:
3604:                    A valid directory handle must be obtained before closing the directory.
3605:                
3606:                  Parameters:
3607:                        handle			- directory handle obtained during directory open.
3608:                
3609:                  Returns:
3610:                        If Success	-	SYS_FS_RES_SUCCESS
3611:                
3612:                        If Failure	-	SYS_FS_RES_FAILURE
3613:                
3614:                	The reason for failure could be retrieved with SYS_FS_Error
3615:                
3616:                  Remarks:
3617:                	None
3618:                */
3619:                
3620:                SYS_FS_RESULT SYS_FS_DirClose(SYS_FS_HANDLE handle)
3621:                {
00000000  00000000   NOP
3622:                    int fileStatus = -1;
3623:                    SYS_FS_DIR_OBJ *obj = (SYS_FS_DIR_OBJ *)handle;
3624:                
3625:                    if(handle == SYS_FS_HANDLE_INVALID)
0000000C  00000000   NOP
3626:                    {
3627:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000018  00000000   NOP
3628:                        return SYS_FS_RES_FAILURE;
00000020  00000000   NOP
3629:                    }
3630:                
3631:                    if(obj->inUse == false)
00000028  00000000   NOP
3632:                    {
3633:                        errorValue = SYS_FS_ERROR_INVALID_OBJECT;
00000034  00000000   NOP
3634:                        SYS_ASSERT(false,"File object is not in use");
3635:                        return SYS_FS_RES_FAILURE;
0000003C  00000000   NOP
3636:                    }
3637:                
3638:                    if(obj->mountPoint->fsFunctions->closeDir == NULL)
00000044  00000000   NOP
3639:                    {
3640:                        obj->errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
00000054  00000000   NOP
3641:                        return SYS_FS_RES_FAILURE;
0000005C  00000000   NOP
3642:                    }
3643:                
3644:                    /* Now, call the real file open function */
3645:                
3646:                    fileStatus = obj->mountPoint->fsFunctions->closeDir(obj->nativeFSDirObj);
00000064  00000000   NOP
3647:                    if(fileStatus == 0)
0000006C  00000000   NOP
3648:                    {
3649:                        /* Return the SYS_FS file system object. */
3650:                        obj->inUse = false;
3651:                        return SYS_FS_RES_SUCCESS;
00000074  00000000   NOP
3652:                    }
3653:                    else
3654:                    {
3655:                        obj->errorValue = fileStatus;
3656:                        return SYS_FS_RES_FAILURE;
0000007C  00000000   NOP
3657:                    }
3658:                }
00000080  00000000   NOP
3659:                
3660:                //******************************************************************************
3661:                /* Function:
3662:                    SYS_FS_RESULT SYS_FS_DrivePartition(const char *path, const uint32_t partition[], void *work)
3663:                
3664:                  Summary:
3665:                    Partitions a physical drive (media).
3666:                
3667:                  Description:
3668:                    This function partitions a physical drive (media) into requested partition sizes. This
3669:                    function will alter the MBR of the physical drive and make it into multi paritions.
3670:                    Windows operating systems do not support multi paritioned removable media.
3671:                
3672:                    Maximum 4 partitions can be created on a media.
3673:                
3674:                  Precondition:
3675:                    Prior to partitioning the media, the media should have a valid MBR and it should be
3676:                    mounted as a volume with the file system.
3677:                
3678:                  Parameters:
3679:                    path      	     			- Path to the volume with the volume name. The string of
3680:                                                          volume name has to be preceeded by "/mnt/". Also,
3681:                                                          the volume name and directory name has to be separated by a
3682:                                                          slash "/".
3683:                    partition[]                         - Array with 4 items, where each items mentions the sizes
3684:                                                          of each parition in terms of number of sector. 0th element of
3685:                                                          array specifies the number of sectors for first partition and
3686:                                                          3rd element of array specifies the number of sectors for fourth
3687:                                                          partition.
3688:                
3689:                    work                                - Pointer to the buffer for function work area. The size must be
3690:                                                          at least FAT_FS_MAX_SS bytes.
3691:                
3692:                  Returns:
3693:                	If Success                      - SYS_FS_RES_SUCCESS
3694:                
3695:                	If Failure 			- SYS_FS_RES_FAILURE
3696:                
3697:                	The reason for failure could be retrieved with SYS_FS_Error
3698:                
3699:                  Remarks:
3700:                	None
3701:                */
3702:                
3703:                SYS_FS_RESULT SYS_FS_DrivePartition(const char *path, const uint32_t partition[], void *work)
3704:                {
00000000  00000000   NOP
3705:                    int fileStatus = SYS_FS_ERROR_NOT_READY;
3706:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000018  00000000   NOP
3707:                
3708:                    /* Get disk number */
3709:                    if(_SYS_FS_DiskGet(path, &disk) == SYS_FS_RES_FAILURE)
0000001C  00000000   NOP
3710:                    {
3711:                        // reason or cause of error is alredy present in "errorValue" variable
3712:                        return SYS_FS_RES_FAILURE;
00000090  00000000   NOP
3713:                    }
3714:                
3715:                    /* For MPFS file system, opening a file is possible only in "READ" mode */
3716:                    if(disk->fsType == MPFS2)
00000030  00000000   NOP
3717:                    {
3718:                        errorValue = SYS_FS_ERROR_DENIED;
00000040  00000000   NOP
3719:                        return SYS_FS_RES_FAILURE;
00000048  00000000   NOP
3720:                    }
3721:                
3722:                    /* Now, call the real file open function */
3723:                    if(disk->fsFunctions->partitionDisk == NULL)
00000050  00000000   NOP
3724:                    {
3725:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
0000005C  00000000   NOP
3726:                        return (SYS_FS_RES_FAILURE);
00000064  00000000   NOP
3727:                    }
3728:                
3729:                    fileStatus = disk->fsFunctions->partitionDisk((uint8_t)disk->diskNumber, partition, work);
0000006C  00000000   NOP
3730:                
3731:                
3732:                    if(fileStatus == 0)
0000007C  00000000   NOP
3733:                    {
3734:                        return(SYS_FS_RES_SUCCESS);
3735:                    }
3736:                    else
3737:                    {
3738:                        errorValue = fileStatus;
00000084  00000000   NOP
3739:                        return(SYS_FS_RES_FAILURE);
00000088  00000000   NOP
3740:                    }
3741:                }
00000094  00000000   NOP
3742:                
3743:                //******************************************************************************
3744:                /*Function:
3745:                    SYS_FS_RESULT SYS_FS_DriveSectorGet(const char* path, uint32_t *totalSectors, uint32_t *freeSectors)
3746:                
3747:                    Summary:
3748:                        Obtain total and free sectors
3749:                
3750:                    Description:
3751:                        Function to obtain the total number of sectors and number of free sectors in a
3752:                        drive (media).
3753:                
3754:                    Precondition:
3755:                        Atlesat, one drive has to be mounted before this funcion could be set.
3756:                
3757:                    Parameters:
3758:                        path      	     		- Path to the volume with the volume name. The string of
3759:                                                          volume name has to be preceeded by "/mnt/". Also,
3760:                                                          the volume name and directory name has to be separated by a
3761:                                                          slash "/".
3762:                
3763:                        totalSectors                    - Pointer to a variable passed to the
3764:                                                          function, which will contain the total
3765:                                                          number of sectors available in the
3766:                                                          drive (media). This data will be
3767:                                                          available only if the function
3768:                                                          returns successfully.
3769:                
3770:                        freeSectors                     - Pointer to a variable passed to the
3771:                                                          function, which will contain the free
3772:                                                          number of sectors available in the
3773:                                                          drive (media). This data will be
3774:                                                          available only if the function
3775:                                                          returns successfully.
3776:                
3777:                    Returns:
3778:                        If Success	-	SYS_FS_RES_SUCCESS
3779:                
3780:                        If Failure	-	SYS_FS_RES_FAILURE
3781:                
3782:                		The reason for failure could be retrieved with SYS_FS_Error
3783:                  Remarks:
3784:                	None
3785:                ***************************************************************************/
3786:                SYS_FS_RESULT SYS_FS_DriveSectorGet(const char* path, uint32_t *totalSectors, uint32_t *freeSectors)
3787:                {
00000000  00000000   NOP
3788:                    volatile int fileStatus = SYS_FS_ERROR_NOT_READY;
00000018  00000000   NOP
3789:                    SYS_FS_MOUNT_POINT *disk = (SYS_FS_MOUNT_POINT *) NULL;
00000020  00000000   NOP
3790:                    uint8_t pathWithDiskNo[3] = {};
00000024  00000000   NOP
3791:                
3792:                    if(path != NULL)
00000028  00000000   NOP
3793:                    {
3794:                        /* Get disk number */
3795:                        if(_SYS_FS_DiskGet(path, &disk) == SYS_FS_RES_FAILURE)
00000030  00000000   NOP
3796:                        {
3797:                            // reason or cause of error is alredy present in "errorValue" variable
3798:                            return SYS_FS_RES_FAILURE;
3799:                        }
3800:                    }
3801:                    else    /* if(drive == NULL */
3802:                    {
3803:                        if(gSYSFSCurrentMountPoint.inUse == false)
0000004C  00000000   NOP
3804:                        {
3805:                            SYS_ASSERT(false, "Invalid mount point. Was the disk mounted?");
3806:                            errorValue = SYS_FS_ERROR_NO_FILESYSTEM;
00000058  00000000   NOP
3807:                            return SYS_FS_RES_FAILURE;
00000060  00000000   NOP
3808:                        }
3809:                
3810:                        disk = gSYSFSCurrentMountPoint.currentDisk;
00000068  00000000   NOP
3811:                
3812:                    }
3813:                
3814:                    /* For MPFS file system, label name is not supported */
3815:                    if(disk->fsType == MPFS2)
0000006C  00000000   NOP
3816:                    {
3817:                        errorValue = SYS_FS_ERROR_DENIED;
00000080  00000000   NOP
3818:                        return SYS_FS_RES_FAILURE;
00000088  00000000   NOP
3819:                    }
3820:                
3821:                    /* Append "0:" before the file name. This is required
3822:                     * for different disks */
3823:                    pathWithDiskNo[0] = (uint8_t)disk->diskNumber + '0';
00000090  00000000   NOP
3824:                    pathWithDiskNo[1] = ':';
00000098  00000000   NOP
3825:                    pathWithDiskNo[2] = '\0';
000000A0  00000000   NOP
3826:                
3827:                    if(disk->fsFunctions->getCluster == NULL)
000000A4  00000000   NOP
3828:                    {
3829:                        errorValue = SYS_FS_ERROR_NOT_SUPPORTED_IN_NATIVE_FS;
000000B4  00000000   NOP
3830:                        return SYS_FS_RES_FAILURE;
000000BC  00000000   NOP
3831:                    }
3832:                    if(OSAL_MUTEX_Lock(&(disk->mutexDiskVolume), OSAL_WAIT_FOREVER)
3833:                                                                        == OSAL_RESULT_TRUE)
3834:                    {
3835:                
3836:                       fileStatus = disk->fsFunctions->getCluster((const char *)pathWithDiskNo, totalSectors, freeSectors);
000000D4  00000000   NOP
3837:                       OSAL_MUTEX_Unlock(&(disk->mutexDiskVolume));
3838:                    }
3839:                
3840:                
3841:                    if(fileStatus == 0)
000000F4  00000000   NOP
3842:                    {
3843:                        return SYS_FS_RES_SUCCESS;
3844:                    }
3845:                    else
3846:                    {
3847:                        errorValue = fileStatus;
00000100  00000000   NOP
3848:                        return SYS_FS_RES_FAILURE;
3849:                    }
3850:                }
0000010C  00000000   NOP
3851:                
3852:                /*************************************************************************
3853:                *
3854:                * END OF sys_fs.c
3855:                ***************************************************************************/
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/system/fs/ff.c
1:                   /*----------------------------------------------------------------------------/
2:                   /  FatFs - FAT file system module  R0.09b                 (C)ChaN, 2013
3:                   /-----------------------------------------------------------------------------/
4:                   / FatFs module is a generic FAT file system module for small embedded systems.
5:                   / This is a free software that opened for education, research and commercial
6:                   / developments under license policy of following terms.
7:                   /
8:                   /  Copyright (C) 2013, ChaN, all right reserved.
9:                   /
10:                  / * The FatFs module is a free software and there is NO WARRANTY.
11:                  / * No restriction on use. You can use, modify and redistribute it for
12:                  /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
13:                  / * Redistributions of source code must retain the above copyright notice.
14:                  /
15:                  /-----------------------------------------------------------------------------/
16:                  / Feb 26,'06 R0.00  Prototype.
17:                  /
18:                  / Apr 29,'06 R0.01  First stable version.
19:                  /
20:                  / Jun 01,'06 R0.02  Added FAT12 support.
21:                  /                   Removed unbuffered mode.
22:                  /                   Fixed a problem on small (<32M) partition.
23:                  / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
24:                  /
25:                  / Sep 22,'06 R0.03  Added f_rename().
26:                  /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
27:                  / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
28:                  /                   Fixed f_mkdir() creates incorrect directory on FAT32.
29:                  /
30:                  / Feb 04,'07 R0.04  Supported multiple drive system.
31:                  /                   Changed some interfaces for multiple drive system.
32:                  /                   Changed f_mountdrv() to f_mount().
33:                  /                   Added f_mkfs().
34:                  / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
35:                  /                   Added a capability of extending file size to f_lseek().
36:                  /                   Added minimization level 3.
37:                  /                   Fixed an endian sensitive code in f_mkfs().
38:                  / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
39:                  /                   Added FSInfo support.
40:                  /                   Fixed DBCS name can result FR_INVALID_NAME.
41:                  /                   Fixed short seek (<= csize) collapses the file object.
42:                  /
43:                  / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
44:                  /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
45:                  /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
46:                  / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
47:                  /                   Fixed off by one error at FAT sub-type determination.
48:                  /                   Fixed btr in f_read() can be mistruncated.
49:                  /                   Fixed cached sector is not flushed when create and close without write.
50:                  /
51:                  / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
52:                  /                   Improved performance of f_lseek() on moving to the same or following cluster.
53:                  /
54:                  / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
55:                  /                   Added long file name feature.
56:                  /                   Added multiple code page feature.
57:                  /                   Added re-entrancy for multitask operation.
58:                  /                   Added auto cluster size selection to f_mkfs().
59:                  /                   Added rewind option to f_readdir().
60:                  /                   Changed result code of critical errors.
61:                  /                   Renamed string functions to avoid name collision.
62:                  / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
63:                  /                   Added multiple sector size feature.
64:                  / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
65:                  /                   Fixed wrong cache control in f_lseek().
66:                  /                   Added relative path feature.
67:                  /                   Added f_chdir() and f_chdrive().
68:                  /                   Added proper case conversion to extended char.
69:                  / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
70:                  /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
71:                  /                   Fixed name matching error on the 13 char boundary.
72:                  /                   Added a configuration option, _LFN_UNICODE.
73:                  /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
74:                  /
75:                  / May 15,'10 R0.08  Added a memory configuration option. (FAT_FS_USE_LFN = 3)
76:                  /                   Added file lock feature. (_FS_SHARE)
77:                  /                   Added fast seek feature. (_USE_FASTSEEK)
78:                  /                   Changed some types on the API, XCHAR->TCHAR.
79:                  /                   Changed fname member in the FILINFO structure on Unicode cfg.
80:                  /                   String functions support UTF-8 encoding files on Unicode cfg.
81:                  / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
82:                  /                   Added sector erase feature. (_USE_ERASE)
83:                  /                   Moved file lock semaphore table from fs object to the bss.
84:                  /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
85:                  /                   Fixed f_mkfs() creates wrong FAT32 volume.
86:                  / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
87:                  /                   f_lseek() reports required table size on creating CLMP.
88:                  /                   Extended format syntax of f_printf function.
89:                  /                   Ignores duplicated directory separators in given path name.
90:                  /
91:                  / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
92:                  /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
93:                  / Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
94:                  /                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
95:                  /                   Changed option name _FS_SHARE to _FS_LOCK.
96:                  / Jan 24,'13 R0.09b Added f_setlabel() and f_getlabel(). (_USE_LABEL = 1)
97:                  /---------------------------------------------------------------------------*/
98:                  
99:                  #include "system/fs/fat_fs/src/file_system/ff.h"			/* FatFs configurations and declarations */
100:                 #include "system/fs/fat_fs/src/hardware_access/diskio.h"		/* Declarations of low level disk I/O functions */
101:                 
102:                 
103:                 /*--------------------------------------------------------------------------
104:                 
105:                    Module Private Definitions
106:                 
107:                 ---------------------------------------------------------------------------*/
108:                 
109:                 #if _FATFS != 82786	/* Revision ID */
110:                 #error Wrong include file (ff.h).
111:                 #endif
112:                 
113:                 
114:                 /* Definitions on sector size */
115:                 #if FAT_FS_MAX_SS != 512 && FAT_FS_MAX_SS != 1024 && FAT_FS_MAX_SS != 2048 && FAT_FS_MAX_SS != 4096
116:                 #error Wrong sector size.
117:                 #endif
118:                 #if FAT_FS_MAX_SS != 512
119:                 #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
120:                 #else
121:                 #define	SS(fs)	512U			/* Fixed sector size */
122:                 #endif
123:                 
124:                 
125:                 /* Reentrancy related */
126:                 #if _FS_REENTRANT
127:                 #if FAT_FS_USE_LFN == 1
128:                 #error Static LFN work area must not be used in re-entrant configuration.
129:                 #endif
130:                 #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
131:                 #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
132:                 #else
133:                 #define	ENTER_FF(fs)
134:                 #define LEAVE_FF(fs, res)	return res
135:                 #endif
136:                 
137:                 #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
138:                 
139:                 
140:                 /* File access control feature */
141:                 #if _FS_LOCK
142:                 #if _FS_READONLY
143:                 #error _FS_LOCK must be 0 on read-only cfg.
144:                 #endif
145:                 typedef struct {
146:                 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
147:                 	uint32_t clu;				/* File ID 2, directory */
148:                 	uint16_t idx;				/* File ID 3, directory index */
149:                 	uint16_t ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
150:                 } FILESEM;
151:                 #endif
152:                 
153:                 
154:                 
155:                 /* DBCS code ranges and SBCS extend char conversion table */
156:                 
157:                 #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
158:                 #define _DF1S	0x81	/* DBC 1st byte range 1 start */
159:                 #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
160:                 #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
161:                 #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
162:                 #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
163:                 #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
164:                 #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
165:                 #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
166:                 
167:                 #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
168:                 #define _DF1S	0x81
169:                 #define _DF1E	0xFE
170:                 #define _DS1S	0x40
171:                 #define _DS1E	0x7E
172:                 #define _DS2S	0x80
173:                 #define _DS2E	0xFE
174:                 
175:                 #elif _CODE_PAGE == 949	/* Korean */
176:                 #define _DF1S	0x81
177:                 #define _DF1E	0xFE
178:                 #define _DS1S	0x41
179:                 #define _DS1E	0x5A
180:                 #define _DS2S	0x61
181:                 #define _DS2E	0x7A
182:                 #define _DS3S	0x81
183:                 #define _DS3E	0xFE
184:                 
185:                 #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
186:                 #define _DF1S	0x81
187:                 #define _DF1E	0xFE
188:                 #define _DS1S	0x40
189:                 #define _DS1E	0x7E
190:                 #define _DS2S	0xA1
191:                 #define _DS2E	0xFE
192:                 
193:                 #elif _CODE_PAGE == 437	/* U.S. (OEM) */
194:                 #define _DF1S	0
195:                 #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
196:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
197:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
198:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
199:                 
200:                 #elif _CODE_PAGE == 720	/* Arabic (OEM) */
201:                 #define _DF1S	0
202:                 #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
203:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
204:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
205:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
206:                 
207:                 #elif _CODE_PAGE == 737	/* Greek (OEM) */
208:                 #define _DF1S	0
209:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
210:                 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
211:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
212:                 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
213:                 
214:                 #elif _CODE_PAGE == 775	/* Baltic (OEM) */
215:                 #define _DF1S	0
216:                 #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
217:                 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
218:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
219:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
220:                 
221:                 #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
222:                 #define _DF1S	0
223:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
224:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
225:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
226:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
227:                 
228:                 #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
229:                 #define _DF1S	0
230:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
231:                 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
232:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
233:                 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
234:                 
235:                 #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
236:                 #define _DF1S	0
237:                 #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
238:                 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
239:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
240:                 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
241:                 
242:                 #elif _CODE_PAGE == 857	/* Turkish (OEM) */
243:                 #define _DF1S	0
244:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
245:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
246:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
247:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
248:                 
249:                 #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
250:                 #define _DF1S	0
251:                 #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
252:                 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
253:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
254:                 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
255:                 
256:                 #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
257:                 #define _DF1S	0
258:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
259:                 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
260:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
261:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
262:                 
263:                 #elif _CODE_PAGE == 866	/* Russian (OEM) */
264:                 #define _DF1S	0
265:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
266:                 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
267:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
268:                 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
269:                 
270:                 #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
271:                 #define _DF1S	0
272:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
273:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
274:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
275:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
276:                 
277:                 #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
278:                 #define _DF1S	0
279:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
280:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
281:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
282:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
283:                 
284:                 #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
285:                 #define _DF1S	0
286:                 #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
287:                 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
288:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
289:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
290:                 
291:                 #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
292:                 #define _DF1S	0
293:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
294:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
295:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
296:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
297:                 
298:                 #elif _CODE_PAGE == 1253 /* Greek (Windows) */
299:                 #define _DF1S	0
300:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
301:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
302:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
303:                 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
304:                 
305:                 #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
306:                 #define _DF1S	0
307:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
308:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
309:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
310:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
311:                 
312:                 #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
313:                 #define _DF1S	0
314:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
315:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
316:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
317:                 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
318:                 
319:                 #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
320:                 #define _DF1S	0
321:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
322:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
323:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
324:                 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
325:                 
326:                 #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
327:                 #define _DF1S	0
328:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
329:                 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
330:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
331:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
332:                 
333:                 #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
334:                 #define _DF1S	0
335:                 #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
336:                 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
337:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
338:                 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
339:                 
340:                 #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
341:                 #if FAT_FS_USE_LFN
342:                 #error Cannot use LFN feature without valid code page.
343:                 #endif
344:                 #define _DF1S	0
345:                 
346:                 #else
347:                 #error Unknown code page
348:                 
349:                 #endif
350:                 
351:                 
352:                 /* Character code support macros */
353:                 #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
354:                 #define IsLower(c)	(((c)>='a')&&((c)<='z'))
355:                 #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
356:                 
357:                 #if _DF1S		/* Code page is DBCS */
358:                 
359:                 #ifdef _DF2S	/* Two 1st byte areas */
360:                 #define IsDBCS1(c)	(((uint8_t)(c) >= _DF1S && (uint8_t)(c) <= _DF1E) || ((uint8_t)(c) >= _DF2S && (uint8_t)(c) <= _DF2E))
361:                 #else			/* One 1st byte area */
362:                 #define IsDBCS1(c)	((uint8_t)(c) >= _DF1S && (uint8_t)(c) <= _DF1E)
363:                 #endif
364:                 
365:                 #ifdef _DS3S	/* Three 2nd byte areas */
366:                 #define IsDBCS2(c)	(((uint8_t)(c) >= _DS1S && (uint8_t)(c) <= _DS1E) || ((uint8_t)(c) >= _DS2S && (uint8_t)(c) <= _DS2E) || ((uint8_t)(c) >= _DS3S && (uint8_t)(c) <= _DS3E))
367:                 #else			/* Two 2nd byte areas */
368:                 #define IsDBCS2(c)	(((uint8_t)(c) >= _DS1S && (uint8_t)(c) <= _DS1E) || ((uint8_t)(c) >= _DS2S && (uint8_t)(c) <= _DS2E))
369:                 #endif
370:                 
371:                 #else			/* Code page is SBCS */
372:                 
373:                 #define IsDBCS1(c)	0
374:                 #define IsDBCS2(c)	0
375:                 
376:                 #endif /* _DF1S */
377:                 
378:                 
379:                 /* Name status flags */
380:                 #define NS			11		/* Index of name status byte in fn[] */
381:                 #define NS_LOSS		0x01	/* Out of 8.3 format */
382:                 #define NS_LFN		0x02	/* Force to create LFN entry */
383:                 #define NS_LAST		0x04	/* Last segment */
384:                 #define NS_BODY		0x08	/* Lower case flag (body) */
385:                 #define NS_EXT		0x10	/* Lower case flag (ext) */
386:                 #define NS_DOT		0x20	/* Dot entry */
387:                 
388:                 
389:                 /* FAT sub-type boundaries */
390:                 /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
391:                 #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
392:                 #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
393:                 
394:                 
395:                 /* FatFs refers the members in the FAT structures as byte array instead of
396:                 / structure member because the structure is not binary compatible between
397:                 / different platforms */
398:                 
399:                 #define BS_jmpBoot			0	/* Jump instruction (3) */
400:                 #define BS_OEMName			3	/* OEM name (8) */
401:                 #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
402:                 #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
403:                 #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
404:                 #define BPB_NumFATs			16	/* Number of FAT copies (1) */
405:                 #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
406:                 #define BPB_TotSec16		19	/* Volume size [sector] (2) */
407:                 #define BPB_Media			21	/* Media descriptor (1) */
408:                 #define BPB_FATSz16			22	/* FAT size [sector] (2) */
409:                 #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
410:                 #define BPB_NumHeads		26	/* Number of heads (2) */
411:                 #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
412:                 #define BPB_TotSec32		32	/* Volume size [sector] (4) */
413:                 #define BS_DrvNum			36	/* Physical drive number (2) */
414:                 #define BS_BootSig			38	/* Extended boot signature (1) */
415:                 #define BS_VolID			39	/* Volume serial number (4) */
416:                 #define BS_VolLab			43	/* Volume label (8) */
417:                 #define BS_FilSysType		54	/* File system type (1) */
418:                 #define BPB_FATSz32			36	/* FAT size [sector] (4) */
419:                 #define BPB_ExtFlags		40	/* Extended flags (2) */
420:                 #define BPB_FSVer			42	/* File system version (2) */
421:                 #define BPB_RootClus		44	/* Root dir first cluster (4) */
422:                 #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
423:                 #define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
424:                 #define BS_DrvNum32			64	/* Physical drive number (2) */
425:                 #define BS_BootSig32		66	/* Extended boot signature (1) */
426:                 #define BS_VolID32			67	/* Volume serial number (4) */
427:                 #define BS_VolLab32			71	/* Volume label (8) */
428:                 #define BS_FilSysType32		82	/* File system type (1) */
429:                 #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
430:                 #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
431:                 #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
432:                 #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
433:                 #define MBR_Table			446	/* MBR: Partition table offset (2) */
434:                 #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
435:                 #define BS_55AA				510	/* Boot sector signature (2) */
436:                 
437:                 #define	DIR_Name			0	/* Short file name (11) */
438:                 #define	DIR_Attr			11	/* Attribute (1) */
439:                 #define	DIR_NTres			12	/* NT flag (1) */
440:                 #define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
441:                 #define	DIR_CrtTime			14	/* Created time (2) */
442:                 #define	DIR_CrtDate			16	/* Created date (2) */
443:                 #define DIR_LstAccDate		18	/* Last accessed date (2) */
444:                 #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
445:                 #define	DIR_WrtTime			22	/* Modified time (2) */
446:                 #define	DIR_WrtDate			24	/* Modified date (2) */
447:                 #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
448:                 #define	DIR_FileSize		28	/* File size (4) */
449:                 #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
450:                 #define	LDIR_Attr			11	/* LFN attribute (1) */
451:                 #define	LDIR_Type			12	/* LFN type (1) */
452:                 #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
453:                 #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
454:                 #define	SZ_DIR				32		/* Size of a directory entry */
455:                 #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
456:                 #define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
457:                 #define	NDDE				0x05	/* Replacement of the character collides with DDE */
458:                 
459:                 
460:                 /*------------------------------------------------------------*/
461:                 /* Module private work area                                   */
462:                 /*------------------------------------------------------------*/
463:                 /* Note that uninitialized variables with static duration are
464:                 /  zeroed/nulled at start-up. If not, the compiler or start-up
465:                 /  routine is out of ANSI-C standard.
466:                 */
467:                 
468:                 
469:                 #if SYS_FS_VOLUME_NUMBER
470:                 static FATFS_VOLUME_OBJECT __attribute__ ((coherent, aligned(16))) FAFFSVolume[SYS_FS_VOLUME_NUMBER];
471:                 static FATFS  *FatFs[SYS_FS_VOLUME_NUMBER];	/* Pointer to the file system objects (logical drives) */
472:                 #else
473:                 #error Number of volumes must not be 0.
474:                 #endif
475:                 
476:                 static FATFS_FILE_OBJECT __attribute__ ((coherent, aligned(16))) FATFSFileObject[SYS_FS_MAX_FILES];
477:                 
478:                 static FATFS_DIR_OBJECT FATFSDirObject[SYS_FS_MAX_FILES];
479:                 static uint8_t startupflag = 0;
480:                 static
481:                 uint16_t Fsid;				/* File system mount ID */
482:                 
483:                 #if _FS_RPATH
484:                 static
485:                 uint8_t CurrVol;			/* Current drive */
486:                 #endif
487:                 
488:                 #if _FS_LOCK
489:                 static
490:                 FILESEM	 Files[_FS_LOCK];	/* File lock semaphores */
491:                 #endif
492:                 
493:                 #if FAT_FS_USE_LFN == 0			/* No LFN feature */
494:                 #define	DEF_NAMEBUF			uint8_t sfn[12]
495:                 #define INIT_BUF(dobj)		(dobj).fn = sfn
496:                 #define	FREE_BUF()
497:                 
498:                 #elif FAT_FS_USE_LFN == 1			/* LFN feature with static working buffer */
499:                 static uint16_t LfnBuf[FAT_FS_MAX_LFN+1];
500:                 #define	DEF_NAMEBUF			uint8_t sfn[12]
501:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
502:                 #define	FREE_BUF()
503:                 
504:                 #define ff_convert(wc, x) ((char)wc)
505:                 
506:                 uint16_t ff_wtoupper(uint16_t wc) {
9D016E98  3082FFFF   ANDI V0, A0, -1
507:                     char c = (char)wc;
508:                     if (c >= 'a' && c <= 'z') wc -= ' ';
9D016E9C  2443FF9F   ADDIU V1, V0, -97
9D016EA0  306300FF   ANDI V1, V1, 255
9D016EA4  2C63001A   SLTIU V1, V1, 26
9D016EA8  10600003   BEQ V1, ZERO, 0x9D016EB8
9D016EAC  00000000   NOP
9D016EB0  2442FFE0   ADDIU V0, V0, -32
9D016EB4  3042FFFF   ANDI V0, V0, -1
509:                     return wc;
510:                 }
9D016EB8  03E00008   JR RA
511:                 
512:                 #elif FAT_FS_USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
513:                 #define	DEF_NAMEBUF			uint8_t sfn[12]; uint16_t lbuf[FAT_FS_MAX_LFN+1]
514:                 #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
515:                 #define	FREE_BUF()
516:                 
517:                 #elif FAT_FS_USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
518:                 #define	DEF_NAMEBUF			uint8_t sfn[12]; uint16_t *lfn
519:                 #define INIT_BUF(dobj)		{ lfn = ff_memalloc((FAT_FS_MAX_LFN + 1) * 2); \
520:                 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
521:                 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
522:                 #define	FREE_BUF()			ff_memfree(lfn)
523:                 
524:                 #else
525:                 #error Wrong LFN configuration.
526:                 #endif
527:                 
528:                 
529:                 #ifdef _EXCVT
530:                 static
531:                 const uint8_t ExCvt[] = _EXCVT;	/* Upper conversion table for extended chars */
532:                 #endif
533:                 
534:                 
535:                 /****************************************************************************
536:                  Function pointers
537:                 *****************************************************************************/
538:                 const SYS_FS_FUNCTIONS FatFsFunctions =
539:                 {
540:                     .mount  = f_mount,
541:                     .unmount = f_unmount,
542:                     .open   = f_open,
543:                     .read   = f_read,
544:                     .write  = f_write,
545:                     .close  = f_close,
546:                     .seek   = f_lseek,
547:                     .tell   = f_tell,
548:                     .eof    = f_eof,
549:                     .size   = f_size,
550:                     .fstat   = f_stat,
551:                     .mkdir = f_mkdir,
552:                     .chdir = f_chdir,
553:                     .remove = f_unlink,
554:                     .getlabel = f_getlabel,
555:                     .setlabel = f_setlabel,
556:                     .truncate = f_truncate,
557:                     .currWD = f_getcwd,
558:                     .chdrive = f_chdrive,
559:                     .chmode = f_chmod,
560:                     .chtime = f_utime,
561:                     .rename = f_rename,
562:                     .sync = f_sync,
563:                     .getstrn = f_gets,
564:                     .putchr = f_putc,
565:                     .putstrn = f_puts,
566:                     .formattedprint = f_printf,
567:                     .testerror = f_error,
568:                     .formatDisk = f_mkfs,
569:                     .openDir = f_opendir,
570:                     .readDir = f_readdir,
571:                     .closeDir = f_closedir,
572:                     .partitionDisk = f_fdisk,
573:                     .getCluster = f_getclusters
574:                 };
575:                 
576:                 
577:                 
578:                 /*--------------------------------------------------------------------------
579:                 
580:                    Module Private Functions
581:                 
582:                 ---------------------------------------------------------------------------*/
583:                 
584:                 
585:                 /*-----------------------------------------------------------------------*/
586:                 /* String functions                                                      */
587:                 /*-----------------------------------------------------------------------*/
588:                 
589:                 /* Copy memory to memory */
590:                 static
591:                 void mem_cpy (void* dst, const void* src, uint32_t cnt) {
592:                 	uint8_t *d = (uint8_t*)dst;
593:                 	const uint8_t *s = (const uint8_t*)src;
594:                 
595:                 #if _WORD_ACCESS == 1
596:                 	while (cnt >= sizeof (int)) {
597:                 		*(int*)d = *(int*)s;
598:                 		d += sizeof (int); s += sizeof (int);
599:                 		cnt -= sizeof (int);
600:                 	}
601:                 #endif
602:                 	while (cnt--)
9D016F38  10C00006   BEQ A2, ZERO, 0x9D016F54
9D016F3C  00863021   ADDU A2, A0, A2
9D016F4C  1486FFFC   BNE A0, A2, 0x9D016F40
603:                 		*d++ = *s++;
9D016F40  24840001   ADDIU A0, A0, 1
9D016F44  24A50001   ADDIU A1, A1, 1
9D016F48  90A2FFFF   LBU V0, -1(A1)
604:                 }
605:                 
606:                 /* Fill memory */
607:                 static
608:                 void mem_set (void* dst, int val, uint32_t cnt) {
609:                 	uint8_t *d = (uint8_t*)dst;
610:                 
611:                 	while (cnt--)
9D0170C0  10C00004   BEQ A2, ZERO, 0x9D0170D4
9D0170C4  00863021   ADDU A2, A0, A2
9D0170CC  1486FFFE   BNE A0, A2, 0x9D0170C8
612:                 		*d++ = (uint8_t)val;
9D0170C8  24840001   ADDIU A0, A0, 1
613:                 }
614:                 
615:                 /* Compare memory to memory */
616:                 static
617:                 int mem_cmp (const void* dst, const void* src, uint32_t cnt) {
618:                 	const uint8_t *d = (const uint8_t *)dst, *s = (const uint8_t *)src;
619:                 	int r = 0;
620:                 
621:                 	while (cnt-- && (r = *d++ - *s++) == 0) ;
9D00AC10  5205001E   BEQL S0, A1, 0x9D00AC8C
622:                 	return r;
623:                 }
624:                 
625:                 /* Check if chr is contained in the string */
626:                 static
627:                 int chk_chr (const char* str, int chr) {
628:                 	while (*str && *str != chr) str++;
9D004464  24160022   ADDIU S6, ZERO, 34
9D004468  0B401121   J follow_path::create_name
9D00446C  3C179D01   LUI S7, -25343
9D004568  1096014C   BEQ A0, S6, 0x9D004A9C
9D00456C  00803021   ADDU A2, A0, ZERO
9D004570  26E21B15   ADDIU V0, S7, 6933
9D004574  80430000   LB V1, 0(V0)
9D004578  50600005   BEQL V1, ZERO, follow_path::create_name
9D00457C  26310001   ADDIU S1, S1, 1
9D004580  14C3FFFC   BNE A2, V1, 0x9D004574
9D004584  24420001   ADDIU V0, V0, 1
9D00486C  2408002B   ADDIU T0, ZERO, 43
9D004A60  0B40121C   J 0x9D004870
9D004A64  2408002B   ADDIU T0, ZERO, 43
9D0078B8  10B4006C   BEQ A1, S4, 0x9D007A6C
9D0078BC  00A02021   ADDU A0, A1, ZERO
9D0078C0  26A21B29   ADDIU V0, S5, 6953
9D0078C4  80430000   LB V1, 0(V0)
9D0078C8  50600072   BEQL V1, ZERO, 0x9D007A94
9D0078CC  2CA20100   SLTIU V0, A1, 256
9D0078D0  1483FFFC   BNE A0, V1, 0x9D0078C4
9D0078D4  24420001   ADDIU V0, V0, 1
9D007A88  24140022   ADDIU S4, ZERO, 34
9D007A8C  0B401E04   J 0x9D007810
9D007A90  3C159D01   LUI S5, -25343
629:                 	return *str;
630:                 }
631:                 
632:                 
633:                 
634:                 /*-----------------------------------------------------------------------*/
635:                 /* Request/Release grant to access the volume                            */
636:                 /*-----------------------------------------------------------------------*/
637:                 #if _FS_REENTRANT
638:                 
639:                 static
640:                 int lock_fs (
641:                 	FATFS *fs		/* File system object */
642:                 )
643:                 {
644:                 	return ff_req_grant(fs->sobj);
645:                 }
646:                 
647:                 
648:                 static
649:                 void unlock_fs (
650:                 	FATFS *fs,		/* File system object */
651:                 	FRESULT res		/* Result code to be returned */
652:                 )
653:                 {
654:                 	if (fs &&
655:                 		res != FR_NOT_ENABLED &&
656:                 		res != FR_INVALID_DRIVE &&
657:                 		res != FR_INVALID_OBJECT &&
658:                 		res != FR_TIMEOUT) {
659:                 		ff_rel_grant(fs->sobj);
660:                 	}
661:                 }
662:                 #endif
663:                 
664:                 
665:                 
666:                 /*-----------------------------------------------------------------------*/
667:                 /* File lock control functions                                           */
668:                 /*-----------------------------------------------------------------------*/
669:                 #if _FS_LOCK
670:                 
671:                 static
672:                 FRESULT chk_lock (	/* Check if the file can be accessed */
673:                 	DIR* dj,		/* Directory object pointing the file to be checked */
674:                 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
675:                 )
676:                 {
677:                 	uint32_t i, be;
678:                 
679:                 	/* Search file semaphore table */
680:                 	for (i = be = 0; i < _FS_LOCK; i++) {
681:                 		if (Files[i].fs) {	/* Existing entry */
9D014C54  3C038001   LUI V1, -32767
9D014C58  8C634630   LW V1, 17968(V1)
9D014C5C  50600010   BEQL V1, ZERO, 0x9D014CA0
9D014C60  24060001   ADDIU A2, ZERO, 1
682:                 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
9D014C64  8C870000   LW A3, 0(A0)
9D014C68  1467000D   BNE V1, A3, 0x9D014CA0
9D014C6C  00003021   ADDU A2, ZERO, ZERO
9D014C74  8C434634   LW V1, 17972(V0)
9D014C78  8C820008   LW V0, 8(A0)
9D014C7C  14620009   BNE V1, V0, 0x9D014CA4
9D014C80  00001021   ADDU V0, ZERO, ZERO
683:                 				Files[i].clu == dj->sclust &&
9D014C70  3C028001   LUI V0, -32767
9D014C88  94434638   LHU V1, 17976(V0)
9D014C8C  94820006   LHU V0, 6(A0)
9D014C90  10620011   BEQ V1, V0, 0x9D014CD8
9D014C94  00000000   NOP
9D014C98  0B405329   J 0x9D014CA4
9D014C9C  00001021   ADDU V0, ZERO, ZERO
684:                 				Files[i].idx == dj->index) break;
9D014C84  3C028001   LUI V0, -32767
685:                 		} else {			/* Blank entry */
686:                 			be++;
687:                 		}
688:                 	}
689:                 	if (i == _FS_LOCK)	/* The file is not opened */
690:                 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
9D014CA0  00001021   ADDU V0, ZERO, ZERO
9D014CA4  14C0000E   BNE A2, ZERO, 0x9D014CE0
9D014CA8  24030012   ADDIU V1, ZERO, 18
9D014CAC  38A20002   XORI V0, A1, 2
9D014CB0  0002180A   MOVZ V1, ZERO, V0
9D014CB4  03E00008   JR RA
9D014CB8  00601021   ADDU V0, V1, ZERO
691:                 
692:                 	/* The file has been opened. Reject any open against writing file and all write mode open */
693:                 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
9D014CBC  3C028001   LUI V0, -32767
9D014CC0  9442463A   LHU V0, 17978(V0)
9D014CC4  38420100   XORI V0, V0, 256
9D014CC8  24030010   ADDIU V1, ZERO, 16
9D014CCC  0002180B   MOVN V1, ZERO, V0
9D014CD0  03E00008   JR RA
9D014CD4  00601021   ADDU V0, V1, ZERO
9D014CD8  10A0FFF8   BEQ A1, ZERO, 0x9D014CBC
9D014CDC  24020010   ADDIU V0, ZERO, 16
694:                 }
9D014CE0  03E00008   JR RA
695:                 
696:                 
697:                 static
698:                 int enq_lock (void)	/* Check if an entry is available for a new file */
699:                 {
700:                 	uint32_t i;
701:                 
702:                 	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
9D007BD0  3C028001   LUI V0, -32767
703:                 	return (i == _FS_LOCK) ? 0 : 1;
704:                 }
705:                 
706:                 
707:                 static
708:                 uint32_t inc_lock (	/* Increment file open counter and returns its index (0:int error) */
709:                 	DIR* dj,	/* Directory object pointing the file to register or increment */
710:                 	int acc		/* Desired access mode (0:Read, !0:Write) */
711:                 )
712:                 {
713:                 	uint32_t i;
714:                 
715:                 
716:                 	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
717:                 		if (Files[i].fs == dj->fs &&
9D007D34  3C038001   LUI V1, -32767
9D007D38  8C634630   LW V1, 17968(V1)
9D007D3C  14430048   BNE V0, V1, f_open::inc_lock
9D007D40  326400FE   ANDI A0, S3, 254
9D007D48  8CA64634   LW A2, 17972(A1)
9D007D4C  8FA50018   LW A1, 24(SP)
9D007D50  14C50043   BNE A2, A1, f_open::inc_lock
9D007D54  3C058001   LUI A1, -32767
718:                 			Files[i].clu == dj->sclust &&
9D007D44  3C058001   LUI A1, -32767
9D007D58  94A64638   LHU A2, 17976(A1)
9D007D5C  97A50016   LHU A1, 22(SP)
9D007D60  14C5003F   BNE A2, A1, f_open::inc_lock
9D007D64  00000000   NOP
9D007D68  0B401F63   J 0x9D007D8C
9D007D6C  00000000   NOP
719:                 			Files[i].idx == dj->index) break;
720:                 	}
721:                 
722:                 	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
723:                 		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
9D007E60  5460FFF8   BNEL V1, ZERO, 0x9D007E44
9D007E64  3C02A001   LUI V0, -24575
724:                 		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
725:                 		Files[i].fs = dj->fs;
9D007D70  AC624630   SW V0, 17968(V1)
9D007E68  0B401F5C   J 0x9D007D70
9D007E6C  3C038001   LUI V1, -32767
726:                 		Files[i].clu = dj->sclust;
9D007D74  24624630   ADDIU V0, V1, 17968
9D007D78  8FA30018   LW V1, 24(SP)
9D007D7C  AC430004   SW V1, 4(V0)
727:                 		Files[i].idx = dj->index;
9D007D80  97A30016   LHU V1, 22(SP)
9D007D84  A4430008   SH V1, 8(V0)
728:                 		Files[i].ctr = 0;
9D007D88  A440000A   SH ZERO, 10(V0)
729:                 	}
730:                 
731:                 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
9D007D8C  10800006   BEQ A0, ZERO, f_open::inc_lock
9D007D90  3C028001   LUI V0, -32767
9D007D94  9442463A   LHU V0, 17978(V0)
9D007D98  10400006   BEQ V0, ZERO, 0x9D007DB4
9D007D9C  24030100   ADDIU V1, ZERO, 256
732:                 
733:                 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
9D007DA8  9443463A   LHU V1, 17978(V0)
9D007DAC  24630001   ADDIU V1, V1, 1
9D007DB0  3063FFFF   ANDI V1, V1, -1
9D007DB4  3C028001   LUI V0, -32767
9D007DB8  A443463A   SH V1, 17978(V0)
734:                 
735:                 	return i + 1;
736:                 }
737:                 
738:                 
739:                 static
740:                 FRESULT dec_lock (	/* Decrement file open counter */
741:                 	uint32_t i			/* Semaphore index */
742:                 )
743:                 {
744:                 	uint16_t n;
745:                 	FRESULT res;
746:                 
747:                 
748:                 	if (--i < _FS_LOCK) {
9D01505C  8E040028   LW A0, 40(S0)
9D015060  24030001   ADDIU V1, ZERO, 1
9D015064  54830015   BNEL A0, V1, 0x9D0150BC
9D015068  24020002   ADDIU V0, ZERO, 2
749:                 		n = Files[i].ctr;
9D01506C  3C038001   LUI V1, -32767
9D015070  9463463A   LHU V1, 17978(V1)
750:                 		if (n == 0x100) n = 0;
9D015074  24040100   ADDIU A0, ZERO, 256
9D015078  5064000A   BEQL V1, A0, f_close::dec_lock
9D01507C  00001821   ADDU V1, ZERO, ZERO
751:                 		if (n) n--;
9D015080  10600009   BEQ V1, ZERO, 0x9D0150A8
9D015084  3C048001   LUI A0, -32767
9D015088  2463FFFF   ADDIU V1, V1, -1
9D01508C  3063FFFF   ANDI V1, V1, -1
752:                 		Files[i].ctr = n;
9D0150A4  3C048001   LUI A0, -32767
9D0150A8  0B405426   J 0x9D015098
9D0150AC  A483463A   SH V1, 17978(A0)
753:                 		if (!n) Files[i].fs = 0;
9D015090  14600007   BNE V1, ZERO, 0x9D0150B0
9D015094  A483463A   SH V1, 17978(A0)
9D015098  3C038001   LUI V1, -32767
9D01509C  0B40542C   J 0x9D0150B0
9D0150A0  AC604630   SW ZERO, 17968(V1)
754:                 		res = FR_OK;
755:                 	} else {
756:                 		res = FR_INT_ERR;
757:                 	}
758:                 	return res;
759:                 }
760:                 
761:                 
762:                 static
763:                 void clear_lock (	/* Clear lock entries of the volume */
764:                 	FATFS *fs
765:                 )
766:                 {
767:                 	uint32_t i;
768:                 
769:                 	for (i = 0; i < _FS_LOCK; i++) {
770:                 		if (Files[i].fs == fs) Files[i].fs = 0;
9D0170DC  3C028001   LUI V0, -32767
771:                 	}
772:                 }
773:                 #endif
774:                 
775:                 
776:                 
777:                 /*-----------------------------------------------------------------------*/
778:                 /* Move/Flush disk access window                                         */
779:                 /*-----------------------------------------------------------------------*/
780:                 
781:                 
782:                 #if !_FS_READONLY
783:                 static
784:                 FRESULT sync_window (
785:                 	FATFS *fs		/* File system object */
786:                 )
787:                 {
9D013118  27BDFFD8   ADDIU SP, SP, -40
9D01311C  AFBF0024   SW RA, 36(SP)
9D013120  AFB30020   SW S3, 32(SP)
9D013124  AFB2001C   SW S2, 28(SP)
9D013128  AFB10018   SW S1, 24(SP)
9D01312C  AFB00014   SW S0, 20(SP)
9D013130  00808021   ADDU S0, A0, ZERO
788:                 	uint32_t wsect;
789:                 	uint32_t nf;
790:                 
791:                 	
792:                 	if (fs->wflag) {	/* Write back the sector if it is dirty */
9D013134  90820004   LBU V0, 4(A0)
9D013138  10400025   BEQ V0, ZERO, 0x9D0131D0
9D01313C  00001821   ADDU V1, ZERO, ZERO
793:                 		wsect = fs->winsect;	/* Current sector number */
9D013140  8C910034   LW S1, 52(A0)
794:                 		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
9D013144  24930038   ADDIU S3, A0, 56
9D013148  90840001   LBU A0, 1(A0)
9D01314C  02602821   ADDU A1, S3, ZERO
9D013150  02203021   ADDU A2, S1, ZERO
9D013154  0F405432   JAL disk_write
9D013158  24070001   ADDIU A3, ZERO, 1
9D01315C  1440001C   BNE V0, ZERO, 0x9D0131D0
9D013160  24030001   ADDIU V1, ZERO, 1
795:                 			return FR_DISK_ERR;
796:                 		fs->wflag = 0;
9D013164  A2000004   SB ZERO, 4(S0)
797:                 		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
9D013168  8E020028   LW V0, 40(S0)
9D01316C  0222202B   SLTU A0, S1, V0
9D013170  14800017   BNE A0, ZERO, 0x9D0131D0
9D013174  00001821   ADDU V1, ZERO, ZERO
9D013178  8E030020   LW V1, 32(S0)
9D01317C  00431021   ADDU V0, V0, V1
9D013180  0222102B   SLTU V0, S1, V0
9D013184  10400012   BEQ V0, ZERO, 0x9D0131D0
9D013188  00001821   ADDU V1, ZERO, ZERO
798:                 			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
9D01318C  92120003   LBU S2, 3(S0)
9D013190  2E420002   SLTIU V0, S2, 2
9D013194  1440000F   BNE V0, ZERO, 0x9D0131D4
9D013198  00601021   ADDU V0, V1, ZERO
9D0131B8  2652FFFF   ADDIU S2, S2, -1
9D0131BC  24020001   ADDIU V0, ZERO, 1
9D0131C0  5642FFF7   BNEL S2, V0, 0x9D0131A0
9D0131C4  8E020020   LW V0, 32(S0)
9D0131C8  0B404C74   J 0x9D0131D0
9D0131CC  00001821   ADDU V1, ZERO, ZERO
799:                 				wsect += fs->fsize;
9D01319C  8E020020   LW V0, 32(S0)
9D0131A0  02228821   ADDU S1, S1, V0
800:                 				disk_write(fs->drv, fs->win, wsect, 1);
9D0131A4  92040001   LBU A0, 1(S0)
9D0131A8  02602821   ADDU A1, S3, ZERO
9D0131AC  02203021   ADDU A2, S1, ZERO
9D0131B0  0F405432   JAL disk_write
9D0131B4  24070001   ADDIU A3, ZERO, 1
801:                 			}
802:                 		}
803:                 	}
804:                 	return FR_OK;
805:                 }
9D0131D0  00601021   ADDU V0, V1, ZERO
806:                 #endif
807:                 
808:                 
809:                 static
810:                 FRESULT move_window (
811:                 	FATFS *fs,		/* File system object */
812:                 	uint32_t sector	/* Sector number to make appearance in the fs->win[] */
813:                 )
814:                 {
9D015A44  27BDFFE0   ADDIU SP, SP, -32
9D015A48  AFBF001C   SW RA, 28(SP)
9D015A4C  AFB10018   SW S1, 24(SP)
9D015A50  AFB00014   SW S0, 20(SP)
9D015A54  00808021   ADDU S0, A0, ZERO
9D015A58  00A08821   ADDU S1, A1, ZERO
815:                 	if (sector != fs->winsect) {	/* Changed current window */
9D015A5C  8C820034   LW V0, 52(A0)
9D015A60  1045000E   BEQ V0, A1, 0x9D015A9C
9D015A64  00001821   ADDU V1, ZERO, ZERO
816:                 #if !_FS_READONLY
817:                 		if (sync_window(fs) != FR_OK)
9D015A68  0F404C46   JAL sync_window
9D015A6C  00000000   NOP
9D015A70  1440000A   BNE V0, ZERO, 0x9D015A9C
9D015A74  24030001   ADDIU V1, ZERO, 1
818:                 			return FR_DISK_ERR;
819:                 #endif
820:                 		if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
9D015A78  92040001   LBU A0, 1(S0)
9D015A7C  26050038   ADDIU A1, S0, 56
9D015A80  02203021   ADDU A2, S1, ZERO
9D015A84  0F40561B   JAL disk_read
9D015A88  24070001   ADDIU A3, ZERO, 1
9D015A8C  14400003   BNE V0, ZERO, 0x9D015A9C
9D015A90  24030001   ADDIU V1, ZERO, 1
821:                 			return FR_DISK_ERR;
822:                 		fs->winsect = sector;
9D015A94  AE110034   SW S1, 52(S0)
823:                 	}
824:                 
825:                 	return FR_OK;
9D015A98  00001821   ADDU V1, ZERO, ZERO
826:                 }
9D015A9C  00601021   ADDU V0, V1, ZERO
827:                 
828:                 
829:                 
830:                 
831:                 /*-----------------------------------------------------------------------*/
832:                 /* Synchronize file system and strage device                             */
833:                 /*-----------------------------------------------------------------------*/
834:                 #if !_FS_READONLY
835:                 static
836:                 FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
837:                 	FATFS *fs		/* File system object */
838:                 )
839:                 {
9D011F5C  27BDFFE0   ADDIU SP, SP, -32
9D011F60  AFBF001C   SW RA, 28(SP)
9D011F64  AFB10018   SW S1, 24(SP)
9D011F68  AFB00014   SW S0, 20(SP)
840:                 	FRESULT res;
841:                 
842:                 
843:                 	res = sync_window(fs);
9D011F6C  0F404C46   JAL sync_window
9D011F70  00808021   ADDU S0, A0, ZERO
844:                 	if (res == FR_OK) {
9D011F74  1440003A   BNE V0, ZERO, 0x9D012060
9D011F78  8FBF001C   LW RA, 28(SP)
845:                 		/* Update FSInfo sector if needed */
846:                 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
9D011F7C  92030000   LBU V1, 0(S0)
9D011F80  24020003   ADDIU V0, ZERO, 3
9D011F84  54620031   BNEL V1, V0, 0x9D01204C
9D011F88  92040001   LBU A0, 1(S0)
9D011F8C  92020005   LBU V0, 5(S0)
9D011F90  5040002E   BEQL V0, ZERO, 0x9D01204C
9D011F94  92040001   LBU A0, 1(S0)
847:                 			fs->winsect = 0;
9D011F98  AE000034   SW ZERO, 52(S0)
848:                 			/* Create FSInfo structure */
849:                 			mem_set(fs->win, 0, 512);
9D011F9C  26110038   ADDIU S1, S0, 56
9D011FA0  02202021   ADDU A0, S1, ZERO
9D011FA4  00002821   ADDU A1, ZERO, ZERO
9D011FA8  0F405C30   JAL mem_set
9D011FAC  24060200   ADDIU A2, ZERO, 512
850:                 			ST_WORD(fs->win+BS_55AA, 0xAA55);
9D011FB0  24020055   ADDIU V0, ZERO, 85
9D011FB4  A2020236   SB V0, 566(S0)
9D011FB8  2402FFAA   ADDIU V0, ZERO, -86
9D011FBC  A2020237   SB V0, 567(S0)
851:                 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
9D011FC0  24020052   ADDIU V0, ZERO, 82
9D011FC4  A2020038   SB V0, 56(S0)
9D011FC8  A2020039   SB V0, 57(S0)
9D011FCC  24020061   ADDIU V0, ZERO, 97
9D011FD0  A202003A   SB V0, 58(S0)
9D011FD4  24030041   ADDIU V1, ZERO, 65
9D011FD8  A203003B   SB V1, 59(S0)
852:                 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
9D011FDC  24040072   ADDIU A0, ZERO, 114
9D011FE0  A204021C   SB A0, 540(S0)
9D011FE4  A204021D   SB A0, 541(S0)
9D011FE8  A203021E   SB V1, 542(S0)
9D011FEC  A202021F   SB V0, 543(S0)
853:                 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
9D011FF0  8E020010   LW V0, 16(S0)
9D011FF4  A2020220   SB V0, 544(S0)
9D011FF8  7C433A00   EXT V1, V0, 8, 8
9D011FFC  A2030221   SB V1, 545(S0)
9D012000  00021C02   SRL V1, V0, 16
9D012004  A2030222   SB V1, 546(S0)
9D012008  00021602   SRL V0, V0, 24
9D01200C  A2020223   SB V0, 547(S0)
854:                 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
9D012010  8E02000C   LW V0, 12(S0)
9D012014  A2020224   SB V0, 548(S0)
9D012018  7C433A00   EXT V1, V0, 8, 8
9D01201C  A2030225   SB V1, 549(S0)
9D012020  00021C02   SRL V1, V0, 16
9D012024  A2030226   SB V1, 550(S0)
9D012028  00021602   SRL V0, V0, 24
9D01202C  A2020227   SB V0, 551(S0)
855:                 			/* Write it into the FSInfo sector */
856:                 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
9D012030  92040001   LBU A0, 1(S0)
9D012034  02202821   ADDU A1, S1, ZERO
9D012038  8E060014   LW A2, 20(S0)
9D01203C  0F405432   JAL disk_write
9D012040  24070001   ADDIU A3, ZERO, 1
857:                 			fs->fsi_flag = 0;
9D012044  A2000005   SB ZERO, 5(S0)
858:                 		}
859:                 		/* Make sure that no pending write process in the physical drive */
860:                 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
9D012048  92040001   LBU A0, 1(S0)
9D01204C  00002821   ADDU A1, ZERO, ZERO
9D012050  0F40553C   JAL disk_ioctl
9D012054  00003021   ADDU A2, ZERO, ZERO
9D012058  0002102B   SLTU V0, ZERO, V0
861:                 			res = FR_DISK_ERR;
862:                 	}
863:                 
864:                 	return res;
865:                 }
9D01205C  8FBF001C   LW RA, 28(SP)
866:                 #endif
867:                 
868:                 
869:                 
870:                 
871:                 /*-----------------------------------------------------------------------*/
872:                 /* Get sector# from cluster#                                             */
873:                 /*-----------------------------------------------------------------------*/
874:                 
875:                 
876:                 uint32_t clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
877:                 	FATFS *fs,		/* File system object */
878:                 	uint32_t clst		/* Cluster# to be converted */
879:                 )
880:                 {
881:                 	clst -= 2;
9D016AC4  24A5FFFE   ADDIU A1, A1, -2
882:                 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
9D016AC8  8C83001C   LW V1, 28(A0)
9D016ACC  2463FFFE   ADDIU V1, V1, -2
9D016AD0  00A3182B   SLTU V1, A1, V1
9D016AD4  10600005   BEQ V1, ZERO, 0x9D016AEC
9D016AD8  00001021   ADDU V0, ZERO, ZERO
883:                 	return clst * fs->csize + fs->database;
9D016ADC  90830002   LBU V1, 2(A0)
9D016AE0  8C820030   LW V0, 48(A0)
9D016AE4  70A32002   MUL A0, A1, V1
9D016AE8  00821021   ADDU V0, A0, V0
884:                 }
9D016AEC  03E00008   JR RA
885:                 
886:                 
887:                 
888:                 
889:                 /*-----------------------------------------------------------------------*/
890:                 /* FAT access - Read value of a FAT entry                                */
891:                 /*-----------------------------------------------------------------------*/
892:                 
893:                 
894:                 uint32_t get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
895:                 	FATFS *fs,	/* File system object */
896:                 	uint32_t clst	/* Cluster# to get the link information */
897:                 )
898:                 {
9D00F804  27BDFFD8   ADDIU SP, SP, -40
9D00F808  AFBF0024   SW RA, 36(SP)
9D00F80C  AFB30020   SW S3, 32(SP)
9D00F810  AFB2001C   SW S2, 28(SP)
9D00F814  AFB10018   SW S1, 24(SP)
9D00F818  AFB00014   SW S0, 20(SP)
899:                 	uint32_t wc, bc;
900:                 	uint8_t *p;
901:                 
902:                 
903:                 	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
9D00F81C  2CA20002   SLTIU V0, A1, 2
9D00F820  14400051   BNE V0, ZERO, 0x9D00F968
9D00F824  00A08021   ADDU S0, A1, ZERO
9D00F828  00808821   ADDU S1, A0, ZERO
9D00F82C  8C82001C   LW V0, 28(A0)
9D00F830  00A2102B   SLTU V0, A1, V0
9D00F834  1040004D   BEQ V0, ZERO, 0x9D00F96C
9D00F838  24030001   ADDIU V1, ZERO, 1
904:                 		return 1;
905:                 
906:                 	switch (fs->fs_type) {
9D00F83C  90820000   LBU V0, 0(A0)
9D00F840  24030002   ADDIU V1, ZERO, 2
9D00F844  50430025   BEQL V0, V1, 0x9D00F8DC
9D00F848  00052A02   SRL A1, A1, 8
9D00F84C  24030003   ADDIU V1, ZERO, 3
9D00F850  5043002F   BEQL V0, V1, 0x9D00F910
9D00F854  000529C2   SRL A1, A1, 7
9D00F858  24030001   ADDIU V1, ZERO, 1
9D00F85C  54430043   BNEL V0, V1, 0x9D00F96C
9D00F860  2403FFFF   ADDIU V1, ZERO, -1
907:                 	case FS_FAT12 :
908:                 		bc = (uint32_t)clst; bc += bc / 2;
9D00F864  00059042   SRL S2, A1, 1
9D00F868  02459021   ADDU S2, S2, A1
909:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
9D00F86C  00122A42   SRL A1, S2, 9
9D00F870  8C820028   LW V0, 40(A0)
9D00F874  0F405691   JAL move_window
9D00F878  00A22821   ADDU A1, A1, V0
9D00F87C  1440003B   BNE V0, ZERO, 0x9D00F96C
9D00F880  2403FFFF   ADDIU V1, ZERO, -1
910:                 		wc = fs->win[bc % SS(fs)]; bc++;
9D00F884  324201FF   ANDI V0, S2, 511
9D00F888  02221021   ADDU V0, S1, V0
9D00F88C  90530038   LBU S3, 56(V0)
9D00F890  26520001   ADDIU S2, S2, 1
911:                 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
9D00F894  00122A42   SRL A1, S2, 9
9D00F898  8E220028   LW V0, 40(S1)
9D00F89C  02202021   ADDU A0, S1, ZERO
9D00F8A0  0F405691   JAL move_window
9D00F8A4  00A22821   ADDU A1, A1, V0
9D00F8A8  14400030   BNE V0, ZERO, 0x9D00F96C
9D00F8AC  2403FFFF   ADDIU V1, ZERO, -1
912:                 		wc |= fs->win[bc % SS(fs)] << 8;
9D00F8B0  325201FF   ANDI S2, S2, 511
9D00F8B4  02328821   ADDU S1, S1, S2
9D00F8B8  92220038   LBU V0, 56(S1)
9D00F8BC  00021200   SLL V0, V0, 8
9D00F8C0  00539825   OR S3, V0, S3
913:                 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
9D00F8C4  32030001   ANDI V1, S0, 1
9D00F8C8  00131102   SRL V0, S3, 4
9D00F8CC  32730FFF   ANDI S3, S3, 4095
9D00F8D0  0263100A   MOVZ V0, S3, V1
9D00F8D4  0B403E5B   J 0x9D00F96C
9D00F8D8  00401821   ADDU V1, V0, ZERO
914:                 
915:                 	case FS_FAT16 :
916:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
9D00F8DC  8C820028   LW V0, 40(A0)
9D00F8E0  0F405691   JAL move_window
9D00F8E4  00A22821   ADDU A1, A1, V0
9D00F8E8  14400020   BNE V0, ZERO, 0x9D00F96C
9D00F8EC  2403FFFF   ADDIU V1, ZERO, -1
917:                 		p = &fs->win[clst * 2 % SS(fs)];
9D00F8F0  00108040   SLL S0, S0, 1
9D00F8F4  321001FE   ANDI S0, S0, 510
918:                 		return LD_WORD(p);
9D00F8F8  02301021   ADDU V0, S1, S0
9D00F8FC  90430039   LBU V1, 57(V0)
9D00F900  00031A00   SLL V1, V1, 8
9D00F904  90420038   LBU V0, 56(V0)
9D00F908  0B403E5B   J 0x9D00F96C
9D00F90C  00621825   OR V1, V1, V0
919:                 
920:                 	case FS_FAT32 :
921:                 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
9D00F910  8C820028   LW V0, 40(A0)
9D00F914  0F405691   JAL move_window
9D00F918  00A22821   ADDU A1, A1, V0
9D00F91C  14400013   BNE V0, ZERO, 0x9D00F96C
9D00F920  2403FFFF   ADDIU V1, ZERO, -1
922:                 		p = &fs->win[clst * 4 % SS(fs)];
9D00F924  00108080   SLL S0, S0, 2
9D00F928  321001FC   ANDI S0, S0, 508
9D00F92C  26020038   ADDIU V0, S0, 56
9D00F930  02221021   ADDU V0, S1, V0
923:                 		return LD_DWORD(p) & 0x0FFFFFFF;
9D00F934  90440002   LBU A0, 2(V0)
9D00F938  00042400   SLL A0, A0, 16
9D00F93C  90430003   LBU V1, 3(V0)
9D00F940  00031E00   SLL V1, V1, 24
9D00F944  00831825   OR V1, A0, V1
9D00F948  90420001   LBU V0, 1(V0)
9D00F94C  00021200   SLL V0, V0, 8
9D00F950  00621825   OR V1, V1, V0
9D00F954  02308021   ADDU S0, S1, S0
9D00F958  92020038   LBU V0, 56(S0)
9D00F95C  00621825   OR V1, V1, V0
9D00F960  0B403E5B   J 0x9D00F96C
9D00F964  7C63D800   EXT V1, V1, 0, 28
9D00F968  24030001   ADDIU V1, ZERO, 1
924:                 	}
925:                 
926:                 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
927:                 }
9D00F96C  00601021   ADDU V0, V1, ZERO
928:                 
929:                 
930:                 
931:                 
932:                 /*-----------------------------------------------------------------------*/
933:                 /* FAT access - Change value of a FAT entry                              */
934:                 /*-----------------------------------------------------------------------*/
935:                 #if !_FS_READONLY
936:                 
937:                 FRESULT put_fat (
938:                 	FATFS *fs,	/* File system object */
939:                 	uint32_t clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
940:                 	uint32_t val	/* New value to mark the cluster */
941:                 )
942:                 {
9D00E96C  27BDFFD8   ADDIU SP, SP, -40
9D00E970  AFBF0024   SW RA, 36(SP)
9D00E974  AFB30020   SW S3, 32(SP)
9D00E978  AFB2001C   SW S2, 28(SP)
9D00E97C  AFB10018   SW S1, 24(SP)
9D00E980  AFB00014   SW S0, 20(SP)
9D00E984  00A08021   ADDU S0, A1, ZERO
943:                 	uint32_t bc;
944:                 	uint8_t *p;
945:                 	FRESULT res;
946:                 
947:                 
948:                 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
9D00E988  2CA30002   SLTIU V1, A1, 2
9D00E98C  1460005F   BNE V1, ZERO, 0x9D00EB0C
9D00E990  24020002   ADDIU V0, ZERO, 2
9D00E994  8C83001C   LW V1, 28(A0)
9D00E998  00A3182B   SLTU V1, A1, V1
9D00E99C  1060005B   BEQ V1, ZERO, 0x9D00EB0C
9D00E9A0  00808821   ADDU S1, A0, ZERO
949:                 		res = FR_INT_ERR;
950:                 
951:                 	} else {
952:                 		switch (fs->fs_type) {
9D00E9A4  90820000   LBU V0, 0(A0)
9D00E9A8  24030002   ADDIU V1, ZERO, 2
9D00E9AC  10430031   BEQ V0, V1, 0x9D00EA74
9D00E9B0  00C09021   ADDU S2, A2, ZERO
9D00E9B4  24030003   ADDIU V1, ZERO, 3
9D00E9B8  1043003B   BEQ V0, V1, 0x9D00EAA8
9D00E9BC  24030001   ADDIU V1, ZERO, 1
9D00E9C0  14430050   BNE V0, V1, 0x9D00EB04
9D00E9C4  24020002   ADDIU V0, ZERO, 2
953:                 		case FS_FAT12 :
954:                 			bc = (uint32_t)clst; bc += bc / 2;
9D00E9C8  00059842   SRL S3, A1, 1
9D00E9CC  02659821   ADDU S3, S3, A1
955:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D00E9D0  00132A42   SRL A1, S3, 9
9D00E9D4  8C820028   LW V0, 40(A0)
9D00E9D8  0F405691   JAL move_window
9D00E9DC  00A22821   ADDU A1, A1, V0
956:                 			if (res != FR_OK) break;
9D00E9E0  14400049   BNE V0, ZERO, 0x9D00EB08
9D00E9E4  24030001   ADDIU V1, ZERO, 1
957:                 			p = &fs->win[bc % SS(fs)];
9D00E9E8  326301FF   ANDI V1, S3, 511
958:                 			*p = (clst & 1) ? ((*p & 0x0F) | ((uint8_t)val << 4)) : (uint8_t)val;
9D00E9EC  32100001   ANDI S0, S0, 1
9D00E9F0  12000008   BEQ S0, ZERO, 0x9D00EA14
9D00E9F4  324200FF   ANDI V0, S2, 255
9D00E9F8  02231021   ADDU V0, S1, V1
9D00E9FC  90440038   LBU A0, 56(V0)
9D00EA00  3084000F   ANDI A0, A0, 15
9D00EA04  324200FF   ANDI V0, S2, 255
9D00EA08  00021100   SLL V0, V0, 4
9D00EA0C  00821025   OR V0, A0, V0
9D00EA10  304200FF   ANDI V0, V0, 255
9D00EA14  02231821   ADDU V1, S1, V1
9D00EA18  A0620038   SB V0, 56(V1)
959:                 			bc++;
9D00EA1C  26730001   ADDIU S3, S3, 1
960:                 			fs->wflag = 1;
9D00EA20  24020001   ADDIU V0, ZERO, 1
9D00EA24  A2220004   SB V0, 4(S1)
961:                 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
9D00EA28  00132A42   SRL A1, S3, 9
9D00EA2C  8E220028   LW V0, 40(S1)
9D00EA30  02202021   ADDU A0, S1, ZERO
9D00EA34  0F405691   JAL move_window
9D00EA38  00A22821   ADDU A1, A1, V0
962:                 			if (res != FR_OK) break;
9D00EA3C  14400032   BNE V0, ZERO, 0x9D00EB08
9D00EA40  24030001   ADDIU V1, ZERO, 1
963:                 			p = &fs->win[bc % SS(fs)];
964:                 			*p = (clst & 1) ? (uint8_t)(val >> 4) : ((*p & 0xF0) | ((uint8_t)(val >> 8) & 0x0F));
9D00EA44  12000003   BEQ S0, ZERO, 0x9D00EA54
9D00EA48  327301FF   ANDI S3, S3, 511
9D00EA4C  0B403A9A   J 0x9D00EA68
9D00EA50  7E523900   EXT S2, S2, 4, 8
9D00EA54  02331821   ADDU V1, S1, S3
9D00EA58  90630038   LBU V1, 56(V1)
9D00EA5C  306300F0   ANDI V1, V1, 240
9D00EA60  7E521A00   EXT S2, S2, 8, 4
9D00EA64  00729025   OR S2, V1, S2
9D00EA68  02339821   ADDU S3, S1, S3
965:                 			break;
9D00EA6C  0B403AC1   J 0x9D00EB04
9D00EA70  A2720038   SB S2, 56(S3)
966:                 
967:                 		case FS_FAT16 :
968:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
9D00EA74  00052A02   SRL A1, A1, 8
9D00EA78  8C820028   LW V0, 40(A0)
9D00EA7C  0F405691   JAL move_window
9D00EA80  00A22821   ADDU A1, A1, V0
969:                 			if (res != FR_OK) break;
9D00EA84  14400020   BNE V0, ZERO, 0x9D00EB08
9D00EA88  24030001   ADDIU V1, ZERO, 1
970:                 			p = &fs->win[clst * 2 % SS(fs)];
9D00EA8C  00108040   SLL S0, S0, 1
9D00EA90  321001FE   ANDI S0, S0, 510
971:                 			ST_WORD(p, (uint16_t)val);
9D00EA94  02301821   ADDU V1, S1, S0
9D00EA98  A0720038   SB S2, 56(V1)
9D00EA9C  7E523A00   EXT S2, S2, 8, 8
972:                 			break;
9D00EAA0  0B403AC1   J 0x9D00EB04
9D00EAA4  A0720039   SB S2, 57(V1)
973:                 
974:                 		case FS_FAT32 :
975:                 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
9D00EAA8  000529C2   SRL A1, A1, 7
9D00EAAC  8C820028   LW V0, 40(A0)
9D00EAB0  0F405691   JAL move_window
9D00EAB4  00A22821   ADDU A1, A1, V0
976:                 			if (res != FR_OK) break;
9D00EAB8  14400013   BNE V0, ZERO, 0x9D00EB08
9D00EABC  24030001   ADDIU V1, ZERO, 1
977:                 			p = &fs->win[clst * 4 % SS(fs)];
9D00EAC0  00108080   SLL S0, S0, 2
9D00EAC4  321001FC   ANDI S0, S0, 508
9D00EAC8  26030038   ADDIU V1, S0, 56
9D00EACC  02231821   ADDU V1, S1, V1
978:                 			val |= LD_DWORD(p) & 0xF0000000;
9D00EAD0  90650003   LBU A1, 3(V1)
9D00EAD4  00052E00   SLL A1, A1, 24
9D00EAD8  02308021   ADDU S0, S1, S0
9D00EADC  3C04F000   LUI A0, -4096
9D00EAE0  00A42024   AND A0, A1, A0
9D00EAE4  00929025   OR S2, A0, S2
979:                 			ST_DWORD(p, val);
9D00EAE8  A2120038   SB S2, 56(S0)
9D00EAEC  7E443A00   EXT A0, S2, 8, 8
9D00EAF0  A0640001   SB A0, 1(V1)
9D00EAF4  00122402   SRL A0, S2, 16
9D00EAF8  A0640002   SB A0, 2(V1)
9D00EAFC  00129602   SRL S2, S2, 24
9D00EB00  A0720003   SB S2, 3(V1)
980:                 			break;
981:                 
982:                 		default :
983:                 			res = FR_INT_ERR;
984:                 		}
985:                 		fs->wflag = 1;
9D00EB04  24030001   ADDIU V1, ZERO, 1
9D00EB08  A2230004   SB V1, 4(S1)
986:                 	}
987:                 
988:                 	return res;
989:                 }
9D00EB0C  8FBF0024   LW RA, 36(SP)
990:                 #endif /* !_FS_READONLY */
991:                 
992:                 
993:                 
994:                 
995:                 /*-----------------------------------------------------------------------*/
996:                 /* FAT handling - Remove a cluster chain                                 */
997:                 /*-----------------------------------------------------------------------*/
998:                 #if !_FS_READONLY
999:                 static
1000:                FRESULT remove_chain (
1001:                	FATFS *fs,			/* File system object */
1002:                	uint32_t clst			/* Cluster# to remove a chain from */
1003:                )
1004:                {
9D012CC8  27BDFFD0   ADDIU SP, SP, -48
9D012CCC  AFBF002C   SW RA, 44(SP)
9D012CD0  AFB50028   SW S5, 40(SP)
9D012CD4  AFB40024   SW S4, 36(SP)
9D012CD8  AFB30020   SW S3, 32(SP)
9D012CDC  AFB2001C   SW S2, 28(SP)
9D012CE0  AFB10018   SW S1, 24(SP)
9D012CE4  AFB00014   SW S0, 20(SP)
9D012CE8  00A09021   ADDU S2, A1, ZERO
1005:                	FRESULT res;
1006:                	uint32_t nxt;
1007:                #if _USE_ERASE
1008:                	uint32_t scl = clst, ecl = clst, rt[2];
1009:                #endif
1010:                
1011:                	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
9D012CEC  2CA30002   SLTIU V1, A1, 2
9D012CF0  14600024   BNE V1, ZERO, 0x9D012D84
9D012CF4  24020002   ADDIU V0, ZERO, 2
9D012CF8  8C83001C   LW V1, 28(A0)
9D012CFC  00A3182B   SLTU V1, A1, V1
9D012D00  10600020   BEQ V1, ZERO, 0x9D012D84
9D012D04  00808021   ADDU S0, A0, ZERO
1012:                		res = FR_INT_ERR;
1013:                
1014:                	} else {
1015:                		res = FR_OK;
1016:                		while (clst < fs->n_fatent) {			/* Not a last link? */
9D012D60  8E03001C   LW V1, 28(S0)
9D012D64  0223182B   SLTU V1, S1, V1
9D012D68  10600006   BEQ V1, ZERO, 0x9D012D84
9D012D6C  02209021   ADDU S2, S1, ZERO
1017:                			nxt = get_fat(fs, clst);			/* Get cluster status */
9D012D14  02002021   ADDU A0, S0, ZERO
9D012D18  0F403E01   JAL get_fat
9D012D1C  02402821   ADDU A1, S2, ZERO
9D012D70  0B404B46   J 0x9D012D18
9D012D74  02002021   ADDU A0, S0, ZERO
9D012D78  0B404B61   J 0x9D012D84
9D012D7C  00001021   ADDU V0, ZERO, ZERO
1018:                			if (nxt == 0) break;				/* Empty cluster? */
9D012D20  10400015   BEQ V0, ZERO, 0x9D012D78
9D012D24  00408821   ADDU S1, V0, ZERO
1019:                			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
9D012D08  24140001   ADDIU S4, ZERO, 1
9D012D28  50540016   BEQL V0, S4, 0x9D012D84
9D012D2C  24020002   ADDIU V0, ZERO, 2
1020:                			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
9D012D0C  2413FFFF   ADDIU S3, ZERO, -1
9D012D30  10530013   BEQ V0, S3, 0x9D012D80
9D012D34  02002021   ADDU A0, S0, ZERO
9D012D80  24020001   ADDIU V0, ZERO, 1
1021:                			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
9D012D38  02402821   ADDU A1, S2, ZERO
9D012D3C  0F403A5B   JAL put_fat
9D012D40  00003021   ADDU A2, ZERO, ZERO
1022:                			if (res != FR_OK) break;
9D012D44  14400010   BNE V0, ZERO, 0x9D012D88
9D012D48  8FBF002C   LW RA, 44(SP)
1023:                			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
9D012D4C  8E030010   LW V1, 16(S0)
9D012D50  10730003   BEQ V1, S3, 0x9D012D60
9D012D54  24630001   ADDIU V1, V1, 1
1024:                				fs->free_clust++;
9D012D58  AE030010   SW V1, 16(S0)
1025:                				fs->fsi_flag = 1;
9D012D10  24150001   ADDIU S5, ZERO, 1
9D012D5C  A2150005   SB S5, 5(S0)
1026:                			}
1027:                #if _USE_ERASE
1028:                			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
1029:                				ecl = nxt;
1030:                			} else {				/* End of contiguous clusters */ 
1031:                				rt[0] = clust2sect(fs, scl);					/* Start sector */
1032:                				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
1033:                				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
1034:                				scl = ecl = nxt;
1035:                			}
1036:                #endif
1037:                			clst = nxt;	/* Next cluster */
1038:                		}
1039:                	}
1040:                
1041:                	return res;
1042:                }
9D012D84  8FBF002C   LW RA, 44(SP)
1043:                #endif
1044:                
1045:                
1046:                
1047:                
1048:                /*-----------------------------------------------------------------------*/
1049:                /* FAT handling - Stretch or Create a cluster chain                      */
1050:                /*-----------------------------------------------------------------------*/
1051:                #if !_FS_READONLY
1052:                static
1053:                uint32_t create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
1054:                	FATFS *fs,			/* File system object */
1055:                	uint32_t clst			/* Cluster# to stretch. 0 means create a new chain. */
1056:                )
1057:                {
9D00F4E8  27BDFFD0   ADDIU SP, SP, -48
9D00F4EC  AFBF002C   SW RA, 44(SP)
9D00F4F0  AFB60028   SW S6, 40(SP)
9D00F4F4  AFB50024   SW S5, 36(SP)
9D00F4F8  AFB40020   SW S4, 32(SP)
9D00F4FC  AFB3001C   SW S3, 28(SP)
9D00F500  AFB20018   SW S2, 24(SP)
9D00F504  AFB10014   SW S1, 20(SP)
9D00F508  AFB00010   SW S0, 16(SP)
9D00F50C  00808821   ADDU S1, A0, ZERO
1058:                	uint32_t cs, ncl, scl;
1059:                	FRESULT res;
1060:                
1061:                
1062:                	if (clst == 0) {		/* Create a new chain */
9D00F510  14A00009   BNE A1, ZERO, 0x9D00F538
9D00F514  00A0B021   ADDU S6, A1, ZERO
1063:                		scl = fs->last_clust;			/* Get suggested start point */
9D00F518  8C92000C   LW S2, 12(A0)
1064:                		if (!scl || scl >= fs->n_fatent) scl = 1;
9D00F51C  52400011   BEQL S2, ZERO, 0x9D00F564
9D00F520  24120001   ADDIU S2, ZERO, 1
9D00F524  8C83001C   LW V1, 28(A0)
9D00F528  0243182B   SLTU V1, S2, V1
9D00F52C  24020001   ADDIU V0, ZERO, 1
9D00F530  0B403D59   J 0x9D00F564
9D00F534  0043900A   MOVZ S2, V0, V1
1065:                	}
1066:                	else {					/* Stretch the current chain */
1067:                		cs = get_fat(fs, clst);			/* Check the cluster status */
9D00F538  0F403E01   JAL get_fat
9D00F53C  00000000   NOP
1068:                		if (cs < 2) return 1;			/* It is an invalid cluster */
9D00F540  2C430002   SLTIU V1, V0, 2
9D00F544  54600042   BNEL V1, ZERO, 0x9D00F650
9D00F548  24020001   ADDIU V0, ZERO, 1
1069:                		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
9D00F54C  8E23001C   LW V1, 28(S1)
9D00F550  0043182B   SLTU V1, V0, V1
9D00F554  10600003   BEQ V1, ZERO, 0x9D00F564
9D00F558  02C09021   ADDU S2, S6, ZERO
1070:                		scl = clst;
1071:                	}
1072:                
1073:                	ncl = scl;				/* Start cluster */
9D00F564  02408021   ADDU S0, S2, ZERO
1074:                	for (;;) {
1075:                		ncl++;							/* Next cluster */
9D00F574  26100001   ADDIU S0, S0, 1
1076:                		if (ncl >= fs->n_fatent) {		/* Wrap around */
9D00F578  8E22001C   LW V0, 28(S1)
9D00F57C  0202102B   SLTU V0, S0, V0
9D00F580  14400004   BNE V0, ZERO, 0x9D00F594
9D00F584  02202021   ADDU A0, S1, ZERO
1077:                			ncl = 2;
1078:                			if (ncl > scl) return 0;	/* No free cluster */
9D00F568  2E550002   SLTIU S5, S2, 2
9D00F588  16A0002C   BNE S5, ZERO, 0x9D00F63C
9D00F58C  24100002   ADDIU S0, ZERO, 2
9D00F63C  0B403D94   J 0x9D00F650
9D00F640  00001021   ADDU V0, ZERO, ZERO
1079:                		}
1080:                		cs = get_fat(fs, ncl);			/* Get the cluster status */
9D00F590  02202021   ADDU A0, S1, ZERO
9D00F594  0F403E01   JAL get_fat
9D00F598  02002821   ADDU A1, S0, ZERO
1081:                		if (cs == 0) break;				/* Found a free cluster */
9D00F59C  50400009   BEQL V0, ZERO, 0x9D00F5C4
9D00F5A0  02009021   ADDU S2, S0, ZERO
1082:                		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
9D00F56C  2413FFFF   ADDIU S3, ZERO, -1
9D00F570  24140001   ADDIU S4, ZERO, 1
9D00F5A4  1053002B   BEQ V0, S3, 0x9D00F654
9D00F5A8  8FBF002C   LW RA, 44(SP)
9D00F5AC  5054002A   BEQL V0, S4, 0x9D00F658
9D00F5B0  8FB60028   LW S6, 40(SP)
1083:                			return cs;
1084:                		if (ncl == scl) return 0;		/* No free cluster */
9D00F5B4  1612FFF0   BNE S0, S2, 0x9D00F578
9D00F5B8  26100001   ADDIU S0, S0, 1
9D00F5BC  0B403D91   J 0x9D00F644
9D00F5C0  00001021   ADDU V0, ZERO, ZERO
1085:                	}
1086:                
1087:                	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
9D00F5C4  02202021   ADDU A0, S1, ZERO
9D00F5C8  02002821   ADDU A1, S0, ZERO
9D00F5CC  3C060FFF   LUI A2, 4095
9D00F5D0  0F403A5B   JAL put_fat
9D00F5D4  34C6FFFF   ORI A2, A2, -1
1088:                	if (res == FR_OK && clst != 0) {
9D00F5D8  14400013   BNE V0, ZERO, 0x9D00F628
9D00F5DC  38420001   XORI V0, V0, 1
9D00F5E0  52C00008   BEQL S6, ZERO, 0x9D00F604
9D00F5E4  AE32000C   SW S2, 12(S1)
1089:                		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
9D00F5E8  02202021   ADDU A0, S1, ZERO
9D00F5EC  02C02821   ADDU A1, S6, ZERO
9D00F5F0  0F403A5B   JAL put_fat
9D00F5F4  02003021   ADDU A2, S0, ZERO
1090:                	}
1091:                	if (res == FR_OK) {
9D00F5F8  1440000B   BNE V0, ZERO, 0x9D00F628
9D00F5FC  38420001   XORI V0, V0, 1
1092:                		fs->last_clust = ncl;			/* Update FSINFO */
9D00F600  AE32000C   SW S2, 12(S1)
1093:                		if (fs->free_clust != 0xFFFFFFFF) {
9D00F604  8E220010   LW V0, 16(S1)
9D00F608  2403FFFF   ADDIU V1, ZERO, -1
9D00F60C  1043000F   BEQ V0, V1, 0x9D00F64C
9D00F610  2442FFFF   ADDIU V0, V0, -1
1094:                			fs->free_clust--;
9D00F614  AE220010   SW V0, 16(S1)
1095:                			fs->fsi_flag = 1;
9D00F618  24020001   ADDIU V0, ZERO, 1
9D00F61C  A2220005   SB V0, 5(S1)
9D00F620  0B403D94   J 0x9D00F650
9D00F624  02001021   ADDU V0, S0, ZERO
1096:                		}
1097:                	} else {
1098:                		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
9D00F628  2403FFFF   ADDIU V1, ZERO, -1
9D00F62C  24040001   ADDIU A0, ZERO, 1
9D00F630  0082180B   MOVN V1, A0, V0
9D00F634  0B403D94   J 0x9D00F650
9D00F638  00601021   ADDU V0, V1, ZERO
1099:                	}
1100:                
1101:                	return ncl;		/* Return new cluster number or error code */
1102:                }
9D00F55C  0B403D95   J 0x9D00F654
9D00F560  8FBF002C   LW RA, 44(SP)
9D00F644  0B403D95   J 0x9D00F654
1103:                #endif /* !_FS_READONLY */
1104:                
1105:                
1106:                
1107:                /*-----------------------------------------------------------------------*/
1108:                /* FAT handling - Convert offset into cluster with link map table        */
1109:                /*-----------------------------------------------------------------------*/
1110:                
1111:                #if _USE_FASTSEEK
1112:                static
1113:                uint32_t clmt_clust (	/* <2:Error, >=2:Cluster number */
1114:                	FIL* fp,		/* Pointer to the file object */
1115:                	uint32_t ofs		/* File offset to be converted to cluster# */
1116:                )
1117:                {
1118:                	uint32_t cl, ncl, *tbl;
1119:                
1120:                
1121:                	tbl = fp->cltbl + 1;	/* Top of CLMT */
1122:                	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
1123:                	for (;;) {
1124:                		ncl = *tbl++;			/* Number of cluters in the fragment */
1125:                		if (!ncl) return 0;		/* End of table? (error) */
1126:                		if (cl < ncl) break;	/* In this fragment? */
1127:                		cl -= ncl; tbl++;		/* Next fragment */
1128:                	}
1129:                	return cl + *tbl;	/* Return the cluster number */
1130:                }
1131:                #endif	/* _USE_FASTSEEK */
1132:                
1133:                
1134:                
1135:                /*-----------------------------------------------------------------------*/
1136:                /* Directory handling - Set directory index                              */
1137:                /*-----------------------------------------------------------------------*/
1138:                
1139:                static
1140:                FRESULT dir_sdi (
1141:                	DIR *dj,		/* Pointer to directory object */
1142:                	uint16_t idx		/* Index of directory table */
1143:                )
1144:                {
9D011264  27BDFFD8   ADDIU SP, SP, -40
9D011268  AFBF0024   SW RA, 36(SP)
9D01126C  AFB30020   SW S3, 32(SP)
9D011270  AFB2001C   SW S2, 28(SP)
9D011274  AFB10018   SW S1, 24(SP)
9D011278  AFB00014   SW S0, 20(SP)
9D01127C  00808021   ADDU S0, A0, ZERO
9D011280  00A08821   ADDU S1, A1, ZERO
1145:                	uint32_t clst;
1146:                	uint16_t ic;
1147:                
1148:                
1149:                	dj->index = idx;
9D011284  A6050006   SH A1, 6(S0)
1150:                	clst = dj->sclust;
9D011288  8C850008   LW A1, 8(A0)
1151:                	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
9D01128C  24030001   ADDIU V1, ZERO, 1
9D011290  10A3003E   BEQ A1, V1, 0x9D01138C
9D011294  24020002   ADDIU V0, ZERO, 2
9D011298  8C830000   LW V1, 0(A0)
9D01129C  8C64001C   LW A0, 28(V1)
9D0112A0  00A4202B   SLTU A0, A1, A0
9D0112A4  5080003A   BEQL A0, ZERO, 0x9D011390
9D0112A8  8FBF0024   LW RA, 36(SP)
1152:                		return FR_INT_ERR;
1153:                	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
9D0112AC  54A00012   BNEL A1, ZERO, 0x9D0112F8
9D0112B0  90720002   LBU S2, 2(V1)
9D0112B4  90640000   LBU A0, 0(V1)
9D0112B8  24020003   ADDIU V0, ZERO, 3
9D0112BC  54820005   BNEL A0, V0, 0x9D0112D4
9D0112C0  AE00000C   SW ZERO, 12(S0)
1154:                		clst = dj->fs->dirbase;
9D0112C4  8C65002C   LW A1, 44(V1)
1155:                
1156:                	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
9D0112C8  54A0000B   BNEL A1, ZERO, 0x9D0112F8
9D0112CC  90720002   LBU S2, 2(V1)
1157:                		dj->clust = clst;
9D0112D0  AE00000C   SW ZERO, 12(S0)
1158:                		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
9D0112D4  94640008   LHU A0, 8(V1)
9D0112D8  0224202B   SLTU A0, S1, A0
9D0112DC  1080002B   BEQ A0, ZERO, 0x9D01138C
9D0112E0  24020002   ADDIU V0, ZERO, 2
1159:                			return FR_INT_ERR;
1160:                		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
9D0112E4  00111102   SRL V0, S1, 4
9D0112E8  8C63002C   LW V1, 44(V1)
9D0112EC  00431021   ADDU V0, V0, V1
9D0112F0  0B4044D8   J 0x9D011360
9D0112F4  AE020010   SW V0, 16(S0)
1161:                	}
1162:                	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
1163:                		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
9D0112F8  00129100   SLL S2, S2, 4
1164:                		while (idx >= ic) {	/* Follow cluster chain */
9D0112FC  0232102B   SLTU V0, S1, S2
9D011300  14400011   BNE V0, ZERO, 0x9D011348
9D011304  2413FFFF   ADDIU S3, ZERO, -1
9D01133C  0232102B   SLTU V0, S1, S2
9D011340  1040FFF1   BEQ V0, ZERO, 0x9D011308
9D011344  00000000   NOP
1165:                			clst = get_fat(dj->fs, clst);				/* Get next cluster */
9D011308  0F403E01   JAL get_fat
9D01130C  8E040000   LW A0, 0(S0)
1166:                			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
9D011310  1053001B   BEQ V0, S3, 0x9D011380
9D011314  00402821   ADDU A1, V0, ZERO
9D011380  0B4044E3   J 0x9D01138C
9D011384  24020001   ADDIU V0, ZERO, 1
1167:                			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
9D011318  2C420002   SLTIU V0, V0, 2
9D01131C  1440001B   BNE V0, ZERO, 0x9D01138C
9D011320  24020002   ADDIU V0, ZERO, 2
9D011324  8E020000   LW V0, 0(S0)
9D011328  8C42001C   LW V0, 28(V0)
9D01132C  00A2102B   SLTU V0, A1, V0
9D011330  10400015   BEQ V0, ZERO, 0x9D011388
9D011334  02328823   SUBU S1, S1, S2
1168:                				return FR_INT_ERR;
9D011388  24020002   ADDIU V0, ZERO, 2
1169:                			idx -= ic;
9D011338  3231FFFF   ANDI S1, S1, -1
1170:                		}
1171:                		dj->clust = clst;
9D011348  AE05000C   SW A1, 12(S0)
1172:                		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
9D01134C  0F405AB1   JAL clust2sect
9D011350  8E040000   LW A0, 0(S0)
9D011354  00111902   SRL V1, S1, 4
9D011358  00621021   ADDU V0, V1, V0
9D01135C  AE020010   SW V0, 16(S0)
1173:                	}
1174:                
1175:                	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
9D011360  3222000F   ANDI V0, S1, 15
9D011364  00021140   SLL V0, V0, 5
9D011368  24420038   ADDIU V0, V0, 56
9D01136C  8E030000   LW V1, 0(S0)
9D011370  00621021   ADDU V0, V1, V0
9D011374  AE020014   SW V0, 20(S0)
1176:                
1177:                	return FR_OK;	/* Seek succeeded */
9D011378  0B4044E3   J 0x9D01138C
9D01137C  00001021   ADDU V0, ZERO, ZERO
1178:                }
9D01138C  8FBF0024   LW RA, 36(SP)
1179:                
1180:                
1181:                
1182:                
1183:                /*-----------------------------------------------------------------------*/
1184:                /* Directory handling - Move directory table index next                  */
1185:                /*-----------------------------------------------------------------------*/
1186:                
1187:                static
1188:                FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
1189:                	DIR *dj,		/* Pointer to the directory object */
1190:                	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
1191:                )
1192:                {
9D00DC88  27BDFFD0   ADDIU SP, SP, -48
9D00DC8C  AFBF002C   SW RA, 44(SP)
9D00DC90  AFB50028   SW S5, 40(SP)
9D00DC94  AFB40024   SW S4, 36(SP)
9D00DC98  AFB30020   SW S3, 32(SP)
9D00DC9C  AFB2001C   SW S2, 28(SP)
9D00DCA0  AFB10018   SW S1, 24(SP)
9D00DCA4  AFB00014   SW S0, 20(SP)
9D00DCA8  00808021   ADDU S0, A0, ZERO
1193:                	uint32_t clst;
1194:                	uint16_t i;
1195:                
1196:                
1197:                	stretch = stretch;		/* To suppress warning on read-only cfg. */
1198:                	i = dj->index + 1;
9D00DCAC  94910006   LHU S1, 6(A0)
9D00DCB0  26310001   ADDIU S1, S1, 1
9D00DCB4  3231FFFF   ANDI S1, S1, -1
1199:                	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
9D00DCB8  12200065   BEQ S1, ZERO, 0x9D00DE50
9D00DCBC  24030004   ADDIU V1, ZERO, 4
9D00DCC0  8C820010   LW V0, 16(A0)
9D00DCC4  50400063   BEQL V0, ZERO, 0x9D00DE54
9D00DCC8  00601021   ADDU V0, V1, ZERO
1200:                		return FR_NO_FILE;
1201:                
1202:                	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
9D00DCCC  3233000F   ANDI S3, S1, 15
9D00DCD0  56600057   BNEL S3, ZERO, 0x9D00DE30
9D00DCD4  A6110006   SH S1, 6(S0)
9D00DCD8  00A09021   ADDU S2, A1, ZERO
1203:                		dj->sect++;					/* Next sector */
9D00DCDC  24420001   ADDIU V0, V0, 1
9D00DCE0  AC820010   SW V0, 16(A0)
1204:                
1205:                		if (dj->clust == 0) {	/* Static table */
9D00DCE4  8C85000C   LW A1, 12(A0)
9D00DCE8  54A00008   BNEL A1, ZERO, 0x9D00DD0C
9D00DCEC  8C840000   LW A0, 0(A0)
1206:                			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
9D00DCF0  8C820000   LW V0, 0(A0)
9D00DCF4  94420008   LHU V0, 8(V0)
9D00DCF8  0222102B   SLTU V0, S1, V0
9D00DCFC  10400055   BEQ V0, ZERO, 0x9D00DE54
9D00DD00  00601021   ADDU V0, V1, ZERO
9D00DD04  0B40378C   J 0x9D00DE30
9D00DD08  A6110006   SH S1, 6(S0)
1207:                				return FR_NO_FILE;
1208:                		}
1209:                		else {					/* Dynamic table */
1210:                			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
9D00DD0C  90830002   LBU V1, 2(A0)
9D00DD10  2463FFFF   ADDIU V1, V1, -1
9D00DD14  00111102   SRL V0, S1, 4
9D00DD18  00621024   AND V0, V1, V0
9D00DD1C  54400044   BNEL V0, ZERO, 0x9D00DE30
9D00DD20  A6110006   SH S1, 6(S0)
1211:                				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
9D00DD24  0F403E01   JAL get_fat
9D00DD28  00000000   NOP
9D00DD2C  0040A021   ADDU S4, V0, ZERO
1212:                				if (clst <= 1) return FR_INT_ERR;
9D00DD30  2C420002   SLTIU V0, V0, 2
9D00DD34  14400046   BNE V0, ZERO, 0x9D00DE50
9D00DD38  24030002   ADDIU V1, ZERO, 2
1213:                				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
9D00DD3C  2402FFFF   ADDIU V0, ZERO, -1
9D00DD40  52820043   BEQL S4, V0, 0x9D00DE50
9D00DD44  24030001   ADDIU V1, ZERO, 1
1214:                				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
9D00DD48  8E040000   LW A0, 0(S0)
9D00DD4C  8C82001C   LW V0, 28(A0)
9D00DD50  0282102B   SLTU V0, S4, V0
9D00DD54  54400031   BNEL V0, ZERO, 0x9D00DE1C
9D00DD58  AE14000C   SW S4, 12(S0)
1215:                #if !_FS_READONLY
1216:                					uint8_t c;
1217:                					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
9D00DD5C  1240003C   BEQ S2, ZERO, 0x9D00DE50
9D00DD60  24030004   ADDIU V1, ZERO, 4
1218:                					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
9D00DD64  0F403D3A   JAL create_chain
9D00DD68  8E05000C   LW A1, 12(S0)
9D00DD6C  0040A021   ADDU S4, V0, ZERO
1219:                					if (clst == 0) return FR_DENIED;			/* No free cluster */
9D00DD70  10400037   BEQ V0, ZERO, 0x9D00DE50
9D00DD74  24030007   ADDIU V1, ZERO, 7
1220:                					if (clst == 1) return FR_INT_ERR;
9D00DD78  24020001   ADDIU V0, ZERO, 1
9D00DD7C  12820034   BEQ S4, V0, 0x9D00DE50
9D00DD80  24030002   ADDIU V1, ZERO, 2
1221:                					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
9D00DD84  2402FFFF   ADDIU V0, ZERO, -1
9D00DD88  12820031   BEQ S4, V0, 0x9D00DE50
9D00DD8C  24030001   ADDIU V1, ZERO, 1
1222:                					/* Clean-up stretched table */
1223:                					if (sync_window(dj->fs)) return FR_DISK_ERR;	/* Flush active window */
9D00DD90  0F404C46   JAL sync_window
9D00DD94  8E040000   LW A0, 0(S0)
9D00DD98  1440002D   BNE V0, ZERO, 0x9D00DE50
9D00DD9C  24030001   ADDIU V1, ZERO, 1
1224:                					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
9D00DDA0  8E040000   LW A0, 0(S0)
9D00DDA4  24840038   ADDIU A0, A0, 56
9D00DDA8  00002821   ADDU A1, ZERO, ZERO
9D00DDAC  0F405C30   JAL mem_set
9D00DDB0  24060200   ADDIU A2, ZERO, 512
1225:                					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
9D00DDB4  8E120000   LW S2, 0(S0)
9D00DDB8  02402021   ADDU A0, S2, ZERO
9D00DDBC  0F405AB1   JAL clust2sect
9D00DDC0  02802821   ADDU A1, S4, ZERO
9D00DDC4  AE420034   SW V0, 52(S2)
1226:                					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
9D00DDC8  00009021   ADDU S2, ZERO, ZERO
9D00DDCC  0B40377E   J 0x9D00DDF8
9D00DDD0  24150001   ADDIU S5, ZERO, 1
9D00DDF4  325200FF   ANDI S2, S2, 255
9D00DDF8  8E020000   LW V0, 0(S0)
9D00DDFC  90430002   LBU V1, 2(V0)
9D00DE00  0243182B   SLTU V1, S2, V1
9D00DE04  5460FFF3   BNEL V1, ZERO, 0x9D00DDD4
9D00DE08  A0550004   SB S5, 4(V0)
1227:                						dj->fs->wflag = 1;
1228:                						if (sync_window(dj->fs)) return FR_DISK_ERR;
9D00DDD4  0F404C46   JAL sync_window
9D00DDD8  8E040000   LW A0, 0(S0)
9D00DDDC  1440001B   BNE V0, ZERO, 0x9D00DE4C
9D00DDE0  26520001   ADDIU S2, S2, 1
9D00DE4C  24030001   ADDIU V1, ZERO, 1
1229:                						dj->fs->winsect++;
9D00DDE4  8E020000   LW V0, 0(S0)
9D00DDE8  8C430034   LW V1, 52(V0)
9D00DDEC  24630001   ADDIU V1, V1, 1
9D00DDF0  AC430034   SW V1, 52(V0)
1230:                					}
1231:                					dj->fs->winsect -= c;						/* Rewind window address */
9D00DE0C  8C430034   LW V1, 52(V0)
9D00DE10  00729023   SUBU S2, V1, S2
9D00DE14  AC520034   SW S2, 52(V0)
1232:                #else
1233:                					return FR_NO_FILE;			/* Report EOT */
1234:                #endif
1235:                				}
1236:                				dj->clust = clst;				/* Initialize data for new cluster */
9D00DE18  AE14000C   SW S4, 12(S0)
1237:                				dj->sect = clust2sect(dj->fs, clst);
9D00DE1C  8E040000   LW A0, 0(S0)
9D00DE20  0F405AB1   JAL clust2sect
9D00DE24  02802821   ADDU A1, S4, ZERO
9D00DE28  AE020010   SW V0, 16(S0)
1238:                			}
1239:                		}
1240:                	}
1241:                
1242:                	dj->index = i;
9D00DE2C  A6110006   SH S1, 6(S0)
1243:                	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
9D00DE30  00139940   SLL S3, S3, 5
9D00DE34  26730038   ADDIU S3, S3, 56
9D00DE38  8E020000   LW V0, 0(S0)
9D00DE3C  00539821   ADDU S3, V0, S3
9D00DE40  AE130014   SW S3, 20(S0)
1244:                
1245:                	return FR_OK;
9D00DE44  0B403794   J 0x9D00DE50
9D00DE48  00001821   ADDU V1, ZERO, ZERO
1246:                }
9D00DE50  00601021   ADDU V0, V1, ZERO
1247:                
1248:                
1249:                
1250:                
1251:                /*-----------------------------------------------------------------------*/
1252:                /* Directory handling - Reserve directory entry                          */
1253:                /*-----------------------------------------------------------------------*/
1254:                
1255:                #if !_FS_READONLY
1256:                static
1257:                FRESULT dir_alloc (
1258:                	DIR* dj,	/* Pointer to the directory object */
1259:                	uint32_t nent	/* Number of contiguous entries to allocate (1-21) */
1260:                )
1261:                {
9D0146CC  27BDFFD8   ADDIU SP, SP, -40
9D0146D0  AFBF0024   SW RA, 36(SP)
9D0146D4  AFB30020   SW S3, 32(SP)
9D0146D8  AFB2001C   SW S2, 28(SP)
9D0146DC  AFB10018   SW S1, 24(SP)
9D0146E0  AFB00014   SW S0, 20(SP)
9D0146E4  00808021   ADDU S0, A0, ZERO
9D0146E8  00A09821   ADDU S3, A1, ZERO
1262:                	FRESULT res;
1263:                	uint32_t n;
1264:                
1265:                
1266:                	res = dir_sdi(dj, 0);
9D0146EC  0F404499   JAL dir_sdi
9D0146F0  00002821   ADDU A1, ZERO, ZERO
1267:                	if (res == FR_OK) {
9D0146F4  14400017   BNE V0, ZERO, 0x9D014754
9D0146F8  00008821   ADDU S1, ZERO, ZERO
1268:                		n = 0;
1269:                		do {
1270:                			res = move_window(dj->fs, dj->sect);
9D014700  8E040000   LW A0, 0(S0)
9D014704  0F405691   JAL move_window
9D014708  8E050010   LW A1, 16(S0)
1271:                			if (res != FR_OK) break;
9D01470C  14400012   BNE V0, ZERO, 0x9D014758
9D014710  8FBF0024   LW RA, 36(SP)
1272:                			if (dj->dir[0] == DDE || dj->dir[0] == 0) {	/* Is it a blank entry? */
9D0146FC  241200E5   ADDIU S2, ZERO, 229
9D014714  8E030014   LW V1, 20(S0)
9D014718  90630000   LBU V1, 0(V1)
9D01471C  50720004   BEQL V1, S2, 0x9D014730
9D014720  26310001   ADDIU S1, S1, 1
9D014724  54600006   BNEL V1, ZERO, 0x9D014740
9D014728  00008821   ADDU S1, ZERO, ZERO
1273:                				if (++n == nent) break;	/* A block of contiguous entry is found */
9D01472C  26310001   ADDIU S1, S1, 1
9D014730  16330004   BNE S1, S3, 0x9D014744
9D014734  02002021   ADDU A0, S0, ZERO
9D014738  0B4051D6   J 0x9D014758
9D01473C  8FBF0024   LW RA, 36(SP)
1274:                			} else {
1275:                				n = 0;					/* Not a blank entry. Restart to search */
1276:                			}
1277:                			res = dir_next(dj, 1);		/* Next entry with table stretch enabled */
9D014740  02002021   ADDU A0, S0, ZERO
9D014744  0F403722   JAL dir_next
9D014748  24050001   ADDIU A1, ZERO, 1
1278:                		} while (res == FR_OK);
9D01474C  5040FFED   BEQL V0, ZERO, 0x9D014704
9D014750  8E040000   LW A0, 0(S0)
1279:                	}
1280:                	return res;
1281:                }
9D014754  8FBF0024   LW RA, 36(SP)
1282:                #endif
1283:                
1284:                
1285:                
1286:                /*-----------------------------------------------------------------------*/
1287:                /* Directory handling - Load/Store start cluster number                  */
1288:                /*-----------------------------------------------------------------------*/
1289:                
1290:                static
1291:                uint32_t ld_clust (
1292:                	FATFS *fs,	/* Pointer to the fs object */
1293:                	uint8_t *dir	/* Pointer to the directory entry */
1294:                )
1295:                {
1296:                	uint32_t cl;
1297:                
1298:                	cl = LD_WORD(dir+DIR_FstClusLO);
9D016774  90A2001B   LBU V0, 27(A1)
9D016778  00021200   SLL V0, V0, 8
9D01677C  90A3001A   LBU V1, 26(A1)
9D016780  00431025   OR V0, V0, V1
1299:                	if (fs->fs_type == FS_FAT32)
9D016784  90840000   LBU A0, 0(A0)
9D016788  24030003   ADDIU V1, ZERO, 3
9D01678C  14830007   BNE A0, V1, 0x9D0167AC
9D016790  00000000   NOP
1300:                		cl |= (uint32_t)LD_WORD(dir+DIR_FstClusHI) << 16;
9D016794  90A30015   LBU V1, 21(A1)
9D016798  00031A00   SLL V1, V1, 8
9D01679C  90A40014   LBU A0, 20(A1)
9D0167A0  00641825   OR V1, V1, A0
9D0167A4  00031C00   SLL V1, V1, 16
9D0167A8  00431025   OR V0, V0, V1
1301:                
1302:                	return cl;
1303:                }
9D0167AC  03E00008   JR RA
1304:                
1305:                
1306:                #if !_FS_READONLY
1307:                static
1308:                void st_clust (
1309:                	uint8_t *dir,	/* Pointer to the directory entry */
1310:                	uint32_t cl	/* Value to be set */
1311:                )
1312:                {
1313:                	ST_WORD(dir+DIR_FstClusLO, cl);
9D007C74  A240001A   SB ZERO, 26(S2)
9D0090E4  326300FF   ANDI V1, S3, 255
9D009140  A2220072   SB V0, 114(S1)
9D0091F4  8FA30050   LW V1, 80(SP)
9D00BDA8  A0620072   SB V0, 114(V1)
9D011468  A222001A   SB V0, 26(S1)
1314:                	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
9D007C7C  A2400014   SB ZERO, 20(S2)
9D0090F8  0013F402   SRL S8, S3, 16
9D00914C  00021402   SRL V0, V0, 16
9D009200  A0570014   SB S7, 20(V0)
9D00BDB4  00021402   SRL V0, V0, 16
9D011474  00021402   SRL V0, V0, 16
1315:                }
1316:                #endif
1317:                
1318:                
1319:                
1320:                /*-----------------------------------------------------------------------*/
1321:                /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
1322:                /*-----------------------------------------------------------------------*/
1323:                #if FAT_FS_USE_LFN
1324:                static
1325:                const uint8_t LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
1326:                
1327:                
1328:                static
1329:                int cmp_lfn (			/* 1:Matched, 0:Not matched */
1330:                	uint16_t *lfnbuf,		/* Pointer to the LFN to be compared */
1331:                	uint8_t *dir			/* Pointer to the directory entry containing a part of LFN */
1332:                )
1333:                {
1334:                	uint32_t i, s;
1335:                	uint16_t wc, uc;
1336:                
1337:                
1338:                	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
9D00AB00  92040000   LBU A0, 0(S0)
9D00AB04  AFA4001C   SW A0, 28(SP)
9D00AB08  2403FFBF   ADDIU V1, ZERO, -65
9D00AB0C  00831024   AND V0, A0, V1
9D00AB10  2442FFFF   ADDIU V0, V0, -1
9D00AB14  00021880   SLL V1, V0, 2
9D00AB18  0002B900   SLL S7, V0, 4
9D00AB1C  02E3B823   SUBU S7, S7, V1
9D00AB20  02E2B821   ADDU S7, S7, V0
9D00AB24  8FB40010   LW S4, 16(SP)
1339:                	s = 0; wc = 1;
9D00AB28  24160001   ADDIU S6, ZERO, 1
1340:                	do {
1341:                		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
9D00AB2C  92820000   LBU V0, 0(S4)
9D00AB30  02021021   ADDU V0, S0, V0
9D00AB34  90440001   LBU A0, 1(V0)
9D00AB38  00042200   SLL A0, A0, 8
9D00AB3C  90420000   LBU V0, 0(V0)
1342:                		if (wc) {	/* Last char has not been processed */
9D00AB40  12C00010   BEQ S6, ZERO, 0x9D00AB84
9D00AB44  00822025   OR A0, A0, V0
1343:                			wc = ff_wtoupper(uc);		/* Convert it to upper case */
9D00AB48  0F405BA6   JAL ff_wtoupper
9D00AB4C  00000000   NOP
9D00AB50  0040B021   ADDU S6, V0, ZERO
1344:                			if (i >= FAT_FS_MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
9D00AB54  2EE200FF   SLTIU V0, S7, 255
9D00AB58  10400039   BEQ V0, ZERO, dir_find::cmp_lfn
9D00AB5C  26E40001   ADDIU A0, S7, 1
9D00AB60  AFA40014   SW A0, 20(SP)
9D00AB64  0017B840   SLL S7, S7, 1
9D00AB68  02B7B821   ADDU S7, S5, S7
9D00AB6C  0F405BA6   JAL ff_wtoupper
9D00AB70  96E40000   LHU A0, 0(S7)
9D00AB74  16C20035   BNE S6, V0, dir_find::cmp_lfn
9D00AB78  8FB70014   LW S7, 20(SP)
9D00AB7C  0B402AE5   J 0x9D00AB94
9D00AB80  26940001   ADDIU S4, S4, 1
9D00AC40  8FB60018   LW S6, 24(SP)
9D00AC4C  8FB60018   LW S6, 24(SP)
1345:                				return 0;				/* Not matched */
1346:                		} else {
1347:                			if (uc != 0xFFFF) return 0;	/* Check filler */
9D00AB84  3402FFFF   ORI V0, ZERO, -1
9D00AB88  54820033   BNEL A0, V0, 0x9D00AC58
9D00AB8C  8FB60018   LW S6, 24(SP)
9D00AB90  26940001   ADDIU S4, S4, 1
1348:                		}
1349:                	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
9D00AB94  569EFFE6   BNEL S4, S8, 0x9D00AB30
9D00AB98  92820000   LBU V0, 0(S4)
1350:                
1351:                	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
9D00AB9C  8FA3001C   LW V1, 28(SP)
9D00ABA0  30620040   ANDI V0, V1, 64
9D00ABA4  304200FF   ANDI V0, V0, 255
9D00ABA8  50400035   BEQL V0, ZERO, 0x9D00AC80
9D00ABAC  2652FFFF   ADDIU S2, S2, -1
9D00ABB0  52C00033   BEQL S6, ZERO, 0x9D00AC80
9D00ABB4  2652FFFF   ADDIU S2, S2, -1
9D00ABB8  0017B840   SLL S7, S7, 1
9D00ABBC  02B7A821   ADDU S5, S5, S7
9D00ABC0  96A20000   LHU V0, 0(S5)
9D00ABC4  5040002E   BEQL V0, ZERO, 0x9D00AC80
9D00ABC8  2652FFFF   ADDIU S2, S2, -1
9D00ABCC  0B402B18   J 0x9D00AC60
9D00ABD0  8FB60018   LW S6, 24(SP)
1352:                		return 0;
1353:                
1354:                	return 1;						/* The part of LFN matched */
1355:                }
1356:                
1357:                
1358:                
1359:                static
1360:                int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
1361:                	uint16_t *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
1362:                	uint8_t *dir			/* Pointer to the directory entry */
1363:                )
1364:                {
1365:                	uint32_t i, s;
1366:                	uint16_t wc, uc;
1367:                
1368:                
1369:                	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
9D00CF2C  90830000   LBU V1, 0(A0)
9D00CF30  3063003F   ANDI V1, V1, 63
9D00CF34  2463FFFF   ADDIU V1, V1, -1
9D00CF38  00032880   SLL A1, V1, 2
9D00CF3C  00033100   SLL A2, V1, 4
9D00CF40  00C53023   SUBU A2, A2, A1
9D00CF44  00C33021   ADDU A2, A2, V1
9D00CF48  02E01821   ADDU V1, S7, ZERO
1370:                
1371:                	s = 0; wc = 1;
9D00CF4C  240A0001   ADDIU T2, ZERO, 1
1372:                	do {
1373:                		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
9D00CF54  90650000   LBU A1, 0(V1)
9D00CF58  00852821   ADDU A1, A0, A1
9D00CF5C  90A80001   LBU T0, 1(A1)
9D00CF60  00084200   SLL T0, T0, 8
9D00CF64  90A70000   LBU A3, 0(A1)
1374:                		if (wc) {	/* Last char has not been processed */
9D00CF68  11400009   BEQ T2, ZERO, dir_read::pick_lfn
9D00CF6C  01072825   OR A1, T0, A3
1375:                			if (i >= FAT_FS_MAX_LFN) return 0;	/* Buffer overflow? */
9D00CF70  2CC700FF   SLTIU A3, A2, 255
9D00CF74  10E0002E   BEQ A3, ZERO, 0x9D00D030
9D00CF78  00063840   SLL A3, A2, 1
1376:                			lfnbuf[i++] = wc = uc;			/* Store it */
9D00CF7C  01673821   ADDU A3, T3, A3
9D00CF80  A4E50000   SH A1, 0(A3)
9D00CF84  00A05021   ADDU T2, A1, ZERO
9D00CF88  0B4033E6   J 0x9D00CF98
9D00CF8C  24C60001   ADDIU A2, A2, 1
1377:                		} else {
1378:                			if (uc != 0xFFFF) return 0;		/* Check filler */
9D00CF50  340CFFFF   ORI T4, ZERO, -1
9D00CF90  14AC0028   BNE A1, T4, 0x9D00D034
9D00CF94  0120B021   ADDU S6, T1, ZERO
9D00CF98  24630001   ADDIU V1, V1, 1
1379:                		}
1380:                	} while (++s < 13);						/* Read all character in the entry */
9D00CF9C  547EFFEE   BNEL V1, S8, 0x9D00CF58
9D00CFA0  90650000   LBU A1, 0(V1)
1381:                
1382:                	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
9D00CFA4  90830000   LBU V1, 0(A0)
9D00CFA8  30630040   ANDI V1, V1, 64
9D00CFAC  306300FF   ANDI V1, V1, 255
9D00CFB0  1060001B   BEQ V1, ZERO, 0x9D00D020
9D00CFB4  2CC300FF   SLTIU V1, A2, 255
1383:                		if (i >= FAT_FS_MAX_LFN) return 0;		/* Buffer overflow? */
9D00CFB8  1060001D   BEQ V1, ZERO, 0x9D00D030
9D00CFBC  00063040   SLL A2, A2, 1
1384:                		lfnbuf[i] = 0;
9D00CFC0  01665821   ADDU T3, T3, A2
9D00CFC4  0B403408   J 0x9D00D020
9D00CFC8  A5600000   SH ZERO, 0(T3)
1385:                	}
1386:                
1387:                	return 1;
1388:                }
1389:                
1390:                
1391:                #if !_FS_READONLY
1392:                static
1393:                void fit_lfn (
1394:                	const uint16_t *lfnbuf,	/* Pointer to the LFN buffer */
1395:                	uint8_t *dir,				/* Pointer to the directory entry */
1396:                	uint8_t ord,				/* LFN order (1-20) */
1397:                	uint8_t sum				/* SFN sum */
1398:                )
1399:                {
1400:                	uint32_t i, s;
1401:                	uint16_t wc;
1402:                
1403:                
1404:                	dir[LDIR_Chksum] = sum;			/* Set check sum */
9D008DE0  A0F7000D   SB S7, 13(A3)
1405:                	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
9D008DB0  2416000F   ADDIU S6, ZERO, 15
9D008DB4  3C159D01   LUI S5, -25343
9D008DE4  A0F6000B   SB S6, 11(A3)
1406:                	dir[LDIR_Type] = 0;
9D008DE8  A0E0000C   SB ZERO, 12(A3)
1407:                	ST_WORD(dir+LDIR_FstClusLO, 0);
9D008DEC  A0E0001A   SB ZERO, 26(A3)
9D008DF0  A0E0001B   SB ZERO, 27(A3)
1408:                
1409:                	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
9D008DF4  2542FFFF   ADDIU V0, T2, -1
9D008DF8  00021880   SLL V1, V0, 2
9D008DFC  00023100   SLL A2, V0, 4
9D008E00  00C33023   SUBU A2, A2, V1
9D008E04  00C23021   ADDU A2, A2, V0
9D008E08  26A41B68   ADDIU A0, S5, 7016
9D008E0C  24020001   ADDIU V0, ZERO, 1
1410:                	s = wc = 0;
9D008E10  0B402389   J 0x9D008E24
9D008E14  00001821   ADDU V1, ZERO, ZERO
1411:                	do {
1412:                		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
9D008DB8  3410FFFF   ORI S0, ZERO, -1
9D008E24  10700034   BEQ V1, S0, dir_register::fit_lfn
9D008E28  24C80001   ADDIU T0, A2, 1
9D008E2C  00063040   SLL A2, A2, 1
9D008E30  01263021   ADDU A2, T1, A2
9D008E34  94C30000   LHU V1, 0(A2)
9D008E50  01003021   ADDU A2, T0, ZERO
1413:                		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
9D008DBC  2411FFFF   ADDIU S1, ZERO, -1
9D008E38  90850000   LBU A1, 0(A0)
9D008E3C  00E52821   ADDU A1, A3, A1
9D008E40  A0A30000   SB V1, 0(A1)
9D008E44  00033202   SRL A2, V1, 8
9D008EF8  90850000   LBU A1, 0(A0)
9D008EFC  00E52821   ADDU A1, A3, A1
9D008F00  A0B10000   SB S1, 0(A1)
9D008F04  0B402395   J 0x9D008E54
9D008F08  A0B10001   SB S1, 1(A1)
1414:                		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
9D008E18  02001821   ADDU V1, S0, ZERO
9D008E1C  24420001   ADDIU V0, V0, 1
9D008E20  24840001   ADDIU A0, A0, 1
9D008E48  10600030   BEQ V1, ZERO, dir_register::fit_lfn
9D008E4C  A0A60001   SB A2, 1(A1)
1415:                	} while (++s < 13);
9D008E54  2C45000D   SLTIU A1, V0, 13
9D008E58  14A0FFF1   BNE A1, ZERO, 0x9D008E20
9D008E5C  24420001   ADDIU V0, V0, 1
9D008F0C  2C43000D   SLTIU V1, V0, 13
9D008F10  1460FFC1   BNE V1, ZERO, dir_register::fit_lfn
9D008F14  01003021   ADDU A2, T0, ZERO
1416:                	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
9D008E60  10700005   BEQ V1, S0, 0x9D008E78
9D008E64  00063040   SLL A2, A2, 1
9D008E68  01264821   ADDU T1, T1, A2
9D008E6C  95220000   LHU V0, 0(T1)
9D008E70  54400003   BNEL V0, ZERO, 0x9D008E80
9D008E74  A0EA0000   SB T2, 0(A3)
9D008E78  354A0040   ORI T2, T2, 64
9D008F18  0B40239F   J 0x9D008E7C
9D008F1C  354A0040   ORI T2, T2, 64
1417:                	dir[LDIR_Ord] = ord;			/* Set the LFN order */
9D008E7C  A0EA0000   SB T2, 0(A3)
1418:                }
1419:                
1420:                #endif
1421:                #endif
1422:                
1423:                
1424:                
1425:                /*-----------------------------------------------------------------------*/
1426:                /* Create numbered name                                                  */
1427:                /*-----------------------------------------------------------------------*/
1428:                #if FAT_FS_USE_LFN
1429:                void gen_numname (
1430:                	uint8_t *dst,			/* Pointer to generated SFN */
1431:                	const uint8_t *src,	/* Pointer to source SFN to be modified */
1432:                	const uint16_t *lfn,	/* Pointer to LFN */
1433:                	uint16_t seq			/* Sequence number */
1434:                )
1435:                {
9D0107D4  27BDFFD8   ADDIU SP, SP, -40
9D0107D8  AFBF0024   SW RA, 36(SP)
9D0107DC  AFB20020   SW S2, 32(SP)
9D0107E0  AFB1001C   SW S1, 28(SP)
9D0107E4  AFB00018   SW S0, 24(SP)
9D0107E8  00808821   ADDU S1, A0, ZERO
9D0107EC  00C09021   ADDU S2, A2, ZERO
9D0107F0  30F0FFFF   ANDI S0, A3, -1
9D01082C  24040007   ADDIU A0, ZERO, 7
1436:                	uint8_t ns[8], c;
1437:                	uint32_t i, j;
1438:                
1439:                
1440:                	mem_cpy(dst, src, 11);
9D0107F4  0F405BCE   JAL mem_cpy
9D0107F8  2406000B   ADDIU A2, ZERO, 11
1441:                
1442:                	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
9D0107FC  2E020006   SLTIU V0, S0, 6
9D010800  1440000B   BNE V0, ZERO, 0x9D010830
9D010804  24040007   ADDIU A0, ZERO, 7
1443:                		do seq = (seq >> 1) + (seq << 15) + (uint16_t)*lfn++; while (*lfn);
9D010808  00101042   SRL V0, S0, 1
9D01080C  001083C0   SLL S0, S0, 15
9D010810  00508025   OR S0, V0, S0
9D010814  26520002   ADDIU S2, S2, 2
9D010818  9642FFFE   LHU V0, -2(S2)
9D01081C  02028021   ADDU S0, S0, V0
9D010820  96420000   LHU V0, 0(S2)
9D010824  1440FFF8   BNE V0, ZERO, 0x9D010808
9D010828  3210FFFF   ANDI S0, S0, -1
1444:                	}
1445:                
1446:                	/* itoa (hexdecimal) */
1447:                	i = 7;
1448:                	do {
1449:                		c = (seq % 16) + '0';
9D010830  3203000F   ANDI V1, S0, 15
9D010834  24620030   ADDIU V0, V1, 48
1450:                		if (c > '9') c += 7;
9D010838  2C45003A   SLTIU A1, V0, 58
9D01083C  24630037   ADDIU V1, V1, 55
9D010840  0065100A   MOVZ V0, V1, A1
1451:                		ns[i--] = c;
9D010844  2483FFFF   ADDIU V1, A0, -1
9D010848  27A60010   ADDIU A2, SP, 16
9D01084C  00C32821   ADDU A1, A2, V1
9D01085C  0B40420C   J 0x9D010830
9D010860  00602021   ADDU A0, V1, ZERO
9D010864  00603021   ADDU A2, V1, ZERO
1452:                		seq /= 16;
9D010850  00108102   SRL S0, S0, 4
1453:                	} while (seq);
9D010854  12000003   BEQ S0, ZERO, 0x9D010864
9D010858  A0A20001   SB V0, 1(A1)
1454:                	ns[i] = '~';
9D010868  2405007E   ADDIU A1, ZERO, 126
9D01086C  03A31021   ADDU V0, SP, V1
1455:                
1456:                	/* Append the number */
1457:                	for (j = 0; j < i && dst[j] != ' '; j++) {
9D010870  1060001C   BEQ V1, ZERO, 0x9D0108E4
9D010874  A0450010   SB A1, 16(V0)
9D010878  92250000   LBU A1, 0(S1)
9D01087C  24020020   ADDIU V0, ZERO, 32
9D010880  10A20019   BEQ A1, V0, 0x9D0108E8
9D010884  00001021   ADDU V0, ZERO, ZERO
9D01088C  24070020   ADDIU A3, ZERO, 32
9D0108C0  24420001   ADDIU V0, V0, 1
9D0108C4  0046202B   SLTU A0, V0, A2
9D0108C8  50800008   BEQL A0, ZERO, 0x9D0108EC
9D0108CC  27A60010   ADDIU A2, SP, 16
9D0108D0  7E22298A   LBUX A1, V0(S1)
9D0108D4  14A7FFEF   BNE A1, A3, 0x9D010894
9D0108D8  24A4007F   ADDIU A0, A1, 127
9D0108DC  0B40423B   J 0x9D0108EC
9D0108E0  27A60010   ADDIU A2, SP, 16
9D0108E4  00001021   ADDU V0, ZERO, ZERO
1458:                		if (IsDBCS1(dst[j])) {
9D010890  24A4007F   ADDIU A0, A1, 127
9D010894  308400FF   ANDI A0, A0, 255
9D010898  2C84001F   SLTIU A0, A0, 31
9D01089C  14800005   BNE A0, ZERO, 0x9D0108B4
9D0108A0  24A50020   ADDIU A1, A1, 32
9D0108A4  30A500FF   ANDI A1, A1, 255
9D0108A8  2CA5001D   SLTIU A1, A1, 29
9D0108AC  50A00005   BEQL A1, ZERO, 0x9D0108C4
9D0108B0  24420001   ADDIU V0, V0, 1
1459:                			if (j == i - 1) break;
9D010888  2488FFFE   ADDIU T0, A0, -2
9D0108B4  5102000D   BEQL T0, V0, 0x9D0108EC
9D0108B8  27A60010   ADDIU A2, SP, 16
1460:                			j++;
9D0108BC  24420001   ADDIU V0, V0, 1
1461:                		}
1462:                	}
1463:                	do {
1464:                		dst[j++] = (i < 8) ? ns[i++] : ' ';
9D0108E8  27A60010   ADDIU A2, SP, 16
9D0108EC  24420001   ADDIU V0, V0, 1
9D0108F0  2C640008   SLTIU A0, V1, 8
9D0108F4  10800003   BEQ A0, ZERO, 0x9D010904
9D0108F8  24050020   ADDIU A1, ZERO, 32
9D0108FC  7CC3298A   LBUX A1, V1(A2)
9D010900  24630001   ADDIU V1, V1, 1
9D010904  02222021   ADDU A0, S1, V0
9D010908  A085FFFF   SB A1, -1(A0)
1465:                	} while (j < 8);
9D01090C  2C440008   SLTIU A0, V0, 8
9D010910  5480FFF7   BNEL A0, ZERO, 0x9D0108F0
9D010914  24420001   ADDIU V0, V0, 1
1466:                }
9D010918  8FBF0024   LW RA, 36(SP)
1467:                #endif
1468:                
1469:                
1470:                
1471:                
1472:                /*-----------------------------------------------------------------------*/
1473:                /* Calculate sum of an SFN                                               */
1474:                /*-----------------------------------------------------------------------*/
1475:                #if FAT_FS_USE_LFN
1476:                static
1477:                uint8_t sum_sfn (
1478:                	const uint8_t *dir		/* Ptr to directory entry */
1479:                )
1480:                {
9D016A94  2485000B   ADDIU A1, A0, 11
1481:                	uint8_t sum = 0;
9D016A98  00001021   ADDU V0, ZERO, ZERO
1482:                	uint32_t n = 11;
1483:                
1484:                	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
9D016A9C  00021842   SRL V1, V0, 1
9D016AA0  000211C0   SLL V0, V0, 7
9D016AA4  00621025   OR V0, V1, V0
9D016AA8  24840001   ADDIU A0, A0, 1
9D016AAC  9083FFFF   LBU V1, -1(A0)
9D016AB0  00431021   ADDU V0, V0, V1
9D016AB4  1485FFF9   BNE A0, A1, 0x9D016A9C
9D016AB8  304200FF   ANDI V0, V0, 255
1485:                	return sum;
1486:                }
9D016ABC  03E00008   JR RA
1487:                #endif
1488:                
1489:                
1490:                
1491:                
1492:                /*-----------------------------------------------------------------------*/
1493:                /* Directory handling - Find an object in the directory                  */
1494:                /*-----------------------------------------------------------------------*/
1495:                
1496:                static
1497:                FRESULT dir_find (
1498:                	DIR *dj			/* Pointer to the directory object linked to the file name */
1499:                )
1500:                {
9D00AA08  27BDFFB8   ADDIU SP, SP, -72
9D00AA0C  AFBF0044   SW RA, 68(SP)
9D00AA10  AFBE0040   SW S8, 64(SP)
9D00AA14  AFB7003C   SW S7, 60(SP)
9D00AA18  AFB60038   SW S6, 56(SP)
9D00AA1C  AFB50034   SW S5, 52(SP)
9D00AA20  AFB40030   SW S4, 48(SP)
9D00AA24  AFB3002C   SW S3, 44(SP)
9D00AA28  AFB20028   SW S2, 40(SP)
9D00AA2C  AFB10024   SW S1, 36(SP)
9D00AA30  AFB00020   SW S0, 32(SP)
9D00AA34  00808821   ADDU S1, A0, ZERO
1501:                	FRESULT res;
1502:                	uint8_t c, *dir;
1503:                #if FAT_FS_USE_LFN
1504:                	uint8_t a, ord, sum;
1505:                #endif
1506:                
1507:                	res = dir_sdi(dj, 0);			/* Rewind directory object */
9D00AA38  0F404499   JAL dir_sdi
9D00AA3C  00002821   ADDU A1, ZERO, ZERO
9D00AA40  00401821   ADDU V1, V0, ZERO
1508:                	if (res != FR_OK) return res;
9D00AA44  14600091   BNE V1, ZERO, 0x9D00AC8C
9D00AA48  241600FF   ADDIU S6, ZERO, 255
9D00AA4C  241400FF   ADDIU S4, ZERO, 255
1509:                
1510:                #if FAT_FS_USE_LFN
1511:                	ord = sum = 0xFF;
1512:                #endif
1513:                	do {
1514:                		res = move_window(dj->fs, dj->sect);
9D00AA64  8E240000   LW A0, 0(S1)
9D00AA68  0F405691   JAL move_window
9D00AA6C  8E250010   LW A1, 16(S1)
1515:                		if (res != FR_OK) break;
9D00AA70  14400087   BNE V0, ZERO, 0x9D00AC90
9D00AA74  8FBF0044   LW RA, 68(SP)
1516:                		dir = dj->dir;					/* Ptr to the directory entry of current index */
9D00AA78  8E300014   LW S0, 20(S1)
1517:                		c = dir[DIR_Name];
9D00AA7C  92120000   LBU S2, 0(S0)
1518:                		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
9D00AA80  12400083   BEQ S2, ZERO, 0x9D00AC90
9D00AA84  24020004   ADDIU V0, ZERO, 4
1519:                #if FAT_FS_USE_LFN	/* LFN configuration */
1520:                		a = dir[DIR_Attr] & AM_MASK;
9D00AA88  9202000B   LBU V0, 11(S0)
1521:                		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
9D00AA50  241300E5   ADDIU S3, ZERO, 229
9D00AA54  3C029D01   LUI V0, -25343
9D00AA58  24421B68   ADDIU V0, V0, 7016
9D00AA5C  AFA20010   SW V0, 16(SP)
9D00AA60  245E000D   ADDIU S8, V0, 13
9D00AA8C  1253006A   BEQ S2, S3, 0x9D00AC38
9D00AA90  3043003F   ANDI V1, V0, 63
9D00AA94  30420008   ANDI V0, V0, 8
9D00AA98  304200FF   ANDI V0, V0, 255
9D00AA9C  10400005   BEQ V0, ZERO, 0x9D00AAB4
9D00AAA0  2402000F   ADDIU V0, ZERO, 15
9D00AAA4  5462006F   BNEL V1, V0, 0x9D00AC64
9D00AAA8  241400FF   ADDIU S4, ZERO, 255
9D00AAAC  0B402AB0   J 0x9D00AAC0
9D00AAB0  8E35001C   LW S5, 28(S1)
1522:                			ord = 0xFF;
9D00AC38  0B402B19   J 0x9D00AC64
9D00AC3C  241400FF   ADDIU S4, ZERO, 255
1523:                		} else {
1524:                			if (a == AM_LFN) {			/* An LFN entry is found */
9D00AAB4  14620047   BNE V1, V0, 0x9D00ABD4
9D00AAB8  00000000   NOP
1525:                				if (dj->lfn) {
9D00AABC  8E35001C   LW S5, 28(S1)
9D00AAC0  12A00068   BEQ S5, ZERO, 0x9D00AC64
9D00AAC4  32420040   ANDI V0, S2, 64
1526:                					if (c & LLE) {		/* Is it start of LFN sequence? */
9D00AAC8  304200FF   ANDI V0, V0, 255
9D00AACC  10400006   BEQ V0, ZERO, 0x9D00AAE8
9D00AAD0  2402FFBF   ADDIU V0, ZERO, -65
1527:                						sum = dir[LDIR_Chksum];
9D00AAD4  9216000D   LBU S6, 13(S0)
1528:                						c &= ~LLE; ord = c;	/* LFN start order */
9D00AAD8  02429024   AND S2, S2, V0
1529:                						dj->lfn_idx = dj->index;
9D00AADC  96220006   LHU V0, 6(S1)
9D00AAE0  0B402ABC   J 0x9D00AAF0
9D00AAE4  A6220020   SH V0, 32(S1)
1530:                					}
1531:                					/* Check validity of the LFN entry and compare it with given name */
1532:                					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
9D00AAE8  5692005E   BNEL S4, S2, 0x9D00AC64
9D00AAEC  241400FF   ADDIU S4, ZERO, 255
9D00AAF0  9203000D   LBU V1, 13(S0)
9D00AAF4  AFA30018   SW V1, 24(SP)
9D00AAF8  1476005A   BNE V1, S6, 0x9D00AC64
9D00AAFC  241400FF   ADDIU S4, ZERO, 255
9D00AC44  0B402B19   J 0x9D00AC64
9D00AC48  241400FF   ADDIU S4, ZERO, 255
9D00AC50  0B402B19   J 0x9D00AC64
9D00AC54  241400FF   ADDIU S4, ZERO, 255
9D00AC58  0B402B19   J 0x9D00AC64
9D00AC5C  241400FF   ADDIU S4, ZERO, 255
9D00AC60  241400FF   ADDIU S4, ZERO, 255
9D00AC80  325400FF   ANDI S4, S2, 255
9D00AC84  0B402B19   J 0x9D00AC64
9D00AC88  8FB60018   LW S6, 24(SP)
1533:                				}
1534:                			} else {					/* An SFN entry is found */
1535:                				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
9D00ABD4  16800006   BNE S4, ZERO, 0x9D00ABF0
9D00ABD8  2402FFFF   ADDIU V0, ZERO, -1
9D00ABDC  0F405AA5   JAL sum_sfn
9D00ABE0  02002021   ADDU A0, S0, ZERO
9D00ABE4  10560029   BEQ V0, S6, 0x9D00AC8C
9D00ABE8  00001021   ADDU V0, ZERO, ZERO
1536:                				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
9D00ABEC  2402FFFF   ADDIU V0, ZERO, -1
9D00ABF0  A6220020   SH V0, 32(S1)
1537:                				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
9D00ABF4  8E220018   LW V0, 24(S1)
9D00ABF8  9043000B   LBU V1, 11(V0)
9D00ABFC  30630001   ANDI V1, V1, 1
9D00AC00  10600005   BEQ V1, ZERO, 0x9D00AC18
9D00AC04  2605000B   ADDIU A1, S0, 11
9D00AC08  0B402B19   J 0x9D00AC64
9D00AC0C  241400FF   ADDIU S4, ZERO, 255
1538:                			}
1539:                		}
1540:                #else		/* Non LFN configuration */
1541:                		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
1542:                			break;
1543:                #endif
1544:                		res = dir_next(dj, 0);		/* Next entry */
9D00AC30  0B402B1A   J 0x9D00AC68
9D00AC34  02202021   ADDU A0, S1, ZERO
9D00AC64  02202021   ADDU A0, S1, ZERO
9D00AC68  0F403722   JAL dir_next
9D00AC6C  00002821   ADDU A1, ZERO, ZERO
1545:                	} while (res == FR_OK);
9D00AC70  5040FF7D   BEQL V0, ZERO, 0x9D00AA68
9D00AC74  8E240000   LW A0, 0(S1)
9D00AC78  0B402B24   J 0x9D00AC90
9D00AC7C  8FBF0044   LW RA, 68(SP)
1546:                
1547:                	return res;
1548:                }
9D00AC8C  8FBF0044   LW RA, 68(SP)
1549:                
1550:                
1551:                
1552:                
1553:                /*-----------------------------------------------------------------------*/
1554:                /* Read an object from the directory                                     */
1555:                /*-----------------------------------------------------------------------*/
1556:                #if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
1557:                static
1558:                FRESULT dir_read (
1559:                	DIR *dj,		/* Pointer to the directory object */
1560:                	int vol			/* Filtered by 0:file/dir or 1:volume label */
1561:                )
1562:                {
9D00CE58  27BDFFC8   ADDIU SP, SP, -56
9D00CE5C  AFBF0034   SW RA, 52(SP)
9D00CE60  AFBE0030   SW S8, 48(SP)
9D00CE64  AFB7002C   SW S7, 44(SP)
9D00CE68  AFB60028   SW S6, 40(SP)
9D00CE6C  AFB50024   SW S5, 36(SP)
9D00CE70  AFB40020   SW S4, 32(SP)
9D00CE74  AFB3001C   SW S3, 28(SP)
9D00CE78  AFB20018   SW S2, 24(SP)
9D00CE7C  AFB10014   SW S1, 20(SP)
9D00CE80  AFB00010   SW S0, 16(SP)
9D00CE84  00808021   ADDU S0, A0, ZERO
9D00CE88  00A0A021   ADDU S4, A1, ZERO
1563:                	FRESULT res;
1564:                	uint8_t a, c, *dir;
1565:                #if FAT_FS_USE_LFN
1566:                	uint8_t ord = 0xFF, sum = 0xFF;
9D00CE8C  241600FF   ADDIU S6, ZERO, 255
9D00CE90  241200FF   ADDIU S2, ZERO, 255
1567:                #endif
1568:                
1569:                	res = FR_NO_FILE;
9D00CE94  24110004   ADDIU S1, ZERO, 4
1570:                	while (dj->sect) {
9D00CEA8  0B403401   J 0x9D00D004
9D00CEAC  26FE000D   ADDIU S8, S7, 13
9D00D004  8E050010   LW A1, 16(S0)
9D00D008  14A0FFA9   BNE A1, ZERO, 0x9D00CEB0
9D00D00C  00000000   NOP
1571:                		res = move_window(dj->fs, dj->sect);
9D00CEB0  0F405691   JAL move_window
9D00CEB4  8E040000   LW A0, 0(S0)
1572:                		if (res != FR_OK) break;
9D00CEB8  14400057   BNE V0, ZERO, 0x9D00D018
9D00CEBC  00408821   ADDU S1, V0, ZERO
1573:                		dir = dj->dir;					/* Ptr to the directory entry of current index */
9D00CEC0  8E040014   LW A0, 20(S0)
1574:                		c = dir[DIR_Name];
9D00CEC4  90820000   LBU V0, 0(A0)
1575:                		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
9D00CEC8  50400053   BEQL V0, ZERO, 0x9D00D018
9D00CECC  24110004   ADDIU S1, ZERO, 4
1576:                		a = dir[DIR_Attr] & AM_MASK;
9D00CED0  9083000B   LBU V1, 11(A0)
1577:                #if FAT_FS_USE_LFN	/* LFN configuration */
1578:                		if (c == DDE || (!_FS_RPATH && c == '.') || (a == AM_VOL) != vol) {	/* An entry without valid data */
9D00CE98  241300E5   ADDIU S3, ZERO, 229
9D00CED4  10530045   BEQ V0, S3, 0x9D00CFEC
9D00CED8  3063003F   ANDI V1, V1, 63
9D00CEDC  38650008   XORI A1, V1, 8
9D00CEE0  2CA50001   SLTIU A1, A1, 1
9D00CEE4  54B40042   BNEL A1, S4, 0x9D00CFF0
9D00CEE8  241200FF   ADDIU S2, ZERO, 255
1579:                			ord = 0xFF;
1580:                		} else {
1581:                			if (a == AM_LFN) {			/* An LFN entry is found */
9D00CE9C  2415000F   ADDIU S5, ZERO, 15
9D00CEA0  3C179D01   LUI S7, -25343
9D00CEA4  26F71B68   ADDIU S7, S7, 7016
9D00CEEC  14750037   BNE V1, S5, 0x9D00CFCC
9D00CEF0  30430040   ANDI V1, V0, 64
1582:                				if (c & LLE) {			/* Is it start of LFN sequence? */
9D00CEF4  306300FF   ANDI V1, V1, 255
9D00CEF8  10600006   BEQ V1, ZERO, 0x9D00CF14
9D00CEFC  00000000   NOP
1583:                					sum = dir[LDIR_Chksum];
9D00CF00  9096000D   LBU S6, 13(A0)
1584:                					c &= ~LLE; ord = c;
9D00CF04  304200BF   ANDI V0, V0, 191
1585:                					dj->lfn_idx = dj->index;
9D00CF08  96030006   LHU V1, 6(S0)
9D00CF0C  0B4033C7   J 0x9D00CF1C
9D00CF10  A6030020   SH V1, 32(S0)
1586:                				}
1587:                				/* Check LFN validity and capture it */
1588:                				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
9D00CF14  56420036   BNEL S2, V0, 0x9D00CFF0
9D00CF18  241200FF   ADDIU S2, ZERO, 255
9D00CF1C  9089000D   LBU T1, 13(A0)
9D00CF20  15360033   BNE T1, S6, 0x9D00CFF0
9D00CF24  241200FF   ADDIU S2, ZERO, 255
9D00CF28  8E0B001C   LW T3, 28(S0)
9D00D020  2442FFFF   ADDIU V0, V0, -1
9D00D024  305200FF   ANDI S2, V0, 255
9D00D028  0B4033FC   J 0x9D00CFF0
9D00D02C  0120B021   ADDU S6, T1, ZERO
9D00D030  0120B021   ADDU S6, T1, ZERO
9D00D034  0B4033FC   J 0x9D00CFF0
9D00D038  241200FF   ADDIU S2, ZERO, 255
1589:                			} else {					/* An SFN entry is found */
1590:                				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
9D00CFCC  16400005   BNE S2, ZERO, 0x9D00CFE4
9D00CFD0  2402FFFF   ADDIU V0, ZERO, -1
9D00CFD4  0F405AA5   JAL sum_sfn
9D00CFD8  00000000   NOP
9D00CFDC  10560017   BEQ V0, S6, 0x9D00D03C
9D00CFE0  2402FFFF   ADDIU V0, ZERO, -1
1591:                					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
9D00CFE4  0B40340F   J 0x9D00D03C
9D00CFE8  A6020020   SH V0, 32(S0)
9D00CFEC  241200FF   ADDIU S2, ZERO, 255
1592:                				break;
1593:                			}
1594:                		}
1595:                #else		/* Non LFN configuration */
1596:                		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid entry? */
1597:                			break;
1598:                #endif
1599:                		res = dir_next(dj, 0);				/* Next entry */
9D00CFF0  02002021   ADDU A0, S0, ZERO
9D00CFF4  0F403722   JAL dir_next
9D00CFF8  00002821   ADDU A1, ZERO, ZERO
1600:                		if (res != FR_OK) break;
9D00CFFC  14400006   BNE V0, ZERO, 0x9D00D018
9D00D000  00408821   ADDU S1, V0, ZERO
1601:                	}
1602:                
1603:                	if (res != FR_OK) dj->sect = 0;
9D00D010  1220000B   BEQ S1, ZERO, 0x9D00D040
9D00D014  02201021   ADDU V0, S1, ZERO
9D00D018  0B40340F   J 0x9D00D03C
9D00D01C  AE000010   SW ZERO, 16(S0)
1604:                
1605:                	return res;
1606:                }
9D00D03C  02201021   ADDU V0, S1, ZERO
1607:                #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
1608:                
1609:                
1610:                
1611:                /*-----------------------------------------------------------------------*/
1612:                /* Register an object to the directory                                   */
1613:                /*-----------------------------------------------------------------------*/
1614:                #if !_FS_READONLY
1615:                static
1616:                FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
1617:                	DIR *dj				/* Target directory with object name to be created */
1618:                )
1619:                {
9D008C2C  27BDFFB8   ADDIU SP, SP, -72
9D008C30  AFBF0044   SW RA, 68(SP)
9D008C34  AFB70040   SW S7, 64(SP)
9D008C38  AFB6003C   SW S6, 60(SP)
9D008C3C  AFB50038   SW S5, 56(SP)
9D008C40  AFB40034   SW S4, 52(SP)
9D008C44  AFB30030   SW S3, 48(SP)
9D008C48  AFB2002C   SW S2, 44(SP)
9D008C4C  AFB10028   SW S1, 40(SP)
9D008C50  AFB00024   SW S0, 36(SP)
9D008C54  00809021   ADDU S2, A0, ZERO
1620:                	FRESULT res;
1621:                #if FAT_FS_USE_LFN	/* LFN configuration */
1622:                	uint16_t n, ne;
1623:                	uint8_t sn[12], *fn, sum;
1624:                	uint16_t *lfn;
1625:                
1626:                
1627:                	fn = dj->fn; lfn = dj->lfn;
9D008C58  8C930018   LW S3, 24(A0)
9D008C5C  8C94001C   LW S4, 28(A0)
1628:                	mem_cpy(sn, fn, 12);
9D008C60  27A40010   ADDIU A0, SP, 16
9D008C64  02602821   ADDU A1, S3, ZERO
9D008C68  0F405BCE   JAL mem_cpy
9D008C6C  2406000C   ADDIU A2, ZERO, 12
1629:                
1630:                	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
9D008C70  93A2001B   LBU V0, 27(SP)
9D008C74  30440020   ANDI A0, V0, 32
9D008C78  308400FF   ANDI A0, A0, 255
9D008C7C  148000AF   BNE A0, ZERO, 0x9D008F3C
9D008C80  24030006   ADDIU V1, ZERO, 6
1631:                		return FR_INVALID_NAME;
1632:                
1633:                	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
9D008C84  30420001   ANDI V0, V0, 1
9D008C88  1040001D   BEQ V0, ZERO, 0x9D008D00
9D008C8C  93A2001B   LBU V0, 27(SP)
1634:                		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
9D008C90  A260000B   SB ZERO, 11(S3)
9D008C94  AE40001C   SW ZERO, 28(S2)
9D008C98  24100001   ADDIU S0, ZERO, 1
1635:                		for (n = 1; n < 100; n++) {
9D008C9C  24150064   ADDIU S5, ZERO, 100
9D008CA0  3211FFFF   ANDI S1, S0, -1
9D008CD0  1615FFF3   BNE S0, S5, 0x9D008CA0
9D008CD4  3231FFFF   ANDI S1, S1, -1
1636:                			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
9D008CA4  02602021   ADDU A0, S3, ZERO
9D008CA8  27A50010   ADDIU A1, SP, 16
9D008CAC  02803021   ADDU A2, S4, ZERO
9D008CB0  0F4041F5   JAL gen_numname
9D008CB4  02003821   ADDU A3, S0, ZERO
1637:                			res = dir_find(dj);				/* Check if the name collides with existing SFN */
9D008CB8  0F402A82   JAL dir_find
9D008CBC  02402021   ADDU A0, S2, ZERO
1638:                			if (res != FR_OK) break;
9D008CC0  54400006   BNEL V0, ZERO, 0x9D008CDC
9D008CC4  24040064   ADDIU A0, ZERO, 100
9D008CC8  26310001   ADDIU S1, S1, 1
9D008CCC  26100001   ADDIU S0, S0, 1
1639:                		}
1640:                		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
9D008CD8  24040064   ADDIU A0, ZERO, 100
9D008CDC  12240097   BEQ S1, A0, 0x9D008F3C
9D008CE0  24030007   ADDIU V1, ZERO, 7
1641:                		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
9D008CE4  24040004   ADDIU A0, ZERO, 4
9D008CE8  14440094   BNE V0, A0, 0x9D008F3C
9D008CEC  00401821   ADDU V1, V0, ZERO
1642:                		fn[NS] = sn[NS]; dj->lfn = lfn;
9D008CF0  93A2001B   LBU V0, 27(SP)
9D008CF4  A262000B   SB V0, 11(S3)
9D008CF8  AE54001C   SW S4, 28(S2)
1643:                	}
1644:                
1645:                	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
9D008CFC  93A2001B   LBU V0, 27(SP)
9D008D00  30420002   ANDI V0, V0, 2
9D008D04  304200FF   ANDI V0, V0, 255
9D008D08  10400016   BEQ V0, ZERO, 0x9D008D64
9D008D0C  24130001   ADDIU S3, ZERO, 1
1646:                		for (n = 0; lfn[n]; n++) ;
9D008D10  96820000   LHU V0, 0(S4)
9D008D14  1040000A   BEQ V0, ZERO, 0x9D008D40
9D008D18  00001021   ADDU V0, ZERO, ZERO
9D008D1C  24420001   ADDIU V0, V0, 1
9D008D20  3042FFFF   ANDI V0, V0, -1
9D008D24  00021840   SLL V1, V0, 1
9D008D28  02831821   ADDU V1, S4, V1
9D008D2C  94630000   LHU V1, 0(V1)
9D008D30  5460FFFB   BNEL V1, ZERO, 0x9D008D20
9D008D34  24420001   ADDIU V0, V0, 1
9D008D38  0B402351   J 0x9D008D44
9D008D3C  24420019   ADDIU V0, V0, 25
1647:                		ne = (n + 25) / 13;
9D008D40  24420019   ADDIU V0, V0, 25
9D008D44  3C134EC4   LUI S3, 20164
9D008D48  3673EC4F   ORI S3, S3, -5041
9D008D4C  00530018   MULT 0, V0, S3
9D008D50  00009810   MFHI S3
9D008D54  00139883   SRA S3, S3, 2
9D008D58  000217C3   SRA V0, V0, 31
9D008D5C  02629823   SUBU S3, S3, V0
9D008D60  3273FFFF   ANDI S3, S3, -1
1648:                	} else {						/* Otherwise allocate an entry for an SFN  */
1649:                		ne = 1;
1650:                	}
1651:                	res = dir_alloc(dj, ne);		/* Allocate entries */
9D008D64  02402021   ADDU A0, S2, ZERO
9D008D68  0F4051B3   JAL dir_alloc
9D008D6C  02602821   ADDU A1, S3, ZERO
1652:                
1653:                	if (res == FR_OK && --ne) {		/* Set LFN entry if needed */
9D008D70  14400072   BNE V0, ZERO, 0x9D008F3C
9D008D74  00401821   ADDU V1, V0, ZERO
9D008D78  2673FFFF   ADDIU S3, S3, -1
9D008D7C  3273FFFF   ANDI S3, S3, -1
9D008D80  52600067   BEQL S3, ZERO, 0x9D008F20
9D008D84  8E440000   LW A0, 0(S2)
1654:                		res = dir_sdi(dj, (uint16_t)(dj->index - ne));
9D008D88  96450006   LHU A1, 6(S2)
9D008D8C  00B32823   SUBU A1, A1, S3
9D008D90  02402021   ADDU A0, S2, ZERO
9D008D94  0F404499   JAL dir_sdi
9D008D98  30A5FFFF   ANDI A1, A1, -1
1655:                		if (res == FR_OK) {
9D008D9C  14400067   BNE V0, ZERO, 0x9D008F3C
9D008DA0  00401821   ADDU V1, V0, ZERO
1656:                			sum = sum_sfn(dj->fn);	/* Sum value of the SFN tied to the LFN */
9D008DA4  0F405AA5   JAL sum_sfn
9D008DA8  8E440018   LW A0, 24(S2)
9D008DAC  0040B821   ADDU S7, V0, ZERO
1657:                			do {					/* Store LFN entries in bottom first */
1658:                				res = move_window(dj->fs, dj->sect);
9D008DC4  8E440000   LW A0, 0(S2)
9D008DC8  0F405691   JAL move_window
9D008DCC  8E450010   LW A1, 16(S2)
1659:                				if (res != FR_OK) break;
9D008DD0  14400059   BNE V0, ZERO, 0x9D008F38
9D008DD4  326A00FF   ANDI T2, S3, 255
1660:                				fit_lfn(dj->lfn, dj->dir, (uint8_t)ne, sum);
9D008DD8  8E49001C   LW T1, 28(S2)
9D008DDC  8E470014   LW A3, 20(S2)
1661:                				dj->fs->wflag = 1;
9D008DC0  24140001   ADDIU S4, ZERO, 1
9D008E80  8E420000   LW V0, 0(S2)
9D008E84  A0540004   SB S4, 4(V0)
1662:                				res = dir_next(dj, 0);	/* Next entry */
9D008E88  02402021   ADDU A0, S2, ZERO
9D008E8C  0F403722   JAL dir_next
9D008E90  00002821   ADDU A1, ZERO, ZERO
1663:                			} while (res == FR_OK && --ne);
9D008E94  14400028   BNE V0, ZERO, 0x9D008F38
9D008E98  2673FFFF   ADDIU S3, S3, -1
9D008E9C  3273FFFF   ANDI S3, S3, -1
9D008EA0  1660FFC9   BNE S3, ZERO, 0x9D008DC8
9D008EA4  8E440000   LW A0, 0(S2)
9D008EA8  0B4023C8   J 0x9D008F20
9D008EAC  00000000   NOP
1664:                		}
1665:                	}
1666:                #else	/* Non LFN configuration */
1667:                	res = dir_alloc(dj, 1);		/* Allocate an entry for SFN */
1668:                #endif
1669:                
1670:                	if (res == FR_OK) {				/* Set SFN entry */
1671:                		res = move_window(dj->fs, dj->sect);
9D008EF0  0B4023CF   J 0x9D008F3C
9D008EF4  02001821   ADDU V1, S0, ZERO
9D008F20  0F405691   JAL move_window
9D008F24  8E450010   LW A1, 16(S2)
9D008F30  0B4023CF   J 0x9D008F3C
9D008F34  00401821   ADDU V1, V0, ZERO
9D008F38  00401821   ADDU V1, V0, ZERO
1672:                		if (res == FR_OK) {
9D008F28  1040FFE1   BEQ V0, ZERO, 0x9D008EB0
9D008F2C  00408021   ADDU S0, V0, ZERO
1673:                			mem_set(dj->dir, 0, SZ_DIR);	/* Clean the entry */
9D008EB0  8E440014   LW A0, 20(S2)
9D008EB4  00002821   ADDU A1, ZERO, ZERO
9D008EB8  0F405C30   JAL mem_set
9D008EBC  24060020   ADDIU A2, ZERO, 32
1674:                			mem_cpy(dj->dir, dj->fn, 11);	/* Put SFN */
9D008EC0  8E440014   LW A0, 20(S2)
9D008EC4  8E450018   LW A1, 24(S2)
9D008EC8  0F405BCE   JAL mem_cpy
9D008ECC  2406000B   ADDIU A2, ZERO, 11
1675:                #if FAT_FS_USE_LFN
1676:                			dj->dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
9D008ED0  8E420014   LW V0, 20(S2)
9D008ED4  8E430018   LW V1, 24(S2)
9D008ED8  9063000B   LBU V1, 11(V1)
9D008EDC  30630018   ANDI V1, V1, 24
9D008EE0  A043000C   SB V1, 12(V0)
1677:                #endif
1678:                			dj->fs->wflag = 1;
9D008EE4  8E420000   LW V0, 0(S2)
9D008EE8  24030001   ADDIU V1, ZERO, 1
9D008EEC  A0430004   SB V1, 4(V0)
1679:                		}
1680:                	}
1681:                
1682:                	return res;
1683:                }
9D008F3C  00601021   ADDU V0, V1, ZERO
1684:                #endif /* !_FS_READONLY */
1685:                
1686:                
1687:                
1688:                
1689:                /*-----------------------------------------------------------------------*/
1690:                /* Remove an object from the directory                                   */
1691:                /*-----------------------------------------------------------------------*/
1692:                #if !_FS_READONLY && !_FS_MINIMIZE
1693:                static
1694:                FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
1695:                	DIR *dj				/* Directory object pointing the entry to be removed */
1696:                )
1697:                {
9D014378  27BDFFD8   ADDIU SP, SP, -40
9D01437C  AFBF0024   SW RA, 36(SP)
9D014380  AFB30020   SW S3, 32(SP)
9D014384  AFB2001C   SW S2, 28(SP)
9D014388  AFB10018   SW S1, 24(SP)
9D01438C  AFB00014   SW S0, 20(SP)
9D014390  00808021   ADDU S0, A0, ZERO
1698:                	FRESULT res;
1699:                #if FAT_FS_USE_LFN	/* LFN configuration */
1700:                	uint16_t i;
1701:                
1702:                	i = dj->index;	/* SFN index */
9D014394  94910006   LHU S1, 6(A0)
1703:                	res = dir_sdi(dj, (uint16_t)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
9D014398  94820020   LHU V0, 32(A0)
9D01439C  3845FFFF   XORI A1, V0, -1
9D0143A0  0225100A   MOVZ V0, S1, A1
9D0143A4  0F404499   JAL dir_sdi
9D0143A8  00402821   ADDU A1, V0, ZERO
1704:                	if (res == FR_OK) {
9D0143AC  14400016   BNE V0, ZERO, 0x9D014408
9D0143B0  2413FFE5   ADDIU S3, ZERO, -27
1705:                		do {
1706:                			res = move_window(dj->fs, dj->sect);
9D0143B8  8E040000   LW A0, 0(S0)
9D0143BC  0F405691   JAL move_window
9D0143C0  8E050010   LW A1, 16(S0)
1707:                			if (res != FR_OK) break;
9D0143C4  1440000E   BNE V0, ZERO, 0x9D014400
9D0143C8  38440004   XORI A0, V0, 4
1708:                			*dj->dir = DDE;			/* Mark the entry "deleted" */
9D0143CC  8E030014   LW V1, 20(S0)
9D0143D0  A0730000   SB S3, 0(V1)
1709:                			dj->fs->wflag = 1;
9D0143B4  24120001   ADDIU S2, ZERO, 1
9D0143D4  8E030000   LW V1, 0(S0)
9D0143D8  A0720004   SB S2, 4(V1)
1710:                			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
9D0143DC  96030006   LHU V1, 6(S0)
9D0143E0  0071182B   SLTU V1, V1, S1
9D0143E4  10600008   BEQ V1, ZERO, 0x9D014408
9D0143E8  02002021   ADDU A0, S0, ZERO
1711:                			res = dir_next(dj, 0);		/* Next entry */
9D0143EC  0F403722   JAL dir_next
9D0143F0  00002821   ADDU A1, ZERO, ZERO
1712:                		} while (res == FR_OK);
9D0143F4  5040FFF1   BEQL V0, ZERO, 0x9D0143BC
9D0143F8  8E040000   LW A0, 0(S0)
1713:                		if (res == FR_NO_FILE) res = FR_INT_ERR;
9D0143FC  38440004   XORI A0, V0, 4
9D014400  24030002   ADDIU V1, ZERO, 2
9D014404  0064100A   MOVZ V0, V1, A0
1714:                	}
1715:                
1716:                #else			/* Non LFN configuration */
1717:                	res = dir_sdi(dj, dj->index);
1718:                	if (res == FR_OK) {
1719:                		res = move_window(dj->fs, dj->sect);
1720:                		if (res == FR_OK) {
1721:                			*dj->dir = DDE;			/* Mark the entry "deleted" */
1722:                			dj->fs->wflag = 1;
1723:                		}
1724:                	}
1725:                #endif
1726:                
1727:                	return res;
1728:                }
9D014408  8FBF0024   LW RA, 36(SP)
1729:                #endif /* !_FS_READONLY */
1730:                
1731:                
1732:                
1733:                
1734:                /*-----------------------------------------------------------------------*/
1735:                /* Pick a segment and create the object name in directory form           */
1736:                /*-----------------------------------------------------------------------*/
1737:                
1738:                static
1739:                FRESULT create_name (
1740:                	DIR *dj,			/* Pointer to the directory object */
1741:                	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
1742:                )
1743:                {
1744:                #if FAT_FS_USE_LFN	/* LFN configuration */
1745:                	uint8_t b, cf;
1746:                	uint16_t w, *lfn;
1747:                	uint32_t i, ni, si, di;
1748:                	const TCHAR *p;
1749:                
1750:                	/* Create LFN in Unicode */
1751:                	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
9D004460  2413005C   ADDIU S3, ZERO, 92
9D004484  82020000   LB V0, 0(S0)
9D004488  5052FFFE   BEQL V0, S2, follow_path::create_name
9D00448C  26100001   ADDIU S0, S0, 1
9D004490  5053FFFC   BEQL V0, S3, follow_path::create_name
9D004494  26100001   ADDIU S0, S0, 1
1752:                	lfn = dj->lfn;
1753:                	si = di = 0;
9D0044BC  00008821   ADDU S1, ZERO, ZERO
9D0044C4  00002821   ADDU A1, ZERO, ZERO
9D004A10  00008821   ADDU S1, ZERO, ZERO
1754:                	for (;;) {
1755:                		w = p[si++];					/* Get a character */
9D004498  82020000   LB V0, 0(S0)
9D00449C  3042FFFF   ANDI V0, V0, -1
9D0044C0  24030001   ADDIU V1, ZERO, 1
9D004594  02051021   ADDU V0, S0, A1
9D004598  80420000   LB V0, 0(V0)
9D00459C  3042FFFF   ANDI V0, V0, -1
9D004A14  24030001   ADDIU V1, ZERO, 1
9D004A24  0B40128C   J 0x9D004A30
9D004A28  24030001   ADDIU V1, ZERO, 1
9D004A2C  24030001   ADDIU V1, ZERO, 1
1756:                		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
9D0044A0  2C430020   SLTIU V1, V0, 32
9D0044A4  1460015A   BNE V1, ZERO, follow_path::create_name
9D0044A8  8E95001C   LW S5, 28(S4)
9D0044AC  1052015D   BEQ V0, S2, 0x9D004A24
9D0044B0  00008821   ADDU S1, ZERO, ZERO
9D0044B4  1053015D   BEQ V0, S3, follow_path::create_name
9D0044B8  02A03821   ADDU A3, S5, ZERO
9D0044D0  50520158   BEQL V0, S2, 0x9D004A34
9D0044D4  02038021   ADDU S0, S0, V1
9D0044D8  50530156   BEQL V0, S3, 0x9D004A34
9D0044DC  02038021   ADDU S0, S0, V1
9D0045A0  2C440020   SLTIU A0, V0, 32
9D0045A4  1080FFCA   BEQ A0, ZERO, follow_path::create_name
9D0045A8  24A30001   ADDIU V1, A1, 1
1757:                		if (di >= FAT_FS_MAX_LFN)				/* Reject too long name */
9D0044C8  0B40113A   J 0x9D0044E8
9D0044CC  240800FF   ADDIU T0, ZERO, 255
9D0044E0  1228016E   BEQ S1, T0, 0x9D004A9C
9D0044E4  24E70002   ADDIU A3, A3, 2
1758:                			return FR_INVALID_NAME;
1759:                #if !_LFN_UNICODE
1760:                		w &= 0xFF;
9D0044E8  304200FF   ANDI V0, V0, 255
1761:                		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
9D0044EC  304400FF   ANDI A0, V0, 255
9D0044F0  2486007F   ADDIU A2, A0, 127
9D0044F4  30C600FF   ANDI A2, A2, 255
9D0044F8  2CC6001F   SLTIU A2, A2, 31
9D0044FC  54C00007   BNEL A2, ZERO, 0x9D00451C
9D004500  7E03198A   LBUX V1, V1(S0)
9D004504  24840020   ADDIU A0, A0, 32
9D004508  308400FF   ANDI A0, A0, 255
9D00450C  2C84001D   SLTIU A0, A0, 29
9D004510  5080000E   BEQL A0, ZERO, 0x9D00454C
9D004514  00602821   ADDU A1, V1, ZERO
1762:                			b = (uint8_t)p[si++];			/* Get 2nd byte */
9D004518  7E03198A   LBUX V1, V1(S0)
1763:                			if (!IsDBCS2(b))
9D00451C  2464FFC0   ADDIU A0, V1, -64
9D004520  308400FF   ANDI A0, A0, 255
9D004524  2C84003F   SLTIU A0, A0, 63
9D004528  14800005   BNE A0, ZERO, 0x9D004540
9D00452C  24A50002   ADDIU A1, A1, 2
9D004530  38640080   XORI A0, V1, 128
9D004534  2C84007D   SLTIU A0, A0, 125
9D004538  5080015F   BEQL A0, ZERO, 0x9D004AB8
9D00453C  24020006   ADDIU V0, ZERO, 6
1764:                				return FR_INVALID_NAME;	/* Reject invalid sequence */
1765:                			w = (w << 8) + b;			/* Create a DBC */
9D004540  00021200   SLL V0, V0, 8
9D004544  00431021   ADDU V0, V0, V1
9D004548  3042FFFF   ANDI V0, V0, -1
1766:                		}
1767:                		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
9D00454C  7C021420   SEB V0, V0
9D004550  3044FFFF   ANDI A0, V0, -1
1768:                		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
9D004554  10800158   BEQ A0, ZERO, 0x9D004AB8
9D004558  24020006   ADDIU V0, ZERO, 6
1769:                #endif
1770:                		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
9D00455C  2C820080   SLTIU V0, A0, 128
9D004560  5040000B   BEQL V0, ZERO, follow_path::create_name
9D004564  26310001   ADDIU S1, S1, 1
1771:                			return FR_INVALID_NAME;
1772:                		lfn[di++] = w;					/* Store the Unicode char */
9D004590  A4E40000   SH A0, 0(A3)
1773:                	}
1774:                	*path = &p[si];						/* Return pointer to the next segment */
9D0045AC  0B401287   J 0x9D004A1C
9D0045B0  02038021   ADDU S0, S0, V1
9D004A18  02038021   ADDU S0, S0, V1
9D004A30  02038021   ADDU S0, S0, V1
1775:                	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
9D004A1C  0B40116D   J follow_path::create_name
9D004A20  241E0004   ADDIU S8, ZERO, 4
9D004A34  0B40116D   J follow_path::create_name
9D004A38  0000F021   ADDU S8, ZERO, ZERO
1776:                #if _FS_RPATH
1777:                	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
9D0045B4  24020001   ADDIU V0, ZERO, 1
9D0045B8  16220007   BNE S1, V0, follow_path::create_name
9D0045BC  24020002   ADDIU V0, ZERO, 2
9D0045C0  96A30000   LHU V1, 0(S5)
9D0045C4  2402002E   ADDIU V0, ZERO, 46
9D0045C8  14620011   BNE V1, V0, 0x9D004610
9D0045CC  00111040   SLL V0, S1, 1
9D0045D8  16220006   BNE S1, V0, follow_path::create_name
9D0045DC  2402002E   ADDIU V0, ZERO, 46
1778:                		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
9D0045E0  96A30002   LHU V1, 2(S5)
9D0045E4  1462000A   BNE V1, V0, 0x9D004610
9D0045E8  00111040   SLL V0, S1, 1
9D0045EC  0B401181   J follow_path::create_name
9D0045F0  96A30000   LHU V1, 0(S5)
9D004604  2402002E   ADDIU V0, ZERO, 46
9D004608  10620005   BEQ V1, V0, follow_path::create_name
9D00460C  00111040   SLL V0, S1, 1
9D004610  02A21021   ADDU V0, S5, V0
1779:                		lfn[di] = 0;
9D0045D0  0B401189   J 0x9D004624
9D0045D4  02A2A821   ADDU S5, S5, V0
9D004620  02A2A821   ADDU S5, S5, V0
9D004624  A6A00000   SH ZERO, 0(S5)
1780:                		for (i = 0; i < 11; i++)
9D004628  00001021   ADDU V0, ZERO, ZERO
9D004634  2405000B   ADDIU A1, ZERO, 11
9D00464C  24420001   ADDIU V0, V0, 1
9D004650  1445FFF9   BNE V0, A1, 0x9D004638
9D004654  A0680000   SB T0, 0(V1)
1781:                			dj->fn[i] = (i < di) ? '.' : ' ';
9D00462C  24070020   ADDIU A3, ZERO, 32
9D004630  2406002E   ADDIU A2, ZERO, 46
9D004638  8E830018   LW V1, 24(S4)
9D00463C  00621821   ADDU V1, V1, V0
9D004640  0051202B   SLTU A0, V0, S1
9D004644  00C04021   ADDU T0, A2, ZERO
9D004648  00E4400A   MOVZ T0, A3, A0
1782:                		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
9D004658  8E820018   LW V0, 24(S4)
9D00465C  37DE0020   ORI S8, S8, 32
9D004660  0B4012A0   J 0x9D004A80
9D004664  A05E000B   SB S8, 11(V0)
1783:                		return FR_OK;
1784:                	}
1785:                #endif
1786:                	while (di) {						/* Strip trailing spaces and dots */
9D0045F4  56200006   BNEL S1, ZERO, 0x9D004610
9D0045F8  00111040   SLL V0, S1, 1
9D004680  1620FFF9   BNE S1, ZERO, follow_path::create_name
9D004684  2442FFFE   ADDIU V0, V0, -2
1787:                		w = lfn[di-1];
9D004668  9443FFFE   LHU V1, -2(V0)
1788:                		if (w != ' ' && w != '.') break;
9D004614  24040020   ADDIU A0, ZERO, 32
9D004618  0B40119A   J follow_path::create_name
9D00461C  2405002E   ADDIU A1, ZERO, 46
9D00466C  50640004   BEQL V1, A0, 0x9D004680
9D004670  2631FFFF   ADDIU S1, S1, -1
9D004674  14650006   BNE V1, A1, follow_path::create_name
9D004678  00000000   NOP
1789:                		di--;
9D00467C  2631FFFF   ADDIU S1, S1, -1
1790:                	}
1791:                	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
9D004690  52200109   BEQL S1, ZERO, 0x9D004AB8
9D004694  24020006   ADDIU V0, ZERO, 6
1792:                
1793:                	lfn[di] = 0;						/* LFN is created */
9D004698  00111040   SLL V0, S1, 1
9D00469C  AFA20010   SW V0, 16(SP)
9D0046A0  02A21821   ADDU V1, S5, V0
9D0046A4  AFA30014   SW V1, 20(SP)
9D0046A8  A4600000   SH ZERO, 0(V1)
1794:                
1795:                	/* Create SFN in directory form */
1796:                	mem_set(dj->fn, ' ', 11);
9D0046AC  8E840018   LW A0, 24(S4)
9D0046B0  24050020   ADDIU A1, ZERO, 32
9D0046B4  0F405C30   JAL mem_set
9D0046B8  2406000B   ADDIU A2, ZERO, 11
9D0046BC  02A01021   ADDU V0, S5, ZERO
1797:                	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
9D0046C0  00001821   ADDU V1, ZERO, ZERO
9D0046C4  24050020   ADDIU A1, ZERO, 32
9D0046C8  0B4011B5   J follow_path::create_name
9D0046CC  2406002E   ADDIU A2, ZERO, 46
9D0046D0  24420002   ADDIU V0, V0, 2
9D0046D4  94440000   LHU A0, 0(V0)
9D0046D8  5085FFFD   BEQL A0, A1, 0x9D0046D0
9D0046DC  24630001   ADDIU V1, V1, 1
9D0046E0  5086FFFB   BEQL A0, A2, 0x9D0046D0
9D0046E4  24630001   ADDIU V1, V1, 1
1798:                	if (si) cf |= NS_LOSS | NS_LFN;
9D0046E8  37C20003   ORI V0, S8, 3
9D0046EC  0043F00B   MOVN S8, V0, V1
1799:                	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
9D0046F0  8FA40010   LW A0, 16(SP)
9D0046F4  02A41021   ADDU V0, S5, A0
9D0046F8  9444FFFE   LHU A0, -2(V0)
9D0046FC  2402002E   ADDIU V0, ZERO, 46
9D004700  148200CE   BNE A0, V0, 0x9D004A3C
9D004704  8FA20014   LW V0, 20(SP)
9D004710  2631FFFF   ADDIU S1, S1, -1
9D004714  16200006   BNE S1, ZERO, follow_path::create_name
9D004718  2442FFFE   ADDIU V0, V0, -2
9D004730  9444FFFE   LHU A0, -2(V0)
9D004734  5485FFF7   BNEL A0, A1, 0x9D004714
9D004738  2631FFFF   ADDIU S1, S1, -1
9D004A3C  0B4011C4   J follow_path::create_name
9D004A40  2405002E   ADDIU A1, ZERO, 46
1800:                
1801:                	b = i = 0; ni = 8;
1802:                	for (;;) {
1803:                		w = lfn[si++];					/* Get an LFN char */
9D004708  0B4011C8   J 0x9D004720
9D00470C  24050008   ADDIU A1, ZERO, 8
9D00471C  24050008   ADDIU A1, ZERO, 8
9D004720  AFA50014   SW A1, 20(SP)
9D004724  AFA0001C   SW ZERO, 28(SP)
9D004728  0B4011D1   J follow_path::create_name
9D00472C  AFA00018   SW ZERO, 24(SP)
9D00473C  0B4011C8   J 0x9D004720
9D004740  24050008   ADDIU A1, ZERO, 8
9D004744  24680001   ADDIU T0, V1, 1
9D004748  AFA80010   SW T0, 16(SP)
9D00474C  00031040   SLL V0, V1, 1
9D004750  02A21021   ADDU V0, S5, V0
9D004754  94440000   LHU A0, 0(V0)
9D004780  0B4011D1   J follow_path::create_name
9D004784  8FA30010   LW V1, 16(SP)
9D004838  8FA30010   LW V1, 16(SP)
9D0048EC  0B4011D1   J follow_path::create_name
9D0048F0  8FA30010   LW V1, 16(SP)
1804:                		if (!w) break;					/* Break on end of the LFN */
9D004758  10800066   BEQ A0, ZERO, 0x9D0048F4
9D00475C  24020020   ADDIU V0, ZERO, 32
9D0048F4  0B401240   J 0x9D004900
9D0048F8  8FA50018   LW A1, 24(SP)
1805:                		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
9D004760  50820007   BEQL A0, V0, 0x9D004780
9D004764  37DE0003   ORI S8, S8, 3
9D004768  2403002E   ADDIU V1, ZERO, 46
9D00476C  14830006   BNE A0, V1, follow_path::create_name
9D004770  8FA5001C   LW A1, 28(SP)
9D004774  122800CB   BEQ S1, T0, follow_path::create_name
9D004778  2402000B   ADDIU V0, ZERO, 11
1806:                			cf |= NS_LOSS | NS_LFN; continue;
9D00477C  37DE0003   ORI S8, S8, 3
1807:                		}
1808:                
1809:                		if (i >= ni || si == di) {		/* Extension or end of SFN */
9D004788  8FA80014   LW T0, 20(SP)
9D00478C  00A8102B   SLTU V0, A1, T0
9D004790  10400006   BEQ V0, ZERO, follow_path::create_name
9D004794  2402000B   ADDIU V0, ZERO, 11
9D004798  8FA20010   LW V0, 16(SP)
9D00479C  56220017   BNEL S1, V0, follow_path::create_name
9D0047A0  2C820080   SLTIU V0, A0, 128
1810:                			if (ni == 11) {				/* Long extension */
9D0047A4  0B401291   J follow_path::create_name
9D0047A8  2402000B   ADDIU V0, ZERO, 11
9D0047AC  8FA30014   LW V1, 20(SP)
9D0047B0  14620004   BNE V1, V0, follow_path::create_name
9D0047B4  8FA40010   LW A0, 16(SP)
9D004A44  8FA30014   LW V1, 20(SP)
9D004A48  5462FF63   BNEL V1, V0, 0x9D0047D8
9D004A4C  8FA50018   LW A1, 24(SP)
9D004AA4  8FA40014   LW A0, 20(SP)
9D004AA8  5482FF4B   BNEL A0, V0, 0x9D0047D8
9D004AAC  8FA50018   LW A1, 24(SP)
1811:                				cf |= NS_LOSS | NS_LFN; break;
9D0047B8  37DE0003   ORI S8, S8, 3
9D0047BC  0B401240   J 0x9D004900
9D0047C0  8FA50018   LW A1, 24(SP)
9D004A50  0B4011EF   J 0x9D0047BC
9D004A54  37DE0003   ORI S8, S8, 3
9D004AB0  0B4011EF   J 0x9D0047BC
9D004AB4  37DE0003   ORI S8, S8, 3
1812:                			}
1813:                			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
9D0047C4  12240003   BEQ S1, A0, 0x9D0047D4
9D0047C8  0224102B   SLTU V0, S1, A0
1814:                			if (si > di) break;			/* No extension */
9D004588  0B4012AE   J 0x9D004AB8
9D00458C  24020006   ADDIU V0, ZERO, 6
9D0045FC  0B4012AE   J 0x9D004AB8
9D004600  24020006   ADDIU V0, ZERO, 6
9D004688  0B4012AE   J 0x9D004AB8
9D00468C  24020006   ADDIU V0, ZERO, 6
9D0047CC  1440004B   BNE V0, ZERO, follow_path::create_name
9D0047D0  37DE0003   ORI S8, S8, 3
9D0048FC  8FA50018   LW A1, 24(SP)
9D004A9C  0B4012AE   J 0x9D004AB8
9D004AA0  24020006   ADDIU V0, ZERO, 6
1815:                			si = di; i = 8; ni = 11;	/* Enter extension section */
9D0047E8  2408000B   ADDIU T0, ZERO, 11
9D0047EC  AFA80014   SW T0, 20(SP)
9D0047F0  24020008   ADDIU V0, ZERO, 8
9D0047F4  0B4011D1   J follow_path::create_name
9D0047F8  AFA2001C   SW V0, 28(SP)
1816:                			b <<= 2; continue;
9D0047D4  8FA50018   LW A1, 24(SP)
9D0047D8  00051080   SLL V0, A1, 2
9D0047DC  304200FF   ANDI V0, V0, 255
9D0047E0  AFA20018   SW V0, 24(SP)
9D0047E4  02201821   ADDU V1, S1, ZERO
1817:                		}
1818:                
1819:                		if (w >= 0x80) {				/* Non ASCII char */
9D0047FC  14400096   BNE V0, ZERO, follow_path::create_name
9D004800  2C820100   SLTIU V0, A0, 256
1820:                #ifdef _EXCVT
1821:                			w = ff_convert(w, 0);		/* Unicode -> OEM code */
1822:                			if (w) w = ExCvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
1823:                #else
1824:                			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
9D004804  0F405BA6   JAL ff_wtoupper
9D004808  37DE0002   ORI S8, S8, 2
9D00480C  7C021420   SEB V0, V0
9D004810  3044FFFF   ANDI A0, V0, -1
1825:                #endif
1826:                			cf |= NS_LFN;				/* Force create LFN entry */
1827:                		}
1828:                
1829:                		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
9D004814  2C820100   SLTIU V0, A0, 256
9D004818  14400012   BNE V0, ZERO, follow_path::create_name
9D00481C  8FA30014   LW V1, 20(SP)
9D004A58  1040FF71   BEQ V0, ZERO, 0x9D004820
9D004A5C  8FA30014   LW V1, 20(SP)
1830:                			if (i >= ni - 1) {
9D004820  2462FFFF   ADDIU V0, V1, -1
9D004824  8FA5001C   LW A1, 28(SP)
9D004828  00A2102B   SLTU V0, A1, V0
9D00482C  54400006   BNEL V0, ZERO, follow_path::create_name
9D004830  8FA3001C   LW V1, 28(SP)
1831:                				cf |= NS_LOSS | NS_LFN; i = ni; continue;
9D004834  37DE0003   ORI S8, S8, 3
9D00483C  8FA80014   LW T0, 20(SP)
9D004840  0B4011D1   J follow_path::create_name
9D004844  AFA8001C   SW T0, 28(SP)
1832:                			}
1833:                			dj->fn[i++] = (uint8_t)(w >> 8);
9D004848  24620001   ADDIU V0, V1, 1
9D00484C  8E830018   LW V1, 24(S4)
9D004850  8FA5001C   LW A1, 28(SP)
9D004854  00651821   ADDU V1, V1, A1
9D004858  00042A02   SRL A1, A0, 8
9D00485C  0B401236   J 0x9D0048D8
9D004860  A0650000   SB A1, 0(V1)
1834:                		} else {						/* Single byte char */
1835:                			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
9D004864  5080000C   BEQL A0, ZERO, 0x9D004898
9D004868  37DE0003   ORI S8, S8, 3
1836:                				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
9D004894  37DE0003   ORI S8, S8, 3
9D004898  8FA2001C   LW V0, 28(SP)
9D00489C  0B401236   J 0x9D0048D8
9D0048A0  2404005F   ADDIU A0, ZERO, 95
1837:                			} else {
1838:                				if (IsUpper(w)) {		/* ASCII large capital */
9D004A68  3042FFFF   ANDI V0, V0, -1
9D004A6C  2C42001A   SLTIU V0, V0, 26
9D004A70  1440FF8C   BNE V0, ZERO, follow_path::create_name
9D004A74  8FA50018   LW A1, 24(SP)
1839:                					b |= 2;
9D0048A4  34A50002   ORI A1, A1, 2
9D0048A8  AFA50018   SW A1, 24(SP)
9D0048AC  0B401236   J 0x9D0048D8
9D0048B0  8FA2001C   LW V0, 28(SP)
1840:                				} else {
1841:                					if (IsLower(w)) {	/* ASCII small capital */
9D0048B4  3063FFFF   ANDI V1, V1, -1
9D0048B8  2C63001A   SLTIU V1, V1, 26
9D0048BC  10600006   BEQ V1, ZERO, 0x9D0048D8
9D0048C0  8FA2001C   LW V0, 28(SP)
9D004A78  0B40122D   J follow_path::create_name
9D004A7C  2483FF9F   ADDIU V1, A0, -97
1842:                						b |= 1; w -= 0x20;
9D0048C4  8FA80018   LW T0, 24(SP)
9D0048C8  35080001   ORI T0, T0, 1
9D0048CC  AFA80018   SW T0, 24(SP)
9D0048D0  2484FFE0   ADDIU A0, A0, -32
9D0048D4  3084FFFF   ANDI A0, A0, -1
1843:                					}
1844:                				}
1845:                			}
1846:                		}
1847:                		dj->fn[i++] = (uint8_t)w;
9D0048D8  24430001   ADDIU V1, V0, 1
9D0048DC  AFA3001C   SW V1, 28(SP)
9D0048E0  8E830018   LW V1, 24(S4)
9D0048E4  00621021   ADDU V0, V1, V0
9D0048E8  A0440000   SB A0, 0(V0)
1848:                	}
1849:                
1850:                	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
9D004900  8E820018   LW V0, 24(S4)
9D004904  90440000   LBU A0, 0(V0)
9D004908  240300E5   ADDIU V1, ZERO, 229
9D00490C  54830004   BNEL A0, V1, 0x9D004920
9D004910  24020008   ADDIU V0, ZERO, 8
9D004914  24030005   ADDIU V1, ZERO, 5
9D004918  A0430000   SB V1, 0(V0)
1851:                
1852:                	if (ni == 8) b <<= 2;
9D00491C  24020008   ADDIU V0, ZERO, 8
9D004920  8FA40014   LW A0, 20(SP)
9D004924  54820005   BNEL A0, V0, 0x9D00493C
9D004928  8FA50018   LW A1, 24(SP)
9D00492C  00052880   SLL A1, A1, 2
9D004930  30A500FF   ANDI A1, A1, 255
9D004934  AFA50018   SW A1, 24(SP)
1853:                	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
9D004938  8FA50018   LW A1, 24(SP)
9D00493C  30A2000C   ANDI V0, A1, 12
9D004940  2403000C   ADDIU V1, ZERO, 12
9D004944  10430004   BEQ V0, V1, 0x9D004958
9D004948  30A40003   ANDI A0, A1, 3
9D00494C  24030003   ADDIU V1, ZERO, 3
9D004950  14830003   BNE A0, V1, 0x9D004960
9D004954  33C30002   ANDI V1, S8, 2
1854:                		cf |= NS_LFN;
9D004958  37DE0002   ORI S8, S8, 2
1855:                	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
9D00495C  33C30002   ANDI V1, S8, 2
9D004960  306300FF   ANDI V1, V1, 255
9D004964  5460000A   BNEL V1, ZERO, 0x9D004990
9D004968  8E820018   LW V0, 24(S4)
1856:                		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
9D00496C  8FA80018   LW T0, 24(SP)
9D004970  31040003   ANDI A0, T0, 3
9D004974  37C30010   ORI V1, S8, 16
9D004978  38840001   XORI A0, A0, 1
9D00497C  0064F00A   MOVZ S8, V1, A0
1857:                		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
9D004980  37C30008   ORI V1, S8, 8
9D004984  38420004   XORI V0, V0, 4
9D004988  0062F00A   MOVZ S8, V1, V0
1858:                	}
1859:                
1860:                	dj->fn[NS] = cf;	/* SFN is created */
9D00498C  8E820018   LW V0, 24(S4)
9D004990  0B4012A0   J 0x9D004A80
9D004994  A05E000B   SB S8, 11(V0)
1861:                
1862:                	return FR_OK;
1863:                
1864:                
1865:                #else	/* Non-LFN configuration */
1866:                	uint8_t b, c, d, *sfn;
1867:                	uint32_t ni, si, i;
1868:                	const char *p;
1869:                
1870:                	/* Create file name in directory form */
1871:                	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
1872:                	sfn = dj->fn;
1873:                	mem_set(sfn, ' ', 11);
1874:                	si = i = b = 0; ni = 8;
1875:                #if _FS_RPATH
1876:                	if (p[si] == '.') { /* Is this a dot entry? */
1877:                		for (;;) {
1878:                			c = (uint8_t)p[si++];
1879:                			if (c != '.' || si >= 3) break;
1880:                			sfn[i++] = c;
1881:                		}
1882:                		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
1883:                		*path = &p[si];									/* Return pointer to the next segment */
1884:                		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
1885:                		return FR_OK;
1886:                	}
1887:                #endif
1888:                	for (;;) {
1889:                		c = (uint8_t)p[si++];
1890:                		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
1891:                		if (c == '.' || i >= ni) {
1892:                			if (ni != 8 || c != '.') return FR_INVALID_NAME;
1893:                			i = 8; ni = 11;
1894:                			b <<= 2; continue;
1895:                		}
1896:                		if (c >= 0x80) {				/* Extended char? */
1897:                			b |= 3;						/* Eliminate NT flag */
1898:                #ifdef _EXCVT
1899:                			c = ExCvt[c - 0x80];		/* To upper extended chars (SBCS cfg) */
1900:                #else
1901:                #if !_DF1S
1902:                			return FR_INVALID_NAME;		/* Reject extended chars (ASCII cfg) */
1903:                #endif
1904:                #endif
1905:                		}
1906:                		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
1907:                			d = (uint8_t)p[si++];			/* Get 2nd byte */
1908:                			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
1909:                				return FR_INVALID_NAME;
1910:                			sfn[i++] = c;
1911:                			sfn[i++] = d;
1912:                		} else {						/* Single byte code */
1913:                			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
1914:                				return FR_INVALID_NAME;
1915:                			if (IsUpper(c)) {			/* ASCII large capital? */
1916:                				b |= 2;
1917:                			} else {
1918:                				if (IsLower(c)) {		/* ASCII small capital? */
1919:                					b |= 1; c -= 0x20;
1920:                				}
1921:                			}
1922:                			sfn[i++] = c;
1923:                		}
1924:                	}
1925:                	*path = &p[si];						/* Return pointer to the next segment */
1926:                	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
1927:                
1928:                	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
1929:                	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
1930:                
1931:                	if (ni == 8) b <<= 2;
1932:                	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
1933:                	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
1934:                
1935:                	sfn[NS] = c;		/* Store NT flag, File name is created */
1936:                
1937:                	return FR_OK;
1938:                #endif
1939:                }
1940:                
1941:                
1942:                
1943:                
1944:                /*-----------------------------------------------------------------------*/
1945:                /* Get file information from directory entry                             */
1946:                /*-----------------------------------------------------------------------*/
1947:                #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
1948:                static
1949:                void get_fileinfo (		/* No return code */
1950:                	DIR *dj,			/* Pointer to the directory object */
1951:                	FILINFO *fno	 	/* Pointer to the file information to be filled */
1952:                )
1953:                {
1954:                	uint32_t i;
1955:                	uint8_t nt, *dir;
1956:                	TCHAR *p, c;
1957:                
1958:                
1959:                	p = fno->fname;
1960:                	if (dj->sect) {
9D00BE24  8C820010   LW V0, 16(A0)
9D00BE28  1040005B   BEQ V0, ZERO, 0x9D00BF98
9D00BE2C  24A30009   ADDIU V1, A1, 9
1961:                		dir = dj->dir;
9D00BE30  8C870014   LW A3, 20(A0)
1962:                		nt = dir[DIR_NTres];		/* NT flag */
1963:                		for (i = 0; i < 8; i++) {	/* Copy name body */
9D00BE44  00003021   ADDU A2, ZERO, ZERO
9D00BE58  24090008   ADDIU T1, ZERO, 8
9D00BEA4  24C60001   ADDIU A2, A2, 1
9D00BEA8  14C9FFEE   BNE A2, T1, 0x9D00BE64
9D00BEAC  A062FFFF   SB V0, -1(V1)
1964:                			c = dir[i];
9D00BE34  80E20000   LB V0, 0(A3)
9D00BE68  80420000   LB V0, 0(V0)
1965:                			if (c == ' ') break;
9D00BE38  24060020   ADDIU A2, ZERO, 32
9D00BE3C  1046001C   BEQ V0, A2, 0x9D00BEB0
9D00BE40  90EF000C   LBU T7, 12(A3)
9D00BE5C  0B402F9D   J 0x9D00BE74
9D00BE60  240D0020   ADDIU T5, ZERO, 32
9D00BE64  00E61021   ADDU V0, A3, A2
9D00BE6C  504D0011   BEQL V0, T5, 0x9D00BEB4
9D00BE70  90E60008   LBU A2, 8(A3)
1966:                			if (c == NDDE) c = (TCHAR)DDE;
9D00BE48  240C0005   ADDIU T4, ZERO, 5
9D00BE4C  240BFFE5   ADDIU T3, ZERO, -27
9D00BE74  004C4026   XOR T0, V0, T4
1967:                			if (FAT_FS_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
9D00BE50  31EA0008   ANDI T2, T7, 8
9D00BE54  314A00FF   ANDI T2, T2, 255
9D00BE78  11400009   BEQ T2, ZERO, 0x9D00BEA0
9D00BE7C  0168100A   MOVZ V0, T3, T0
9D00BE80  304800FF   ANDI T0, V0, 255
9D00BE84  250EFFBF   ADDIU T6, T0, -65
9D00BE88  31CE00FF   ANDI T6, T6, 255
9D00BE8C  2DCE001A   SLTIU T6, T6, 26
9D00BE90  51C00004   BEQL T6, ZERO, 0x9D00BEA4
9D00BE94  24630001   ADDIU V1, V1, 1
9D00BE98  25020020   ADDIU V0, T0, 32
9D00BE9C  7C021420   SEB V0, V0
1968:                #if _LFN_UNICODE
1969:                			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
1970:                				c = (c << 8) | dir[++i];
1971:                			c = ff_convert(c, 1);
1972:                			if (!c) c = '?';
1973:                #endif
1974:                			*p++ = c;
9D00BEA0  24630001   ADDIU V1, V1, 1
1975:                		}
1976:                		if (dir[8] != ' ') {		/* Copy name extension */
9D00BEB0  90E60008   LBU A2, 8(A3)
9D00BEB4  24020020   ADDIU V0, ZERO, 32
9D00BEB8  10C20020   BEQ A2, V0, 0x9D00BF3C
9D00BEBC  2402002E   ADDIU V0, ZERO, 46
1977:                			*p++ = '.';
9D00BEC0  A0620000   SB V0, 0(V1)
9D00BEE0  01401821   ADDU V1, T2, ZERO
9D00BF38  01401821   ADDU V1, T2, ZERO
1978:                			for (i = 8; i < 11; i++) {
9D00BF28  1469FFF2   BNE V1, T1, 0x9D00BEF4
9D00BF2C  A062FFFF   SB V0, -1(V1)
1979:                				c = dir[i];
9D00BEC4  90E60008   LBU A2, 8(A3)
9D00BEC8  7C061420   SEB V0, A2
9D00BEF4  91060000   LBU A2, 0(T0)
9D00BEF8  7C061420   SEB V0, A2
1980:                				if (c == ' ') break;
9D00BECC  24080020   ADDIU T0, ZERO, 32
9D00BED0  10480019   BEQ V0, T0, 0x9D00BF38
9D00BED4  246A0001   ADDIU T2, V1, 1
9D00BED8  24E80009   ADDIU T0, A3, 9
9D00BEDC  24690004   ADDIU T1, V1, 4
9D00BEEC  0B402FC1   J 0x9D00BF04
9D00BEF0  240A0020   ADDIU T2, ZERO, 32
9D00BEFC  104A000F   BEQ V0, T2, 0x9D00BF3C
9D00BF00  25080001   ADDIU T0, T0, 1
1981:                				if (FAT_FS_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
9D00BEE4  31EF0010   ANDI T7, T7, 16
9D00BEE8  31EF00FF   ANDI T7, T7, 255
9D00BF04  11E00008   BEQ T7, ZERO, 0x9D00BF28
9D00BF08  24630001   ADDIU V1, V1, 1
9D00BF0C  24CBFFBF   ADDIU T3, A2, -65
9D00BF10  316B00FF   ANDI T3, T3, 255
9D00BF14  2D6B001A   SLTIU T3, T3, 26
9D00BF18  11600003   BEQ T3, ZERO, 0x9D00BF28
9D00BF1C  00000000   NOP
9D00BF20  24C20020   ADDIU V0, A2, 32
9D00BF24  7C021420   SEB V0, V0
1982:                #if _LFN_UNICODE
1983:                				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
1984:                					c = (c << 8) | dir[++i];
1985:                				c = ff_convert(c, 1);
1986:                				if (!c) c = '?';
1987:                #endif
1988:                				*p++ = c;
1989:                			}
1990:                		}
1991:                		fno->fattrib = dir[DIR_Attr];				/* Attribute */
9D00BF30  0B402FD0   J 0x9D00BF40
9D00BF34  90E2000B   LBU V0, 11(A3)
9D00BF3C  90E2000B   LBU V0, 11(A3)
9D00BF40  A0A20008   SB V0, 8(A1)
1992:                		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
9D00BF44  90E6001F   LBU A2, 31(A3)
9D00BF48  00063600   SLL A2, A2, 24
9D00BF4C  90E2001E   LBU V0, 30(A3)
9D00BF50  00021400   SLL V0, V0, 16
9D00BF54  00C21025   OR V0, A2, V0
9D00BF58  90E6001C   LBU A2, 28(A3)
9D00BF5C  00461025   OR V0, V0, A2
9D00BF60  90E6001D   LBU A2, 29(A3)
9D00BF64  00063200   SLL A2, A2, 8
9D00BF68  00461025   OR V0, V0, A2
9D00BF6C  ACA20000   SW V0, 0(A1)
1993:                		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
9D00BF70  90E20019   LBU V0, 25(A3)
9D00BF74  00021200   SLL V0, V0, 8
9D00BF78  90E60018   LBU A2, 24(A3)
9D00BF7C  00461025   OR V0, V0, A2
9D00BF80  A4A20004   SH V0, 4(A1)
1994:                		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
9D00BF84  90E20017   LBU V0, 23(A3)
9D00BF88  00021200   SLL V0, V0, 8
9D00BF8C  90E60016   LBU A2, 22(A3)
9D00BF90  00461025   OR V0, V0, A2
9D00BF94  A4A20006   SH V0, 6(A1)
1995:                	}
1996:                	*p = 0;		/* Terminate SFN str by a \0 */
9D00BF98  A0600000   SB ZERO, 0(V1)
1997:                
1998:                #if FAT_FS_USE_LFN
1999:                	if (fno->lfname && fno->lfsize) {
9D00BF9C  8CA70018   LW A3, 24(A1)
9D00BFA0  10E00035   BEQ A3, ZERO, 0x9D00C078
9D00BFA4  00000000   NOP
9D00BFA8  8CA2001C   LW V0, 28(A1)
9D00BFAC  10400032   BEQ V0, ZERO, 0x9D00C078
9D00BFB0  00000000   NOP
2000:                		TCHAR *tp = fno->lfname;
2001:                		uint16_t w, *lfn;
2002:                
2003:                		i = 0;
9D00C054  0B40301C   J 0x9D00C070
9D00C058  00004021   ADDU T0, ZERO, ZERO
2004:                		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
9D00BFB4  8C820010   LW V0, 16(A0)
9D00BFB8  1040002D   BEQ V0, ZERO, 0x9D00C070
9D00BFBC  00004021   ADDU T0, ZERO, ZERO
9D00BFC0  94830020   LHU V1, 32(A0)
9D00BFC4  3402FFFF   ORI V0, ZERO, -1
9D00BFC8  5062002A   BEQL V1, V0, 0x9D00C074
9D00BFCC  00E83821   ADDU A3, A3, T0
2005:                			lfn = dj->lfn;
9D00BFD0  8C82001C   LW V0, 28(A0)
2006:                			while ((w = *lfn++) != 0) {			/* Get an LFN char */
9D00BFD4  94440000   LHU A0, 0(V0)
9D00BFD8  1080001E   BEQ A0, ZERO, 0x9D00C054
9D00BFDC  24460002   ADDIU A2, V0, 2
9D00C03C  24C60002   ADDIU A2, A2, 2
9D00C040  94C4FFFE   LHU A0, -2(A2)
9D00C044  5480FFEC   BNEL A0, ZERO, 0x9D00BFF8
9D00C048  7C042420   SEB A0, A0
2007:                #if !_LFN_UNICODE
2008:                				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
9D00BFE0  7C042420   SEB A0, A0
9D00BFE4  3083FFFF   ANDI V1, A0, -1
9D00BFF8  3083FFFF   ANDI V1, A0, -1
2009:                				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
9D00BFE8  1060001C   BEQ V1, ZERO, 0x9D00C05C
9D00BFEC  00001021   ADDU V0, ZERO, ZERO
9D00BFFC  10600019   BEQ V1, ZERO, 0x9D00C064
9D00C000  01001021   ADDU V0, T0, ZERO
9D00C05C  0B40301C   J 0x9D00C070
9D00C060  00004021   ADDU T0, ZERO, ZERO
9D00C064  0B40301C   J 0x9D00C070
9D00C068  00004021   ADDU T0, ZERO, ZERO
2010:                				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
9D00BFF0  0B403002   J 0x9D00C008
9D00BFF4  2C680100   SLTIU T0, V1, 256
9D00C004  2C680100   SLTIU T0, V1, 256
9D00C008  55000006   BNEL T0, ZERO, 0x9D00C024
9D00C00C  8CA3001C   LW V1, 28(A1)
2011:                					tp[i++] = (TCHAR)(w >> 8);
9D00C010  00E24021   ADDU T0, A3, V0
9D00C014  00031A02   SRL V1, V1, 8
9D00C018  A1030000   SB V1, 0(T0)
9D00C01C  24420001   ADDIU V0, V0, 1
2012:                #endif
2013:                				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
9D00C020  8CA3001C   LW V1, 28(A1)
9D00C024  2463FFFF   ADDIU V1, V1, -1
9D00C028  0043182B   SLTU V1, V0, V1
9D00C02C  1060000F   BEQ V1, ZERO, 0x9D00C06C
9D00C030  24480001   ADDIU T0, V0, 1
9D00C06C  00004021   ADDU T0, ZERO, ZERO
2014:                				tp[i++] = (TCHAR)w;
9D00C034  00E21021   ADDU V0, A3, V0
9D00C038  A0440000   SB A0, 0(V0)
2015:                			}
2016:                		}
2017:                		tp[i] = 0;	/* Terminate the LFN str by a \0 */
9D00C04C  0B40301D   J 0x9D00C074
9D00C050  00E83821   ADDU A3, A3, T0
9D00C070  00E83821   ADDU A3, A3, T0
2018:                	}
2019:                #endif
2020:                }
2021:                #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2*/
2022:                
2023:                
2024:                
2025:                
2026:                /*-----------------------------------------------------------------------*/
2027:                /* Follow a file path                                                    */
2028:                /*-----------------------------------------------------------------------*/
2029:                
2030:                static
2031:                FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
2032:                	DIR *dj,			/* Directory object to return last directory and found object */
2033:                	const TCHAR *path	/* Full-path string to find a file or directory */
2034:                )
2035:                {
9D0043F0  27BDFFB8   ADDIU SP, SP, -72
9D0043F4  AFBF0044   SW RA, 68(SP)
9D0043F8  AFBE0040   SW S8, 64(SP)
9D0043FC  AFB7003C   SW S7, 60(SP)
9D004400  AFB60038   SW S6, 56(SP)
9D004404  AFB50034   SW S5, 52(SP)
9D004408  AFB40030   SW S4, 48(SP)
9D00440C  AFB3002C   SW S3, 44(SP)
9D004410  AFB20028   SW S2, 40(SP)
9D004414  AFB10024   SW S1, 36(SP)
9D004418  AFB00020   SW S0, 32(SP)
9D00441C  0080A021   ADDU S4, A0, ZERO
2036:                	FRESULT res;
2037:                	uint8_t *dir, ns;
2038:                
2039:                
2040:                #if _FS_RPATH
2041:                	if (*path == '/' || *path == '\\') { /* There is a heading separator */
9D004420  80A20000   LB V0, 0(A1)
9D004424  2403002F   ADDIU V1, ZERO, 47
9D004428  10430004   BEQ V0, V1, 0x9D00443C
9D00442C  00A08021   ADDU S0, A1, ZERO
9D004430  2403005C   ADDIU V1, ZERO, 92
9D004434  54430004   BNEL V0, V1, 0x9D004448
9D004438  8C820000   LW V0, 0(A0)
2042:                		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
9D00443C  26100001   ADDIU S0, S0, 1
9D004440  0B401114   J 0x9D004450
9D004444  AE800008   SW ZERO, 8(S4)
2043:                	} else {							/* No heading separator */
2044:                		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
9D004448  8C420018   LW V0, 24(V0)
9D00444C  AC820008   SW V0, 8(A0)
2045:                	}
2046:                #else
2047:                	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
2048:                		path++;
2049:                	dj->sclust = 0;						/* Start from the root dir */
2050:                #endif
2051:                
2052:                	if ((uint32_t)*path < ' ') {			/* Nul path means the start directory itself */
9D004450  92020000   LBU V0, 0(S0)
9D004454  2C420020   SLTIU V0, V0, 32
9D004458  14400005   BNE V0, ZERO, 0x9D004470
9D00445C  2412002F   ADDIU S2, ZERO, 47
2053:                		res = dir_sdi(dj, 0);
9D004470  02802021   ADDU A0, S4, ZERO
9D004474  0F404499   JAL dir_sdi
9D004478  00002821   ADDU A1, ZERO, ZERO
9D00447C  0B4012AE   J 0x9D004AB8
9D004480  AE800014   SW ZERO, 20(S4)
2054:                		dj->dir = 0;
2055:                	} else {							/* Follow path */
2056:                		for (;;) {
2057:                			res = create_name(dj, &path);	/* Get a segment */
2058:                			if (res != FR_OK) break;
2059:                			res = dir_find(dj);				/* Find it */
9D004A80  0F402A82   JAL dir_find
9D004A84  02802021   ADDU A0, S4, ZERO
2060:                			ns = *(dj->fn+NS);
9D004A88  8E830018   LW V1, 24(S4)
2061:                			if (res != FR_OK) {				/* Failed to find the object */
9D004A8C  1440FFC2   BNE V0, ZERO, 0x9D004998
9D004A90  9063000B   LBU V1, 11(V1)
9D004A94  0B401277   J 0x9D0049DC
9D004A98  30630004   ANDI V1, V1, 4
2062:                				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
9D004998  24040004   ADDIU A0, ZERO, 4
9D00499C  14440046   BNE V0, A0, 0x9D004AB8
9D0049A0  30640020   ANDI A0, V1, 32
2063:                				/* Object not found */
2064:                				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
9D0049A4  308400FF   ANDI A0, A0, 255
9D0049A8  50800008   BEQL A0, ZERO, 0x9D0049CC
9D0049AC  30630004   ANDI V1, V1, 4
2065:                					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
9D0049B0  AE800008   SW ZERO, 8(S4)
2066:                					res = FR_OK;
9D0049C4  0B4012AE   J 0x9D004AB8
9D0049C8  00001021   ADDU V0, ZERO, ZERO
2067:                					if (!(ns & NS_LAST)) continue;
9D0049B4  30620004   ANDI V0, V1, 4
9D0049B8  304200FF   ANDI V0, V0, 255
9D0049BC  1040FEB1   BEQ V0, ZERO, follow_path::create_name
9D0049C0  AE800014   SW ZERO, 20(S4)
2068:                				} else {							/* Could not find the object */
2069:                					if (!(ns & NS_LAST)) res = FR_NO_PATH;
9D0049CC  306400FF   ANDI A0, V1, 255
9D0049D0  24030005   ADDIU V1, ZERO, 5
9D0049D4  0B4012AE   J 0x9D004AB8
9D0049D8  0064100A   MOVZ V0, V1, A0
2070:                				}
2071:                				break;
2072:                			}
2073:                			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
9D0049DC  306300FF   ANDI V1, V1, 255
9D0049E0  14600036   BNE V1, ZERO, 0x9D004ABC
9D0049E4  8FBF0044   LW RA, 68(SP)
2074:                			dir = dj->dir;						/* There is next segment. Follow the sub directory */
9D0049E8  8E850014   LW A1, 20(S4)
2075:                			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
9D0049EC  90A2000B   LBU V0, 11(A1)
9D0049F0  30420010   ANDI V0, V0, 16
9D0049F4  304200FF   ANDI V0, V0, 255
9D0049F8  10400030   BEQ V0, ZERO, 0x9D004ABC
9D0049FC  24020005   ADDIU V0, ZERO, 5
2076:                				res = FR_NO_PATH; break;
2077:                			}
2078:                			dj->sclust = ld_clust(dj->fs, dir);
9D004A00  0F4059DD   JAL ld_clust
9D004A04  8E840000   LW A0, 0(S4)
9D004A08  0B401121   J follow_path::create_name
9D004A0C  AE820008   SW V0, 8(S4)
2079:                		}
2080:                	}
2081:                
2082:                	return res;
2083:                }
9D004AB8  8FBF0044   LW RA, 68(SP)
2084:                
2085:                
2086:                
2087:                
2088:                /*-----------------------------------------------------------------------*/
2089:                /* Load a sector and check if it is an FAT Volume Boot Record            */
2090:                /*-----------------------------------------------------------------------*/
2091:                
2092:                static
2093:                uint8_t check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
2094:                	FATFS *fs,	/* File system object */
2095:                	uint32_t sect	/* Sector# (lba) to check if it is an FAT boot record or not */
2096:                )
2097:                {
9D013040  27BDFFE8   ADDIU SP, SP, -24
9D013044  AFBF0014   SW RA, 20(SP)
9D013048  AFB00010   SW S0, 16(SP)
9D01304C  00808021   ADDU S0, A0, ZERO
9D013050  00A03021   ADDU A2, A1, ZERO
2098:                	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
9D013054  90840001   LBU A0, 1(A0)
9D013058  26050038   ADDIU A1, S0, 56
9D01305C  0F40561B   JAL disk_read
9D013060  24070001   ADDIU A3, ZERO, 1
9D013064  14400027   BNE V0, ZERO, 0x9D013104
9D013068  24030003   ADDIU V1, ZERO, 3
2099:                		return 3;
2100:                	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
9D01306C  92040237   LBU A0, 567(S0)
9D013070  00042200   SLL A0, A0, 8
9D013074  92020236   LBU V0, 566(S0)
9D013078  00822025   OR A0, A0, V0
9D01307C  7C042620   SEH A0, A0
9D013080  2402AA55   ADDIU V0, ZERO, -21931
9D013084  1482001F   BNE A0, V0, 0x9D013104
9D013088  24030002   ADDIU V1, ZERO, 2
2101:                		return 2;
2102:                
2103:                	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
9D01308C  92030071   LBU V1, 113(S0)
9D013090  00031E00   SLL V1, V1, 24
9D013094  92020070   LBU V0, 112(S0)
9D013098  00021400   SLL V0, V0, 16
9D01309C  00621825   OR V1, V1, V0
9D0130A0  9202006E   LBU V0, 110(S0)
9D0130A4  00621825   OR V1, V1, V0
9D0130A8  9202006F   LBU V0, 111(S0)
9D0130AC  00021200   SLL V0, V0, 8
9D0130B0  00621825   OR V1, V1, V0
9D0130B4  7C63B800   EXT V1, V1, 0, 24
9D0130B8  3C020054   LUI V0, 84
9D0130BC  24424146   ADDIU V0, V0, 16710
9D0130C0  50620010   BEQL V1, V0, 0x9D013104
9D0130C4  00001821   ADDU V1, ZERO, ZERO
2104:                		return 0;
2105:                	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
9D0130C8  9203008D   LBU V1, 141(S0)
9D0130CC  00031E00   SLL V1, V1, 24
9D0130D0  9202008C   LBU V0, 140(S0)
9D0130D4  00021400   SLL V0, V0, 16
9D0130D8  00621825   OR V1, V1, V0
9D0130DC  9202008A   LBU V0, 138(S0)
9D0130E0  00621825   OR V1, V1, V0
9D0130E4  9202008B   LBU V0, 139(S0)
9D0130E8  00021200   SLL V0, V0, 8
9D0130EC  00621825   OR V1, V1, V0
9D0130F0  7C63B800   EXT V1, V1, 0, 24
9D0130F4  3C02FFAB   LUI V0, -85
9D0130F8  3442BEBA   ORI V0, V0, -16710
9D0130FC  00621821   ADDU V1, V1, V0
9D013100  0003182B   SLTU V1, ZERO, V1
2106:                		return 0;
2107:                
2108:                	return 1;
2109:                }
9D013104  00601021   ADDU V0, V1, ZERO
2110:                
2111:                
2112:                
2113:                
2114:                /*-----------------------------------------------------------------------*/
2115:                /* Check if the file system object is valid or not                       */
2116:                /*-----------------------------------------------------------------------*/
2117:                
2118:                static
2119:                FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
2120:                	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
2121:                	FATFS **rfs,		/* Pointer to pointer to the found file system object */
2122:                	uint8_t wmode			/* !=0: Check write protection for write access */
2123:                )
2124:                {
9D005B78  27BDFFE0   ADDIU SP, SP, -32
9D005B7C  AFBF001C   SW RA, 28(SP)
9D005B80  AFB20018   SW S2, 24(SP)
9D005B84  AFB10014   SW S1, 20(SP)
9D005B88  AFB00010   SW S0, 16(SP)
2125:                	uint8_t fmt, b, pi, *tbl;
2126:                	uint32_t vol;
2127:                	DSTATUS stat;
2128:                	uint32_t bsect, fasize, tsect, sysect, nclst, szbfat;
2129:                	uint16_t nrsv;
2130:                	const TCHAR *p = *path;
9D005B8C  8C820000   LW V0, 0(A0)
2131:                	FATFS *fs;
2132:                
2133:                
2134:                	/* Get logical drive number from the path name */
2135:                	vol = p[0] - '0';					/* Is there a drive number? */
9D005B90  80430000   LB V1, 0(V0)
9D005B94  2463FFD0   ADDIU V1, V1, -48
2136:                	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
9D005B98  2C67000A   SLTIU A3, V1, 10
9D005B9C  10E00008   BEQ A3, ZERO, 0x9D005BC0
9D005BA0  00C08821   ADDU S1, A2, ZERO
9D005BA4  80470001   LB A3, 1(V0)
9D005BA8  2406003A   ADDIU A2, ZERO, 58
9D005BAC  54E60005   BNEL A3, A2, 0x9D005BC4
9D005BB0  93838054   LBU V1, -32684(GP)
2137:                		p += 2; *path = p;				/* Return pointer to the path name */
9D005BB4  24420002   ADDIU V0, V0, 2
9D005BB8  0B4016F1   J 0x9D005BC4
9D005BBC  AC820000   SW V0, 0(A0)
2138:                	} else {							/* No drive number, use default drive */
2139:                #if _FS_RPATH
2140:                		vol = CurrVol;					/* Use current drive */
9D005BC0  93838054   LBU V1, -32684(GP)
2141:                #else
2142:                		vol = 0;						/* Use drive 0 */
2143:                #endif
2144:                	}
2145:                
2146:                	/* Check if the file system object is valid or not */
2147:                	*rfs = 0;
9D005BC4  ACA00000   SW ZERO, 0(A1)
2148:                	if (vol >= SYS_FS_VOLUME_NUMBER) 				/* Is the drive number valid? */
9D005BC8  1460012D   BNE V1, ZERO, 0x9D006080
9D005BCC  2402000B   ADDIU V0, ZERO, 11
2149:                		return FR_INVALID_DRIVE;
2150:                	fs = FatFs[vol];					/* Get corresponding file system object */
9D005BD0  8F90805C   LW S0, -32676(GP)
2151:                	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
9D005BD4  1200012A   BEQ S0, ZERO, 0x9D006080
9D005BD8  2402000C   ADDIU V0, ZERO, 12
2152:                
2153:                	ENTER_FF(fs);						/* Lock volume */
2154:                
2155:                	*rfs = fs;							/* Return pointer to the corresponding file system object */
9D005BDC  ACB00000   SW S0, 0(A1)
2156:                	if (fs->fs_type) {					/* If the volume has been mounted */
9D005BE0  92020000   LBU V0, 0(S0)
9D005BE4  5040000D   BEQL V0, ZERO, 0x9D005C1C
9D005BE8  A2000000   SB ZERO, 0(S0)
2157:                		stat = disk_status(fs->drv);
9D005BEC  0F405CE8   JAL disk_status
9D005BF0  92040001   LBU A0, 1(S0)
9D005BF4  00401821   ADDU V1, V0, ZERO
2158:                		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
9D005BF8  30420001   ANDI V0, V0, 1
9D005BFC  54400007   BNEL V0, ZERO, 0x9D005C1C
9D005C00  A2000000   SB ZERO, 0(S0)
2159:                			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
9D005C04  1220011E   BEQ S1, ZERO, 0x9D006080
9D005C08  30630004   ANDI V1, V1, 4
9D005C0C  306300FF   ANDI V1, V1, 255
2160:                				return FR_WRITE_PROTECTED;
2161:                			return FR_OK;				/* The file system object is valid */
9D005C10  2402000A   ADDIU V0, ZERO, 10
9D005C14  0B401820   J 0x9D006080
9D005C18  0003100A   MOVZ V0, ZERO, V1
2162:                		}
2163:                	}
2164:                
2165:                	/* The file system object is not valid. */
2166:                	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
2167:                
2168:                	fs->fs_type = 0;					/* Clear the file system object */
2169:                	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
9D005C1C  938480B4   LBU A0, -32588(GP)
2170:                	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
9D005C20  0F405BD7   JAL disk_initialize
9D005C24  A2040001   SB A0, 1(S0)
9D005C28  00401821   ADDU V1, V0, ZERO
2171:                	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
9D005C2C  30440001   ANDI A0, V0, 1
9D005C30  14800113   BNE A0, ZERO, 0x9D006080
9D005C34  24020003   ADDIU V0, ZERO, 3
2172:                		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
2173:                	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
9D005C38  12200004   BEQ S1, ZERO, 0x9D005C4C
9D005C3C  30630004   ANDI V1, V1, 4
9D005C40  306300FF   ANDI V1, V1, 255
9D005C44  1460010E   BNE V1, ZERO, 0x9D006080
9D005C48  2402000A   ADDIU V0, ZERO, 10
2174:                		return FR_WRITE_PROTECTED;
2175:                #if FAT_FS_MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
2176:                	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
2177:                		return FR_DISK_ERR;
2178:                #endif
2179:                	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
2180:                	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
9D005C4C  02002021   ADDU A0, S0, ZERO
9D005C50  0F404C10   JAL check_fs
9D005C54  00002821   ADDU A1, ZERO, ZERO
9D005C58  00401821   ADDU V1, V0, ZERO
2181:                	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
9D005C5C  938280B5   LBU V0, -32587(GP)
9D005C60  104000FB   BEQ V0, ZERO, 0x9D006050
9D005C64  24040001   ADDIU A0, ZERO, 1
9D005C68  2C640002   SLTIU A0, V1, 2
9D005C6C  10800017   BEQ A0, ZERO, 0x9D005CCC
9D005C70  00008821   ADDU S1, ZERO, ZERO
2182:                	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
9D006050  1064FF0A   BEQ V1, A0, 0x9D005C7C
9D006054  00008821   ADDU S1, ZERO, ZERO
2183:                		/* Check the partition listed in the partition table */
2184:                		pi = LD2PT(vol);
2185:                		if (pi) pi--;
9D005C74  2442FFFF   ADDIU V0, V0, -1
9D005C78  304200FF   ANDI V0, V0, 255
2186:                		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
9D005C7C  00021100   SLL V0, V0, 4
9D005C80  244301F6   ADDIU V1, V0, 502
9D005C84  02031821   ADDU V1, S0, V1
2187:                		if (tbl[4]) {						/* Is the partition existing? */
9D005C88  90640004   LBU A0, 4(V1)
9D005C8C  108000FC   BEQ A0, ZERO, 0x9D006080
9D005C90  2402000D   ADDIU V0, ZERO, 13
2188:                			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
9D005C94  9071000B   LBU S1, 11(V1)
9D005C98  00118E00   SLL S1, S1, 24
9D005C9C  9062000A   LBU V0, 10(V1)
9D005CA0  00021400   SLL V0, V0, 16
9D005CA4  02228825   OR S1, S1, V0
9D005CA8  90620008   LBU V0, 8(V1)
9D005CAC  02228825   OR S1, S1, V0
9D005CB0  90620009   LBU V0, 9(V1)
9D005CB4  00021200   SLL V0, V0, 8
9D005CB8  02228825   OR S1, S1, V0
2189:                			fmt = check_fs(fs, bsect);		/* Check the partition */
9D005CBC  02002021   ADDU A0, S0, ZERO
9D005CC0  0F404C10   JAL check_fs
9D005CC4  02202821   ADDU A1, S1, ZERO
9D005CC8  00401821   ADDU V1, V0, ZERO
2190:                		}
2191:                	}
2192:                	if (fmt == 3) return FR_DISK_ERR;
9D005CCC  24020003   ADDIU V0, ZERO, 3
9D005CD0  506200EB   BEQL V1, V0, 0x9D006080
9D005CD4  24020001   ADDIU V0, ZERO, 1
9D006058  0B401734   J 0x9D005CD0
9D00605C  24020003   ADDIU V0, ZERO, 3
2193:                	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
9D005CD8  146000E9   BNE V1, ZERO, 0x9D006080
9D005CDC  2402000D   ADDIU V0, ZERO, 13
2194:                
2195:                	/* An FAT volume is found. Following code initializes the file system object */
2196:                
2197:                	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
9D005CE0  92040044   LBU A0, 68(S0)
9D005CE4  00042200   SLL A0, A0, 8
9D005CE8  92020043   LBU V0, 67(S0)
9D005CEC  00822025   OR A0, A0, V0
9D005CF0  7C042620   SEH A0, A0
9D005CF4  24030200   ADDIU V1, ZERO, 512
9D005CF8  148300E1   BNE A0, V1, 0x9D006080
9D005CFC  2402000D   ADDIU V0, ZERO, 13
2198:                		return FR_NO_FILESYSTEM;
2199:                
2200:                	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
9D005D00  9204004F   LBU A0, 79(S0)
9D005D04  00042200   SLL A0, A0, 8
9D005D08  9202004E   LBU V0, 78(S0)
9D005D0C  00822025   OR A0, A0, V0
2201:                	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
9D005D10  5480000C   BNEL A0, ZERO, 0x9D005D44
9D005D14  AE040020   SW A0, 32(S0)
9D005D18  9204005F   LBU A0, 95(S0)
9D005D1C  00042600   SLL A0, A0, 24
9D005D20  9202005E   LBU V0, 94(S0)
9D005D24  00021400   SLL V0, V0, 16
9D005D28  00822025   OR A0, A0, V0
9D005D2C  9202005C   LBU V0, 92(S0)
9D005D30  00822025   OR A0, A0, V0
9D005D34  9202005D   LBU V0, 93(S0)
9D005D38  00021200   SLL V0, V0, 8
9D005D3C  00822025   OR A0, A0, V0
2202:                	fs->fsize = fasize;
9D005D40  AE040020   SW A0, 32(S0)
2203:                
2204:                	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
9D005D44  92060048   LBU A2, 72(S0)
9D005D48  A2060003   SB A2, 3(S0)
2205:                	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
9D005D4C  24C3FFFF   ADDIU V1, A2, -1
9D005D50  306300FF   ANDI V1, V1, 255
9D005D54  2C630002   SLTIU V1, V1, 2
9D005D58  106000C9   BEQ V1, ZERO, 0x9D006080
9D005D5C  2402000D   ADDIU V0, ZERO, 13
2206:                	fasize *= b;										/* Number of sectors for FAT area */
9D005DF0  70864802   MUL T1, A0, A2
2207:                
2208:                	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
9D005D60  92030045   LBU V1, 69(S0)
2209:                	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
9D005D64  106000C6   BEQ V1, ZERO, 0x9D006080
9D005D68  A2030002   SB V1, 2(S0)
9D005D6C  2465FFFF   ADDIU A1, V1, -1
9D005D70  00A32824   AND A1, A1, V1
9D005D74  14A000C3   BNE A1, ZERO, 0x9D006084
9D005D78  8FBF001C   LW RA, 28(SP)
2210:                
2211:                	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
9D005D7C  9205004A   LBU A1, 74(S0)
9D005D80  00052A00   SLL A1, A1, 8
9D005D84  92020049   LBU V0, 73(S0)
9D005D88  00A22825   OR A1, A1, V0
9D005D8C  A6050008   SH A1, 8(S0)
2212:                	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
9D005D90  30A7000F   ANDI A3, A1, 15
9D005D94  14E000BA   BNE A3, ZERO, 0x9D006080
9D005D98  2402000D   ADDIU V0, ZERO, 13
2213:                
2214:                	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
9D005D9C  9208004C   LBU T0, 76(S0)
9D005DA0  00084200   SLL T0, T0, 8
9D005DA4  9202004B   LBU V0, 75(S0)
9D005DA8  01024025   OR T0, T0, V0
2215:                	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
9D005DAC  1500000B   BNE T0, ZERO, 0x9D005DDC
9D005DB0  92070047   LBU A3, 71(S0)
9D005DB4  9208005B   LBU T0, 91(S0)
9D005DB8  00084600   SLL T0, T0, 24
9D005DBC  9202005A   LBU V0, 90(S0)
9D005DC0  00021400   SLL V0, V0, 16
9D005DC4  01024025   OR T0, T0, V0
9D005DC8  92020058   LBU V0, 88(S0)
9D005DCC  01024025   OR T0, T0, V0
9D005DD0  92020059   LBU V0, 89(S0)
9D005DD4  00021200   SLL V0, V0, 8
9D005DD8  01024025   OR T0, T0, V0
2216:                
2217:                	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
9D005DDC  00073A00   SLL A3, A3, 8
9D005DE0  92020046   LBU V0, 70(S0)
9D005DE4  00E23825   OR A3, A3, V0
2218:                	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
9D005DE8  10E000A5   BEQ A3, ZERO, 0x9D006080
9D005DEC  2402000D   ADDIU V0, ZERO, 13
2219:                
2220:                	/* Determine the FAT sub type */
2221:                	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
9D005DF4  00053102   SRL A2, A1, 4
9D005DF8  00C73021   ADDU A2, A2, A3
9D005DFC  00C93021   ADDU A2, A2, T1
2222:                	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
9D005E00  0106502B   SLTU T2, T0, A2
9D005E04  1540009F   BNE T2, ZERO, 0x9D006084
9D005E08  8FBF001C   LW RA, 28(SP)
2223:                	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
9D005E0C  01064023   SUBU T0, T0, A2
9D005E10  0103001B   DIVU T0, V1
9D005E14  006001F4   TEQ V1, ZERO
9D005E18  00001812   MFLO V1
2224:                	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
9D005E1C  1060009A   BEQ V1, ZERO, 0x9D006088
9D005E20  8FB20018   LW S2, 24(SP)
2225:                	fmt = FS_FAT12;
9D005E28  24020001   ADDIU V0, ZERO, 1
9D005E2C  24080002   ADDIU T0, ZERO, 2
9D005E30  0112100A   MOVZ V0, T0, S2
9D005E34  00409021   ADDU S2, V0, ZERO
2226:                	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
9D005E24  2C720FF6   SLTIU S2, V1, 4086
2227:                	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
9D005E38  3402FFF6   ORI V0, ZERO, -10
9D005E3C  0062102B   SLTU V0, V1, V0
9D005E40  10400087   BEQ V0, ZERO, 0x9D006060
9D005E44  24630002   ADDIU V1, V1, 2
9D006078  0B40179A   J 0x9D005E68
9D00607C  24120003   ADDIU S2, ZERO, 3
2228:                
2229:                	/* Boundaries and Limits */
2230:                	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
9D005E48  AE03001C   SW V1, 28(S0)
9D006060  AE03001C   SW V1, 28(S0)
2231:                	fs->volbase = bsect;								/* Volume start sector */
9D005E4C  AE110024   SW S1, 36(S0)
9D006064  AE110024   SW S1, 36(S0)
2232:                	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
9D005E50  02273821   ADDU A3, S1, A3
9D005E54  AE070028   SW A3, 40(S0)
9D006068  02273821   ADDU A3, S1, A3
9D00606C  AE070028   SW A3, 40(S0)
2233:                	fs->database = bsect + sysect;						/* Data start sector */
9D005E58  00D13021   ADDU A2, A2, S1
9D006070  00D13021   ADDU A2, A2, S1
9D006074  AE060030   SW A2, 48(S0)
2234:                	if (fmt == FS_FAT32) {
9D005E5C  24020003   ADDIU V0, ZERO, 3
9D005E60  16420010   BNE S2, V0, 0x9D005EA4
9D005E64  AE060030   SW A2, 48(S0)
2235:                		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
9D005E68  14A00085   BNE A1, ZERO, 0x9D006080
9D005E6C  2402000D   ADDIU V0, ZERO, 13
2236:                		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
9D005E70  92050067   LBU A1, 103(S0)
9D005E74  00052E00   SLL A1, A1, 24
9D005E78  92020066   LBU V0, 102(S0)
9D005E7C  00021400   SLL V0, V0, 16
9D005E80  00A22825   OR A1, A1, V0
9D005E84  92020064   LBU V0, 100(S0)
9D005E88  00A22825   OR A1, A1, V0
9D005E8C  92020065   LBU V0, 101(S0)
9D005E90  00021200   SLL V0, V0, 8
9D005E94  00A21025   OR V0, A1, V0
9D005E98  AE02002C   SW V0, 44(S0)
9D005E9C  0B4017B6   J 0x9D005ED8
9D005EA0  00031880   SLL V1, V1, 2
2237:                		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
2238:                	} else {
2239:                		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
9D005EA4  10A00076   BEQ A1, ZERO, 0x9D006080
9D005EA8  2402000D   ADDIU V0, ZERO, 13
2240:                		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
9D005EAC  01273821   ADDU A3, T1, A3
2241:                		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
2242:                			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
9D005EB0  24020002   ADDIU V0, ZERO, 2
9D005EB4  16420003   BNE S2, V0, 0x9D005EC4
9D005EB8  AE07002C   SW A3, 44(S0)
9D005EBC  0B4017B6   J 0x9D005ED8
9D005EC0  00031840   SLL V1, V1, 1
9D005EC4  24020003   ADDIU V0, ZERO, 3
9D005EC8  70621002   MUL V0, V1, V0
9D005ECC  00021042   SRL V0, V0, 1
9D005ED0  30630001   ANDI V1, V1, 1
9D005ED4  00431821   ADDU V1, V0, V1
2243:                	}
2244:                	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
9D005ED8  246201FF   ADDIU V0, V1, 511
9D005EDC  00021242   SRL V0, V0, 9
9D005EE0  0082202B   SLTU A0, A0, V0
9D005EE4  14800066   BNE A0, ZERO, 0x9D006080
9D005EE8  2402000D   ADDIU V0, ZERO, 13
2245:                		return FR_NO_FILESYSTEM;
2246:                
2247:                #if !_FS_READONLY
2248:                	/* Initialize cluster allocation information */
2249:                	fs->free_clust = 0xFFFFFFFF;
9D005EEC  2402FFFF   ADDIU V0, ZERO, -1
9D005EF0  AE020010   SW V0, 16(S0)
2250:                	fs->last_clust = 0;
2251:                
2252:                	/* Get fsinfo if available */
2253:                	if (fmt == FS_FAT32) {
9D005EF4  24020003   ADDIU V0, ZERO, 3
9D005EF8  16420048   BNE S2, V0, 0x9D00601C
9D005EFC  AE00000C   SW ZERO, 12(S0)
2254:                	 	fs->fsi_flag = 0;
9D005F00  A2000005   SB ZERO, 5(S0)
2255:                		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
9D005F04  92060069   LBU A2, 105(S0)
9D005F08  00063200   SLL A2, A2, 8
9D005F0C  92020068   LBU V0, 104(S0)
9D005F10  00C23025   OR A2, A2, V0
9D005F14  02263021   ADDU A2, S1, A2
9D005F18  AE060014   SW A2, 20(S0)
2256:                		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
9D005F1C  92040001   LBU A0, 1(S0)
9D005F20  26050038   ADDIU A1, S0, 56
9D005F24  0F40561B   JAL disk_read
9D005F28  24070001   ADDIU A3, ZERO, 1
9D005F2C  5440003C   BNEL V0, ZERO, 0x9D006020
9D005F30  A2120000   SB S2, 0(S0)
9D005F44  7C031E20   SEH V1, V1
9D005F48  2402AA55   ADDIU V0, ZERO, -21931
9D005F4C  54620034   BNEL V1, V0, 0x9D006020
9D005F50  A2120000   SB S2, 0(S0)
2257:                			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
9D005F34  92030237   LBU V1, 567(S0)
9D005F38  00031A00   SLL V1, V1, 8
9D005F3C  92020236   LBU V0, 566(S0)
9D005F40  00621825   OR V1, V1, V0
9D005F7C  3C024161   LUI V0, 16737
9D005F80  24425252   ADDIU V0, V0, 21074
9D005F84  54620026   BNEL V1, V0, 0x9D006020
9D005F88  A2120000   SB S2, 0(S0)
2258:                			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
9D005F54  9203003B   LBU V1, 59(S0)
9D005F58  00031E00   SLL V1, V1, 24
9D005F5C  9202003A   LBU V0, 58(S0)
9D005F60  00021400   SLL V0, V0, 16
9D005F64  00621825   OR V1, V1, V0
9D005F68  92020038   LBU V0, 56(S0)
9D005F6C  00621825   OR V1, V1, V0
9D005F70  92020039   LBU V0, 57(S0)
9D005F74  00021200   SLL V0, V0, 8
9D005F78  00621825   OR V1, V1, V0
9D005FB4  3C026141   LUI V0, 24897
9D005FB8  24427272   ADDIU V0, V0, 29298
9D005FBC  54620018   BNEL V1, V0, 0x9D006020
9D005FC0  A2120000   SB S2, 0(S0)
2259:                			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
9D005F8C  9203021F   LBU V1, 543(S0)
9D005F90  00031E00   SLL V1, V1, 24
9D005F94  9202021E   LBU V0, 542(S0)
9D005F98  00021400   SLL V0, V0, 16
9D005F9C  00621825   OR V1, V1, V0
9D005FA0  9202021C   LBU V0, 540(S0)
9D005FA4  00621825   OR V1, V1, V0
9D005FA8  9202021D   LBU V0, 541(S0)
9D005FAC  00021200   SLL V0, V0, 8
9D005FB0  00621825   OR V1, V1, V0
2260:                				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
9D005FC4  92030227   LBU V1, 551(S0)
9D005FC8  00031E00   SLL V1, V1, 24
9D005FCC  92020226   LBU V0, 550(S0)
9D005FD0  00021400   SLL V0, V0, 16
9D005FD4  00621825   OR V1, V1, V0
9D005FD8  92020224   LBU V0, 548(S0)
9D005FDC  00621825   OR V1, V1, V0
9D005FE0  92020225   LBU V0, 549(S0)
9D005FE4  00021200   SLL V0, V0, 8
9D005FE8  00621025   OR V0, V1, V0
9D005FEC  AE02000C   SW V0, 12(S0)
2261:                				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
9D005FF0  92030223   LBU V1, 547(S0)
9D005FF4  00031E00   SLL V1, V1, 24
9D005FF8  92020222   LBU V0, 546(S0)
9D005FFC  00021400   SLL V0, V0, 16
9D006000  00621825   OR V1, V1, V0
9D006004  92020220   LBU V0, 544(S0)
9D006008  00621825   OR V1, V1, V0
9D00600C  92020221   LBU V0, 545(S0)
9D006010  00021200   SLL V0, V0, 8
9D006014  00621025   OR V0, V1, V0
9D006018  AE020010   SW V0, 16(S0)
2262:                		}
2263:                	}
2264:                #endif
2265:                	fs->fs_type = fmt;		/* FAT sub-type */
9D00601C  A2120000   SB S2, 0(S0)
2266:                	fs->id = ++Fsid;		/* File system mount ID */
9D006020  97828056   LHU V0, -32682(GP)
9D006024  24420001   ADDIU V0, V0, 1
9D006028  3042FFFF   ANDI V0, V0, -1
9D00602C  A7828056   SH V0, -32682(GP)
9D006030  A6020006   SH V0, 6(S0)
2267:                	fs->winsect = 0;		/* Invalidate sector cache */
9D006034  AE000034   SW ZERO, 52(S0)
2268:                	fs->wflag = 0;
9D006038  A2000004   SB ZERO, 4(S0)
2269:                #if _FS_RPATH
2270:                	fs->cdir = 0;			/* Current directory (root dir) */
9D00603C  AE000018   SW ZERO, 24(S0)
2271:                #endif
2272:                #if _FS_LOCK				/* Clear file lock semaphores */
2273:                	clear_lock(fs);
9D006040  0F405C37   JAL clear_lock
9D006044  02002021   ADDU A0, S0, ZERO
2274:                #endif
2275:                
2276:                	return FR_OK;
9D006048  0B401820   J 0x9D006080
9D00604C  00001021   ADDU V0, ZERO, ZERO
2277:                }
9D006080  8FBF001C   LW RA, 28(SP)
2278:                
2279:                
2280:                
2281:                
2282:                /*-----------------------------------------------------------------------*/
2283:                /* Check if the file/dir object is valid or not                          */
2284:                /*-----------------------------------------------------------------------*/
2285:                
2286:                static
2287:                FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
2288:                	void* obj		/* Pointer to the object FIL/DIR to check validity */
2289:                )
2290:                {
9D015918  27BDFFE8   ADDIU SP, SP, -24
9D01591C  AFBF0014   SW RA, 20(SP)
2291:                	FIL *fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
2292:                
2293:                
2294:                	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
9D0158E8  10800014   BEQ A0, ZERO, 0x9D01593C
9D0158EC  00000000   NOP
9D0158F0  8C830000   LW V1, 0(A0)
9D0158F4  10600013   BEQ V1, ZERO, 0x9D015944
9D0158F8  00000000   NOP
9D0158FC  90650000   LBU A1, 0(V1)
9D015900  10A00014   BEQ A1, ZERO, 0x9D015954
9D015904  24020009   ADDIU V0, ZERO, 9
9D015908  94650006   LHU A1, 6(V1)
9D01590C  94840004   LHU A0, 4(A0)
9D015910  14A40010   BNE A1, A0, 0x9D015954
9D015914  00000000   NOP
2295:                		return FR_INVALID_OBJECT;
9D01593C  03E00008   JR RA
9D015940  24020009   ADDIU V0, ZERO, 9
9D015944  03E00008   JR RA
9D015948  24020009   ADDIU V0, ZERO, 9
2296:                
2297:                	ENTER_FF(fil->fs);		/* Lock file system */
2298:                
2299:                	if (disk_status(fil->fs->drv) & STA_NOINIT)
9D015920  0F405CE8   JAL disk_status
9D015924  90640001   LBU A0, 1(V1)
9D015928  30420001   ANDI V0, V0, 1
2300:                		return FR_NOT_READY;
9D01592C  24030003   ADDIU V1, ZERO, 3
9D015930  0002180A   MOVZ V1, ZERO, V0
9D015934  0B405653   J 0x9D01594C
9D015938  00601021   ADDU V0, V1, ZERO
2301:                
2302:                	return FR_OK;
2303:                }
9D01594C  8FBF0014   LW RA, 20(SP)
2304:                
2305:                
2306:                
2307:                
2308:                /*--------------------------------------------------------------------------
2309:                
2310:                   Public Functions
2311:                
2312:                --------------------------------------------------------------------------*/
2313:                
2314:                
2315:                
2316:                /*-----------------------------------------------------------------------*/
2317:                /* Mount a Logical Drive                                                 */
2318:                /*-----------------------------------------------------------------------*/
2319:                
2320:                int f_mount (
2321:                	uint8_t vol		/* Logical drive number to be mounted */
2322:                )
2323:                {
9D014D78  27BDFFE8   ADDIU SP, SP, -24
9D014D7C  AFBF0014   SW RA, 20(SP)
9D014D80  AFB00010   SW S0, 16(SP)
2324:                	FATFS *rfs;
2325:                        FATFS *fs = (FATFS *)0;
2326:                        uint8_t index = 0;
2327:                
2328:                        if(0 == startupflag)
9D014D84  93828058   LBU V0, -32680(GP)
9D014D88  14400007   BNE V0, ZERO, 0x9D014DA8
9D014D8C  308400FF   ANDI A0, A0, 255
2329:                        {
2330:                            startupflag = 1;
9D014D90  24020001   ADDIU V0, ZERO, 1
9D014D94  A3828058   SB V0, -32680(GP)
2331:                            for(index = 0; index != SYS_FS_VOLUME_NUMBER ; index++ )
2332:                            {
2333:                                FAFFSVolume[index].inUse = false;
9D014D98  3C02A001   LUI V0, -24575
9D014D9C  A04041F0   SB ZERO, 16880(V0)
2334:                            }
2335:                            for(index = 0; index != SYS_FS_MAX_FILES ; index++ )
2336:                            {
2337:                                FATFSFileObject[index].inUse = false;
9D014DA0  3C02A001   LUI V0, -24575
9D014DA4  A0404670   SB ZERO, 18032(V0)
2338:                            }
2339:                        }
2340:                
2341:                	if (vol >= SYS_FS_VOLUME_NUMBER)		/* Check if the drive number is valid */
9D014DA8  14800013   BNE A0, ZERO, 0x9D014DF8
9D014DAC  2402000B   ADDIU V0, ZERO, 11
2342:                		return FR_INVALID_DRIVE;
2343:                
2344:                        /* If the volume specified is already in use, then return failure, as we cannot mount it again */
2345:                        if(FAFFSVolume[vol].inUse == 1)
9D014DB0  3C02A001   LUI V0, -24575
9D014DB4  904441F0   LBU A0, 16880(V0)
9D014DB8  24030001   ADDIU V1, ZERO, 1
9D014DBC  1083000E   BEQ A0, V1, 0x9D014DF8
9D014DC0  2402000B   ADDIU V0, ZERO, 11
2346:                        {
2347:                            return FR_INVALID_DRIVE;
2348:                        }
2349:                        else
2350:                        {
2351:                            FAFFSVolume[vol].inUse = 1;  // take the volume
9D014DC4  3C02A001   LUI V0, -24575
9D014DC8  A04341F0   SB V1, 16880(V0)
2352:                            fs = &FAFFSVolume[vol].volObj;
2353:                        }
2354:                
2355:                        /* Get current fs object */
2356:                	rfs = FatFs[vol];			
9D014DCC  8F90805C   LW S0, -32676(GP)
2357:                
2358:                	if (rfs) {
9D014DD0  12000005   BEQ S0, ZERO, 0x9D014DE8
9D014DD4  3C02A001   LUI V0, -24575
2359:                #if _FS_LOCK
2360:                		clear_lock(rfs);
9D014DD8  0F405C37   JAL clear_lock
9D014DDC  02002021   ADDU A0, S0, ZERO
2361:                #endif
2362:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2363:                		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2364:                #endif
2365:                		rfs->fs_type = 0;		/* Clear old fs object */
9D014DE0  A2000000   SB ZERO, 0(S0)
2366:                	}
2367:                
2368:                	if (fs) {
2369:                		fs->fs_type = 0;		/* Clear new fs object */
9D014DE4  3C02A001   LUI V0, -24575
9D014DE8  A04041F4   SB ZERO, 16884(V0)
2370:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2371:                		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2372:                #endif
2373:                	}
2374:                	FatFs[vol] = fs;			/* Register new fs object */
9D014DEC  244241F4   ADDIU V0, V0, 16884
9D014DF0  AF82805C   SW V0, -32676(GP)
2375:                
2376:                	return FR_OK;
9D014DF4  00001021   ADDU V0, ZERO, ZERO
2377:                }
9D014DF8  8FBF0014   LW RA, 20(SP)
2378:                
2379:                /*-----------------------------------------------------------------------*/
2380:                /* Unmount a Logical Drive                                                 */
2381:                /*-----------------------------------------------------------------------*/
2382:                
2383:                int f_unmount (
2384:                	uint8_t vol		/* Logical drive number to be unmounted */
2385:                )
2386:                {
9D013958  308400FF   ANDI A0, A0, 255
9D013978  27BDFFE8   ADDIU SP, SP, -24
9D01397C  AFBF0014   SW RA, 20(SP)
9D013980  AFB00010   SW S0, 16(SP)
2387:                	FATFS *rfs;
2388:                    uint32_t hFATfs =0;
2389:                        FATFS *fs = (FATFS *)0;
2390:                
2391:                
2392:                	if (vol >= SYS_FS_VOLUME_NUMBER)		/* Check if the drive number is valid */
9D01395C  1480002E   BNE A0, ZERO, 0x9D013A18
9D013960  2402000B   ADDIU V0, ZERO, 11
2393:                		return FR_INVALID_DRIVE;
2394:                
2395:                        /* If the volume specified not in use, then return failure, as we cannot unmount mount a free volume */
2396:                        if(FAFFSVolume[vol].inUse != 1)
9D013964  3C02A001   LUI V0, -24575
9D013968  904441F0   LBU A0, 16880(V0)
9D01396C  24030001   ADDIU V1, ZERO, 1
9D013970  14830029   BNE A0, V1, 0x9D013A18
9D013974  2402000B   ADDIU V0, ZERO, 11
2397:                        {
2398:                            return FR_INVALID_DRIVE;
2399:                        }
2400:                        else
2401:                        {
2402:                            FAFFSVolume[vol].inUse = 0;  // free the volume
9D013984  3C02A001   LUI V0, -24575
9D013988  A04041F0   SB ZERO, 16880(V0)
2403:                        }
2404:                
2405:                	rfs = FatFs[vol];			/* Get current fs object */
9D01398C  8F90805C   LW S0, -32676(GP)
2406:                	if (rfs) {
9D013990  5200001D   BEQL S0, ZERO, 0x9D013A08
9D013994  AF80805C   SW ZERO, -32676(GP)
2407:                #if _FS_LOCK
2408:                		clear_lock(rfs);
9D013998  0F405C37   JAL clear_lock
9D01399C  02002021   ADDU A0, S0, ZERO
2409:                    for(hFATfs = 0; hFATfs < SYS_FS_MAX_FILES; hFATfs++)
2410:                    {
2411:                        if(FATFSFileObject[hFATfs].inUse)
9D0139A0  3C02A001   LUI V0, -24575
9D0139A4  90424670   LBU V0, 18032(V0)
9D0139A8  1040000A   BEQ V0, ZERO, 0x9D0139D4
9D0139AC  3C028001   LUI V0, -32767
2412:                        {
2413:                            if(LD2PD(vol) == FATFSFileObject[hFATfs].fileObj.fs->drv)
9D0139B0  3C02A001   LUI V0, -24575
9D0139B4  8C424674   LW V0, 18036(V0)
9D0139B8  938380B4   LBU V1, -32588(GP)
9D0139BC  90420001   LBU V0, 1(V0)
9D0139C0  14620004   BNE V1, V0, 0x9D0139D4
9D0139C4  3C028001   LUI V0, -32767
2414:                            {
2415:                                FATFSFileObject[hFATfs].inUse = 0;
9D0139C8  3C02A001   LUI V0, -24575
9D0139CC  A0404670   SB ZERO, 18032(V0)
2416:                            }
2417:                        }
2418:                        if(FATFSDirObject[hFATfs].inUse)
9D0139D0  3C028001   LUI V0, -32767
9D0139D4  9042463C   LBU V0, 17980(V0)
9D0139D8  5040000A   BEQL V0, ZERO, 0x9D013A04
9D0139DC  A2000000   SB ZERO, 0(S0)
2419:                        {
2420:                            if(LD2PD(vol) == FATFSDirObject[hFATfs].dirObj.fs->drv)
9D0139E0  3C028001   LUI V0, -32767
9D0139E4  8C424640   LW V0, 17984(V0)
9D0139E8  938380B4   LBU V1, -32588(GP)
9D0139EC  90420001   LBU V0, 1(V0)
9D0139F0  54620004   BNEL V1, V0, 0x9D013A04
9D0139F4  A2000000   SB ZERO, 0(S0)
2421:                            {
2422:                                FATFSDirObject[hFATfs].inUse = 0;
9D0139F8  3C028001   LUI V0, -32767
9D0139FC  A040463C   SB ZERO, 17980(V0)
2423:                            }            
2424:                        }
2425:                    }
2426:                        
2427:                #endif
2428:                #if _FS_REENTRANT				/* Discard sync object of the current volume */
2429:                		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
2430:                #endif
2431:                		rfs->fs_type = 0;		/* Clear old fs object */
9D013A00  A2000000   SB ZERO, 0(S0)
2432:                	}
2433:                
2434:                	if (fs) {
2435:                		fs->fs_type = 0;		/* Clear new fs object */
2436:                #if _FS_REENTRANT				/* Create sync object for the new volume */
2437:                		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
2438:                #endif
2439:                	}
2440:                	FatFs[vol] = fs;			/* Register new fs object */
9D013A04  AF80805C   SW ZERO, -32676(GP)
2441:                    
2442:                	return FR_OK;
9D013A08  00001021   ADDU V0, ZERO, ZERO
2443:                }
9D013A0C  8FBF0014   LW RA, 20(SP)
2444:                
2445:                
2446:                
2447:                /*-----------------------------------------------------------------------*/
2448:                /* Open or Create a File                                                 */
2449:                /*-----------------------------------------------------------------------*/
2450:                
2451:                int f_open (
2452:                	uintptr_t handle,			/* Pointer to the blank file object */
2453:                	const char *path,	/* Pointer to the file name */
2454:                	uint8_t mode			/* Access mode and file open mode flags */
2455:                )
2456:                {
9D007AE4  27BDFFA0   ADDIU SP, SP, -96
9D007AE8  AFBF005C   SW RA, 92(SP)
9D007AEC  AFB50058   SW S5, 88(SP)
9D007AF0  AFB40054   SW S4, 84(SP)
9D007AF4  AFB30050   SW S3, 80(SP)
9D007AF8  AFB2004C   SW S2, 76(SP)
9D007AFC  AFB10048   SW S1, 72(SP)
9D007B00  AFB00044   SW S0, 68(SP)
9D007B04  AFA50064   SW A1, 100(SP)
9D007B08  30D000FF   ANDI S0, A2, 255
2457:                	FRESULT res = FR_OK;
2458:                	DIR dj = {};
9D007B0C  AFA00010   SW ZERO, 16(SP)
9D007B10  AFA00014   SW ZERO, 20(SP)
9D007B14  AFA00018   SW ZERO, 24(SP)
9D007B18  AFA0001C   SW ZERO, 28(SP)
9D007B1C  AFA00020   SW ZERO, 32(SP)
9D007B20  AFA00024   SW ZERO, 36(SP)
9D007B24  AFA00028   SW ZERO, 40(SP)
9D007B28  AFA0002C   SW ZERO, 44(SP)
9D007B2C  AFA00030   SW ZERO, 48(SP)
2459:                	uint8_t *dir = NULL;
2460:                	DEF_NAMEBUF;
2461:                        uint32_t hFATfs = 0;
2462:                
2463:                        FIL *fp;
2464:                
2465:                
2466:                        for(hFATfs = 0; hFATfs < SYS_FS_MAX_FILES; hFATfs++)
2467:                        {
2468:                            if(FATFSFileObject[hFATfs].inUse == 0)
9D007B30  3C02A001   LUI V0, -24575
9D007B34  90434670   LBU V1, 18032(V0)
9D007B38  146000CD   BNE V1, ZERO, 0x9D007E70
9D007B3C  24020009   ADDIU V0, ZERO, 9
2469:                            {
2470:                                FATFSFileObject[hFATfs].inUse = 1;
9D007B40  3C02A001   LUI V0, -24575
9D007B44  24030001   ADDIU V1, ZERO, 1
9D007B48  A0434670   SB V1, 18032(V0)
2471:                                fp = &FATFSFileObject[hFATfs].fileObj;
2472:                                *(uintptr_t *)handle = (uintptr_t)&FATFSFileObject[hFATfs];
9D007B4C  24424670   ADDIU V0, V0, 18032
9D007B50  AC820000   SW V0, 0(A0)
2473:                                break;
2474:                            }
2475:                        }
2476:                        
2477:                        if(hFATfs >= SYS_FS_MAX_FILES)
2478:                        {
2479:                            return FR_INVALID_OBJECT;
2480:                        }
2481:                        
2482:                	if (!fp) return FR_INVALID_OBJECT;
2483:                
2484:                	fp->fs = 0;			/* Clear file object */
9D007B54  AC400004   SW ZERO, 4(V0)
2485:                
2486:                #if !_FS_READONLY
2487:                	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
9D007B58  3213001F   ANDI S3, S0, 31
2488:                	res = chk_mounted(&path, &dj.fs, (uint8_t)(mode & ~FA_READ));
9D007B5C  27A40064   ADDIU A0, SP, 100
9D007B60  27A50010   ADDIU A1, SP, 16
9D007B64  0F4016DE   JAL chk_mounted
9D007B68  3206001E   ANDI A2, S0, 30
2489:                #else
2490:                	mode &= FA_READ;
2491:                	res = chk_mounted(&path, &dj.fs, 0);
2492:                #endif
2493:                	if (res == FR_OK) {
9D007B6C  144000B7   BNE V0, ZERO, 0x9D007E4C
9D007B70  00408821   ADDU S1, V0, ZERO
2494:                		INIT_BUF(dj);
9D007B74  27A20034   ADDIU V0, SP, 52
9D007B78  AFA20028   SW V0, 40(SP)
9D007B7C  3C028001   LUI V0, -32767
9D007B80  24424430   ADDIU V0, V0, 17456
9D007B84  AFA2002C   SW V0, 44(SP)
2495:                		res = follow_path(&dj, path);	/* Follow the file path */
9D007B88  27A40010   ADDIU A0, SP, 16
9D007B8C  0F4010FC   JAL follow_path
9D007B90  8FA50064   LW A1, 100(SP)
2496:                		dir = dj.dir;
2497:                #if !_FS_READONLY	/* R/W configuration */
2498:                		if (res == FR_OK) {
9D007B94  144000A6   BNE V0, ZERO, 0x9D007E30
9D007B98  8FB20024   LW S2, 36(SP)
2499:                			if (!dir)	/* Current dir itself */
9D007B9C  124000A3   BEQ S2, ZERO, 0x9D007E2C
9D007BA0  3265001E   ANDI A1, S3, 30
2500:                				res = FR_INVALID_NAME;
9D007E2C  24020006   ADDIU V0, ZERO, 6
2501:                #if _FS_LOCK
2502:                			else
2503:                				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
9D007BA4  27A40010   ADDIU A0, SP, 16
9D007BA8  0F405315   JAL chk_lock
9D007BAC  0005282B   SLTU A1, ZERO, A1
9D007E58  0B401F93   J 0x9D007E4C
9D007E5C  00408821   ADDU S1, V0, ZERO
2504:                #endif
2505:                		}
2506:                		/* Create or Open a file */
2507:                		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
9D007BB0  3203001C   ANDI V1, S0, 28
9D007BB4  10600043   BEQ V1, ZERO, 0x9D007CC4
9D007BB8  00000000   NOP
9D007E30  3203001C   ANDI V1, S0, 28
9D007E34  1460FF61   BNE V1, ZERO, 0x9D007BBC
9D007E38  00000000   NOP
9D007E3C  0B401F41   J 0x9D007D04
9D007E40  00000000   NOP
2508:                			uint32_t dw, cl;
2509:                
2510:                			if (res != FR_OK) {					/* No file, create new */
9D007BBC  5040000F   BEQL V0, ZERO, 0x9D007BFC
9D007BC0  9242000B   LBU V0, 11(S2)
2511:                				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
9D007BC4  24030004   ADDIU V1, ZERO, 4
9D007BC8  544300A0   BNEL V0, V1, 0x9D007E4C
9D007BCC  00408821   ADDU S1, V0, ZERO
2512:                #if _FS_LOCK
2513:                					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
9D007BE0  0F40230B   JAL dir_register
9D007BE4  27A40010   ADDIU A0, SP, 16
9D007BF4  0B401F93   J 0x9D007E4C
9D007BF8  00408821   ADDU S1, V0, ZERO
2514:                #else
2515:                					res = dir_register(&dj);
2516:                #endif
2517:                				mode |= FA_CREATE_ALWAYS;		/* File is created */
9D007BE8  36730008   ORI S3, S3, 8
2518:                				dir = dj.dir;					/* New entry */
2519:                			}
2520:                			else {								/* Any object is already existing */
2521:                				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
9D007BFC  30420011   ANDI V0, V0, 17
9D007C00  54400092   BNEL V0, ZERO, 0x9D007E4C
9D007C04  24110007   ADDIU S1, ZERO, 7
2522:                					res = FR_DENIED;
2523:                				} else {
2524:                					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
9D007C08  32020004   ANDI V0, S0, 4
9D007C0C  304200FF   ANDI V0, V0, 255
9D007C10  5440008E   BNEL V0, ZERO, 0x9D007E4C
9D007C14  24110008   ADDIU S1, ZERO, 8
2525:                						res = FR_EXIST;
2526:                				}
2527:                			}
2528:                			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
9D007BEC  1040000A   BEQ V0, ZERO, 0x9D007C18
9D007BF0  8FB20024   LW S2, 36(SP)
9D007C18  32620008   ANDI V0, S3, 8
9D007C1C  304200FF   ANDI V0, V0, 255
9D007C20  1040003B   BEQ V0, ZERO, 0x9D007D10
9D007C24  32630008   ANDI V1, S3, 8
2529:                				dw = get_fattime();					/* Created time */
9D007C28  0F405C45   JAL get_fattime
9D007C2C  00000000   NOP
2530:                				ST_DWORD(dir+DIR_CrtTime, dw);
9D007C30  A242000E   SB V0, 14(S2)
9D007C34  7C433A00   EXT V1, V0, 8, 8
9D007C38  A243000F   SB V1, 15(S2)
9D007C3C  00021C02   SRL V1, V0, 16
9D007C40  A2430010   SB V1, 16(S2)
9D007C44  00021602   SRL V0, V0, 24
9D007C48  A2420011   SB V0, 17(S2)
2531:                				dir[DIR_Attr] = 0;					/* Reset attribute */
9D007C4C  A240000B   SB ZERO, 11(S2)
2532:                				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
9D007C50  A240001C   SB ZERO, 28(S2)
9D007C54  A240001D   SB ZERO, 29(S2)
9D007C58  A240001E   SB ZERO, 30(S2)
9D007C5C  A240001F   SB ZERO, 31(S2)
2533:                				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
9D007C60  8FB00010   LW S0, 16(SP)
9D007C64  02002021   ADDU A0, S0, ZERO
9D007C68  0F4059DD   JAL ld_clust
9D007C6C  02402821   ADDU A1, S2, ZERO
9D007C70  0040A021   ADDU S4, V0, ZERO
2534:                				st_clust(dir, 0);					/* cluster = 0 */
2535:                				dj.fs->wflag = 1;
9D007C84  24020001   ADDIU V0, ZERO, 1
2536:                				if (cl) {							/* Remove the cluster chain if exist */
9D007C88  12800020   BEQ S4, ZERO, 0x9D007D0C
9D007C8C  A2020004   SB V0, 4(S0)
2537:                					dw = dj.fs->winsect;
9D007C90  8E150034   LW S5, 52(S0)
2538:                					res = remove_chain(dj.fs, cl);
9D007C94  02002021   ADDU A0, S0, ZERO
9D007C98  0F404B32   JAL remove_chain
9D007C9C  02802821   ADDU A1, S4, ZERO
2539:                					if (res == FR_OK) {
9D007CA0  5440006A   BNEL V0, ZERO, 0x9D007E4C
9D007CA4  00408821   ADDU S1, V0, ZERO
2540:                						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
9D007CA8  8FA40010   LW A0, 16(SP)
9D007CAC  2694FFFF   ADDIU S4, S4, -1
9D007CB0  AC94000C   SW S4, 12(A0)
2541:                						res = move_window(dj.fs, dw);
9D007CB4  0F405691   JAL move_window
9D007CB8  02A02821   ADDU A1, S5, ZERO
9D007CBC  0B401F41   J 0x9D007D04
9D007CC0  00000000   NOP
2542:                					}
2543:                				}
2544:                			}
2545:                		}
2546:                		else {	/* Open an existing file */
2547:                			if (res == FR_OK) {						/* Follow succeeded */
9D007CC4  54400061   BNEL V0, ZERO, 0x9D007E4C
9D007CC8  00408821   ADDU S1, V0, ZERO
2548:                				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
9D007CCC  9242000B   LBU V0, 11(S2)
9D007CD0  30430010   ANDI V1, V0, 16
9D007CD4  306300FF   ANDI V1, V1, 255
9D007CD8  5460005C   BNEL V1, ZERO, 0x9D007E4C
9D007CDC  24110004   ADDIU S1, ZERO, 4
2549:                					res = FR_NO_FILE;
2550:                				} else {
2551:                					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
9D007CE0  32030002   ANDI V1, S0, 2
9D007CE4  306300FF   ANDI V1, V1, 255
9D007CE8  10600009   BEQ V1, ZERO, 0x9D007D10
9D007CEC  32630008   ANDI V1, S3, 8
9D007CF0  30420001   ANDI V0, V0, 1
9D007CF4  54400055   BNEL V0, ZERO, 0x9D007E4C
9D007CF8  24110007   ADDIU S1, ZERO, 7
9D007CFC  0B401F45   J 0x9D007D14
9D007D00  306300FF   ANDI V1, V1, 255
2552:                						res = FR_DENIED;
2553:                				}
2554:                			}
2555:                		}
2556:                		if (res == FR_OK) {
9D007D04  54400051   BNEL V0, ZERO, 0x9D007E4C
9D007D08  00408821   ADDU S1, V0, ZERO
2557:                			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
9D007D0C  32630008   ANDI V1, S3, 8
9D007D10  306300FF   ANDI V1, V1, 255
2558:                				mode |= FA__WRITTEN;
9D007D14  36620020   ORI V0, S3, 32
9D007D18  0043980B   MOVN S3, V0, V1
2559:                			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
9D007D1C  8FA20010   LW V0, 16(SP)
9D007D20  3C03A001   LUI V1, -24575
9D007D24  24634670   ADDIU V1, V1, 18032
9D007D28  8C440034   LW A0, 52(V0)
9D007D2C  AC640020   SW A0, 32(V1)
2560:                			fp->dir_ptr = dir;
9D007D30  AC720024   SW S2, 36(V1)
2561:                #if _FS_LOCK
2562:                			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
9D007DA0  0B401F91   J 0x9D007E44
9D007DA4  3C02A001   LUI V0, -24575
9D007DBC  3C10A001   LUI S0, -24575
9D007DC0  26104670   ADDIU S0, S0, 18032
9D007DC4  24020001   ADDIU V0, ZERO, 1
9D007DC8  AE020028   SW V0, 40(S0)
9D007E44  AC404698   SW ZERO, 18072(V0)
9D007E48  24110002   ADDIU S1, ZERO, 2
2563:                			if (!fp->lockid) res = FR_INT_ERR;
2564:                #endif
2565:                		}
2566:                
2567:                #else				/* R/O configuration */
2568:                		if (res == FR_OK) {					/* Follow succeeded */
2569:                			dir = dj.dir;
2570:                			if (!dir) {						/* Current dir itself */
2571:                				res = FR_INVALID_NAME;
2572:                			} else {
2573:                				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
2574:                					res = FR_NO_FILE;
2575:                			}
2576:                		}
2577:                #endif
2578:                		FREE_BUF();
2579:                
2580:                		if (res == FR_OK) {
2581:                			fp->flag = mode;					/* File access mode */
9D007DCC  A213000A   SB S3, 10(S0)
2582:                			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
9D007DD0  8FB30010   LW S3, 16(SP)
9D007DD4  02602021   ADDU A0, S3, ZERO
9D007DD8  0F4059DD   JAL ld_clust
9D007DDC  02402821   ADDU A1, S2, ZERO
9D007DE0  AE020014   SW V0, 20(S0)
2583:                			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
9D007DE4  9243001F   LBU V1, 31(S2)
9D007DE8  00031E00   SLL V1, V1, 24
9D007DEC  9242001E   LBU V0, 30(S2)
9D007DF0  00021400   SLL V0, V0, 16
9D007DF4  00621825   OR V1, V1, V0
9D007DF8  9242001C   LBU V0, 28(S2)
9D007DFC  00621825   OR V1, V1, V0
9D007E00  9242001D   LBU V0, 29(S2)
9D007E04  00021200   SLL V0, V0, 8
9D007E08  00621025   OR V0, V1, V0
9D007E0C  AE020010   SW V0, 16(S0)
2584:                			fp->fptr = 0;						/* File pointer */
9D007E10  AE00000C   SW ZERO, 12(S0)
2585:                			fp->dsect = 0;
9D007E14  AE00001C   SW ZERO, 28(S0)
2586:                #if _USE_FASTSEEK
2587:                			fp->cltbl = 0;						/* Normal seek mode */
2588:                #endif
2589:                			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
9D007E18  AE130004   SW S3, 4(S0)
9D007E1C  96620006   LHU V0, 6(S3)
9D007E20  A6020008   SH V0, 8(S0)
2590:                		}
2591:                	}
2592:                
2593:                        if(res != FR_OK)
2594:                        {
2595:                            FATFSFileObject[hFATfs].inUse = 0;
9D007E4C  3C03A001   LUI V1, -24575
9D007E50  0B401F89   J 0x9D007E24
9D007E54  A0604670   SB ZERO, 18032(V1)
2596:                        }
2597:                        
2598:                	LEAVE_FF(dj.fs, res);
9D007E24  0B401F9C   J 0x9D007E70
9D007E28  02201021   ADDU V0, S1, ZERO
2599:                }
9D007E70  8FBF005C   LW RA, 92(SP)
2600:                
2601:                
2602:                
2603:                
2604:                /*-----------------------------------------------------------------------*/
2605:                /* Read File                                                             */
2606:                /*-----------------------------------------------------------------------*/
2607:                
2608:                int f_read (
2609:                	uintptr_t handle, 		/* Pointer to the file object */
2610:                	void *buff,		/* Pointer to data buffer */
2611:                	uint32_t btr,		/* Number of bytes to read */
2612:                	uint32_t *br		/* Pointer to number of bytes read */
2613:                )
2614:                {
9D009284  27BDFFC0   ADDIU SP, SP, -64
9D009288  AFBF003C   SW RA, 60(SP)
9D00928C  AFBE0038   SW S8, 56(SP)
9D009290  AFB70034   SW S7, 52(SP)
9D009294  AFB60030   SW S6, 48(SP)
9D009298  AFB5002C   SW S5, 44(SP)
9D00929C  AFB40028   SW S4, 40(SP)
9D0092A0  AFB30024   SW S3, 36(SP)
9D0092A4  AFB20020   SW S2, 32(SP)
9D0092A8  AFB1001C   SW S1, 28(SP)
9D0092AC  AFB00018   SW S0, 24(SP)
9D0092B0  00808821   ADDU S1, A0, ZERO
9D0092B4  00A0A021   ADDU S4, A1, ZERO
9D0092B8  00C0A821   ADDU S5, A2, ZERO
9D0092BC  00E09821   ADDU S3, A3, ZERO
2615:                	FRESULT res;
2616:                	uint32_t clst, sect, remain;
2617:                	uint32_t rcnt, cc;
2618:                	uint8_t csect, *rbuff = (uint8_t*)buff;
2619:                        FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
2620:                        FIL *fp = &ptr->fileObj;
2621:                
2622:                	*br = 0;	/* Clear read byte counter */
9D0092C0  ACE00000   SW ZERO, 0(A3)
2623:                
2624:                	res = validate(fp);							/* Check validity */
9D0092C4  0F40563A   JAL validate
9D0092C8  24840004   ADDIU A0, A0, 4
2625:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
9D0092CC  144000A5   BNE V0, ZERO, 0x9D009564
9D0092D0  8FBF003C   LW RA, 60(SP)
2626:                	if (fp->flag & FA__ERROR)					/* Aborted file? */
9D0092D4  9223000A   LBU V1, 10(S1)
9D0092D8  7C032420   SEB A0, V1
9D0092DC  048000A0   BLTZ A0, 0x9D009560
9D0092E0  24020002   ADDIU V0, ZERO, 2
2627:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2628:                	if (!(fp->flag & FA_READ)) 					/* Check access mode */
9D0092E4  30630001   ANDI V1, V1, 1
9D0092E8  1060009D   BEQ V1, ZERO, 0x9D009560
9D0092EC  24020007   ADDIU V0, ZERO, 7
2629:                		LEAVE_FF(fp->fs, FR_DENIED);
2630:                	remain = fp->fsize - fp->fptr;
9D0092F0  8E320010   LW S2, 16(S1)
9D0092F4  8E22000C   LW V0, 12(S1)
9D0092F8  02429023   SUBU S2, S2, V0
9D0092FC  0255102B   SLTU V0, S2, S5
9D009300  02A2900A   MOVZ S2, S5, V0
2631:                	if (btr > remain) btr = (uint32_t)remain;		/* Truncate btr by remaining bytes */
2632:                
2633:                	for ( ;  btr;								/* Repeat until all data read */
9D009304  12400095   BEQ S2, ZERO, 0x9D00955C
9D009308  02208021   ADDU S0, S1, ZERO
9D00954C  1640FF73   BNE S2, ZERO, 0x9D00931C
9D009550  AE620000   SW V0, 0(S3)
9D009554  0B402558   J 0x9D009560
9D009558  00001021   ADDU V0, ZERO, ZERO
9D00955C  00001021   ADDU V0, ZERO, ZERO
2634:                		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
9D009530  0295A021   ADDU S4, S4, S5
9D009534  8E02000C   LW V0, 12(S0)
9D009538  00551021   ADDU V0, V0, S5
9D00953C  AE02000C   SW V0, 12(S0)
9D009540  8E620000   LW V0, 0(S3)
9D009544  00551021   ADDU V0, V0, S5
9D009548  02559023   SUBU S2, S2, S5
2635:                		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
9D00931C  8E02000C   LW V0, 12(S0)
9D009320  304301FF   ANDI V1, V0, 511
9D009324  54600076   BNEL V1, ZERO, 0x9D009500
9D009328  8E05000C   LW A1, 12(S0)
2636:                			csect = (uint8_t)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
9D00932C  8E040004   LW A0, 4(S0)
9D009330  0002B242   SRL S6, V0, 9
9D009334  90830002   LBU V1, 2(A0)
9D009338  2463FFFF   ADDIU V1, V1, -1
9D00933C  02C3B024   AND S6, S6, V1
9D009340  32D600FF   ANDI S6, S6, 255
2637:                			if (!csect) {						/* On the cluster boundary? */
9D009344  56C00019   BNEL S6, ZERO, 0x9D0093AC
9D009348  8E170004   LW S7, 4(S0)
2638:                				if (fp->fptr == 0) {			/* On the top of the file? */
9D00934C  14400003   BNE V0, ZERO, 0x9D00935C
9D009350  00000000   NOP
9D009354  0B4024D9   J 0x9D009364
9D009358  8E020014   LW V0, 20(S0)
2639:                					clst = fp->sclust;			/* Follow from the origin */
2640:                				} else {						/* Middle or end of the file */
2641:                #if _USE_FASTSEEK
2642:                					if (fp->cltbl)
2643:                						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
2644:                					else
2645:                #endif
2646:                						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
9D00935C  0F403E01   JAL get_fat
9D009360  8E050018   LW A1, 24(S0)
2647:                				}
2648:                				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
9D009364  2C430002   SLTIU V1, V0, 2
9D009368  10600007   BEQ V1, ZERO, 0x9D009388
9D00936C  2403FFFF   ADDIU V1, ZERO, -1
9D009370  9223000A   LBU V1, 10(S1)
9D009374  2402FF80   ADDIU V0, ZERO, -128
9D009378  00621025   OR V0, V1, V0
9D00937C  A222000A   SB V0, 10(S1)
9D009380  0B402558   J 0x9D009560
9D009384  24020002   ADDIU V0, ZERO, 2
2649:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
9D009388  54430007   BNEL V0, V1, 0x9D0093A8
9D00938C  AE020018   SW V0, 24(S0)
9D009390  9223000A   LBU V1, 10(S1)
9D009394  2402FF80   ADDIU V0, ZERO, -128
9D009398  00621025   OR V0, V1, V0
9D00939C  A222000A   SB V0, 10(S1)
9D0093A0  0B402558   J 0x9D009560
9D0093A4  24020001   ADDIU V0, ZERO, 1
2650:                				fp->clust = clst;				/* Update current cluster */
2651:                			}
2652:                			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
9D0093A8  8E170004   LW S7, 4(S0)
9D0093AC  02E02021   ADDU A0, S7, ZERO
9D0093B0  0F405AB1   JAL clust2sect
9D0093B4  8E050018   LW A1, 24(S0)
2653:                			if (!sect) ABORT(fp->fs, FR_INT_ERR);
9D0093B8  14400007   BNE V0, ZERO, 0x9D0093D8
9D0093BC  0012AA42   SRL S5, S2, 9
9D0093C0  9223000A   LBU V1, 10(S1)
9D0093C4  2402FF80   ADDIU V0, ZERO, -128
9D0093C8  00621025   OR V0, V1, V0
9D0093CC  A222000A   SB V0, 10(S1)
9D0093D0  0B402558   J 0x9D009560
9D0093D4  24020002   ADDIU V0, ZERO, 2
2654:                			sect += csect;
2655:                			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
2656:                			if (cc) {							/* Read maximum contiguous sectors directly */
9D0093D8  12A00023   BEQ S5, ZERO, 0x9D009468
9D0093DC  0056F021   ADDU S8, V0, S6
2657:                				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
9D0093E0  92E20002   LBU V0, 2(S7)
9D0093E4  02B61821   ADDU V1, S5, S6
9D0093E8  0043182B   SLTU V1, V0, V1
2658:                					cc = fp->fs->csize - csect;
9D0093EC  0056B023   SUBU S6, V0, S6
9D0093F0  02C3A80B   MOVN S5, S6, V1
2659:                				if (disk_read(fp->fs->drv, rbuff, sect, (uint8_t)cc) != RES_OK)
9D0093F4  92E40001   LBU A0, 1(S7)
9D0093F8  02802821   ADDU A1, S4, ZERO
9D0093FC  03C03021   ADDU A2, S8, ZERO
9D009400  0F40561B   JAL disk_read
9D009404  32A700FF   ANDI A3, S5, 255
9D009408  50400007   BEQL V0, ZERO, 0x9D009428
9D00940C  9202000A   LBU V0, 10(S0)
2660:                					ABORT(fp->fs, FR_DISK_ERR);
9D009410  9223000A   LBU V1, 10(S1)
9D009414  2402FF80   ADDIU V0, ZERO, -128
9D009418  00621025   OR V0, V1, V0
9D00941C  A222000A   SB V0, 10(S1)
9D009420  0B402558   J 0x9D009560
9D009424  24020001   ADDIU V0, ZERO, 1
2661:                #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
2662:                #if _FS_TINY
2663:                				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
2664:                					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
2665:                #else
2666:                				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
9D009428  30420040   ANDI V0, V0, 64
9D00942C  304200FF   ANDI V0, V0, 255
9D009430  5040003F   BEQL V0, ZERO, 0x9D009530
9D009434  0015AA40   SLL S5, S5, 9
9D009438  8E02001C   LW V0, 28(S0)
9D00943C  005EF023   SUBU S8, V0, S8
9D009440  03D5102B   SLTU V0, S8, S5
9D009444  5040003A   BEQL V0, ZERO, 0x9D009530
9D009448  0015AA40   SLL S5, S5, 9
2667:                					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
9D00944C  001E2240   SLL A0, S8, 9
9D009450  02842021   ADDU A0, S4, A0
9D009454  8FA50014   LW A1, 20(SP)
9D009458  0F405BCE   JAL mem_cpy
9D00945C  24060200   ADDIU A2, ZERO, 512
2668:                #endif
2669:                #endif
2670:                				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
2671:                				continue;
9D009460  0B40254C   J 0x9D009530
9D009464  0015AA40   SLL S5, S5, 9
2672:                			}
2673:                #if !_FS_TINY
2674:                			if (fp->dsect != sect) {			/* Load data sector if not in cache */
9D009468  8E06001C   LW A2, 28(S0)
9D00946C  50DE0023   BEQL A2, S8, 0x9D0094FC
9D009470  AE1E001C   SW S8, 28(S0)
2675:                #if !_FS_READONLY
2676:                				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
9D009474  9202000A   LBU V0, 10(S0)
9D009478  30420040   ANDI V0, V0, 64
9D00947C  304200FF   ANDI V0, V0, 255
9D009480  50400011   BEQL V0, ZERO, 0x9D0094C8
9D009484  8E020004   LW V0, 4(S0)
2677:                					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
9D009488  92E40001   LBU A0, 1(S7)
9D00948C  8FA50014   LW A1, 20(SP)
9D009490  0F405432   JAL disk_write
9D009494  24070001   ADDIU A3, ZERO, 1
9D009498  50400007   BEQL V0, ZERO, 0x9D0094B8
9D00949C  9202000A   LBU V0, 10(S0)
2678:                						ABORT(fp->fs, FR_DISK_ERR);
9D0094A0  9223000A   LBU V1, 10(S1)
9D0094A4  2402FF80   ADDIU V0, ZERO, -128
9D0094A8  00621025   OR V0, V1, V0
9D0094AC  A222000A   SB V0, 10(S1)
9D0094B0  0B402558   J 0x9D009560
9D0094B4  24020001   ADDIU V0, ZERO, 1
2679:                					fp->flag &= ~FA__DIRTY;
9D0094B8  2403FFBF   ADDIU V1, ZERO, -65
9D0094BC  00431024   AND V0, V0, V1
9D0094C0  A202000A   SB V0, 10(S0)
2680:                				}
2681:                #endif
2682:                				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
9D009314  2623002C   ADDIU V1, S1, 44
9D009318  AFA30014   SW V1, 20(SP)
9D0094C4  8E020004   LW V0, 4(S0)
9D0094C8  90440001   LBU A0, 1(V0)
9D0094CC  8FA50014   LW A1, 20(SP)
9D0094D0  03C03021   ADDU A2, S8, ZERO
9D0094D4  0F40561B   JAL disk_read
9D0094D8  24070001   ADDIU A3, ZERO, 1
9D0094DC  50400007   BEQL V0, ZERO, 0x9D0094FC
9D0094E0  AE1E001C   SW S8, 28(S0)
2683:                					ABORT(fp->fs, FR_DISK_ERR);
9D0094E4  9223000A   LBU V1, 10(S1)
9D0094E8  2402FF80   ADDIU V0, ZERO, -128
9D0094EC  00621025   OR V0, V1, V0
9D0094F0  A222000A   SB V0, 10(S1)
9D0094F4  0B402558   J 0x9D009560
9D0094F8  24020001   ADDIU V0, ZERO, 1
2684:                			}
2685:                #endif
2686:                			fp->dsect = sect;
2687:                		}
2688:                		rcnt = SS(fp->fs) - ((uint32_t)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
9D0094FC  8E05000C   LW A1, 12(S0)
9D009500  30A501FF   ANDI A1, A1, 511
9D009504  24030200   ADDIU V1, ZERO, 512
9D009508  00651023   SUBU V0, V1, A1
9D00950C  0052A82B   SLTU S5, V0, S2
9D009510  0255100A   MOVZ V0, S2, S5
9D009514  0040A821   ADDU S5, V0, ZERO
2689:                		if (rcnt > btr) rcnt = btr;
2690:                #if _FS_TINY
2691:                		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
2692:                			ABORT(fp->fs, FR_DISK_ERR);
2693:                		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
2694:                #else
2695:                		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
9D00930C  26220004   ADDIU V0, S1, 4
9D009310  AFA20010   SW V0, 16(SP)
9D009518  24A50028   ADDIU A1, A1, 40
9D00951C  02802021   ADDU A0, S4, ZERO
9D009520  8FA20010   LW V0, 16(SP)
9D009524  00452821   ADDU A1, V0, A1
9D009528  0F405BCE   JAL mem_cpy
9D00952C  02A03021   ADDU A2, S5, ZERO
2696:                #endif
2697:                	}
2698:                
2699:                	LEAVE_FF(fp->fs, FR_OK);
2700:                }
9D009560  8FBF003C   LW RA, 60(SP)
2701:                
2702:                
2703:                
2704:                
2705:                #if !_FS_READONLY
2706:                /*-----------------------------------------------------------------------*/
2707:                /* Write File                                                            */
2708:                /*-----------------------------------------------------------------------*/
2709:                
2710:                int f_write (
2711:                	uintptr_t handle,			/* Pointer to the file object */
2712:                	const void *buff,	/* Pointer to the data to be written */
2713:                	uint32_t btw,			/* Number of bytes to write */
2714:                	uint32_t *bw			/* Pointer to number of bytes written */
2715:                )
2716:                {
9D008570  27BDFFC0   ADDIU SP, SP, -64
9D008574  AFBF003C   SW RA, 60(SP)
9D008578  AFBE0038   SW S8, 56(SP)
9D00857C  AFB70034   SW S7, 52(SP)
9D008580  AFB60030   SW S6, 48(SP)
9D008584  AFB5002C   SW S5, 44(SP)
9D008588  AFB40028   SW S4, 40(SP)
9D00858C  AFB30024   SW S3, 36(SP)
9D008590  AFB20020   SW S2, 32(SP)
9D008594  AFB1001C   SW S1, 28(SP)
9D008598  AFB00018   SW S0, 24(SP)
9D00859C  00809021   ADDU S2, A0, ZERO
9D0085A0  00A0A021   ADDU S4, A1, ZERO
9D0085A4  00C08821   ADDU S1, A2, ZERO
9D0085A8  00E09821   ADDU S3, A3, ZERO
2717:                	FRESULT res;
2718:                	uint32_t clst, sect;
2719:                	uint32_t wcnt, cc;
2720:                	const uint8_t *wbuff = (const uint8_t*)buff;
2721:                	uint8_t csect;
2722:                        FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
2723:                        FIL *fp = &ptr->fileObj;
2724:                
2725:                	*bw = 0;	/* Clear write byte counter */
9D0085AC  ACE00000   SW ZERO, 0(A3)
2726:                
2727:                	res = validate(fp);						/* Check validity */
9D0085B0  0F40563A   JAL validate
9D0085B4  24840004   ADDIU A0, A0, 4
2728:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
9D0085B8  144000BA   BNE V0, ZERO, 0x9D0088A4
9D0085BC  8FBF003C   LW RA, 60(SP)
2729:                	if (fp->flag & FA__ERROR)				/* Aborted file? */
9D0085C0  9243000A   LBU V1, 10(S2)
9D0085C4  7C032420   SEB A0, V1
9D0085C8  048000B5   BLTZ A0, 0x9D0088A0
9D0085CC  24020002   ADDIU V0, ZERO, 2
2730:                		LEAVE_FF(fp->fs, FR_INT_ERR);
2731:                	if (!(fp->flag & FA_WRITE))				/* Check access mode */
9D0085D0  30630002   ANDI V1, V1, 2
9D0085D4  306300FF   ANDI V1, V1, 255
9D0085D8  106000B1   BEQ V1, ZERO, 0x9D0088A0
9D0085DC  24020007   ADDIU V0, ZERO, 7
2732:                		LEAVE_FF(fp->fs, FR_DENIED);
2733:                	if ((uint32_t)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
9D0085E0  8E420010   LW V0, 16(S2)
9D0085E4  02221821   ADDU V1, S1, V0
9D0085E8  0062102B   SLTU V0, V1, V0
9D0085EC  544000A4   BNEL V0, ZERO, 0x9D008880
9D0085F0  8E42000C   LW V0, 12(S2)
2734:                
2735:                	for ( ;  btw;							/* Repeat until all data written */
9D0085F4  122000A1   BEQ S1, ZERO, 0x9D00887C
9D0085F8  02408021   ADDU S0, S2, ZERO
9D008874  1620FF65   BNE S1, ZERO, 0x9D00860C
9D008878  AE620000   SW V0, 0(S3)
2736:                		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
9D008858  0295A021   ADDU S4, S4, S5
9D00885C  8E02000C   LW V0, 12(S0)
9D008860  00551021   ADDU V0, V0, S5
9D008864  AE02000C   SW V0, 12(S0)
9D008868  8E620000   LW V0, 0(S3)
9D00886C  00551021   ADDU V0, V0, S5
9D008870  02358823   SUBU S1, S1, S5
2737:                		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
9D00860C  8E02000C   LW V0, 12(S0)
9D008610  304301FF   ANDI V1, V0, 511
9D008614  54600081   BNEL V1, ZERO, 0x9D00881C
9D008618  8E04000C   LW A0, 12(S0)
2738:                			csect = (uint8_t)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
9D00861C  8E040004   LW A0, 4(S0)
9D008620  0002B242   SRL S6, V0, 9
9D008624  90830002   LBU V1, 2(A0)
9D008628  2463FFFF   ADDIU V1, V1, -1
9D00862C  02C3B024   AND S6, S6, V1
9D008630  32D600FF   ANDI S6, S6, 255
2739:                			if (!csect) {					/* On the cluster boundary? */
9D008634  56C0001F   BNEL S6, ZERO, 0x9D0086B4
9D008638  9202000A   LBU V0, 10(S0)
2740:                				if (fp->fptr == 0) {		/* On the top of the file? */
9D00863C  14400008   BNE V0, ZERO, 0x9D008660
9D008640  00000000   NOP
2741:                					clst = fp->sclust;		/* Follow from the origin */
9D008644  8E020014   LW V0, 20(S0)
2742:                					if (clst == 0)			/* When no cluster is allocated, */
9D008648  14400009   BNE V0, ZERO, 0x9D008670
9D00864C  24030001   ADDIU V1, ZERO, 1
2743:                						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
9D008650  0F403D3A   JAL create_chain
9D008654  00002821   ADDU A1, ZERO, ZERO
9D008658  0B40219A   J 0x9D008668
9D00865C  AE020014   SW V0, 20(S0)
2744:                				} else {					/* Middle or end of the file */
2745:                #if _USE_FASTSEEK
2746:                					if (fp->cltbl)
2747:                						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
2748:                					else
2749:                #endif
2750:                						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
9D008660  0F403D3A   JAL create_chain
9D008664  8E050018   LW A1, 24(S0)
2751:                				}
2752:                				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
9D008668  10400084   BEQ V0, ZERO, 0x9D00887C
9D00866C  24030001   ADDIU V1, ZERO, 1
2753:                				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
9D008670  14430007   BNE V0, V1, 0x9D008690
9D008674  2403FFFF   ADDIU V1, ZERO, -1
9D008678  9243000A   LBU V1, 10(S2)
9D00867C  2402FF80   ADDIU V0, ZERO, -128
9D008680  00621025   OR V0, V1, V0
9D008684  A242000A   SB V0, 10(S2)
9D008688  0B402228   J 0x9D0088A0
9D00868C  24020002   ADDIU V0, ZERO, 2
2754:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
9D008690  54430007   BNEL V0, V1, 0x9D0086B0
9D008694  AE020018   SW V0, 24(S0)
9D008698  9243000A   LBU V1, 10(S2)
9D00869C  2402FF80   ADDIU V0, ZERO, -128
9D0086A0  00621025   OR V0, V1, V0
9D0086A4  A242000A   SB V0, 10(S2)
9D0086A8  0B402228   J 0x9D0088A0
9D0086AC  24020001   ADDIU V0, ZERO, 1
2755:                				fp->clust = clst;			/* Update current cluster */
2756:                			}
2757:                #if _FS_TINY
2758:                			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
2759:                				ABORT(fp->fs, FR_DISK_ERR);
2760:                #else
2761:                			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
9D0086B0  9202000A   LBU V0, 10(S0)
9D0086B4  30420040   ANDI V0, V0, 64
9D0086B8  304200FF   ANDI V0, V0, 255
9D0086BC  50400013   BEQL V0, ZERO, 0x9D00870C
9D0086C0  8E170004   LW S7, 4(S0)
2762:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
9D0086C4  8E020004   LW V0, 4(S0)
9D0086C8  90440001   LBU A0, 1(V0)
9D0086CC  8FA50014   LW A1, 20(SP)
9D0086D0  8E06001C   LW A2, 28(S0)
9D0086D4  0F405432   JAL disk_write
9D0086D8  24070001   ADDIU A3, ZERO, 1
9D0086DC  50400007   BEQL V0, ZERO, 0x9D0086FC
9D0086E0  9202000A   LBU V0, 10(S0)
2763:                					ABORT(fp->fs, FR_DISK_ERR);
9D0086E4  9243000A   LBU V1, 10(S2)
9D0086E8  2402FF80   ADDIU V0, ZERO, -128
9D0086EC  00621025   OR V0, V1, V0
9D0086F0  A242000A   SB V0, 10(S2)
9D0086F4  0B402228   J 0x9D0088A0
9D0086F8  24020001   ADDIU V0, ZERO, 1
2764:                				fp->flag &= ~FA__DIRTY;
9D0086FC  2403FFBF   ADDIU V1, ZERO, -65
9D008700  00431024   AND V0, V0, V1
9D008704  A202000A   SB V0, 10(S0)
2765:                			}
2766:                #endif
2767:                			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
9D008708  8E170004   LW S7, 4(S0)
9D00870C  02E02021   ADDU A0, S7, ZERO
9D008710  0F405AB1   JAL clust2sect
9D008714  8E050018   LW A1, 24(S0)
2768:                			if (!sect) ABORT(fp->fs, FR_INT_ERR);
9D008718  14400007   BNE V0, ZERO, 0x9D008738
9D00871C  0011AA42   SRL S5, S1, 9
9D008720  9243000A   LBU V1, 10(S2)
9D008724  2402FF80   ADDIU V0, ZERO, -128
9D008728  00621025   OR V0, V1, V0
9D00872C  A242000A   SB V0, 10(S2)
9D008730  0B402228   J 0x9D0088A0
9D008734  24020002   ADDIU V0, ZERO, 2
2769:                			sect += csect;
2770:                			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
2771:                			if (cc) {						/* Write maximum contiguous sectors directly */
9D008738  12A00022   BEQ S5, ZERO, 0x9D0087C4
9D00873C  0056F021   ADDU S8, V0, S6
2772:                				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
9D008740  92E20002   LBU V0, 2(S7)
9D008744  02B61821   ADDU V1, S5, S6
9D008748  0043182B   SLTU V1, V0, V1
2773:                					cc = fp->fs->csize - csect;
9D00874C  0056B023   SUBU S6, V0, S6
9D008750  02C3A80B   MOVN S5, S6, V1
2774:                				if (disk_write(fp->fs->drv, wbuff, sect, (uint8_t)cc) != RES_OK)
9D008754  92E40001   LBU A0, 1(S7)
9D008758  02802821   ADDU A1, S4, ZERO
9D00875C  03C03021   ADDU A2, S8, ZERO
9D008760  0F405432   JAL disk_write
9D008764  32A700FF   ANDI A3, S5, 255
9D008768  50400007   BEQL V0, ZERO, 0x9D008788
9D00876C  8E02001C   LW V0, 28(S0)
2775:                					ABORT(fp->fs, FR_DISK_ERR);
9D008770  9243000A   LBU V1, 10(S2)
9D008774  2402FF80   ADDIU V0, ZERO, -128
9D008778  00621025   OR V0, V1, V0
9D00877C  A242000A   SB V0, 10(S2)
9D008780  0B402228   J 0x9D0088A0
9D008784  24020001   ADDIU V0, ZERO, 1
2776:                #if _FS_TINY
2777:                				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
2778:                					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
2779:                					fp->fs->wflag = 0;
2780:                				}
2781:                #else
2782:                				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
9D008788  005EF023   SUBU S8, V0, S8
9D00878C  03D5102B   SLTU V0, S8, S5
9D008790  50400031   BEQL V0, ZERO, 0x9D008858
9D008794  0015AA40   SLL S5, S5, 9
2783:                					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
9D008798  001E2A40   SLL A1, S8, 9
9D00879C  8FA40014   LW A0, 20(SP)
9D0087A0  02852821   ADDU A1, S4, A1
9D0087A4  0F405BCE   JAL mem_cpy
9D0087A8  24060200   ADDIU A2, ZERO, 512
2784:                					fp->flag &= ~FA__DIRTY;
9D0087AC  9202000A   LBU V0, 10(S0)
9D0087B0  2403FFBF   ADDIU V1, ZERO, -65
9D0087B4  00431024   AND V0, V0, V1
9D0087B8  A202000A   SB V0, 10(S0)
2785:                				}
2786:                #endif
2787:                				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
2788:                				continue;
9D0087BC  0B402216   J 0x9D008858
9D0087C0  0015AA40   SLL S5, S5, 9
2789:                			}
2790:                #if _FS_TINY
2791:                			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
2792:                				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
2793:                				fp->fs->winsect = sect;
2794:                			}
2795:                #else
2796:                			if (fp->dsect != sect) {		/* Fill sector cache with file data */
9D0087C4  8E02001C   LW V0, 28(S0)
9D0087C8  505E0013   BEQL V0, S8, 0x9D008818
9D0087CC  AE1E001C   SW S8, 28(S0)
2797:                				if (fp->fptr < fp->fsize &&
9D0087D0  8E03000C   LW V1, 12(S0)
9D0087D4  8E020010   LW V0, 16(S0)
9D0087D8  0062102B   SLTU V0, V1, V0
9D0087DC  5040000E   BEQL V0, ZERO, 0x9D008818
9D0087E0  AE1E001C   SW S8, 28(S0)
9D0087F8  50400007   BEQL V0, ZERO, 0x9D008818
9D0087FC  AE1E001C   SW S8, 28(S0)
2798:                					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
9D008604  2643002C   ADDIU V1, S2, 44
9D008608  AFA30014   SW V1, 20(SP)
9D0087E4  92E40001   LBU A0, 1(S7)
9D0087E8  8FA50014   LW A1, 20(SP)
9D0087EC  03C03021   ADDU A2, S8, ZERO
9D0087F0  0F40561B   JAL disk_read
9D0087F4  24070001   ADDIU A3, ZERO, 1
2799:                						ABORT(fp->fs, FR_DISK_ERR);
9D008800  9243000A   LBU V1, 10(S2)
9D008804  2402FF80   ADDIU V0, ZERO, -128
9D008808  00621025   OR V0, V1, V0
9D00880C  A242000A   SB V0, 10(S2)
9D008810  0B402228   J 0x9D0088A0
9D008814  24020001   ADDIU V0, ZERO, 1
2800:                			}
2801:                #endif
2802:                			fp->dsect = sect;
2803:                		}
2804:                		wcnt = SS(fp->fs) - ((uint32_t)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
9D008818  8E04000C   LW A0, 12(S0)
9D00881C  308401FF   ANDI A0, A0, 511
9D008820  24030200   ADDIU V1, ZERO, 512
9D008824  00641023   SUBU V0, V1, A0
9D008828  0051A82B   SLTU S5, V0, S1
9D00882C  0235100A   MOVZ V0, S1, S5
9D008830  0040A821   ADDU S5, V0, ZERO
2805:                		if (wcnt > btw) wcnt = btw;
2806:                #if _FS_TINY
2807:                		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
2808:                			ABORT(fp->fs, FR_DISK_ERR);
2809:                		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
2810:                		fp->fs->wflag = 1;
2811:                #else
2812:                		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
9D0085FC  26420004   ADDIU V0, S2, 4
9D008600  AFA20010   SW V0, 16(SP)
9D008834  24840028   ADDIU A0, A0, 40
9D008838  8FA20010   LW V0, 16(SP)
9D00883C  00442021   ADDU A0, V0, A0
9D008840  02802821   ADDU A1, S4, ZERO
9D008844  0F405BCE   JAL mem_cpy
9D008848  02A03021   ADDU A2, S5, ZERO
2813:                		fp->flag |= FA__DIRTY;
9D00884C  9202000A   LBU V0, 10(S0)
9D008850  34420040   ORI V0, V0, 64
9D008854  A202000A   SB V0, 10(S0)
2814:                #endif
2815:                	}
2816:                
2817:                	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
9D00887C  8E42000C   LW V0, 12(S2)
9D008880  8E430010   LW V1, 16(S2)
9D008884  0062182B   SLTU V1, V1, V0
9D008888  54600001   BNEL V1, ZERO, 0x9D008890
9D00888C  AE420010   SW V0, 16(S2)
2818:                	fp->flag |= FA__WRITTEN;						/* Set file change flag */
9D008890  9242000A   LBU V0, 10(S2)
9D008894  34420020   ORI V0, V0, 32
9D008898  A242000A   SB V0, 10(S2)
2819:                
2820:                	LEAVE_FF(fp->fs, FR_OK);
9D00889C  00001021   ADDU V0, ZERO, ZERO
2821:                }
9D0088A0  8FBF003C   LW RA, 60(SP)
2822:                
2823:                
2824:                
2825:                
2826:                /*-----------------------------------------------------------------------*/
2827:                /* Synchronize the File Object                                           */
2828:                /*-----------------------------------------------------------------------*/
2829:                
2830:                int f_sync (
2831:                	uintptr_t handle		/* Pointer to the file object */
2832:                )
2833:                {
9D0113A8  27BDFFE0   ADDIU SP, SP, -32
9D0113AC  AFBF001C   SW RA, 28(SP)
9D0113B0  AFB10018   SW S1, 24(SP)
9D0113B4  AFB00014   SW S0, 20(SP)
9D0113B8  00808021   ADDU S0, A0, ZERO
2834:                	FRESULT res;
2835:                	uint32_t tm;
2836:                	uint8_t *dir;
2837:                        FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
2838:                        FIL *fp = &ptr->fileObj;
2839:                
2840:                
2841:                	res = validate(fp);					/* Check validity of the object */
9D0113BC  0F40563A   JAL validate
9D0113C0  24840004   ADDIU A0, A0, 4
2842:                	if (res == FR_OK) {
9D0113C4  14400042   BNE V0, ZERO, 0x9D0114D0
9D0113C8  00401821   ADDU V1, V0, ZERO
2843:                		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
9D0113CC  9203000A   LBU V1, 10(S0)
9D0113D0  30640020   ANDI A0, V1, 32
9D0113D4  308400FF   ANDI A0, A0, 255
9D0113D8  5080003D   BEQL A0, ZERO, 0x9D0114D0
9D0113DC  00401821   ADDU V1, V0, ZERO
2844:                #if !_FS_TINY	/* Write-back dirty buffer */
2845:                			if (fp->flag & FA__DIRTY) {
9D0113E0  30630040   ANDI V1, V1, 64
9D0113E4  306300FF   ANDI V1, V1, 255
9D0113E8  5060000D   BEQL V1, ZERO, 0x9D011420
9D0113EC  8E040004   LW A0, 4(S0)
2846:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
9D0113F0  8E020004   LW V0, 4(S0)
9D0113F4  90440001   LBU A0, 1(V0)
9D0113F8  2605002C   ADDIU A1, S0, 44
9D0113FC  8E06001C   LW A2, 28(S0)
9D011400  0F405432   JAL disk_write
9D011404  24070001   ADDIU A3, ZERO, 1
9D011408  14400031   BNE V0, ZERO, 0x9D0114D0
9D01140C  24030001   ADDIU V1, ZERO, 1
2847:                					LEAVE_FF(fp->fs, FR_DISK_ERR);
2848:                				fp->flag &= ~FA__DIRTY;
9D011410  9202000A   LBU V0, 10(S0)
9D011414  304200BF   ANDI V0, V0, 191
9D011418  A202000A   SB V0, 10(S0)
2849:                			}
2850:                #endif
2851:                			/* Update the directory entry */
2852:                			res = move_window(fp->fs, fp->dir_sect);
9D01141C  8E040004   LW A0, 4(S0)
9D011420  0F405691   JAL move_window
9D011424  8E050020   LW A1, 32(S0)
2853:                			if (res == FR_OK) {
9D011428  14400029   BNE V0, ZERO, 0x9D0114D0
9D01142C  00401821   ADDU V1, V0, ZERO
2854:                				dir = fp->dir_ptr;
9D011430  8E110024   LW S1, 36(S0)
2855:                				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
9D011434  9222000B   LBU V0, 11(S1)
9D011438  34420020   ORI V0, V0, 32
9D01143C  A222000B   SB V0, 11(S1)
2856:                				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
9D011440  8E020010   LW V0, 16(S0)
9D011444  A222001C   SB V0, 28(S1)
9D011448  96020010   LHU V0, 16(S0)
9D01144C  00021202   SRL V0, V0, 8
9D011450  A222001D   SB V0, 29(S1)
9D011454  96020012   LHU V0, 18(S0)
9D011458  A222001E   SB V0, 30(S1)
9D01145C  92020013   LBU V0, 19(S0)
9D011460  A222001F   SB V0, 31(S1)
2857:                				st_clust(dir, fp->sclust);					/* Update start cluster */
9D011464  8E020014   LW V0, 20(S0)
2858:                				tm = get_fattime();							/* Update updated time */
9D011480  0F405C45   JAL get_fattime
9D011484  A2220015   SB V0, 21(S1)
2859:                				ST_DWORD(dir+DIR_WrtTime, tm);
9D011488  A2220016   SB V0, 22(S1)
9D01148C  7C433A00   EXT V1, V0, 8, 8
9D011490  A2230017   SB V1, 23(S1)
9D011494  00021C02   SRL V1, V0, 16
9D011498  A2230018   SB V1, 24(S1)
9D01149C  00021602   SRL V0, V0, 24
9D0114A0  A2220019   SB V0, 25(S1)
2860:                				ST_WORD(dir+DIR_LstAccDate, 0);
9D0114A4  A2200012   SB ZERO, 18(S1)
9D0114A8  A2200013   SB ZERO, 19(S1)
2861:                				fp->flag &= ~FA__WRITTEN;
9D0114AC  9202000A   LBU V0, 10(S0)
9D0114B0  304200DF   ANDI V0, V0, 223
9D0114B4  A202000A   SB V0, 10(S0)
2862:                				fp->fs->wflag = 1;
9D0114B8  8E020004   LW V0, 4(S0)
9D0114BC  24030001   ADDIU V1, ZERO, 1
9D0114C0  A0430004   SB V1, 4(V0)
2863:                				res = sync_fs(fp->fs);
9D0114C4  0F4047D7   JAL sync_fs
9D0114C8  8E040004   LW A0, 4(S0)
2864:                			}
2865:                		}
2866:                	}
2867:                
2868:                	LEAVE_FF(fp->fs, res);
9D0114CC  00401821   ADDU V1, V0, ZERO
2869:                }
9D0114D0  00601021   ADDU V0, V1, ZERO
2870:                
2871:                #endif /* !_FS_READONLY */
2872:                
2873:                
2874:                
2875:                
2876:                /*-----------------------------------------------------------------------*/
2877:                /* Close File                                                            */
2878:                /*-----------------------------------------------------------------------*/
2879:                
2880:                int f_close (
2881:                	uintptr_t   handle		/* Pointer to the file object to be closed */
2882:                )
2883:                {
9D015040  27BDFFE8   ADDIU SP, SP, -24
9D015044  AFBF0014   SW RA, 20(SP)
9D015048  AFB00010   SW S0, 16(SP)
2884:                	FRESULT res;
2885:                        FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
2886:                        FIL *fp = &ptr->fileObj;
2887:                
2888:                #if _FS_READONLY
2889:                	res = validate(fp);
2890:                	{
2891:                #if _FS_REENTRANT
2892:                		FATFS *fs = fp->fs;
2893:                #endif
2894:                		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
2895:                		LEAVE_FF(fs, res);
2896:                	}
2897:                #else
2898:                	res = f_sync(handle);		/* Flush cached data */
9D01504C  0F4044EA   JAL f_sync
9D015050  00808021   ADDU S0, A0, ZERO
2899:                #if _FS_LOCK
2900:                	if (res == FR_OK) {		/* Decrement open counter */
9D015054  14400019   BNE V0, ZERO, 0x9D0150BC
9D015058  8FBF0014   LW RA, 20(SP)
2901:                #if _FS_REENTRANT
2902:                		FATFS *fs = fp->fs;;
2903:                		res = validate(fp);
2904:                		if (res == FR_OK) {
2905:                			res = dec_lock(fp->lockid);	
2906:                			unlock_fs(fs, FR_OK);
2907:                		}
2908:                #else
2909:                		res = dec_lock(fp->lockid);
2910:                #endif
2911:                	}
2912:                #endif
2913:                	if (res == FR_OK)
2914:                        {
2915:                            fp->fs = 0;	/* Discard file object */
9D0150B0  AE000004   SW ZERO, 4(S0)
2916:                            ptr->inUse = 0;
9D0150B4  A2000000   SB ZERO, 0(S0)
2917:                        }
2918:                	return res;
2919:                #endif
2920:                }
9D0150B8  8FBF0014   LW RA, 20(SP)
2921:                
2922:                
2923:                
2924:                
2925:                /*-----------------------------------------------------------------------*/
2926:                /* Current Drive/Directory Handlings                                     */
2927:                /*-----------------------------------------------------------------------*/
2928:                
2929:                #if _FS_RPATH >= 1
2930:                
2931:                int f_chdrive (
2932:                	uint8_t drv		/* Drive number */
2933:                )
2934:                {
9D0170F8  308400FF   ANDI A0, A0, 255
2935:                	if (drv >= SYS_FS_VOLUME_NUMBER) return FR_INVALID_DRIVE;
9D0170FC  14800003   BNE A0, ZERO, 0x9D01710C
9D017100  2402000B   ADDIU V0, ZERO, 11
2936:                
2937:                	CurrVol = drv;
9D017104  A3808054   SB ZERO, -32684(GP)
2938:                
2939:                	return FR_OK;
9D017108  00001021   ADDU V0, ZERO, ZERO
2940:                }
9D01710C  03E00008   JR RA
2941:                
2942:                
2943:                
2944:                int f_chdir (
2945:                	const TCHAR *path	/* Pointer to the directory path */
2946:                )
2947:                {
9D012E88  27BDFFB0   ADDIU SP, SP, -80
9D012E8C  AFBF004C   SW RA, 76(SP)
9D012E90  AFB10048   SW S1, 72(SP)
9D012E94  AFB00044   SW S0, 68(SP)
9D012E98  AFA40050   SW A0, 80(SP)
2948:                	FRESULT res = FR_OK;
2949:                	DIR dj = {};
9D012E9C  AFA00010   SW ZERO, 16(SP)
9D012EA0  AFA00014   SW ZERO, 20(SP)
9D012EA4  AFA00018   SW ZERO, 24(SP)
9D012EA8  AFA0001C   SW ZERO, 28(SP)
9D012EAC  AFA00020   SW ZERO, 32(SP)
9D012EB0  AFA00024   SW ZERO, 36(SP)
9D012EB4  AFA00028   SW ZERO, 40(SP)
9D012EB8  AFA0002C   SW ZERO, 44(SP)
9D012EBC  AFA00030   SW ZERO, 48(SP)
2950:                	DEF_NAMEBUF;
2951:                
2952:                
2953:                	res = chk_mounted(&path, &dj.fs, 0);
9D012EC0  27A40050   ADDIU A0, SP, 80
9D012EC4  27A50010   ADDIU A1, SP, 16
9D012EC8  0F4016DE   JAL chk_mounted
9D012ECC  00003021   ADDU A2, ZERO, ZERO
2954:                	if (res == FR_OK) {
9D012ED0  1440001E   BNE V0, ZERO, 0x9D012F4C
9D012ED4  00408021   ADDU S0, V0, ZERO
2955:                		INIT_BUF(dj);
9D012ED8  27A20034   ADDIU V0, SP, 52
9D012EDC  AFA20028   SW V0, 40(SP)
9D012EE0  3C028001   LUI V0, -32767
9D012EE4  24424430   ADDIU V0, V0, 17456
9D012EE8  AFA2002C   SW V0, 44(SP)
2956:                		res = follow_path(&dj, path);		/* Follow the path */
9D012EEC  27A40010   ADDIU A0, SP, 16
9D012EF0  0F4010FC   JAL follow_path
9D012EF4  8FA50050   LW A1, 80(SP)
2957:                		FREE_BUF();
2958:                		if (res == FR_OK) {					/* Follow completed */
9D012EF8  14400011   BNE V0, ZERO, 0x9D012F40
9D012EFC  00408021   ADDU S0, V0, ZERO
2959:                			if (!dj.dir) {
9D012F00  8FA50024   LW A1, 36(SP)
9D012F04  54A00005   BNEL A1, ZERO, 0x9D012F1C
9D012F08  90A2000B   LBU V0, 11(A1)
2960:                				dj.fs->cdir = dj.sclust;	/* Start directory itself */
9D012F0C  8FA30018   LW V1, 24(SP)
9D012F10  8FA20010   LW V0, 16(SP)
9D012F14  0B404BD3   J 0x9D012F4C
9D012F18  AC430018   SW V1, 24(V0)
2961:                			} else {
2962:                				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
9D012F1C  30420010   ANDI V0, V0, 16
9D012F20  304200FF   ANDI V0, V0, 255
9D012F24  50400009   BEQL V0, ZERO, 0x9D012F4C
9D012F28  24100005   ADDIU S0, ZERO, 5
2963:                					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
9D012F2C  8FB10010   LW S1, 16(SP)
9D012F30  0F4059DD   JAL ld_clust
9D012F34  02202021   ADDU A0, S1, ZERO
9D012F38  0B404BD3   J 0x9D012F4C
9D012F3C  AE220018   SW V0, 24(S1)
2964:                				else
2965:                					res = FR_NO_PATH;		/* Reached but a file */
2966:                			}
2967:                		}
2968:                		if (res == FR_NO_FILE) res = FR_NO_PATH;
9D012F40  38430004   XORI V1, V0, 4
9D012F44  24020005   ADDIU V0, ZERO, 5
9D012F48  0043800A   MOVZ S0, V0, V1
2969:                	}
2970:                
2971:                	LEAVE_FF(dj.fs, res);
2972:                }
9D012F4C  02001021   ADDU V0, S0, ZERO
2973:                
2974:                
2975:                #if _FS_RPATH >= 2
2976:                int f_getcwd (
2977:                	TCHAR *buff,	/* Pointer to the directory path */
2978:                	uint32_t len		/* Size of path */
2979:                )
2980:                {
9D00A18C  27BDFF80   ADDIU SP, SP, -128
9D00A190  AFBF007C   SW RA, 124(SP)
9D00A194  AFB60078   SW S6, 120(SP)
9D00A198  AFB50074   SW S5, 116(SP)
9D00A19C  AFB40070   SW S4, 112(SP)
9D00A1A0  AFB3006C   SW S3, 108(SP)
9D00A1A4  AFB20068   SW S2, 104(SP)
9D00A1A8  AFB10064   SW S1, 100(SP)
9D00A1AC  AFB00060   SW S0, 96(SP)
9D00A1B0  AFA40080   SW A0, 128(SP)
9D00A1B4  00A0A021   ADDU S4, A1, ZERO
2981:                	FRESULT res = FR_OK;
2982:                	DIR dj = {};
9D00A1B8  AFA00010   SW ZERO, 16(SP)
9D00A1BC  AFA00014   SW ZERO, 20(SP)
9D00A1C0  AFA00018   SW ZERO, 24(SP)
9D00A1C4  AFA0001C   SW ZERO, 28(SP)
9D00A1C8  AFA00020   SW ZERO, 32(SP)
9D00A1CC  AFA00024   SW ZERO, 36(SP)
9D00A1D0  AFA00028   SW ZERO, 40(SP)
9D00A1D4  AFA0002C   SW ZERO, 44(SP)
9D00A1D8  AFA00030   SW ZERO, 48(SP)
2983:                	uint32_t i = 0, n = 0;
2984:                	uint32_t ccl = 0;
2985:                	TCHAR *tp = (TCHAR *)NULL;
2986:                	FILINFO fno = {};
9D00A1DC  AFA00034   SW ZERO, 52(SP)
9D00A1E0  AFA00038   SW ZERO, 56(SP)
9D00A1E4  AFA0003C   SW ZERO, 60(SP)
9D00A1E8  AFA00040   SW ZERO, 64(SP)
9D00A1EC  AFA00044   SW ZERO, 68(SP)
9D00A1F0  AFA00048   SW ZERO, 72(SP)
9D00A1F4  AFA0004C   SW ZERO, 76(SP)
9D00A1F8  AFA00050   SW ZERO, 80(SP)
2987:                	DEF_NAMEBUF;
2988:                
2989:                
2990:                	*buff = 0;
9D00A1FC  A0800000   SB ZERO, 0(A0)
2991:                	res = chk_mounted((const TCHAR**)&buff, &dj.fs, 0);	/* Get current volume */
9D00A200  27A40080   ADDIU A0, SP, 128
9D00A204  27A50010   ADDIU A1, SP, 16
9D00A208  0F4016DE   JAL chk_mounted
9D00A20C  00003021   ADDU A2, ZERO, ZERO
2992:                	if (res == FR_OK) {
9D00A210  1440008B   BNE V0, ZERO, 0x9D00A440
9D00A214  00409021   ADDU S2, V0, ZERO
2993:                		INIT_BUF(dj);
9D00A218  27A20054   ADDIU V0, SP, 84
9D00A21C  AFA20028   SW V0, 40(SP)
9D00A220  3C028001   LUI V0, -32767
9D00A224  24424430   ADDIU V0, V0, 17456
9D00A228  AFA2002C   SW V0, 44(SP)
2994:                		i = len;			/* Bottom of buffer (dir stack base) */
9D00A23C  02808021   ADDU S0, S4, ZERO
2995:                		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
9D00A22C  8FA20010   LW V0, 16(SP)
9D00A230  8C560018   LW S6, 24(V0)
2996:                		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
9D00A234  12C0007B   BEQ S6, ZERO, 0x9D00A424
9D00A238  AFB60018   SW S6, 24(SP)
9D00A37C  8FB60018   LW S6, 24(SP)
9D00A380  16C0FFB2   BNE S6, ZERO, 0x9D00A24C
9D00A384  27A40010   ADDIU A0, SP, 16
9D00A388  0B4028F4   J 0x9D00A3D0
9D00A38C  8FA30080   LW V1, 128(SP)
2997:                			res = dir_sdi(&dj, 1);			/* Get parent dir */
9D00A248  27A40010   ADDIU A0, SP, 16
9D00A24C  0F404499   JAL dir_sdi
9D00A250  24050001   ADDIU A1, ZERO, 1
9D00A3F0  0B402903   J 0x9D00A40C
9D00A3F4  00409021   ADDU S2, V0, ZERO
2998:                			if (res != FR_OK) break;
9D00A254  14400066   BNE V0, ZERO, 0x9D00A3F0
9D00A258  27A40010   ADDIU A0, SP, 16
2999:                			res = dir_read(&dj, 0);
9D00A25C  0F403396   JAL dir_read
9D00A260  00002821   ADDU A1, ZERO, ZERO
9D00A3F8  0B402903   J 0x9D00A40C
9D00A3FC  00409021   ADDU S2, V0, ZERO
3000:                			if (res != FR_OK) break;
9D00A264  14400064   BNE V0, ZERO, 0x9D00A3F8
9D00A268  8FA40010   LW A0, 16(SP)
3001:                			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
9D00A26C  0F4059DD   JAL ld_clust
9D00A270  8FA50024   LW A1, 36(SP)
9D00A274  AFA20018   SW V0, 24(SP)
3002:                			res = dir_sdi(&dj, 0);
9D00A278  27A40010   ADDIU A0, SP, 16
9D00A27C  0F404499   JAL dir_sdi
9D00A280  00002821   ADDU A1, ZERO, ZERO
9D00A400  0B402903   J 0x9D00A40C
9D00A404  00409021   ADDU S2, V0, ZERO
3003:                			if (res != FR_OK) break;
9D00A284  1440005E   BNE V0, ZERO, 0x9D00A400
9D00A288  00408821   ADDU S1, V0, ZERO
3004:                			do {							/* Find the entry links to the child dir */
3005:                				res = dir_read(&dj, 0);
9D00A28C  27A40010   ADDIU A0, SP, 16
9D00A290  0F403396   JAL dir_read
9D00A294  00002821   ADDU A1, ZERO, ZERO
3006:                				if (res != FR_OK) break;
9D00A298  14400009   BNE V0, ZERO, 0x9D00A2C0
9D00A29C  8FA40010   LW A0, 16(SP)
3007:                				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
9D00A2A0  0F4059DD   JAL ld_clust
9D00A2A4  8FA50024   LW A1, 36(SP)
9D00A2A8  10560009   BEQ V0, S6, 0x9D00A2D0
9D00A2AC  27A40010   ADDIU A0, SP, 16
3008:                				res = dir_next(&dj, 0);	
9D00A2B0  0F403722   JAL dir_next
9D00A2B4  00002821   ADDU A1, ZERO, ZERO
3009:                			} while (res == FR_OK);
9D00A2B8  1040FFF5   BEQ V0, ZERO, 0x9D00A290
9D00A2BC  27A40010   ADDIU A0, SP, 16
3010:                			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
9D00A240  24150004   ADDIU S5, ZERO, 4
9D00A2C0  50550052   BEQL V0, S5, 0x9D00A40C
9D00A2C4  24120002   ADDIU S2, ZERO, 2
3011:                			if (res != FR_OK) break;
9D00A2C8  54400050   BNEL V0, ZERO, 0x9D00A40C
9D00A2CC  00409021   ADDU S2, V0, ZERO
3012:                #if FAT_FS_USE_LFN
3013:                			fno.lfname = buff;
9D00A2D0  8FA20080   LW V0, 128(SP)
9D00A2D4  AFA2004C   SW V0, 76(SP)
3014:                			fno.lfsize = i;
9D00A2D8  AFB00050   SW S0, 80(SP)
3015:                #endif
3016:                			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
9D00A2DC  27A40010   ADDIU A0, SP, 16
9D00A2E0  0F402F89   JAL get_fileinfo
9D00A2E4  27A50034   ADDIU A1, SP, 52
3017:                			tp = fno.fname;
9D00A2F8  0B4028C4   J 0x9D00A310
9D00A2FC  00002021   ADDU A0, ZERO, ZERO
3018:                			if (FAT_FS_USE_LFN && *buff) tp = buff;
9D00A2E8  8FA50080   LW A1, 128(SP)
9D00A2EC  80A20000   LB V0, 0(A1)
9D00A2F0  10400003   BEQ V0, ZERO, 0x9D00A300
9D00A2F4  83A2003D   LB V0, 61(SP)
3019:                			for (n = 0; tp[n]; n++) ;
9D00A300  1440FFFD   BNE V0, ZERO, 0x9D00A2F8
9D00A304  27A5003D   ADDIU A1, SP, 61
9D00A310  24840001   ADDIU A0, A0, 1
9D00A314  7CA4118A   LBUX V0, A0(A1)
9D00A318  5440FFFE   BNEL V0, ZERO, 0x9D00A314
9D00A31C  24840001   ADDIU A0, A0, 1
3020:                			if (i < n + 3) {
9D00A308  0B402905   J 0x9D00A414
9D00A30C  2E020003   SLTIU V0, S0, 3
9D00A320  24820003   ADDIU V0, A0, 3
9D00A324  0202102B   SLTU V0, S0, V0
9D00A328  54400038   BNEL V0, ZERO, 0x9D00A40C
9D00A32C  24120011   ADDIU S2, ZERO, 17
9D00A414  1440FFFC   BNE V0, ZERO, 0x9D00A408
9D00A418  02003021   ADDU A2, S0, ZERO
3021:                				res = FR_NOT_ENOUGH_CORE; break;
9D00A408  24120011   ADDIU S2, ZERO, 17
3022:                			}
3023:                			while (n) buff[--i] = tp[--n];
9D00A330  1080000D   BEQ A0, ZERO, 0x9D00A368
9D00A334  02043023   SUBU A2, S0, A0
9D00A338  02001821   ADDU V1, S0, ZERO
9D00A33C  00902023   SUBU A0, A0, S0
9D00A340  00A42021   ADDU A0, A1, A0
9D00A344  2463FFFF   ADDIU V1, V1, -1
9D00A348  00831021   ADDU V0, A0, V1
9D00A34C  80450000   LB A1, 0(V0)
9D00A350  8FA20080   LW V0, 128(SP)
9D00A354  00431021   ADDU V0, V0, V1
9D00A358  1466FFFA   BNE V1, A2, 0x9D00A344
9D00A35C  A0450000   SB A1, 0(V0)
9D00A360  0B4028DC   J 0x9D00A370
9D00A364  24D0FFFF   ADDIU S0, A2, -1
9D00A368  02003021   ADDU A2, S0, ZERO
3024:                			buff[--i] = '/';
9D00A244  2413002F   ADDIU S3, ZERO, 47
9D00A36C  24D0FFFF   ADDIU S0, A2, -1
9D00A370  8FA20080   LW V0, 128(SP)
9D00A374  00501021   ADDU V0, V0, S0
9D00A378  A0530000   SB S3, 0(V0)
9D00A41C  0B4028DC   J 0x9D00A370
9D00A420  24D0FFFF   ADDIU S0, A2, -1
3025:                		}
3026:                		tp = buff;
9D00A40C  0B4028F2   J 0x9D00A3C8
9D00A410  8FA20080   LW V0, 128(SP)
9D00A424  8FA30080   LW V1, 128(SP)
3027:                		if (res == FR_OK) {
3028:                			*tp++ = '0' + CurrVol;			/* Put drive number */
9D00A3D0  93828054   LBU V0, -32684(GP)
9D00A3D4  24420030   ADDIU V0, V0, 48
9D00A3D8  A0620000   SB V0, 0(V1)
9D00A428  93828054   LBU V0, -32684(GP)
9D00A42C  24420030   ADDIU V0, V0, 48
9D00A430  A0620000   SB V0, 0(V1)
3029:                			*tp++ = ':';
9D00A3DC  2402003A   ADDIU V0, ZERO, 58
9D00A3E8  0B4028E8   J 0x9D00A3A0
9D00A3EC  24620002   ADDIU V0, V1, 2
9D00A434  2402003A   ADDIU V0, ZERO, 58
9D00A438  0B4028E4   J 0x9D00A390
9D00A43C  A0620001   SB V0, 1(V1)
3030:                			if (i == len) {					/* Root-dir */
9D00A3E0  1214FFEB   BEQ S0, S4, 0x9D00A390
9D00A3E4  A0620001   SB V0, 1(V1)
3031:                				*tp++ = '/';
9D00A390  24620003   ADDIU V0, V1, 3
9D00A394  2404002F   ADDIU A0, ZERO, 47
9D00A398  0B4028F2   J 0x9D00A3C8
9D00A39C  A0640002   SB A0, 2(V1)
3032:                			} else {						/* Sub-dir */
3033:                				do		/* Add stacked path str */
3034:                					*tp++ = buff[i++];
9D00A3A0  24420001   ADDIU V0, V0, 1
9D00A3A4  26030001   ADDIU V1, S0, 1
9D00A3A8  8FA40080   LW A0, 128(SP)
9D00A3AC  00908021   ADDU S0, A0, S0
9D00A3B0  82040000   LB A0, 0(S0)
9D00A3B4  A044FFFF   SB A0, -1(V0)
3035:                				while (i < len);
9D00A3B8  0074202B   SLTU A0, V1, S4
9D00A3BC  1480FFF8   BNE A0, ZERO, 0x9D00A3A0
9D00A3C0  00608021   ADDU S0, V1, ZERO
9D00A3C4  02209021   ADDU S2, S1, ZERO
3036:                			}
3037:                		}
3038:                		*tp = 0;
9D00A3C8  0B402910   J 0x9D00A440
9D00A3CC  A0400000   SB ZERO, 0(V0)
3039:                		FREE_BUF();
3040:                	}
3041:                
3042:                	LEAVE_FF(dj.fs, res);
3043:                }
9D00A440  02401021   ADDU V0, S2, ZERO
3044:                #endif /* _FS_RPATH >= 2 */
3045:                #endif /* _FS_RPATH >= 1 */
3046:                
3047:                
3048:                
3049:                #if _FS_MINIMIZE <= 2
3050:                /*-----------------------------------------------------------------------*/
3051:                /* Seek File R/W Pointer                                                 */
3052:                /*-----------------------------------------------------------------------*/
3053:                
3054:                int f_lseek (
3055:                	uintptr_t handle,		/* Pointer to the file object */
3056:                	uint32_t ofs		/* File pointer from top of file */
3057:                )
3058:                {
9D009590  27BDFFD8   ADDIU SP, SP, -40
9D009594  AFBF0024   SW RA, 36(SP)
9D009598  AFB40020   SW S4, 32(SP)
9D00959C  AFB3001C   SW S3, 28(SP)
9D0095A0  AFB20018   SW S2, 24(SP)
9D0095A4  AFB10014   SW S1, 20(SP)
9D0095A8  AFB00010   SW S0, 16(SP)
9D0095AC  00808021   ADDU S0, A0, ZERO
9D0095B0  00A09021   ADDU S2, A1, ZERO
3059:                	FRESULT res;
3060:                        FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
3061:                        FIL *fp = &ptr->fileObj;
3062:                
3063:                	res = validate(fp);					/* Check validity of the object */
9D0095B4  0F40563A   JAL validate
9D0095B8  24840004   ADDIU A0, A0, 4
3064:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
9D0095BC  144000B0   BNE V0, ZERO, 0x9D009880
9D0095C0  8FBF0024   LW RA, 36(SP)
3065:                	if (fp->flag & FA__ERROR)			/* Check abort flag */
9D0095C4  9203000A   LBU V1, 10(S0)
9D0095C8  7C032420   SEB A0, V1
9D0095CC  048000AB   BLTZ A0, 0x9D00987C
9D0095D0  24020002   ADDIU V0, ZERO, 2
3066:                		LEAVE_FF(fp->fs, FR_INT_ERR);
3067:                
3068:                #if _USE_FASTSEEK
3069:                	if (fp->cltbl) {	/* Fast seek */
3070:                		uint32_t cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
3071:                
3072:                		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
3073:                			tbl = fp->cltbl;
3074:                			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
3075:                			cl = fp->sclust;			/* Top of the chain */
3076:                			if (cl) {
3077:                				do {
3078:                					/* Get a fragment */
3079:                					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
3080:                					do {
3081:                						pcl = cl; ncl++;
3082:                						cl = get_fat(fp->fs, cl);
3083:                						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
3084:                						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
3085:                					} while (cl == pcl + 1);
3086:                					if (ulen <= tlen) {		/* Store the length and top of the fragment */
3087:                						*tbl++ = ncl; *tbl++ = tcl;
3088:                					}
3089:                				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
3090:                			}
3091:                			*fp->cltbl = ulen;	/* Number of items used */
3092:                			if (ulen <= tlen)
3093:                				*tbl = 0;		/* Terminate table */
3094:                			else
3095:                				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
3096:                
3097:                		} else {						/* Fast seek */
3098:                			if (ofs > fp->fsize)		/* Clip offset at the file size */
3099:                				ofs = fp->fsize;
3100:                			fp->fptr = ofs;				/* Set file pointer */
3101:                			if (ofs) {
3102:                				fp->clust = clmt_clust(fp, ofs - 1);
3103:                				dsc = clust2sect(fp->fs, fp->clust);
3104:                				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
3105:                				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
3106:                				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
3107:                #if !_FS_TINY
3108:                #if !_FS_READONLY
3109:                					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
3110:                						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
3111:                							ABORT(fp->fs, FR_DISK_ERR);
3112:                						fp->flag &= ~FA__DIRTY;
3113:                					}
3114:                #endif
3115:                					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
3116:                						ABORT(fp->fs, FR_DISK_ERR);
3117:                #endif
3118:                					fp->dsect = dsc;
3119:                				}
3120:                			}
3121:                		}
3122:                	} else
3123:                #endif
3124:                
3125:                	/* Normal Seek */
3126:                	{
3127:                		uint32_t clst, bcs, nsect, ifptr;
3128:                
3129:                		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
9D0095D4  8E020010   LW V0, 16(S0)
9D0095D8  0052202B   SLTU A0, V0, S2
9D0095DC  10800004   BEQ A0, ZERO, 0x9D0095F0
9D0095E0  02008821   ADDU S1, S0, ZERO
3130:                #if !_FS_READONLY
3131:                			 && !(fp->flag & FA_WRITE)
9D0095E4  30630002   ANDI V1, V1, 2
9D0095E8  306300FF   ANDI V1, V1, 255
3132:                #endif
3133:                			) ofs = fp->fsize;
9D0095EC  0043900A   MOVZ S2, V0, V1
3134:                
3135:                		ifptr = fp->fptr;
9D0095F0  8E02000C   LW V0, 12(S0)
3136:                		fp->fptr = nsect = 0;
3137:                		if (ofs) {
9D0095F4  124000A0   BEQ S2, ZERO, 0x9D009878
9D0095F8  AE00000C   SW ZERO, 12(S0)
3138:                			bcs = (uint32_t)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
9D0095FC  8E040004   LW A0, 4(S0)
9D009600  90930002   LBU S3, 2(A0)
3139:                			if (ifptr > 0 &&
9D009604  10400012   BEQ V0, ZERO, 0x9D009650
9D009608  00139A40   SLL S3, S3, 9
9D009628  00002812   MFLO A1
9D00962C  0065182B   SLTU V1, V1, A1
9D009630  54600008   BNEL V1, ZERO, 0x9D009654
9D009634  8E020014   LW V0, 20(S0)
3140:                				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
9D00960C  2442FFFF   ADDIU V0, V0, -1
9D009610  2643FFFF   ADDIU V1, S2, -1
9D009614  0073001B   DIVU V1, S3
9D009618  026001F4   TEQ S3, ZERO
9D00961C  00001812   MFLO V1
9D009620  0053001B   DIVU V0, S3
9D009624  026001F4   TEQ S3, ZERO
3141:                				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
9D009638  00131823   SUBU V1, ZERO, S3
9D00963C  00621024   AND V0, V1, V0
9D009640  AE02000C   SW V0, 12(S0)
3142:                				ofs -= fp->fptr;
9D009644  02429023   SUBU S2, S2, V0
3143:                				clst = fp->clust;
9D009648  0B4025AB   J 0x9D0096AC
9D00964C  8E020018   LW V0, 24(S0)
3144:                			} else {									/* When seek to back cluster, */
3145:                				clst = fp->sclust;						/* start from the first cluster */
9D009650  8E020014   LW V0, 20(S0)
3146:                #if !_FS_READONLY
3147:                				if (clst == 0) {						/* If no cluster chain, create a new chain */
9D009654  54400015   BNEL V0, ZERO, 0x9D0096AC
9D009658  AE020018   SW V0, 24(S0)
3148:                					clst = create_chain(fp->fs, 0);
9D00965C  0F403D3A   JAL create_chain
9D009660  00002821   ADDU A1, ZERO, ZERO
3149:                					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
9D009664  24030001   ADDIU V1, ZERO, 1
9D009668  14430007   BNE V0, V1, 0x9D009688
9D00966C  2403FFFF   ADDIU V1, ZERO, -1
9D009670  9203000A   LBU V1, 10(S0)
9D009674  2402FF80   ADDIU V0, ZERO, -128
9D009678  00621025   OR V0, V1, V0
9D00967C  A202000A   SB V0, 10(S0)
9D009680  0B40261F   J 0x9D00987C
9D009684  24020002   ADDIU V0, ZERO, 2
3150:                					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
9D009688  54430007   BNEL V0, V1, 0x9D0096A8
9D00968C  AE020014   SW V0, 20(S0)
9D009690  9203000A   LBU V1, 10(S0)
9D009694  2402FF80   ADDIU V0, ZERO, -128
9D009698  00621025   OR V0, V1, V0
9D00969C  A202000A   SB V0, 10(S0)
9D0096A0  0B40261F   J 0x9D00987C
9D0096A4  24020001   ADDIU V0, ZERO, 1
3151:                					fp->sclust = clst;
3152:                				}
3153:                #endif
3154:                				fp->clust = clst;
9D0096A8  AE020018   SW V0, 24(S0)
3155:                			}
3156:                			if (clst != 0) {
9D0096AC  50400041   BEQL V0, ZERO, 0x9D0097B4
9D0096B0  00008821   ADDU S1, ZERO, ZERO
3157:                				while (ofs > bcs) {						/* Cluster following loop */
9D0096B4  0272182B   SLTU V1, S3, S2
9D0096B8  1060002C   BEQ V1, ZERO, 0x9D00976C
9D0096BC  2414FFFF   ADDIU S4, ZERO, -1
9D009758  0272182B   SLTU V1, S3, S2
9D00975C  5460FFD9   BNEL V1, ZERO, 0x9D0096C4
9D009760  9223000A   LBU V1, 10(S1)
9D009764  0B4025DC   J 0x9D009770
9D009768  8E03000C   LW V1, 12(S0)
3158:                #if !_FS_READONLY
3159:                					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
9D0096C0  9223000A   LBU V1, 10(S1)
9D0096C4  30630002   ANDI V1, V1, 2
9D0096C8  306300FF   ANDI V1, V1, 255
9D0096CC  10600007   BEQ V1, ZERO, 0x9D0096EC
9D0096D0  8E240004   LW A0, 4(S1)
3160:                						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
9D0096D4  0F403D3A   JAL create_chain
9D0096D8  00402821   ADDU A1, V0, ZERO
3161:                						if (clst == 0) {				/* When disk gets full, clip file size */
9D0096DC  14400005   BNE V0, ZERO, 0x9D0096F4
9D0096E0  00000000   NOP
9D0096E4  0B4025DB   J 0x9D00976C
9D0096E8  02609021   ADDU S2, S3, ZERO
3162:                							ofs = bcs; break;
3163:                						}
3164:                					} else
3165:                #endif
3166:                						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
9D0096EC  0F403E01   JAL get_fat
9D0096F0  00402821   ADDU A1, V0, ZERO
3167:                					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
9D0096F4  14540007   BNE V0, S4, 0x9D009714
9D0096F8  2C430002   SLTIU V1, V0, 2
9D0096FC  9203000A   LBU V1, 10(S0)
9D009700  2402FF80   ADDIU V0, ZERO, -128
9D009704  00621025   OR V0, V1, V0
9D009708  A202000A   SB V0, 10(S0)
9D00970C  0B40261F   J 0x9D00987C
9D009710  24020001   ADDIU V0, ZERO, 1
3168:                					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
9D009714  54600007   BNEL V1, ZERO, 0x9D009734
9D009718  9203000A   LBU V1, 10(S0)
9D00971C  8E230004   LW V1, 4(S1)
9D009720  8C63001C   LW V1, 28(V1)
9D009724  0043182B   SLTU V1, V0, V1
9D009728  54600007   BNEL V1, ZERO, 0x9D009748
9D00972C  AE220018   SW V0, 24(S1)
9D009730  9203000A   LBU V1, 10(S0)
9D009734  2402FF80   ADDIU V0, ZERO, -128
9D009738  00621025   OR V0, V1, V0
9D00973C  A202000A   SB V0, 10(S0)
9D009740  0B40261F   J 0x9D00987C
9D009744  24020002   ADDIU V0, ZERO, 2
3169:                					fp->clust = clst;
3170:                					fp->fptr += bcs;
9D009748  8E23000C   LW V1, 12(S1)
9D00974C  00731821   ADDU V1, V1, S3
9D009750  AE23000C   SW V1, 12(S1)
3171:                					ofs -= bcs;
9D009754  02539023   SUBU S2, S2, S3
3172:                				}
3173:                				fp->fptr += ofs;
9D00976C  8E03000C   LW V1, 12(S0)
9D009770  00721821   ADDU V1, V1, S2
9D009774  AE03000C   SW V1, 12(S0)
3174:                				if (ofs % SS(fp->fs)) {
9D009778  324301FF   ANDI V1, S2, 511
9D00977C  1060000D   BEQ V1, ZERO, 0x9D0097B4
9D009780  00008821   ADDU S1, ZERO, ZERO
3175:                					nsect = clust2sect(fp->fs, clst);	/* Current sector */
9D009784  8E040004   LW A0, 4(S0)
9D009788  0F405AB1   JAL clust2sect
9D00978C  00402821   ADDU A1, V0, ZERO
3176:                					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
9D009790  14400007   BNE V0, ZERO, 0x9D0097B0
9D009794  00128A42   SRL S1, S2, 9
9D009798  9203000A   LBU V1, 10(S0)
9D00979C  2402FF80   ADDIU V0, ZERO, -128
9D0097A0  00621025   OR V0, V1, V0
9D0097A4  A202000A   SB V0, 10(S0)
9D0097A8  0B40261F   J 0x9D00987C
9D0097AC  24020002   ADDIU V0, ZERO, 2
9D0097B0  00518821   ADDU S1, V0, S1
3177:                					nsect += ofs / SS(fp->fs);
3178:                				}
3179:                			}
3180:                		}
3181:                		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
9D0097B4  8E02000C   LW V0, 12(S0)
9D0097B8  304201FF   ANDI V0, V0, 511
9D0097BC  50400026   BEQL V0, ZERO, 0x9D009858
9D0097C0  8E02000C   LW V0, 12(S0)
9D0097C4  8E06001C   LW A2, 28(S0)
9D0097C8  50D10023   BEQL A2, S1, 0x9D009858
9D0097CC  8E02000C   LW V0, 12(S0)
3182:                #if !_FS_TINY
3183:                #if !_FS_READONLY
3184:                			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
9D0097D0  9202000A   LBU V0, 10(S0)
9D0097D4  30420040   ANDI V0, V0, 64
9D0097D8  304200FF   ANDI V0, V0, 255
9D0097DC  10400010   BEQ V0, ZERO, 0x9D009820
9D0097E0  8E020004   LW V0, 4(S0)
3185:                				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
9D0097E4  90440001   LBU A0, 1(V0)
9D0097E8  2605002C   ADDIU A1, S0, 44
9D0097EC  0F405432   JAL disk_write
9D0097F0  24070001   ADDIU A3, ZERO, 1
9D0097F4  50400007   BEQL V0, ZERO, 0x9D009814
9D0097F8  9202000A   LBU V0, 10(S0)
3186:                					ABORT(fp->fs, FR_DISK_ERR);
9D0097FC  9203000A   LBU V1, 10(S0)
9D009800  2402FF80   ADDIU V0, ZERO, -128
9D009804  00621025   OR V0, V1, V0
9D009808  A202000A   SB V0, 10(S0)
9D00980C  0B40261F   J 0x9D00987C
9D009810  24020001   ADDIU V0, ZERO, 1
3187:                				fp->flag &= ~FA__DIRTY;
9D009814  304200BF   ANDI V0, V0, 191
9D009818  A202000A   SB V0, 10(S0)
3188:                			}
3189:                #endif
3190:                			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
9D00981C  8E020004   LW V0, 4(S0)
9D009820  90440001   LBU A0, 1(V0)
9D009824  2605002C   ADDIU A1, S0, 44
9D009828  02203021   ADDU A2, S1, ZERO
9D00982C  0F40561B   JAL disk_read
9D009830  24070001   ADDIU A3, ZERO, 1
9D009834  50400007   BEQL V0, ZERO, 0x9D009854
9D009838  AE11001C   SW S1, 28(S0)
3191:                				ABORT(fp->fs, FR_DISK_ERR);
9D00983C  9203000A   LBU V1, 10(S0)
9D009840  2402FF80   ADDIU V0, ZERO, -128
9D009844  00621025   OR V0, V1, V0
9D009848  A202000A   SB V0, 10(S0)
9D00984C  0B40261F   J 0x9D00987C
9D009850  24020001   ADDIU V0, ZERO, 1
3192:                #endif
3193:                			fp->dsect = nsect;
3194:                		}
3195:                #if !_FS_READONLY
3196:                		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
9D009854  8E02000C   LW V0, 12(S0)
9D009858  8E030010   LW V1, 16(S0)
9D00985C  0062182B   SLTU V1, V1, V0
9D009860  50600006   BEQL V1, ZERO, 0x9D00987C
9D009864  00001021   ADDU V0, ZERO, ZERO
3197:                			fp->fsize = fp->fptr;
9D009868  AE020010   SW V0, 16(S0)
3198:                			fp->flag |= FA__WRITTEN;
9D00986C  9202000A   LBU V0, 10(S0)
9D009870  34420020   ORI V0, V0, 32
9D009874  A202000A   SB V0, 10(S0)
3199:                		}
3200:                #endif
3201:                	}
3202:                
3203:                	LEAVE_FF(fp->fs, res);
9D009878  00001021   ADDU V0, ZERO, ZERO
3204:                }
9D00987C  8FBF0024   LW RA, 36(SP)
3205:                
3206:                
3207:                
3208:                #if _FS_MINIMIZE <= 1
3209:                /*-----------------------------------------------------------------------*/
3210:                /* Create a Directory Object                                             */
3211:                /*-----------------------------------------------------------------------*/
3212:                
3213:                int f_opendir (
3214:                	uintptr_t handle,       /* Pointer to directory object to create */
3215:                	const TCHAR *path	/* Pointer to the directory path */
3216:                )
3217:                {
9D011C00  27BDFFD8   ADDIU SP, SP, -40
9D011C04  AFBF0024   SW RA, 36(SP)
9D011C08  AFB00020   SW S0, 32(SP)
9D011C0C  AFA5002C   SW A1, 44(SP)
3218:                	FRESULT res;
3219:                	FATFS *fs;
3220:                	DEF_NAMEBUF;
3221:                        uint32_t hFATfs;
3222:                        DIR *dj;
3223:                
3224:                        for(hFATfs = 0; hFATfs < SYS_FS_MAX_FILES; hFATfs++)
3225:                        {
3226:                            if(FATFSDirObject[hFATfs].inUse == 0)
9D011C10  3C028001   LUI V0, -32767
9D011C14  9043463C   LBU V1, 17980(V0)
9D011C18  1460003D   BNE V1, ZERO, 0x9D011D10
9D011C1C  24020009   ADDIU V0, ZERO, 9
3227:                            {
3228:                                FATFSDirObject[hFATfs].inUse = 1;
9D011C20  3C108001   LUI S0, -32767
9D011C24  24020001   ADDIU V0, ZERO, 1
9D011C28  A202463C   SB V0, 17980(S0)
3229:                                dj = &FATFSDirObject[hFATfs].dirObj;
3230:                                *(uintptr_t *)handle = (uintptr_t)&FATFSDirObject[hFATfs];
9D011C2C  2610463C   ADDIU S0, S0, 17980
9D011C30  AC900000   SW S0, 0(A0)
3231:                                break;
3232:                            }
3233:                        }
3234:                
3235:                        if(hFATfs >= SYS_FS_MAX_FILES)
3236:                        {
3237:                            return FR_INVALID_OBJECT;
3238:                        }
3239:                
3240:                	if (!dj) return FR_INVALID_OBJECT;
3241:                
3242:                	res = chk_mounted(&path, &dj->fs, 0);
9D011C34  27A4002C   ADDIU A0, SP, 44
9D011C38  3C058001   LUI A1, -32767
9D011C3C  24A54640   ADDIU A1, A1, 17984
9D011C40  0F4016DE   JAL chk_mounted
9D011C44  00003021   ADDU A2, ZERO, ZERO
3243:                	fs = dj->fs;
3244:                	if (res == FR_OK) {
9D011C48  14400025   BNE V0, ZERO, 0x9D011CE0
9D011C4C  8E100004   LW S0, 4(S0)
3245:                		INIT_BUF(*dj);
9D011C50  3C028001   LUI V0, -32767
9D011C54  2442463C   ADDIU V0, V0, 17980
9D011C58  27A30010   ADDIU V1, SP, 16
9D011C5C  AC43001C   SW V1, 28(V0)
9D011C60  3C038001   LUI V1, -32767
9D011C64  24634430   ADDIU V1, V1, 17456
9D011C68  AC430020   SW V1, 32(V0)
3246:                		res = follow_path(dj, path);			/* Follow the path to the directory */
9D011C6C  3C048001   LUI A0, -32767
9D011C70  24844640   ADDIU A0, A0, 17984
9D011C74  0F4010FC   JAL follow_path
9D011C78  8FA5002C   LW A1, 44(SP)
3247:                		FREE_BUF();
3248:                		if (res == FR_OK) {						/* Follow completed */
9D011C7C  1440000F   BNE V0, ZERO, 0x9D011CBC
9D011C80  24030004   ADDIU V1, ZERO, 4
3249:                			if (dj->dir) {						/* It is not the root dir */
9D011C84  3C028001   LUI V0, -32767
9D011C88  8C454654   LW A1, 18004(V0)
9D011C8C  50A00018   BEQL A1, ZERO, 0x9D011CF0
9D011C90  96030006   LHU V1, 6(S0)
3250:                				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
9D011C94  90A2000B   LBU V0, 11(A1)
9D011C98  30420010   ANDI V0, V0, 16
9D011C9C  304200FF   ANDI V0, V0, 255
9D011CA0  5040000C   BEQL V0, ZERO, 0x9D011CD4
9D011CA4  24020005   ADDIU V0, ZERO, 5
3251:                					dj->sclust = ld_clust(fs, dj->dir);
9D011CA8  0F4059DD   JAL ld_clust
9D011CAC  02002021   ADDU A0, S0, ZERO
9D011CB0  3C038001   LUI V1, -32767
9D011CB4  0B40473B   J 0x9D011CEC
9D011CB8  AC624648   SW V0, 17992(V1)
3252:                				} else {						/* The object is not a directory */
3253:                					res = FR_NO_PATH;
3254:                				}
3255:                			}
3256:                			if (res == FR_OK) {
3257:                				dj->id = fs->id;
9D011CEC  96030006   LHU V1, 6(S0)
9D011CF0  3C028001   LUI V0, -32767
9D011CF4  A4434644   SH V1, 17988(V0)
3258:                				res = dir_sdi(dj, 0);			/* Rewind dir */
9D011CF8  3C048001   LUI A0, -32767
9D011CFC  24844640   ADDIU A0, A0, 17984
9D011D00  0F404499   JAL dir_sdi
9D011D04  00002821   ADDU A1, ZERO, ZERO
3259:                			}
3260:                		}
3261:                		if (res == FR_NO_FILE) res = FR_NO_PATH;
9D011CBC  50430005   BEQL V0, V1, 0x9D011CD4
9D011CC0  24020005   ADDIU V0, ZERO, 5
9D011D08  0B40472F   J 0x9D011CBC
9D011D0C  24030004   ADDIU V1, ZERO, 4
3262:                		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
9D011CC4  10400013   BEQ V0, ZERO, 0x9D011D14
9D011CC8  8FBF0024   LW RA, 36(SP)
9D011CCC  0B404736   J 0x9D011CD8
9D011CD0  3C038001   LUI V1, -32767
9D011CD4  3C038001   LUI V1, -32767
9D011CD8  0B404744   J 0x9D011D10
9D011CDC  AC604640   SW ZERO, 17984(V1)
3263:                	} else {
3264:                		dj->fs = 0;
9D011CE0  3C038001   LUI V1, -32767
3265:                	}
3266:                
3267:                	LEAVE_FF(fs, res);
9D011CE4  0B404744   J 0x9D011D10
9D011CE8  AC604640   SW ZERO, 17984(V1)
3268:                }
9D011D10  8FBF0024   LW RA, 36(SP)
3269:                
3270:                /*-----------------------------------------------------------------------*/
3271:                /* Closes a Directory Object                                             */
3272:                /*-----------------------------------------------------------------------*/
3273:                
3274:                int f_closedir (
3275:                	uintptr_t handle       /* Pointer to directory object to close */
3276:                )
3277:                {
3278:                        FATFS_DIR_OBJECT *ptr = (FATFS_DIR_OBJECT *)handle;
3279:                
3280:                        if(ptr->inUse != 1)
9D01700C  90850000   LBU A1, 0(A0)
9D017010  24030001   ADDIU V1, ZERO, 1
9D017014  14A30003   BNE A1, V1, 0x9D017024
9D017018  24020009   ADDIU V0, ZERO, 9
3281:                        {
3282:                            return FR_INVALID_OBJECT;
3283:                        }
3284:                        else
3285:                        {
3286:                            ptr->inUse = 0;
9D01701C  A0800000   SB ZERO, 0(A0)
3287:                            return FR_OK;
9D017020  00001021   ADDU V0, ZERO, ZERO
3288:                        }
3289:                }
9D017024  03E00008   JR RA
3290:                
3291:                
3292:                
3293:                
3294:                /*-----------------------------------------------------------------------*/
3295:                /* Read Directory Entry in Sequence                                      */
3296:                /*-----------------------------------------------------------------------*/
3297:                
3298:                int f_readdir (
3299:                	uintptr_t handle,	/* Pointer to the open directory object */
3300:                	uintptr_t fileInfo	/* Pointer to file information to return */
3301:                )
3302:                {
9D0136F0  27BDFFC8   ADDIU SP, SP, -56
9D0136F4  AFBF0034   SW RA, 52(SP)
9D0136F8  AFB30030   SW S3, 48(SP)
9D0136FC  AFB2002C   SW S2, 44(SP)
9D013700  AFB10028   SW S1, 40(SP)
9D013704  AFB00024   SW S0, 36(SP)
9D013708  00808821   ADDU S1, A0, ZERO
9D01370C  00A09821   ADDU S3, A1, ZERO
3303:                	FRESULT res;
3304:                	DEF_NAMEBUF;
3305:                        
3306:                        FATFS_DIR_OBJECT *ptr = (FATFS_DIR_OBJECT *)handle;
3307:                        DIR *dj = &ptr->dirObj;
9D013710  24920004   ADDIU S2, A0, 4
3308:                
3309:                        FILINFO *fno = (FILINFO *)fileInfo;
3310:                
3311:                
3312:                	res = validate(dj);						/* Check validity of the object */
9D013714  0F40563A   JAL validate
9D013718  02402021   ADDU A0, S2, ZERO
3313:                	if (res == FR_OK) {
9D01371C  14400020   BNE V0, ZERO, 0x9D0137A0
9D013720  00408021   ADDU S0, V0, ZERO
3314:                		if (!fno) {
9D013724  16600006   BNE S3, ZERO, 0x9D013740
9D013728  27A20010   ADDIU V0, SP, 16
3315:                			res = dir_sdi(dj, 0);			/* Rewind the directory object */
9D01372C  02402021   ADDU A0, S2, ZERO
9D013730  0F404499   JAL dir_sdi
9D013734  00002821   ADDU A1, ZERO, ZERO
9D013738  0B404DE8   J 0x9D0137A0
9D01373C  00408021   ADDU S0, V0, ZERO
3316:                		} else {
3317:                			INIT_BUF(*dj);
9D013740  AE22001C   SW V0, 28(S1)
9D013744  3C028001   LUI V0, -32767
9D013748  24424430   ADDIU V0, V0, 17456
9D01374C  AE220020   SW V0, 32(S1)
3318:                			res = dir_read(dj, 0);			/* Read an item */
9D013750  02402021   ADDU A0, S2, ZERO
9D013754  0F403396   JAL dir_read
9D013758  00002821   ADDU A1, ZERO, ZERO
3319:                			if (res == FR_NO_FILE) {		/* Reached end of dir */
9D01375C  24030004   ADDIU V1, ZERO, 4
9D013760  14430003   BNE V0, V1, 0x9D013770
9D013764  00000000   NOP
3320:                				dj->sect = 0;
9D013768  0B404DDE   J 0x9D013778
9D01376C  AE200014   SW ZERO, 20(S1)
3321:                				res = FR_OK;
3322:                			}
3323:                			if (res == FR_OK) {				/* A valid entry is found */
9D013770  5440000B   BNEL V0, ZERO, 0x9D0137A0
9D013774  00408021   ADDU S0, V0, ZERO
3324:                				get_fileinfo(dj, fno);		/* Get the object information */
9D013778  02402021   ADDU A0, S2, ZERO
9D01377C  0F402F89   JAL get_fileinfo
9D013780  02602821   ADDU A1, S3, ZERO
3325:                				res = dir_next(dj, 0);		/* Increment index for next */
9D013784  02402021   ADDU A0, S2, ZERO
9D013788  0F403722   JAL dir_next
9D01378C  00002821   ADDU A1, ZERO, ZERO
3326:                				if (res == FR_NO_FILE) {
9D013790  24030004   ADDIU V1, ZERO, 4
9D013794  54430002   BNEL V0, V1, 0x9D0137A0
9D013798  00408021   ADDU S0, V0, ZERO
9D01379C  AE200014   SW ZERO, 20(S1)
3327:                					dj->sect = 0;
3328:                					res = FR_OK;
3329:                				}
3330:                			}
3331:                			FREE_BUF();
3332:                		}
3333:                	}
3334:                
3335:                	LEAVE_FF(dj->fs, res);
3336:                }
9D0137A0  02001021   ADDU V0, S0, ZERO
3337:                
3338:                
3339:                
3340:                #if _FS_MINIMIZE == 0
3341:                /*-----------------------------------------------------------------------*/
3342:                /* Get File Status                                                       */
3343:                /*-----------------------------------------------------------------------*/
3344:                
3345:                int f_stat (
3346:                	const char *path,	/* Pointer to the file path */
3347:                	uintptr_t ptr		/* Pointer to file information to return */
3348:                )
3349:                {
9D0140BC  27BDFFB0   ADDIU SP, SP, -80
9D0140C0  AFBF004C   SW RA, 76(SP)
9D0140C4  AFB10048   SW S1, 72(SP)
9D0140C8  AFB00044   SW S0, 68(SP)
9D0140CC  AFA40050   SW A0, 80(SP)
9D0140D0  00A08821   ADDU S1, A1, ZERO
3350:                	FRESULT res = FR_OK;
3351:                	DIR dj = {};
9D0140D4  AFA00010   SW ZERO, 16(SP)
9D0140D8  AFA00014   SW ZERO, 20(SP)
9D0140DC  AFA00018   SW ZERO, 24(SP)
9D0140E0  AFA0001C   SW ZERO, 28(SP)
9D0140E4  AFA00020   SW ZERO, 32(SP)
9D0140E8  AFA00024   SW ZERO, 36(SP)
9D0140EC  AFA00028   SW ZERO, 40(SP)
9D0140F0  AFA0002C   SW ZERO, 44(SP)
9D0140F4  AFA00030   SW ZERO, 48(SP)
3352:                	DEF_NAMEBUF;
3353:                    FILINFO *fno = (FILINFO *)NULL;
3354:                    fno = (FILINFO *)ptr;
3355:                
3356:                
3357:                	res = chk_mounted(&path, &dj.fs, 0);
9D0140F8  27A40050   ADDIU A0, SP, 80
9D0140FC  27A50010   ADDIU A1, SP, 16
9D014100  0F4016DE   JAL chk_mounted
9D014104  00003021   ADDU A2, ZERO, ZERO
3358:                	if (res == FR_OK) {
9D014108  14400013   BNE V0, ZERO, 0x9D014158
9D01410C  00408021   ADDU S0, V0, ZERO
3359:                		INIT_BUF(dj);
9D014110  27A20034   ADDIU V0, SP, 52
9D014114  AFA20028   SW V0, 40(SP)
9D014118  3C028001   LUI V0, -32767
9D01411C  24424430   ADDIU V0, V0, 17456
9D014120  AFA2002C   SW V0, 44(SP)
3360:                		res = follow_path(&dj, path);	/* Follow the file path */
9D014124  27A40010   ADDIU A0, SP, 16
9D014128  0F4010FC   JAL follow_path
9D01412C  8FA50050   LW A1, 80(SP)
3361:                		if (res == FR_OK) {				/* Follow completed */
9D014130  14400009   BNE V0, ZERO, 0x9D014158
9D014134  00408021   ADDU S0, V0, ZERO
3362:                			if (dj.dir)		/* Found an object */
9D014138  8FA20024   LW V0, 36(SP)
9D01413C  10400005   BEQ V0, ZERO, 0x9D014154
9D014140  27A40010   ADDIU A0, SP, 16
3363:                				get_fileinfo(&dj, fno);
9D014144  0F402F89   JAL get_fileinfo
9D014148  02202821   ADDU A1, S1, ZERO
9D01414C  0B405057   J 0x9D01415C
9D014150  02001021   ADDU V0, S0, ZERO
3364:                			else			/* It is root dir */
3365:                				res = FR_INVALID_NAME;
9D014154  24100006   ADDIU S0, ZERO, 6
3366:                		}
3367:                		FREE_BUF();
3368:                	}
3369:                
3370:                	LEAVE_FF(dj.fs, res);
3371:                }
9D014158  02001021   ADDU V0, S0, ZERO
3372:                
3373:                
3374:                
3375:                #if !_FS_READONLY
3376:                /*-----------------------------------------------------------------------*/
3377:                /* Get Number of Free Clusters                                           */
3378:                /*-----------------------------------------------------------------------*/
3379:                
3380:                FRESULT f_getfree (
3381:                	const TCHAR *path,	/* Path name of the logical drive number */
3382:                	uint32_t *nclst,		/* Pointer to a variable to return number of free clusters */
3383:                	FATFS **fatfs		/* Pointer to return pointer to corresponding file system object */
3384:                )
3385:                {
9D00E240  27BDFFC8   ADDIU SP, SP, -56
9D00E244  AFBF0034   SW RA, 52(SP)
9D00E248  AFB70030   SW S7, 48(SP)
9D00E24C  AFB6002C   SW S6, 44(SP)
9D00E250  AFB50028   SW S5, 40(SP)
9D00E254  AFB40024   SW S4, 36(SP)
9D00E258  AFB30020   SW S3, 32(SP)
9D00E25C  AFB2001C   SW S2, 28(SP)
9D00E260  AFB10018   SW S1, 24(SP)
9D00E264  AFB00014   SW S0, 20(SP)
9D00E268  AFA40038   SW A0, 56(SP)
9D00E26C  00A0B021   ADDU S6, A1, ZERO
9D00E270  00C08021   ADDU S0, A2, ZERO
3386:                	FRESULT res = FR_OK;
3387:                	FATFS *fs = (FATFS *)NULL;
3388:                	uint32_t n = 0, clst = 0, sect = 0, stat = 0;
3389:                	uint32_t i = 0;
3390:                	uint8_t fat = 0, *p = NULL;
3391:                
3392:                
3393:                	/* Get drive number */
3394:                	res = chk_mounted(&path, fatfs, 0);
9D00E274  27A40038   ADDIU A0, SP, 56
9D00E278  00C02821   ADDU A1, A2, ZERO
9D00E27C  0F4016DE   JAL chk_mounted
9D00E280  00003021   ADDU A2, ZERO, ZERO
9D00E284  0040A821   ADDU S5, V0, ZERO
3395:                	fs = *fatfs;
3396:                	if (res == FR_OK) {
9D00E288  14400056   BNE V0, ZERO, 0x9D00E3E4
9D00E28C  8E120000   LW S2, 0(S0)
3397:                		/* If free_clust is valid, return it without full cluster scan */
3398:                		if (fs->free_clust <= fs->n_fatent - 2) {
9D00E290  8E420010   LW V0, 16(S2)
9D00E294  8E50001C   LW S0, 28(S2)
9D00E298  2603FFFE   ADDIU V1, S0, -2
9D00E29C  0062182B   SLTU V1, V1, V0
9D00E2A0  54600003   BNEL V1, ZERO, 0x9D00E2B0
9D00E2A4  92530000   LBU S3, 0(S2)
9D00E2A8  0B4038F9   J 0x9D00E3E4
9D00E2AC  AEC20000   SW V0, 0(S6)
3399:                			*nclst = fs->free_clust;
3400:                		} else {
3401:                			/* Get number of free clusters */
3402:                			fat = fs->fs_type;
3403:                			n = 0;
9D00E310  00008821   ADDU S1, ZERO, ZERO
3404:                			if (fat == FS_FAT12) {
9D00E2B0  24020001   ADDIU V0, ZERO, 1
9D00E2B4  56620014   BNEL S3, V0, 0x9D00E308
9D00E2B8  8E450028   LW A1, 40(S2)
9D00E2BC  24100002   ADDIU S0, ZERO, 2
9D00E2C0  00008821   ADDU S1, ZERO, ZERO
3405:                				clst = 2;
3406:                				do {
3407:                					stat = get_fat(fs, clst);
9D00E2CC  02402021   ADDU A0, S2, ZERO
9D00E2D0  0F403E01   JAL get_fat
9D00E2D4  02002821   ADDU A1, S0, ZERO
3408:                					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
9D00E2C4  2413FFFF   ADDIU S3, ZERO, -1
9D00E2D8  50530040   BEQL V0, S3, 0x9D00E3DC
9D00E2DC  24150001   ADDIU S5, ZERO, 1
3409:                					if (stat == 1) { res = FR_INT_ERR; break; }
9D00E2C8  24140001   ADDIU S4, ZERO, 1
9D00E2E0  1054003D   BEQ V0, S4, 0x9D00E3D8
9D00E2E4  2C420001   SLTIU V0, V0, 1
9D00E3D8  24150002   ADDIU S5, ZERO, 2
3410:                					if (stat == 0) n++;
9D00E2E8  02228821   ADDU S1, S1, V0
3411:                				} while (++clst < fs->n_fatent);
9D00E2EC  26100001   ADDIU S0, S0, 1
9D00E2F0  8E42001C   LW V0, 28(S2)
9D00E2F4  0202102B   SLTU V0, S0, V0
9D00E2F8  1440FFF5   BNE V0, ZERO, 0x9D00E2D0
9D00E2FC  02402021   ADDU A0, S2, ZERO
9D00E300  0B4038F4   J 0x9D00E3D0
9D00E304  AE510010   SW S1, 16(S2)
3412:                			} else {
3413:                				clst = fs->n_fatent;
3414:                				sect = fs->fatbase;
3415:                				i = 0; p = 0;
9D00E308  00001821   ADDU V1, ZERO, ZERO
9D00E30C  00003021   ADDU A2, ZERO, ZERO
3416:                				do {
3417:                					if (!i) {
9D00E318  14C00007   BNE A2, ZERO, 0x9D00E338
9D00E31C  24B70001   ADDIU S7, A1, 1
3418:                						res = move_window(fs, sect++);
9D00E320  0F405691   JAL move_window
9D00E324  02402021   ADDU A0, S2, ZERO
9D00E330  02E02821   ADDU A1, S7, ZERO
9D00E3B4  0040A821   ADDU S5, V0, ZERO
3419:                						if (res != FR_OK) break;
9D00E328  14400022   BNE V0, ZERO, 0x9D00E3B4
9D00E32C  26430038   ADDIU V1, S2, 56
3420:                						p = fs->win;
3421:                						i = SS(fs);
9D00E334  24060200   ADDIU A2, ZERO, 512
3422:                					}
3423:                					if (fat == FS_FAT16) {
9D00E314  24140002   ADDIU S4, ZERO, 2
9D00E338  5674000B   BNEL S3, S4, 0x9D00E368
9D00E33C  90640003   LBU A0, 3(V1)
3424:                						if (LD_WORD(p) == 0) n++;
9D00E340  90620001   LBU V0, 1(V1)
9D00E344  00021200   SLL V0, V0, 8
9D00E348  90640000   LBU A0, 0(V1)
9D00E34C  00441025   OR V0, V0, A0
9D00E350  7C021620   SEH V0, V0
9D00E354  2C420001   SLTIU V0, V0, 1
9D00E358  02228821   ADDU S1, S1, V0
3425:                						p += 2; i -= 2;
9D00E35C  24630002   ADDIU V1, V1, 2
9D00E360  0B4038E8   J 0x9D00E3A0
9D00E364  24C6FFFE   ADDIU A2, A2, -2
3426:                					} else {
3427:                						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
9D00E368  00042600   SLL A0, A0, 24
9D00E36C  90620002   LBU V0, 2(V1)
9D00E370  00021400   SLL V0, V0, 16
9D00E374  00821025   OR V0, A0, V0
9D00E378  90640000   LBU A0, 0(V1)
9D00E37C  00441025   OR V0, V0, A0
9D00E380  90640001   LBU A0, 1(V1)
9D00E384  00042200   SLL A0, A0, 8
9D00E388  00441025   OR V0, V0, A0
9D00E38C  7C42D800   EXT V0, V0, 0, 28
9D00E390  2C420001   SLTIU V0, V0, 1
9D00E394  02228821   ADDU S1, S1, V0
3428:                						p += 4; i -= 4;
9D00E398  24630004   ADDIU V1, V1, 4
9D00E39C  24C6FFFC   ADDIU A2, A2, -4
3429:                					}
3430:                				} while (--clst);
9D00E3A0  2610FFFF   ADDIU S0, S0, -1
9D00E3A4  1600FFDC   BNE S0, ZERO, 0x9D00E318
9D00E3A8  00000000   NOP
9D00E3AC  0B4038EF   J 0x9D00E3BC
9D00E3B0  AE510010   SW S1, 16(S2)
3431:                			}
3432:                			fs->free_clust = n;
9D00E3B8  AE510010   SW S1, 16(S2)
9D00E3DC  0B4038F4   J 0x9D00E3D0
9D00E3E0  AE510010   SW S1, 16(S2)
3433:                			if (fat == FS_FAT32) fs->fsi_flag = 1;
9D00E3BC  24020003   ADDIU V0, ZERO, 3
9D00E3C0  56620008   BNEL S3, V0, 0x9D00E3E4
9D00E3C4  AED10000   SW S1, 0(S6)
9D00E3C8  24020001   ADDIU V0, ZERO, 1
9D00E3CC  A2420005   SB V0, 5(S2)
3434:                			*nclst = n;
9D00E3D0  0B4038F9   J 0x9D00E3E4
9D00E3D4  AED10000   SW S1, 0(S6)
3435:                		}
3436:                	}
3437:                	LEAVE_FF(fs, res);
3438:                }
9D00E3E4  02A01021   ADDU V0, S5, ZERO
3439:                
3440:                /*-----------------------------------------------------------------------*/
3441:                /* Function below written separately.                                    */
3442:                /* Not from standard FAT FS code. It is added to allow compatibility with*/
3443:                /* other FS, as this function does not need "FATFS **fatfs"              */
3444:                /*-----------------------------------------------------------------------*/
3445:                
3446:                int f_getclusters (const char *path, uint32_t *tot_sec, uint32_t *free_sec)
3447:                {
9D0157F0  27BDFFD8   ADDIU SP, SP, -40
9D0157F4  AFBF0024   SW RA, 36(SP)
9D0157F8  AFB10020   SW S1, 32(SP)
9D0157FC  AFB0001C   SW S0, 28(SP)
9D015800  00A08821   ADDU S1, A1, ZERO
9D015804  00C08021   ADDU S0, A2, ZERO
3448:                    FATFS *ptr = (FATFS *)NULL;
9D015808  AFA00010   SW ZERO, 16(SP)
3449:                    uint32_t clst = 0;
9D01580C  AFA00014   SW ZERO, 20(SP)
3450:                    FRESULT res = FR_OK;
3451:                
3452:                    res = f_getfree(path, &clst, &ptr);
9D015810  27A50014   ADDIU A1, SP, 20
9D015814  0F403890   JAL f_getfree
9D015818  27A60010   ADDIU A2, SP, 16
3453:                
3454:                    if(res != FR_OK)
9D01581C  50400004   BEQL V0, ZERO, 0x9D015830
9D015820  8FA20010   LW V0, 16(SP)
3455:                    {
3456:                        *tot_sec = 0;
9D015824  AE200000   SW ZERO, 0(S1)
3457:                        *free_sec = 0;
3458:                        return (int)res;
9D015828  0B405616   J 0x9D015858
9D01582C  AE000000   SW ZERO, 0(S0)
3459:                    }
3460:                
3461:                    /* Get total sectors and free sectors */
3462:                    *tot_sec = (ptr->n_fatent - 2) * ptr->csize;
9D015830  90440002   LBU A0, 2(V0)
9D015834  8C43001C   LW V1, 28(V0)
9D015838  2463FFFE   ADDIU V1, V1, -2
9D01583C  70831802   MUL V1, A0, V1
9D015840  AE230000   SW V1, 0(S1)
3463:                    *free_sec = clst * ptr->csize;
9D015844  90430002   LBU V1, 2(V0)
9D015848  8FA20014   LW V0, 20(SP)
9D01584C  70621002   MUL V0, V1, V0
9D015850  AE020000   SW V0, 0(S0)
3464:                
3465:                    return (int)res;
9D015854  00001021   ADDU V0, ZERO, ZERO
3466:                }
9D015858  8FBF0024   LW RA, 36(SP)
3467:                
3468:                
3469:                
3470:                /*-----------------------------------------------------------------------*/
3471:                /* Truncate File                                                         */
3472:                /*-----------------------------------------------------------------------*/
3473:                
3474:                int f_truncate (
3475:                	uintptr_t handle		/* Pointer to the file object */
3476:                )
3477:                {
9D011624  27BDFFE0   ADDIU SP, SP, -32
9D011628  AFBF001C   SW RA, 28(SP)
9D01162C  AFB20018   SW S2, 24(SP)
9D011630  AFB10014   SW S1, 20(SP)
9D011634  AFB00010   SW S0, 16(SP)
9D011638  00808021   ADDU S0, A0, ZERO
3478:                	FRESULT res;
3479:                	uint32_t ncl;
3480:                        FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
3481:                        FIL *fp = &ptr->fileObj;
3482:                
3483:                
3484:                	res = validate(fp);						/* Check validity of the object */
9D01163C  0F40563A   JAL validate
9D011640  24840004   ADDIU A0, A0, 4
3485:                	if (res == FR_OK) {
9D011644  1440003E   BNE V0, ZERO, 0x9D011740
9D011648  00408821   ADDU S1, V0, ZERO
3486:                		if (fp->flag & FA__ERROR) {			/* Check abort flag */
9D01164C  9202000A   LBU V0, 10(S0)
9D011650  7C021C20   SEB V1, V0
9D011654  04600036   BLTZ V1, 0x9D011730
9D011658  30420002   ANDI V0, V0, 2
3487:                			res = FR_INT_ERR;
9D011730  0B4045D0   J 0x9D011740
9D011734  24110002   ADDIU S1, ZERO, 2
3488:                		} else {
3489:                			if (!(fp->flag & FA_WRITE))		/* Check access mode */
9D01165C  304200FF   ANDI V0, V0, 255
9D011660  50400037   BEQL V0, ZERO, 0x9D011740
9D011664  24110007   ADDIU S1, ZERO, 7
9D011668  0B4045C6   J 0x9D011718
9D01166C  8E02000C   LW V0, 12(S0)
3490:                				res = FR_DENIED;
3491:                		}
3492:                	}
3493:                	if (res == FR_OK) {
3494:                		if (fp->fsize > fp->fptr) {
9D011718  8E030010   LW V1, 16(S0)
9D01171C  0043182B   SLTU V1, V0, V1
9D011720  5460FFD3   BNEL V1, ZERO, 0x9D011670
9D011724  AE020010   SW V0, 16(S0)
9D011728  0B4045D1   J 0x9D011744
9D01172C  02201021   ADDU V0, S1, ZERO
3495:                			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
3496:                			fp->flag |= FA__WRITTEN;
9D011670  9203000A   LBU V1, 10(S0)
9D011674  34630020   ORI V1, V1, 32
3497:                			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
9D011678  14400007   BNE V0, ZERO, 0x9D011698
9D01167C  A203000A   SB V1, 10(S0)
3498:                				res = remove_chain(fp->fs, fp->sclust);
9D011680  8E040004   LW A0, 4(S0)
9D011684  0F404B32   JAL remove_chain
9D011688  8E050014   LW A1, 20(S0)
9D01168C  00408821   ADDU S1, V0, ZERO
9D011690  0B4045BF   J 0x9D0116FC
9D011694  AE000014   SW ZERO, 20(S0)
3499:                				fp->sclust = 0;
3500:                			} else {				/* When truncate a part of the file, remove remaining clusters */
3501:                				ncl = get_fat(fp->fs, fp->clust);
9D011698  8E040004   LW A0, 4(S0)
9D01169C  0F403E01   JAL get_fat
9D0116A0  8E050018   LW A1, 24(S0)
9D0116A4  00409021   ADDU S2, V0, ZERO
3502:                				res = FR_OK;
3503:                				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
9D0116B4  2C420001   SLTIU V0, V0, 1
3504:                				if (ncl == 1) res = FR_INT_ERR;
9D0116A8  24020001   ADDIU V0, ZERO, 1
9D0116AC  12420022   BEQ S2, V0, 0x9D011738
9D0116B0  26420001   ADDIU V0, S2, 1
9D011738  0B4045C1   J 0x9D011704
9D01173C  24110002   ADDIU S1, ZERO, 2
3505:                				if (res == FR_OK && ncl < fp->fs->n_fatent) {
9D0116B8  54400012   BNEL V0, ZERO, 0x9D011704
9D0116BC  00408821   ADDU S1, V0, ZERO
9D0116C0  8E040004   LW A0, 4(S0)
9D0116C4  8C82001C   LW V0, 28(A0)
9D0116C8  0242102B   SLTU V0, S2, V0
9D0116CC  1040001D   BEQ V0, ZERO, 0x9D011744
9D0116D0  02201021   ADDU V0, S1, ZERO
3506:                					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
9D0116D4  8E050018   LW A1, 24(S0)
9D0116D8  3C060FFF   LUI A2, 4095
9D0116DC  0F403A5B   JAL put_fat
9D0116E0  34C6FFFF   ORI A2, A2, -1
3507:                					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
9D0116E4  14400007   BNE V0, ZERO, 0x9D011704
9D0116E8  00408821   ADDU S1, V0, ZERO
9D0116EC  8E040004   LW A0, 4(S0)
9D0116F0  0F404B32   JAL remove_chain
9D0116F4  02402821   ADDU A1, S2, ZERO
9D0116F8  00408821   ADDU S1, V0, ZERO
3508:                				}
3509:                			}
3510:                		}
3511:                		if (res != FR_OK) fp->flag |= FA__ERROR;
9D0116FC  12200011   BEQ S1, ZERO, 0x9D011744
9D011700  02201021   ADDU V0, S1, ZERO
9D011704  9203000A   LBU V1, 10(S0)
9D011708  2402FF80   ADDIU V0, ZERO, -128
9D01170C  00621025   OR V0, V1, V0
9D011710  0B4045D0   J 0x9D011740
9D011714  A202000A   SB V0, 10(S0)
3512:                	}
3513:                
3514:                	LEAVE_FF(fp->fs, res);
3515:                }
9D011740  02201021   ADDU V0, S1, ZERO
3516:                
3517:                
3518:                
3519:                
3520:                /*-----------------------------------------------------------------------*/
3521:                /* Delete a File or Directory                                            */
3522:                /*-----------------------------------------------------------------------*/
3523:                
3524:                int f_unlink (
3525:                	const TCHAR *path		/* Pointer to the file or directory path */
3526:                )
3527:                {
9D00E5E4  27BDFF88   ADDIU SP, SP, -120
9D00E5E8  AFBF0074   SW RA, 116(SP)
9D00E5EC  AFB10070   SW S1, 112(SP)
9D00E5F0  AFB0006C   SW S0, 108(SP)
9D00E5F4  AFA40078   SW A0, 120(SP)
3528:                	FRESULT res = FR_OK;
3529:                	DIR dj = {}, sdj = {};
9D00E5F8  AFA00010   SW ZERO, 16(SP)
9D00E5FC  AFA00014   SW ZERO, 20(SP)
9D00E600  AFA00018   SW ZERO, 24(SP)
9D00E604  AFA0001C   SW ZERO, 28(SP)
9D00E608  AFA00020   SW ZERO, 32(SP)
9D00E60C  AFA00024   SW ZERO, 36(SP)
9D00E610  AFA00028   SW ZERO, 40(SP)
9D00E614  AFA0002C   SW ZERO, 44(SP)
9D00E618  AFA00030   SW ZERO, 48(SP)
9D00E61C  AFA00034   SW ZERO, 52(SP)
9D00E620  AFA00038   SW ZERO, 56(SP)
9D00E624  AFA0003C   SW ZERO, 60(SP)
9D00E628  AFA00040   SW ZERO, 64(SP)
9D00E62C  AFA00044   SW ZERO, 68(SP)
9D00E630  AFA00048   SW ZERO, 72(SP)
9D00E634  AFA0004C   SW ZERO, 76(SP)
9D00E638  AFA00050   SW ZERO, 80(SP)
9D00E63C  AFA00054   SW ZERO, 84(SP)
3530:                	uint8_t *dir = NULL;
3531:                	uint32_t dclst = 0;
3532:                	DEF_NAMEBUF;
3533:                
3534:                
3535:                	res = chk_mounted(&path, &dj.fs, 1);
9D00E640  27A40078   ADDIU A0, SP, 120
9D00E644  27A50010   ADDIU A1, SP, 16
9D00E648  0F4016DE   JAL chk_mounted
9D00E64C  24060001   ADDIU A2, ZERO, 1
3536:                	if (res == FR_OK) {
9D00E650  14400053   BNE V0, ZERO, 0x9D00E7A0
9D00E654  8FBF0074   LW RA, 116(SP)
3537:                		INIT_BUF(dj);
9D00E658  27A20058   ADDIU V0, SP, 88
9D00E65C  AFA20028   SW V0, 40(SP)
9D00E660  3C028001   LUI V0, -32767
9D00E664  24424430   ADDIU V0, V0, 17456
9D00E668  AFA2002C   SW V0, 44(SP)
3538:                		res = follow_path(&dj, path);		/* Follow the file path */
9D00E66C  27A40010   ADDIU A0, SP, 16
9D00E670  0F4010FC   JAL follow_path
9D00E674  8FA50078   LW A1, 120(SP)
3539:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D00E678  14400049   BNE V0, ZERO, 0x9D00E7A0
9D00E67C  8FBF0074   LW RA, 116(SP)
9D00E680  8FA20028   LW V0, 40(SP)
9D00E684  9043000B   LBU V1, 11(V0)
9D00E688  30630020   ANDI V1, V1, 32
9D00E68C  306300FF   ANDI V1, V1, 255
9D00E690  14600042   BNE V1, ZERO, 0x9D00E79C
9D00E694  24020006   ADDIU V0, ZERO, 6
9D00E698  0B4039D4   J 0x9D00E750
9D00E69C  27A40010   ADDIU A0, SP, 16
3540:                			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
3541:                #if _FS_LOCK
3542:                		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
9D00E750  0F405315   JAL chk_lock
9D00E754  24050002   ADDIU A1, ZERO, 2
3543:                #endif
3544:                		if (res == FR_OK) {					/* The object is accessible */
9D00E758  5040FFD1   BEQL V0, ZERO, 0x9D00E6A0
9D00E75C  8FA50024   LW A1, 36(SP)
9D00E760  0B4039E8   J 0x9D00E7A0
9D00E764  8FBF0074   LW RA, 116(SP)
3545:                			dir = dj.dir;
3546:                			if (!dir) {
9D00E6A0  50A0003E   BEQL A1, ZERO, 0x9D00E79C
9D00E6A4  24020006   ADDIU V0, ZERO, 6
3547:                				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
3548:                			} else {
3549:                				if (dir[DIR_Attr] & AM_RDO)
9D00E6A8  90B0000B   LBU S0, 11(A1)
9D00E6AC  32030001   ANDI V1, S0, 1
9D00E6B0  1460003A   BNE V1, ZERO, 0x9D00E79C
9D00E6B4  24020007   ADDIU V0, ZERO, 7
9D00E6B8  0B4039DA   J 0x9D00E768
9D00E6BC  00000000   NOP
3550:                					res = FR_DENIED;		/* Cannot remove R/O object */
3551:                			}
3552:                			dclst = ld_clust(dj.fs, dir);
9D00E768  0F4059DD   JAL ld_clust
9D00E76C  8FA40010   LW A0, 16(SP)
3553:                			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
9D00E770  32100010   ANDI S0, S0, 16
9D00E774  321000FF   ANDI S0, S0, 255
9D00E778  1600FFD1   BNE S0, ZERO, 0x9D00E6C0
9D00E77C  00408821   ADDU S1, V0, ZERO
3554:                				if (dclst < 2) {
9D00E6C0  2E230002   SLTIU V1, S1, 2
9D00E6C4  14600035   BNE V1, ZERO, 0x9D00E79C
9D00E6C8  24020002   ADDIU V0, ZERO, 2
3555:                					res = FR_INT_ERR;
3556:                				} else {
3557:                					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
9D00E6CC  27A40034   ADDIU A0, SP, 52
9D00E6D0  27A50010   ADDIU A1, SP, 16
9D00E6D4  0F405BCE   JAL mem_cpy
9D00E6D8  24060024   ADDIU A2, ZERO, 36
3558:                					sdj.sclust = dclst;
9D00E6DC  AFB1003C   SW S1, 60(SP)
3559:                					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
9D00E6E0  27A40034   ADDIU A0, SP, 52
9D00E6E4  0F404499   JAL dir_sdi
9D00E6E8  24050002   ADDIU A1, ZERO, 2
3560:                					if (res == FR_OK) {
9D00E6EC  1440002C   BNE V0, ZERO, 0x9D00E7A0
9D00E6F0  8FBF0074   LW RA, 116(SP)
3561:                						res = dir_read(&sdj, 0);	/* Read an item */
9D00E6F4  27A40034   ADDIU A0, SP, 52
9D00E6F8  0F403396   JAL dir_read
9D00E6FC  00002821   ADDU A1, ZERO, ZERO
3562:                						if (res == FR_OK		/* Not empty dir */
9D00E700  50400026   BEQL V0, ZERO, 0x9D00E79C
9D00E704  24020007   ADDIU V0, ZERO, 7
3563:                #if _FS_RPATH
3564:                						|| dclst == dj.fs->cdir	/* Current dir */
9D00E708  8FA30010   LW V1, 16(SP)
9D00E70C  8C630018   LW V1, 24(V1)
9D00E710  10710021   BEQ V1, S1, 0x9D00E798
9D00E714  24030004   ADDIU V1, ZERO, 4
3565:                #endif
3566:                						) res = FR_DENIED;
3567:                						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
9D00E718  10430019   BEQ V0, V1, 0x9D00E780
9D00E71C  8FBF0074   LW RA, 116(SP)
9D00E720  0B4039E9   J 0x9D00E7A4
9D00E724  8FB10070   LW S1, 112(SP)
3568:                					}
3569:                				}
3570:                			}
3571:                			if (res == FR_OK) {
3572:                				res = dir_remove(&dj);		/* Remove the directory entry */
9D00E780  0F4050DE   JAL dir_remove
9D00E784  27A40010   ADDIU A0, SP, 16
3573:                				if (res == FR_OK) {
9D00E788  1040FFE7   BEQ V0, ZERO, 0x9D00E728
9D00E78C  8FBF0074   LW RA, 116(SP)
9D00E790  0B4039E9   J 0x9D00E7A4
9D00E794  8FB10070   LW S1, 112(SP)
9D00E798  24020007   ADDIU V0, ZERO, 7
3574:                					if (dclst)				/* Remove the cluster chain if exist */
9D00E728  12200005   BEQ S1, ZERO, 0x9D00E740
9D00E72C  8FA40010   LW A0, 16(SP)
3575:                						res = remove_chain(dj.fs, dclst);
9D00E730  0F404B32   JAL remove_chain
9D00E734  02202821   ADDU A1, S1, ZERO
3576:                					if (res == FR_OK) res = sync_fs(dj.fs);
9D00E738  54400019   BNEL V0, ZERO, 0x9D00E7A0
9D00E73C  8FBF0074   LW RA, 116(SP)
9D00E740  0F4047D7   JAL sync_fs
9D00E744  8FA40010   LW A0, 16(SP)
3577:                				}
3578:                			}
3579:                		}
3580:                		FREE_BUF();
3581:                	}
3582:                
3583:                	LEAVE_FF(dj.fs, res);
3584:                }
9D00E748  0B4039E8   J 0x9D00E7A0
9D00E74C  8FBF0074   LW RA, 116(SP)
9D00E79C  8FBF0074   LW RA, 116(SP)
3585:                
3586:                
3587:                
3588:                
3589:                /*-----------------------------------------------------------------------*/
3590:                /* Create a Directory                                                    */
3591:                /*-----------------------------------------------------------------------*/
3592:                
3593:                int f_mkdir (
3594:                	const TCHAR *path		/* Pointer to the directory path */
3595:                )
3596:                {
9D008F6C  27BDFF80   ADDIU SP, SP, -128
9D008F70  AFBF007C   SW RA, 124(SP)
9D008F74  AFBE0078   SW S8, 120(SP)
9D008F78  AFB70074   SW S7, 116(SP)
9D008F7C  AFB60070   SW S6, 112(SP)
9D008F80  AFB5006C   SW S5, 108(SP)
9D008F84  AFB40068   SW S4, 104(SP)
9D008F88  AFB30064   SW S3, 100(SP)
9D008F8C  AFB20060   SW S2, 96(SP)
9D008F90  AFB1005C   SW S1, 92(SP)
9D008F94  AFB00058   SW S0, 88(SP)
9D008F98  AFA40080   SW A0, 128(SP)
3597:                	FRESULT res = FR_OK;
3598:                	DIR dj = {};
9D008F9C  AFA00010   SW ZERO, 16(SP)
9D008FA0  AFA00014   SW ZERO, 20(SP)
9D008FA4  AFA00018   SW ZERO, 24(SP)
9D008FA8  AFA0001C   SW ZERO, 28(SP)
9D008FAC  AFA00020   SW ZERO, 32(SP)
9D008FB0  AFA00024   SW ZERO, 36(SP)
9D008FB4  AFA00028   SW ZERO, 40(SP)
9D008FB8  AFA0002C   SW ZERO, 44(SP)
3599:                	uint8_t *dir = NULL, n = 0;
3600:                	uint32_t dsc = 0, dcl = 0, pcl = 0, tm = get_fattime();
9D008FBC  0F405C45   JAL get_fattime
9D008FC0  AFA00030   SW ZERO, 48(SP)
9D008FC4  0040A021   ADDU S4, V0, ZERO
3601:                	DEF_NAMEBUF;
3602:                
3603:                
3604:                	res = chk_mounted(&path, &dj.fs, 1);
9D008FC8  27A40080   ADDIU A0, SP, 128
9D008FCC  27A50010   ADDIU A1, SP, 16
9D008FD0  0F4016DE   JAL chk_mounted
9D008FD4  24060001   ADDIU A2, ZERO, 1
3605:                	if (res == FR_OK) {
9D008FD8  1440009D   BNE V0, ZERO, 0x9D009250
9D008FDC  00408021   ADDU S0, V0, ZERO
3606:                		INIT_BUF(dj);
9D008FE0  27A20034   ADDIU V0, SP, 52
9D008FE4  AFA20028   SW V0, 40(SP)
9D008FE8  3C028001   LUI V0, -32767
9D008FEC  24424430   ADDIU V0, V0, 17456
9D008FF0  AFA2002C   SW V0, 44(SP)
3607:                		res = follow_path(&dj, path);			/* Follow the file path */
9D008FF4  27A40010   ADDIU A0, SP, 16
9D008FF8  0F4010FC   JAL follow_path
9D008FFC  8FA50080   LW A1, 128(SP)
3608:                		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
9D009000  50400093   BEQL V0, ZERO, 0x9D009250
9D009004  24100008   ADDIU S0, ZERO, 8
3609:                		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
9D009008  24030004   ADDIU V1, ZERO, 4
9D00900C  54430090   BNEL V0, V1, 0x9D009250
9D009010  00408021   ADDU S0, V0, ZERO
9D009014  8FA20028   LW V0, 40(SP)
9D009018  9042000B   LBU V0, 11(V0)
9D00901C  30420020   ANDI V0, V0, 32
9D009020  304200FF   ANDI V0, V0, 255
9D009024  5440008A   BNEL V0, ZERO, 0x9D009250
9D009028  24100006   ADDIU S0, ZERO, 6
9D00902C  0B402488   J 0x9D009220
9D009030  8FA40010   LW A0, 16(SP)
3610:                			res = FR_INVALID_NAME;
3611:                		if (res == FR_NO_FILE) {				/* Can create a new directory */
3612:                			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
9D009220  0F403D3A   JAL create_chain
9D009224  00002821   ADDU A1, ZERO, ZERO
3613:                			res = FR_OK;
3614:                			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
9D009050  24100007   ADDIU S0, ZERO, 7
9D009228  1040FF89   BEQ V0, ZERO, 0x9D009050
9D00922C  00409821   ADDU S3, V0, ZERO
9D009230  0B40240D   J 0x9D009034
9D009234  24020001   ADDIU V0, ZERO, 1
3615:                			if (dcl == 1) res = FR_INT_ERR;
9D009034  5262005F   BEQL S3, V0, 0x9D0091B4
9D009038  24100002   ADDIU S0, ZERO, 2
3616:                			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
9D00903C  2402FFFF   ADDIU V0, ZERO, -1
9D009040  5262005C   BEQL S3, V0, 0x9D0091B4
9D009044  24100001   ADDIU S0, ZERO, 1
9D009048  0B402415   J 0x9D009054
9D00904C  00000000   NOP
3617:                			if (res == FR_OK)					/* Flush FAT */
9D009054  16000058   BNE S0, ZERO, 0x9D0091B8
9D009058  8FA40010   LW A0, 16(SP)
3618:                				res = sync_window(dj.fs);
9D00905C  0F404C46   JAL sync_window
9D009060  8FA40010   LW A0, 16(SP)
3619:                			if (res == FR_OK) {					/* Initialize the new directory table */
9D009064  14400053   BNE V0, ZERO, 0x9D0091B4
9D009068  00408021   ADDU S0, V0, ZERO
3620:                				dsc = clust2sect(dj.fs, dcl);
9D00906C  8FB10010   LW S1, 16(SP)
9D009070  02202021   ADDU A0, S1, ZERO
9D009074  0F405AB1   JAL clust2sect
9D009078  02602821   ADDU A1, S3, ZERO
9D00907C  00408021   ADDU S0, V0, ZERO
3621:                				dir = dj.fs->win;
9D009080  26320038   ADDIU S2, S1, 56
3622:                				mem_set(dir, 0, SS(dj.fs));
9D009084  02402021   ADDU A0, S2, ZERO
9D009088  00002821   ADDU A1, ZERO, ZERO
9D00908C  0F405C30   JAL mem_set
9D009090  24060200   ADDIU A2, ZERO, 512
3623:                				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
9D009094  02402021   ADDU A0, S2, ZERO
9D009098  24050020   ADDIU A1, ZERO, 32
9D00909C  0F405C30   JAL mem_set
9D0090A0  2406000B   ADDIU A2, ZERO, 11
3624:                				dir[DIR_Name] = '.';
9D0090A4  2415002E   ADDIU S5, ZERO, 46
9D0090A8  A2350038   SB S5, 56(S1)
3625:                				dir[DIR_Attr] = AM_DIR;
9D0090AC  24020010   ADDIU V0, ZERO, 16
9D0090B0  A2220043   SB V0, 67(S1)
3626:                				ST_DWORD(dir+DIR_WrtTime, tm);
9D0090B4  328200FF   ANDI V0, S4, 255
9D0090B8  AFA20040   SW V0, 64(SP)
9D0090BC  A222004E   SB V0, 78(S1)
9D0090C0  7E833A00   EXT V1, S4, 8, 8
9D0090C4  AFA30044   SW V1, 68(SP)
9D0090C8  A223004F   SB V1, 79(S1)
9D0090CC  7E823C00   EXT V0, S4, 16, 8
9D0090D0  AFA20048   SW V0, 72(SP)
9D0090D4  A2220050   SB V0, 80(S1)
9D0090D8  0014A602   SRL S4, S4, 24
9D0090DC  AFB4004C   SW S4, 76(SP)
9D0090E0  A2340051   SB S4, 81(S1)
3627:                				st_clust(dir, dcl);
3628:                				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
9D00910C  26240058   ADDIU A0, S1, 88
9D009110  02402821   ADDU A1, S2, ZERO
9D009114  0F405BCE   JAL mem_cpy
9D009118  24060020   ADDIU A2, ZERO, 32
3629:                				dir[33] = '.'; pcl = dj.sclust;
9D00911C  A2350059   SB S5, 89(S1)
3630:                				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
9D009120  8FA30010   LW V1, 16(SP)
9D009124  90650000   LBU A1, 0(V1)
9D009128  24040003   ADDIU A0, ZERO, 3
9D00912C  14A40004   BNE A1, A0, f_mkdir::st_clust
9D009130  8FA20018   LW V0, 24(SP)
9D009134  8C64002C   LW A0, 44(V1)
3631:                					pcl = 0;
9D009138  00822026   XOR A0, A0, V0
9D00913C  0004100A   MOVZ V0, ZERO, A0
3632:                				st_clust(dir+SZ_DIR, pcl);
3633:                				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
9D00915C  90620002   LBU V0, 2(V1)
9D009160  10400035   BEQ V0, ZERO, 0x9D009238
9D009164  2455FFFF   ADDIU S5, V0, -1
9D009168  32B500FF   ANDI S5, S5, 255
9D00916C  26B50001   ADDIU S5, S5, 1
9D009170  02B0A821   ADDU S5, S5, S0
9D0091A4  12350024   BEQ S1, S5, 0x9D009238
9D0091A8  00000000   NOP
3634:                					dj.fs->winsect = dsc++;
9D009178  8FA40010   LW A0, 16(SP)
9D00917C  26110001   ADDIU S1, S0, 1
9D009180  AC900034   SW S0, 52(A0)
9D0091AC  0B40245E   J 0x9D009178
9D0091B0  02208021   ADDU S0, S1, ZERO
3635:                					dj.fs->wflag = 1;
9D009174  24140001   ADDIU S4, ZERO, 1
3636:                					res = sync_window(dj.fs);
9D009184  0F404C46   JAL sync_window
9D009188  A0940004   SB S4, 4(A0)
3637:                					if (res != FR_OK) break;
9D00918C  14400009   BNE V0, ZERO, 0x9D0091B4
9D009190  00408021   ADDU S0, V0, ZERO
3638:                					mem_set(dir, 0, SS(dj.fs));
9D009194  02402021   ADDU A0, S2, ZERO
9D009198  00002821   ADDU A1, ZERO, ZERO
9D00919C  0F405C30   JAL mem_set
9D0091A0  24060200   ADDIU A2, ZERO, 512
3639:                				}
3640:                			}
3641:                			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
9D009238  0F40230B   JAL dir_register
9D00923C  27A40010   ADDIU A0, SP, 16
3642:                			if (res != FR_OK) {
9D009240  1040FFE1   BEQ V0, ZERO, 0x9D0091C8
9D009244  00408021   ADDU S0, V0, ZERO
9D009248  0B40246E   J 0x9D0091B8
9D00924C  8FA40010   LW A0, 16(SP)
3643:                				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
9D0091B4  8FA40010   LW A0, 16(SP)
9D0091B8  0F404B32   JAL remove_chain
9D0091BC  02602821   ADDU A1, S3, ZERO
9D0091C0  0B402495   J 0x9D009254
9D0091C4  02001021   ADDU V0, S0, ZERO
3644:                			} else {
3645:                				dir = dj.dir;
9D0091C8  8FA20024   LW V0, 36(SP)
3646:                				dir[DIR_Attr] = AM_DIR;				/* Attribute */
9D0091CC  24030010   ADDIU V1, ZERO, 16
9D0091D0  A043000B   SB V1, 11(V0)
3647:                				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
9D0091D4  8FA30040   LW V1, 64(SP)
9D0091D8  A0430016   SB V1, 22(V0)
9D0091DC  8FA30044   LW V1, 68(SP)
9D0091E0  A0430017   SB V1, 23(V0)
9D0091E4  8FA30048   LW V1, 72(SP)
9D0091E8  A0430018   SB V1, 24(V0)
9D0091EC  8FA3004C   LW V1, 76(SP)
9D0091F0  A0430019   SB V1, 25(V0)
3648:                				st_clust(dir, dcl);					/* Table start cluster */
3649:                				dj.fs->wflag = 1;
9D009208  8FA40010   LW A0, 16(SP)
9D00920C  24020001   ADDIU V0, ZERO, 1
3650:                				res = sync_fs(dj.fs);
9D009210  0F4047D7   JAL sync_fs
9D009214  A0820004   SB V0, 4(A0)
9D009218  0B402494   J 0x9D009250
9D00921C  00408021   ADDU S0, V0, ZERO
3651:                			}
3652:                		}
3653:                		FREE_BUF();
3654:                	}
3655:                
3656:                	LEAVE_FF(dj.fs, res);
3657:                }
9D009250  02001021   ADDU V0, S0, ZERO
3658:                
3659:                
3660:                
3661:                
3662:                /*-----------------------------------------------------------------------*/
3663:                /* Change Attribute                                                      */
3664:                /*-----------------------------------------------------------------------*/
3665:                
3666:                int f_chmod (
3667:                	const TCHAR *path,	/* Pointer to the file path */
3668:                	uint8_t value,			/* Attribute bits */
3669:                	uint8_t mask			/* Attribute mask to change */
3670:                )
3671:                {
9D012580  27BDFFB0   ADDIU SP, SP, -80
9D012584  AFBF004C   SW RA, 76(SP)
9D012588  AFB10048   SW S1, 72(SP)
9D01258C  AFB00044   SW S0, 68(SP)
9D012590  AFA40050   SW A0, 80(SP)
9D012594  30B000FF   ANDI S0, A1, 255
9D012598  30D100FF   ANDI S1, A2, 255
3672:                	FRESULT res = FR_OK;
3673:                	DIR dj = {};
9D01259C  AFA00010   SW ZERO, 16(SP)
9D0125A0  AFA00014   SW ZERO, 20(SP)
9D0125A4  AFA00018   SW ZERO, 24(SP)
9D0125A8  AFA0001C   SW ZERO, 28(SP)
9D0125AC  AFA00020   SW ZERO, 32(SP)
9D0125B0  AFA00024   SW ZERO, 36(SP)
9D0125B4  AFA00028   SW ZERO, 40(SP)
9D0125B8  AFA0002C   SW ZERO, 44(SP)
9D0125BC  AFA00030   SW ZERO, 48(SP)
3674:                	uint8_t *dir = NULL;
3675:                	DEF_NAMEBUF;
3676:                
3677:                
3678:                	res = chk_mounted(&path, &dj.fs, 1);
9D0125C0  27A40050   ADDIU A0, SP, 80
9D0125C4  27A50010   ADDIU A1, SP, 16
9D0125C8  0F4016DE   JAL chk_mounted
9D0125CC  24060001   ADDIU A2, ZERO, 1
3679:                	if (res == FR_OK) {
9D0125D0  14400023   BNE V0, ZERO, 0x9D012660
9D0125D4  8FBF004C   LW RA, 76(SP)
3680:                		INIT_BUF(dj);
9D0125D8  27A20034   ADDIU V0, SP, 52
9D0125DC  AFA20028   SW V0, 40(SP)
9D0125E0  3C028001   LUI V0, -32767
9D0125E4  24424430   ADDIU V0, V0, 17456
9D0125E8  AFA2002C   SW V0, 44(SP)
3681:                		res = follow_path(&dj, path);		/* Follow the file path */
9D0125EC  27A40010   ADDIU A0, SP, 16
9D0125F0  0F4010FC   JAL follow_path
9D0125F4  8FA50050   LW A1, 80(SP)
3682:                		FREE_BUF();
3683:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D0125F8  14400019   BNE V0, ZERO, 0x9D012660
9D0125FC  8FBF004C   LW RA, 76(SP)
9D012600  8FA20028   LW V0, 40(SP)
9D012604  9043000B   LBU V1, 11(V0)
9D012608  30630020   ANDI V1, V1, 32
9D01260C  306300FF   ANDI V1, V1, 255
9D012610  14600012   BNE V1, ZERO, 0x9D01265C
9D012614  24020006   ADDIU V0, ZERO, 6
9D012618  0B404994   J 0x9D012650
9D01261C  8FA20024   LW V0, 36(SP)
3684:                			res = FR_INVALID_NAME;
3685:                		if (res == FR_OK) {
3686:                			dir = dj.dir;
3687:                			if (!dir) {						/* Is it a root directory? */
9D012650  1440FFF3   BNE V0, ZERO, 0x9D012620
9D012654  32310027   ANDI S1, S1, 39
9D012658  24020006   ADDIU V0, ZERO, 6
3688:                				res = FR_INVALID_NAME;
3689:                			} else {						/* File or sub directory */
3690:                				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
3691:                				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (uint8_t)~mask);	/* Apply attribute change */
9D012620  00112027   NOR A0, ZERO, S1
9D012624  9043000B   LBU V1, 11(V0)
9D012628  00831824   AND V1, A0, V1
9D01262C  02308824   AND S1, S1, S0
9D012630  00718825   OR S1, V1, S1
9D012634  A051000B   SB S1, 11(V0)
3692:                				dj.fs->wflag = 1;
9D012638  8FA40010   LW A0, 16(SP)
9D01263C  24020001   ADDIU V0, ZERO, 1
3693:                				res = sync_fs(dj.fs);
9D012640  0F4047D7   JAL sync_fs
9D012644  A0820004   SB V0, 4(A0)
3694:                			}
3695:                		}
3696:                	}
3697:                
3698:                	LEAVE_FF(dj.fs, res);
3699:                }
9D012648  0B404998   J 0x9D012660
9D01264C  8FBF004C   LW RA, 76(SP)
9D01265C  8FBF004C   LW RA, 76(SP)
3700:                
3701:                
3702:                
3703:                
3704:                /*-----------------------------------------------------------------------*/
3705:                /* Change Timestamp                                                      */
3706:                /*-----------------------------------------------------------------------*/
3707:                
3708:                int f_utime (
3709:                	const TCHAR *path,	/* Pointer to the file/directory name */
3710:                	const uintptr_t ptr	/* Pointer to the time stamp to be set */
3711:                )
3712:                {
9D012670  27BDFFB8   ADDIU SP, SP, -72
9D012674  AFBF0044   SW RA, 68(SP)
9D012678  AFB00040   SW S0, 64(SP)
9D01267C  AFA40048   SW A0, 72(SP)
9D012680  00A08021   ADDU S0, A1, ZERO
3713:                	FRESULT res = FR_OK;
3714:                	DIR dj = {};
9D012684  AFA00010   SW ZERO, 16(SP)
9D012688  AFA00014   SW ZERO, 20(SP)
9D01268C  AFA00018   SW ZERO, 24(SP)
9D012690  AFA0001C   SW ZERO, 28(SP)
9D012694  AFA00020   SW ZERO, 32(SP)
9D012698  AFA00024   SW ZERO, 36(SP)
9D01269C  AFA00028   SW ZERO, 40(SP)
9D0126A0  AFA0002C   SW ZERO, 44(SP)
9D0126A4  AFA00030   SW ZERO, 48(SP)
3715:                	uint8_t *dir = NULL;
3716:                	DEF_NAMEBUF;
3717:                        FILINFO *fno = (FILINFO *)ptr;
3718:                
3719:                
3720:                	res = chk_mounted(&path, &dj.fs, 1);
9D0126A8  27A40048   ADDIU A0, SP, 72
9D0126AC  27A50010   ADDIU A1, SP, 16
9D0126B0  0F4016DE   JAL chk_mounted
9D0126B4  24060001   ADDIU A2, ZERO, 1
3721:                	if (res == FR_OK) {
9D0126B8  14400026   BNE V0, ZERO, 0x9D012754
9D0126BC  8FBF0044   LW RA, 68(SP)
3722:                		INIT_BUF(dj);
9D0126C0  27A20034   ADDIU V0, SP, 52
9D0126C4  AFA20028   SW V0, 40(SP)
9D0126C8  3C028001   LUI V0, -32767
9D0126CC  24424430   ADDIU V0, V0, 17456
9D0126D0  AFA2002C   SW V0, 44(SP)
3723:                		res = follow_path(&dj, path);	/* Follow the file path */
9D0126D4  27A40010   ADDIU A0, SP, 16
9D0126D8  0F4010FC   JAL follow_path
9D0126DC  8FA50048   LW A1, 72(SP)
3724:                		FREE_BUF();
3725:                		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
9D0126E0  1440001C   BNE V0, ZERO, 0x9D012754
9D0126E4  8FBF0044   LW RA, 68(SP)
9D0126E8  8FA20028   LW V0, 40(SP)
9D0126EC  9043000B   LBU V1, 11(V0)
9D0126F0  30630020   ANDI V1, V1, 32
9D0126F4  306300FF   ANDI V1, V1, 255
9D0126F8  14600015   BNE V1, ZERO, 0x9D012750
9D0126FC  24020006   ADDIU V0, ZERO, 6
9D012700  0B4049D1   J 0x9D012744
9D012704  8FA20024   LW V0, 36(SP)
3726:                			res = FR_INVALID_NAME;
3727:                		if (res == FR_OK) {
3728:                			dir = dj.dir;
3729:                			if (!dir) {					/* Root directory */
9D012744  5440FFF0   BNEL V0, ZERO, 0x9D012708
9D012748  96030006   LHU V1, 6(S0)
9D01274C  24020006   ADDIU V0, ZERO, 6
3730:                				res = FR_INVALID_NAME;
3731:                			} else {					/* File or sub-directory */
3732:                				ST_WORD(dir+DIR_WrtTime, fno->ftime);
9D012708  A0430016   SB V1, 22(V0)
9D01270C  96030006   LHU V1, 6(S0)
9D012710  00031A02   SRL V1, V1, 8
9D012714  A0430017   SB V1, 23(V0)
3733:                				ST_WORD(dir+DIR_WrtDate, fno->fdate);
9D012718  96030004   LHU V1, 4(S0)
9D01271C  A0430018   SB V1, 24(V0)
9D012720  96030004   LHU V1, 4(S0)
9D012724  00031A02   SRL V1, V1, 8
9D012728  A0430019   SB V1, 25(V0)
3734:                				dj.fs->wflag = 1;
9D01272C  8FA40010   LW A0, 16(SP)
9D012730  24020001   ADDIU V0, ZERO, 1
3735:                				res = sync_fs(dj.fs);
9D012734  0F4047D7   JAL sync_fs
9D012738  A0820004   SB V0, 4(A0)
3736:                			}
3737:                		}
3738:                	}
3739:                
3740:                	LEAVE_FF(dj.fs, res);
3741:                }
9D01273C  0B4049D5   J 0x9D012754
9D012740  8FBF0044   LW RA, 68(SP)
9D012750  8FBF0044   LW RA, 68(SP)
3742:                
3743:                
3744:                
3745:                
3746:                /*-----------------------------------------------------------------------*/
3747:                /* Rename File/Directory                                                 */
3748:                /*-----------------------------------------------------------------------*/
3749:                
3750:                int f_rename (
3751:                	const TCHAR *path_old,	/* Pointer to the old name */
3752:                	const TCHAR *path_new	/* Pointer to the new name */
3753:                )
3754:                {
9D00BBC4  27BDFF70   ADDIU SP, SP, -144
9D00BBC8  AFBF008C   SW RA, 140(SP)
9D00BBCC  AFB10088   SW S1, 136(SP)
9D00BBD0  AFB00084   SW S0, 132(SP)
9D00BBD4  AFA40090   SW A0, 144(SP)
9D00BBD8  00A08021   ADDU S0, A1, ZERO
3755:                	FRESULT res = FR_OK;
3756:                	DIR djo = {}, djn = {};
9D00BBDC  AFA00010   SW ZERO, 16(SP)
9D00BBE0  AFA00014   SW ZERO, 20(SP)
9D00BBE4  AFA00018   SW ZERO, 24(SP)
9D00BBE8  AFA0001C   SW ZERO, 28(SP)
9D00BBEC  AFA00020   SW ZERO, 32(SP)
9D00BBF0  AFA00024   SW ZERO, 36(SP)
9D00BBF4  AFA00028   SW ZERO, 40(SP)
9D00BBF8  AFA0002C   SW ZERO, 44(SP)
9D00BBFC  AFA00030   SW ZERO, 48(SP)
9D00BC00  AFA00034   SW ZERO, 52(SP)
9D00BC04  AFA00038   SW ZERO, 56(SP)
9D00BC08  AFA0003C   SW ZERO, 60(SP)
9D00BC0C  AFA00040   SW ZERO, 64(SP)
9D00BC10  AFA00044   SW ZERO, 68(SP)
9D00BC14  AFA00048   SW ZERO, 72(SP)
9D00BC18  AFA0004C   SW ZERO, 76(SP)
9D00BC1C  AFA00050   SW ZERO, 80(SP)
9D00BC20  AFA00054   SW ZERO, 84(SP)
3757:                	uint8_t buf[21] = {}, *dir = NULL;
9D00BC24  AFA00058   SW ZERO, 88(SP)
9D00BC28  AFA0005C   SW ZERO, 92(SP)
9D00BC2C  AFA00060   SW ZERO, 96(SP)
9D00BC30  AFA00064   SW ZERO, 100(SP)
9D00BC34  AFA00068   SW ZERO, 104(SP)
9D00BC38  A3A0006C   SB ZERO, 108(SP)
3758:                	uint32_t dw = 0;
3759:                	DEF_NAMEBUF;
3760:                
3761:                
3762:                	res = chk_mounted(&path_old, &djo.fs, 1);
9D00BC3C  27A40090   ADDIU A0, SP, 144
9D00BC40  27A50010   ADDIU A1, SP, 16
9D00BC44  0F4016DE   JAL chk_mounted
9D00BC48  24060001   ADDIU A2, ZERO, 1
3763:                	if (res == FR_OK) {
9D00BC4C  14400071   BNE V0, ZERO, 0x9D00BE14
9D00BC50  8FBF008C   LW RA, 140(SP)
3764:                		djn.fs = djo.fs;
9D00BC54  8FA20010   LW V0, 16(SP)
9D00BC58  AFA20034   SW V0, 52(SP)
3765:                		INIT_BUF(djo);
9D00BC5C  27A20070   ADDIU V0, SP, 112
9D00BC60  AFA20028   SW V0, 40(SP)
9D00BC64  3C028001   LUI V0, -32767
9D00BC68  24424430   ADDIU V0, V0, 17456
9D00BC6C  AFA2002C   SW V0, 44(SP)
3766:                		res = follow_path(&djo, path_old);		/* Check old object */
9D00BC70  27A40010   ADDIU A0, SP, 16
9D00BC74  0F4010FC   JAL follow_path
9D00BC78  8FA50090   LW A1, 144(SP)
3767:                		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
9D00BC7C  14400065   BNE V0, ZERO, 0x9D00BE14
9D00BC80  8FBF008C   LW RA, 140(SP)
9D00BC84  8FA20028   LW V0, 40(SP)
9D00BC88  9043000B   LBU V1, 11(V0)
9D00BC8C  30630020   ANDI V1, V1, 32
9D00BC90  306300FF   ANDI V1, V1, 255
9D00BC94  1460005E   BNE V1, ZERO, 0x9D00BE10
9D00BC98  24020006   ADDIU V0, ZERO, 6
9D00BC9C  0B402F7A   J 0x9D00BDE8
9D00BCA0  27A40010   ADDIU A0, SP, 16
3768:                			res = FR_INVALID_NAME;
3769:                #if _FS_LOCK
3770:                		if (res == FR_OK) res = chk_lock(&djo, 2);
9D00BDE8  0F405315   JAL chk_lock
9D00BDEC  24050002   ADDIU A1, ZERO, 2
3771:                #endif
3772:                		if (res == FR_OK) {						/* Old object is found */
9D00BDF0  5040FFAC   BEQL V0, ZERO, 0x9D00BCA4
9D00BDF4  8FA50024   LW A1, 36(SP)
9D00BDF8  0B402F85   J 0x9D00BE14
9D00BDFC  8FBF008C   LW RA, 140(SP)
3773:                			if (!djo.dir) {						/* Is root dir? */
9D00BCA4  10A0004E   BEQ A1, ZERO, 0x9D00BDE0
9D00BCA8  24A5000B   ADDIU A1, A1, 11
3774:                				res = FR_NO_FILE;
9D00BDE0  0B402F84   J 0x9D00BE10
9D00BDE4  24020004   ADDIU V0, ZERO, 4
3775:                			} else {
3776:                				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
9D00BCAC  27A40058   ADDIU A0, SP, 88
9D00BCB0  0F405BCE   JAL mem_cpy
9D00BCB4  24060015   ADDIU A2, ZERO, 21
3777:                				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
9D00BCB8  27A40034   ADDIU A0, SP, 52
9D00BCBC  27A50010   ADDIU A1, SP, 16
9D00BCC0  0F405BCE   JAL mem_cpy
9D00BCC4  24060024   ADDIU A2, ZERO, 36
3778:                				res = follow_path(&djn, path_new);
9D00BCC8  27A40034   ADDIU A0, SP, 52
9D00BCCC  0F4010FC   JAL follow_path
9D00BCD0  02002821   ADDU A1, S0, ZERO
3779:                				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
9D00BCD4  5040004E   BEQL V0, ZERO, 0x9D00BE10
9D00BCD8  24020008   ADDIU V0, ZERO, 8
3780:                				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
9D00BCDC  24030004   ADDIU V1, ZERO, 4
9D00BCE0  1443004C   BNE V0, V1, 0x9D00BE14
9D00BCE4  8FBF008C   LW RA, 140(SP)
3781:                /* Start critical section that any interruption can cause a cross-link */
3782:                					res = dir_register(&djn);			/* Register the new entry */
9D00BCE8  0F40230B   JAL dir_register
9D00BCEC  27A40034   ADDIU A0, SP, 52
3783:                					if (res == FR_OK) {
9D00BCF0  14400048   BNE V0, ZERO, 0x9D00BE14
9D00BCF4  8FBF008C   LW RA, 140(SP)
3784:                						dir = djn.dir;					/* Copy object information except for name */
9D00BCF8  8FB00048   LW S0, 72(SP)
3785:                						mem_cpy(dir+13, buf+2, 19);
9D00BCFC  2604000D   ADDIU A0, S0, 13
9D00BD00  27A5005A   ADDIU A1, SP, 90
9D00BD04  0F405BCE   JAL mem_cpy
9D00BD08  24060013   ADDIU A2, ZERO, 19
3786:                						dir[DIR_Attr] = buf[0] | AM_ARC;
9D00BD0C  93A20058   LBU V0, 88(SP)
9D00BD10  34420020   ORI V0, V0, 32
9D00BD14  A202000B   SB V0, 11(S0)
3787:                						djo.fs->wflag = 1;
9D00BD18  8FB10010   LW S1, 16(SP)
9D00BD1C  24020001   ADDIU V0, ZERO, 1
9D00BD20  A2220004   SB V0, 4(S1)
3788:                						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
9D00BD24  8FA2003C   LW V0, 60(SP)
9D00BD28  8FA30018   LW V1, 24(SP)
9D00BD2C  10620034   BEQ V1, V0, 0x9D00BE00
9D00BD30  00000000   NOP
9D00BD34  9202000B   LBU V0, 11(S0)
9D00BD38  30420010   ANDI V0, V0, 16
9D00BD3C  304200FF   ANDI V0, V0, 255
9D00BD40  1040002F   BEQ V0, ZERO, 0x9D00BE00
9D00BD44  02202021   ADDU A0, S1, ZERO
3789:                							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
9D00BD48  0F4059DD   JAL ld_clust
9D00BD4C  02002821   ADDU A1, S0, ZERO
9D00BD50  02202021   ADDU A0, S1, ZERO
9D00BD54  0F405AB1   JAL clust2sect
9D00BD58  00402821   ADDU A1, V0, ZERO
9D00BD5C  00402821   ADDU A1, V0, ZERO
3790:                							if (!dw) {
9D00BD60  10A0002B   BEQ A1, ZERO, 0x9D00BE10
9D00BD64  24020002   ADDIU V0, ZERO, 2
3791:                								res = FR_INT_ERR;
3792:                							} else {
3793:                								res = move_window(djo.fs, dw);
9D00BD68  0F405691   JAL move_window
9D00BD6C  02202021   ADDU A0, S1, ZERO
3794:                								dir = djo.fs->win+SZ_DIR;	/* .. entry */
3795:                								if (res == FR_OK && dir[1] == '.') {
9D00BD70  14400027   BNE V0, ZERO, 0x9D00BE10
9D00BD74  8FA30010   LW V1, 16(SP)
9D00BD78  90640059   LBU A0, 89(V1)
9D00BD7C  2402002E   ADDIU V0, ZERO, 46
9D00BD80  1482001F   BNE A0, V0, 0x9D00BE00
9D00BD84  24020003   ADDIU V0, ZERO, 3
3796:                									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
9D00BD88  90640000   LBU A0, 0(V1)
9D00BD8C  14820006   BNE A0, V0, f_rename::st_clust
9D00BD90  8FA2003C   LW V0, 60(SP)
9D00BD94  8C62002C   LW V0, 44(V1)
9D00BD98  8FA4003C   LW A0, 60(SP)
9D00BD9C  14820002   BNE A0, V0, f_rename::st_clust
9D00BDA0  8FA2003C   LW V0, 60(SP)
9D00BDA4  00001021   ADDU V0, ZERO, ZERO
3797:                									st_clust(dir, dw);
3798:                									djo.fs->wflag = 1;
9D00BDC4  24020001   ADDIU V0, ZERO, 1
9D00BDC8  0B402F80   J 0x9D00BE00
9D00BDCC  A0620004   SB V0, 4(V1)
3799:                								}
3800:                							}
3801:                						}
3802:                						if (res == FR_OK) {
3803:                							res = dir_remove(&djo);		/* Remove old entry */
9D00BE00  0F4050DE   JAL dir_remove
9D00BE04  27A40010   ADDIU A0, SP, 16
3804:                							if (res == FR_OK)
9D00BE08  1040FFF1   BEQ V0, ZERO, 0x9D00BDD0
9D00BE0C  00000000   NOP
3805:                								res = sync_fs(djo.fs);
9D00BDD0  0F4047D7   JAL sync_fs
9D00BDD4  8FA40010   LW A0, 16(SP)
3806:                						}
3807:                					}
3808:                /* End critical section */
3809:                				}
3810:                			}
3811:                		}
3812:                		FREE_BUF();
3813:                	}
3814:                
3815:                	LEAVE_FF(djo.fs, res);
3816:                }
9D00BDD8  0B402F85   J 0x9D00BE14
9D00BDDC  8FBF008C   LW RA, 140(SP)
9D00BE10  8FBF008C   LW RA, 140(SP)
3817:                
3818:                #endif /* !_FS_READONLY */
3819:                #endif /* _FS_MINIMIZE == 0 */
3820:                #endif /* _FS_MINIMIZE <= 1 */
3821:                #endif /* _FS_MINIMIZE <= 2 */
3822:                
3823:                
3824:                
3825:                #if _USE_LABEL
3826:                /*-----------------------------------------------------------------------*/
3827:                /* Get volume label                                                      */
3828:                /*-----------------------------------------------------------------------*/
3829:                
3830:                int f_getlabel (
3831:                	const TCHAR* path,	/* Path name of the logical drive number */
3832:                	TCHAR* label,		/* Pointer to a buffer to return the volume label */
3833:                	uint32_t* sn			/* Pointer to a variable to return the volume serial number */
3834:                )
3835:                {
9D010678  27BDFFB8   ADDIU SP, SP, -72
9D01067C  AFBF0044   SW RA, 68(SP)
9D010680  AFB20040   SW S2, 64(SP)
9D010684  AFB1003C   SW S1, 60(SP)
9D010688  AFB00038   SW S0, 56(SP)
9D01068C  AFA40048   SW A0, 72(SP)
9D010690  00A09021   ADDU S2, A1, ZERO
9D010694  00C08821   ADDU S1, A2, ZERO
3836:                	FRESULT res = FR_OK;
3837:                	DIR dj = {};
9D010698  AFA00010   SW ZERO, 16(SP)
9D01069C  AFA00014   SW ZERO, 20(SP)
9D0106A0  AFA00018   SW ZERO, 24(SP)
9D0106A4  AFA0001C   SW ZERO, 28(SP)
9D0106A8  AFA00020   SW ZERO, 32(SP)
9D0106AC  AFA00024   SW ZERO, 36(SP)
9D0106B0  AFA00028   SW ZERO, 40(SP)
9D0106B4  AFA0002C   SW ZERO, 44(SP)
9D0106B8  AFA00030   SW ZERO, 48(SP)
3838:                	uint32_t i = 0, j = 0;
3839:                
3840:                
3841:                	/* Get logical drive */
3842:                	res = chk_mounted(&path, &dj.fs, 0);
9D0106BC  27A40048   ADDIU A0, SP, 72
9D0106C0  27A50010   ADDIU A1, SP, 16
9D0106C4  0F4016DE   JAL chk_mounted
9D0106C8  00003021   ADDU A2, ZERO, ZERO
3843:                
3844:                	/* Get volume label */
3845:                	if (res == FR_OK && label) {
9D0106CC  1440003A   BNE V0, ZERO, 0x9D0107B8
9D0106D0  00408021   ADDU S0, V0, ZERO
9D0106D4  1240001F   BEQ S2, ZERO, 0x9D010754
9D0106D8  27A40010   ADDIU A0, SP, 16
3846:                		dj.sclust = 0;					/* Open root dir */
9D0106DC  AFA00018   SW ZERO, 24(SP)
3847:                		res = dir_sdi(&dj, 0);
9D0106E0  0F404499   JAL dir_sdi
9D0106E4  00002821   ADDU A1, ZERO, ZERO
3848:                		if (res == FR_OK) {
9D0106E8  54400033   BNEL V0, ZERO, 0x9D0107B8
9D0106EC  00408021   ADDU S0, V0, ZERO
3849:                			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
9D0106F0  27A40010   ADDIU A0, SP, 16
9D0106F4  0F403396   JAL dir_read
9D0106F8  24050001   ADDIU A1, ZERO, 1
3850:                			if (res == FR_OK) {			/* A volume label is exist */
9D0106FC  14400012   BNE V0, ZERO, 0x9D010748
9D010700  24030004   ADDIU V1, ZERO, 4
3851:                #if _LFN_UNICODE
3852:                				uint16_t w;
3853:                				i = j = 0;
3854:                				do {
3855:                					w = (i < 11) ? dj.dir[i++] : ' ';
3856:                					if (IsDBCS1(w) && i < 11 && IsDBCS2(dj.dir[i]))
3857:                						w = (w << 8) | dj.dir[i++];
3858:                					label[j++] = ff_convert(w, 1);
3859:                				} while (j < 11);
3860:                #else
3861:                				mem_cpy(label, dj.dir, 11);
9D010704  02402021   ADDU A0, S2, ZERO
9D010708  8FA50024   LW A1, 36(SP)
9D01070C  0F405BCE   JAL mem_cpy
9D010710  2406000B   ADDIU A2, ZERO, 11
3862:                #endif
3863:                				j = 11;
9D01071C  2402000B   ADDIU V0, ZERO, 11
3864:                				do {
3865:                					label[j] = 0;
9D010714  A240000B   SB ZERO, 11(S2)
9D010718  2652000A   ADDIU S2, S2, 10
9D010728  A2400000   SB ZERO, 0(S2)
3866:                					if (!j) break;
9D01072C  10400009   BEQ V0, ZERO, 0x9D010754
9D010730  2652FFFF   ADDIU S2, S2, -1
3867:                				} while (label[--j] == ' ');
9D010720  0B4041CD   J 0x9D010734
9D010724  24040020   ADDIU A0, ZERO, 32
9D010734  82430000   LB V1, 0(S2)
9D010738  1064FFFB   BEQ V1, A0, 0x9D010728
9D01073C  2442FFFF   ADDIU V0, V0, -1
9D010740  0B4041D5   J 0x9D010754
9D010744  00000000   NOP
3868:                			}
3869:                			if (res == FR_NO_FILE) {	/* No label, return nul string */
9D010748  5443001B   BNEL V0, V1, 0x9D0107B8
9D01074C  00408021   ADDU S0, V0, ZERO
3870:                				label[0] = 0;
9D010750  A2400000   SB ZERO, 0(S2)
3871:                				res = FR_OK;
3872:                			}
3873:                		}
3874:                	}
3875:                
3876:                	/* Get volume serial number */
3877:                	if (res == FR_OK && sn) {
9D010754  12200018   BEQ S1, ZERO, 0x9D0107B8
9D010758  8FA20010   LW V0, 16(SP)
3878:                		res = move_window(dj.fs, dj.fs->volbase);
9D01075C  00402021   ADDU A0, V0, ZERO
9D010760  0F405691   JAL move_window
9D010764  8C450024   LW A1, 36(V0)
3879:                		if (res == FR_OK) {
9D010768  14400013   BNE V0, ZERO, 0x9D0107B8
9D01076C  00408021   ADDU S0, V0, ZERO
3880:                			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
9D010770  8FA30010   LW V1, 16(SP)
9D010774  90620000   LBU V0, 0(V1)
9D010778  38420003   XORI V0, V0, 3
9D01077C  24040043   ADDIU A0, ZERO, 67
9D010780  24050027   ADDIU A1, ZERO, 39
9D010784  00A2200B   MOVN A0, A1, V0
3881:                			*sn = LD_DWORD(&dj.fs->win[i]);
9D010788  00641021   ADDU V0, V1, A0
9D01078C  9044003B   LBU A0, 59(V0)
9D010790  00042600   SLL A0, A0, 24
9D010794  9043003A   LBU V1, 58(V0)
9D010798  00031C00   SLL V1, V1, 16
9D01079C  00832025   OR A0, A0, V1
9D0107A0  90430038   LBU V1, 56(V0)
9D0107A4  00832025   OR A0, A0, V1
9D0107A8  90430039   LBU V1, 57(V0)
9D0107AC  00031A00   SLL V1, V1, 8
9D0107B0  00831025   OR V0, A0, V1
9D0107B4  AE220000   SW V0, 0(S1)
3882:                		}
3883:                	}
3884:                
3885:                	LEAVE_FF(dj.fs, res);
3886:                }
9D0107B8  02001021   ADDU V0, S0, ZERO
3887:                
3888:                
3889:                
3890:                #if !_FS_READONLY
3891:                /*-----------------------------------------------------------------------*/
3892:                /* Set volume label                                                      */
3893:                /*-----------------------------------------------------------------------*/
3894:                
3895:                int f_setlabel (
3896:                	const TCHAR* label	/* Pointer to the volume label to set */
3897:                )
3898:                {
9D00772C  27BDFFA0   ADDIU SP, SP, -96
9D007730  AFBF005C   SW RA, 92(SP)
9D007734  AFB50058   SW S5, 88(SP)
9D007738  AFB40054   SW S4, 84(SP)
9D00773C  AFB30050   SW S3, 80(SP)
9D007740  AFB2004C   SW S2, 76(SP)
9D007744  AFB10048   SW S1, 72(SP)
9D007748  AFB00044   SW S0, 68(SP)
9D00774C  AFA40060   SW A0, 96(SP)
3899:                	FRESULT res = FR_OK;
3900:                	DIR dj = {};
9D007750  AFA00010   SW ZERO, 16(SP)
9D007754  AFA00014   SW ZERO, 20(SP)
9D007758  AFA00018   SW ZERO, 24(SP)
9D00775C  AFA0001C   SW ZERO, 28(SP)
9D007760  AFA00020   SW ZERO, 32(SP)
9D007764  AFA00024   SW ZERO, 36(SP)
9D007768  AFA00028   SW ZERO, 40(SP)
9D00776C  AFA0002C   SW ZERO, 44(SP)
9D007770  AFA00030   SW ZERO, 48(SP)
3901:                	uint8_t vn[11] = {};
9D007774  AFA00034   SW ZERO, 52(SP)
9D007778  AFA00038   SW ZERO, 56(SP)
9D00777C  A7A0003C   SH ZERO, 60(SP)
9D007780  A3A0003E   SB ZERO, 62(SP)
3902:                	uint32_t i = 0, j = 0, sl = 0;
3903:                	uint16_t w = 0;
3904:                	uint32_t tm = 0;
3905:                
3906:                
3907:                	/* Get logical drive */
3908:                	res = chk_mounted(&label, &dj.fs, 1);
9D007784  27A40060   ADDIU A0, SP, 96
9D007788  27A50010   ADDIU A1, SP, 16
9D00778C  0F4016DE   JAL chk_mounted
9D007790  24060001   ADDIU A2, ZERO, 1
3909:                	if (res) LEAVE_FF(dj.fs, res);
9D007794  144000CB   BNE V0, ZERO, 0x9D007AC4
9D007798  8FBF005C   LW RA, 92(SP)
3910:                
3911:                	/* Create a volume label in directory form */
3912:                	vn[0] = 0;
9D00779C  A3A00034   SB ZERO, 52(SP)
3913:                	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
9D0077A0  8FB10060   LW S1, 96(SP)
9D0077A4  82220000   LB V0, 0(S1)
9D0077A8  50400063   BEQL V0, ZERO, 0x9D007938
9D0077AC  AFA00018   SW ZERO, 24(SP)
9D0077B0  00008021   ADDU S0, ZERO, ZERO
9D0077B4  26020001   ADDIU V0, S0, 1
9D0077B8  7E22198A   LBUX V1, V0(S1)
9D0077BC  10600003   BEQ V1, ZERO, 0x9D0077CC
9D0077C0  00000000   NOP
9D0077C4  0B401DED   J 0x9D0077B4
9D0077C8  00408021   ADDU S0, V0, ZERO
9D007A7C  00408021   ADDU S0, V0, ZERO
3914:                	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
9D0077CC  10400059   BEQ V0, ZERO, 0x9D007934
9D0077D0  02301821   ADDU V1, S1, S0
9D0077D4  80640000   LB A0, 0(V1)
9D0077D8  24030020   ADDIU V1, ZERO, 32
9D0077DC  148300A7   BNE A0, V1, 0x9D007A7C
9D0077E0  24040020   ADDIU A0, ZERO, 32
9D0077E4  0B401E00   J 0x9D007800
9D0077E8  00000000   NOP
9D0077EC  02221821   ADDU V1, S1, V0
9D0077F0  80630000   LB V1, 0(V1)
9D0077F4  146400A3   BNE V1, A0, 0x9D007A84
9D0077F8  00009821   ADDU S3, ZERO, ZERO
9D0077FC  00408021   ADDU S0, V0, ZERO
9D007800  1600FFFA   BNE S0, ZERO, 0x9D0077EC
9D007804  2602FFFF   ADDIU V0, S0, -1
9D007808  0B401E4E   J 0x9D007938
9D00780C  AFA00018   SW ZERO, 24(SP)
9D007A80  00009821   ADDU S3, ZERO, ZERO
9D007A84  00001021   ADDU V0, ZERO, ZERO
3915:                	if (sl) {	/* Create volume label in directory form */
3916:                		i = j = 0;
3917:                		do {
3918:                #if _LFN_UNICODE
3919:                			w = ff_convert(ff_wtoupper(label[i++]), 0);
3920:                #else
3921:                			w = (uint8_t)label[i++];
9D007810  7E22198A   LBUX V1, V0(S1)
9D00783C  0B401E27   J 0x9D00789C
9D007840  00602021   ADDU A0, V1, ZERO
3922:                			if (IsDBCS1(w))
9D007814  2464007F   ADDIU A0, V1, 127
9D007818  308400FF   ANDI A0, A0, 255
9D00781C  2C84001F   SLTIU A0, A0, 31
9D007820  14800008   BNE A0, ZERO, 0x9D007844
9D007824  24520001   ADDIU S2, V0, 1
9D007828  24640020   ADDIU A0, V1, 32
9D00782C  308400FF   ANDI A0, A0, 255
9D007830  2C84001D   SLTIU A0, A0, 29
9D007834  14800004   BNE A0, ZERO, 0x9D007848
9D007838  2E65000A   SLTIU A1, S3, 10
3923:                				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? (w << 8) | (uint8_t)label[i++] : 0;
9D007844  2E65000A   SLTIU A1, S3, 10
9D007848  10A00014   BEQ A1, ZERO, 0x9D00789C
9D00784C  00002021   ADDU A0, ZERO, ZERO
9D007850  0250282B   SLTU A1, S2, S0
9D007854  10A00012   BEQ A1, ZERO, 0x9D0078A0
9D007858  7C042420   SEB A0, A0
9D00785C  02322021   ADDU A0, S1, S2
9D007860  80860000   LB A2, 0(A0)
9D007864  30C500FF   ANDI A1, A2, 255
9D007868  24A4FFC0   ADDIU A0, A1, -64
9D00786C  308400FF   ANDI A0, A0, 255
9D007870  2C84003F   SLTIU A0, A0, 63
9D007874  54800007   BNEL A0, ZERO, 0x9D007894
9D007878  24520002   ADDIU S2, V0, 2
9D00787C  04C30008   BGEZL A2, 0x9D0078A0
9D007880  7C042420   SEB A0, A0
9D007884  2CA600FD   SLTIU A2, A1, 253
9D007888  50C00005   BEQL A2, ZERO, 0x9D0078A0
9D00788C  7C042420   SEB A0, A0
9D007890  24520002   ADDIU S2, V0, 2
9D007894  00031A00   SLL V1, V1, 8
9D007898  00652025   OR A0, V1, A1
3924:                #if FAT_FS_USE_LFN
3925:                			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
9D00789C  7C042420   SEB A0, A0
9D0078A0  0F405BA6   JAL ff_wtoupper
9D0078A4  3084FFFF   ANDI A0, A0, -1
9D0078A8  7C021420   SEB V0, V0
9D0078AC  3045FFFF   ANDI A1, V0, -1
3926:                #else
3927:                			if (IsLower(w)) w -= 0x20;			/* To upper ASCII chars */
3928:                #ifdef _EXCVT
3929:                			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended chars (SBCS cfg) */
3930:                #else
3931:                			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended chars (ASCII cfg) */
3932:                #endif
3933:                #endif
3934:                #endif
3935:                			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (uint32_t)((w >= 0x100) ? 10 : 11)) /* Reject invalid chars for volume label */
9D0078B0  50A00083   BEQL A1, ZERO, 0x9D007AC0
9D0078B4  24020006   ADDIU V0, ZERO, 6
9D007A94  14400006   BNE V0, ZERO, 0x9D007AB0
9D007A98  2E62000B   SLTIU V0, S3, 11
9D007A9C  2E62000A   SLTIU V0, S3, 10
9D007AA0  5440FF8F   BNEL V0, ZERO, 0x9D0078E0
9D007AA4  26620001   ADDIU V0, S3, 1
9D007AA8  0B401EB0   J 0x9D007AC0
9D007AAC  24020006   ADDIU V0, ZERO, 6
9D007AB0  50400003   BEQL V0, ZERO, 0x9D007AC0
9D007AB4  24020006   ADDIU V0, ZERO, 6
9D007AB8  0B401E3C   J 0x9D0078F0
9D007ABC  02601021   ADDU V0, S3, ZERO
3936:                				LEAVE_FF(dj.fs, FR_INVALID_NAME);
9D0078D8  0B401E9D   J 0x9D007A74
9D0078DC  24020006   ADDIU V0, ZERO, 6
9D007A6C  0B401EB0   J 0x9D007AC0
9D007A70  24020006   ADDIU V0, ZERO, 6
3937:                			if (w >= 0x100) vn[j++] = (uint8_t)(w >> 8);
9D0078E0  27A30010   ADDIU V1, SP, 16
9D0078E4  00739821   ADDU S3, V1, S3
9D0078E8  00051A02   SRL V1, A1, 8
9D0078EC  A2630024   SB V1, 36(S3)
3938:                			vn[j++] = (uint8_t)w;
9D0078F0  24530001   ADDIU S3, V0, 1
9D0078F4  27A30010   ADDIU V1, SP, 16
9D0078F8  00621021   ADDU V0, V1, V0
9D0078FC  A0450024   SB A1, 36(V0)
3939:                		} while (i < sl);
9D007900  0250102B   SLTU V0, S2, S0
9D007904  1440FFC2   BNE V0, ZERO, 0x9D007810
9D007908  02401021   ADDU V0, S2, ZERO
3940:                		while (j < 11) vn[j++] = ' ';
9D00790C  2E62000B   SLTIU V0, S3, 11
9D007910  10400008   BEQ V0, ZERO, 0x9D007934
9D007914  27A20034   ADDIU V0, SP, 52
9D007918  00539821   ADDU S3, V0, S3
9D00791C  27A3003F   ADDIU V1, SP, 63
9D007920  24020020   ADDIU V0, ZERO, 32
9D007924  A2620000   SB V0, 0(S3)
9D007928  26730001   ADDIU S3, S3, 1
9D00792C  5663FFFE   BNEL S3, V1, 0x9D007928
9D007930  A2620000   SB V0, 0(S3)
3941:                	}
3942:                
3943:                	/* Set volume label */
3944:                	dj.sclust = 0;					/* Open root dir */
9D007934  AFA00018   SW ZERO, 24(SP)
3945:                	res = dir_sdi(&dj, 0);
9D007938  27A40010   ADDIU A0, SP, 16
9D00793C  0F404499   JAL dir_sdi
9D007940  00002821   ADDU A1, ZERO, ZERO
3946:                	if (res == FR_OK) {
9D007944  14400047   BNE V0, ZERO, 0x9D007A64
9D007948  00408021   ADDU S0, V0, ZERO
3947:                		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
9D00794C  27A40010   ADDIU A0, SP, 16
9D007950  0F403396   JAL dir_read
9D007954  24050001   ADDIU A1, ZERO, 1
3948:                		if (res == FR_OK) {			/* A volume label is found */
9D007958  1440001D   BNE V0, ZERO, 0x9D0079D0
9D00795C  24030004   ADDIU V1, ZERO, 4
3949:                			if (vn[0]) {
9D007960  93A20034   LBU V0, 52(SP)
9D007964  10400012   BEQ V0, ZERO, 0x9D0079B0
9D007968  2403FFE5   ADDIU V1, ZERO, -27
3950:                				mem_cpy(dj.dir, vn, 11);	/* Change the volume label name */
9D00796C  8FA40024   LW A0, 36(SP)
9D007970  27A50034   ADDIU A1, SP, 52
9D007974  0F405BCE   JAL mem_cpy
9D007978  2406000B   ADDIU A2, ZERO, 11
3951:                				tm = get_fattime();
9D00797C  0F405C45   JAL get_fattime
9D007980  00000000   NOP
3952:                				ST_DWORD(dj.dir+DIR_WrtTime, tm);
9D007984  8FA30024   LW V1, 36(SP)
9D007988  A0620016   SB V0, 22(V1)
9D00798C  7C443A00   EXT A0, V0, 8, 8
9D007990  8FA30024   LW V1, 36(SP)
9D007994  A0640017   SB A0, 23(V1)
9D007998  8FA30024   LW V1, 36(SP)
9D00799C  00022402   SRL A0, V0, 16
9D0079A0  A0640018   SB A0, 24(V1)
9D0079A4  00021602   SRL V0, V0, 24
9D0079A8  0B401E6E   J 0x9D0079B8
9D0079AC  A0620019   SB V0, 25(V1)
3953:                			} else {
3954:                				dj.dir[0] = DDE;			/* Remove the volume label */
9D0079B0  8FA20024   LW V0, 36(SP)
9D0079B4  A0430000   SB V1, 0(V0)
3955:                			}
3956:                			dj.fs->wflag = 1;
9D0079B8  8FA40010   LW A0, 16(SP)
9D0079BC  24020001   ADDIU V0, ZERO, 1
3957:                			res = sync_fs(dj.fs);
9D0079C0  0F4047D7   JAL sync_fs
9D0079C4  A0820004   SB V0, 4(A0)
9D0079C8  0B401E99   J 0x9D007A64
9D0079CC  00408021   ADDU S0, V0, ZERO
3958:                		} else {					/* No volume label is found or error */
3959:                			if (res == FR_NO_FILE) {
9D0079D0  54430024   BNEL V0, V1, 0x9D007A64
9D0079D4  00408021   ADDU S0, V0, ZERO
3960:                				res = FR_OK;
3961:                				if (vn[0]) {				/* Create volume label as new */
9D0079D8  93A20034   LBU V0, 52(SP)
9D0079DC  10400038   BEQ V0, ZERO, 0x9D007AC0
9D0079E0  02001021   ADDU V0, S0, ZERO
3962:                					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
9D0079E4  27A40010   ADDIU A0, SP, 16
9D0079E8  0F4051B3   JAL dir_alloc
9D0079EC  24050001   ADDIU A1, ZERO, 1
3963:                					if (res == FR_OK) {
9D0079F0  1440001C   BNE V0, ZERO, 0x9D007A64
9D0079F4  00408021   ADDU S0, V0, ZERO
3964:                						mem_set(dj.dir, 0, SZ_DIR);	/* Set volume label */
9D0079F8  8FA40024   LW A0, 36(SP)
9D0079FC  00002821   ADDU A1, ZERO, ZERO
9D007A00  0F405C30   JAL mem_set
9D007A04  24060020   ADDIU A2, ZERO, 32
3965:                						mem_cpy(dj.dir, vn, 11);
9D007A08  8FA40024   LW A0, 36(SP)
9D007A0C  27A50034   ADDIU A1, SP, 52
9D007A10  0F405BCE   JAL mem_cpy
9D007A14  2406000B   ADDIU A2, ZERO, 11
3966:                						dj.dir[DIR_Attr] = AM_VOL;
9D007A18  24030008   ADDIU V1, ZERO, 8
9D007A1C  8FA20024   LW V0, 36(SP)
3967:                						tm = get_fattime();
9D007A20  0F405C45   JAL get_fattime
9D007A24  A043000B   SB V1, 11(V0)
3968:                						ST_DWORD(dj.dir+DIR_WrtTime, tm);
9D007A28  8FA30024   LW V1, 36(SP)
9D007A2C  A0620016   SB V0, 22(V1)
9D007A30  7C443A00   EXT A0, V0, 8, 8
9D007A34  8FA30024   LW V1, 36(SP)
9D007A38  A0640017   SB A0, 23(V1)
9D007A3C  8FA30024   LW V1, 36(SP)
9D007A40  00022402   SRL A0, V0, 16
9D007A44  A0640018   SB A0, 24(V1)
9D007A48  00021602   SRL V0, V0, 24
9D007A4C  A0620019   SB V0, 25(V1)
3969:                						dj.fs->wflag = 1;
9D007A50  8FA40010   LW A0, 16(SP)
9D007A54  24020001   ADDIU V0, ZERO, 1
3970:                						res = sync_fs(dj.fs);
9D007A58  0F4047D7   JAL sync_fs
9D007A5C  A0820004   SB V0, 4(A0)
9D007A60  00408021   ADDU S0, V0, ZERO
3971:                					}
3972:                				}
3973:                			}
3974:                		}
3975:                	}
3976:                
3977:                	LEAVE_FF(dj.fs, res);
9D007A64  0B401EB0   J 0x9D007AC0
9D007A68  02001021   ADDU V0, S0, ZERO
3978:                }
9D007A74  0B401EB1   J 0x9D007AC4
9D007A78  8FBF005C   LW RA, 92(SP)
9D007AC0  8FBF005C   LW RA, 92(SP)
3979:                
3980:                #endif /* !_FS_READONLY */
3981:                #endif /* _USE_LABEL */
3982:                
3983:                
3984:                
3985:                /*-----------------------------------------------------------------------*/
3986:                /* Forward data to the stream directly (available on only tiny cfg)      */
3987:                /*-----------------------------------------------------------------------*/
3988:                #if _USE_FORWARD && _FS_TINY
3989:                
3990:                FRESULT f_forward (
3991:                	FIL *fp, 						/* Pointer to the file object */
3992:                	uint32_t (*func)(const uint8_t*,uint32_t),	/* Pointer to the streaming function */
3993:                	uint32_t btf,						/* Number of bytes to forward */
3994:                	uint32_t *bf						/* Pointer to number of bytes forwarded */
3995:                )
3996:                {
3997:                	FRESULT res;
3998:                	uint32_t remain, clst, sect;
3999:                	uint32_t rcnt;
4000:                	uint8_t csect;
4001:                
4002:                
4003:                	*bf = 0;	/* Clear transfer byte counter */
4004:                
4005:                	res = validate(fp);								/* Check validity of the object */
4006:                	if (res != FR_OK) LEAVE_FF(fp->fs, res);
4007:                	if (fp->flag & FA__ERROR)						/* Check error flag */
4008:                		LEAVE_FF(fp->fs, FR_INT_ERR);
4009:                	if (!(fp->flag & FA_READ))						/* Check access mode */
4010:                		LEAVE_FF(fp->fs, FR_DENIED);
4011:                
4012:                	remain = fp->fsize - fp->fptr;
4013:                	if (btf > remain) btf = (uint32_t)remain;			/* Truncate btf by remaining bytes */
4014:                
4015:                	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
4016:                		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
4017:                		csect = (uint8_t)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
4018:                		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
4019:                			if (!csect) {							/* On the cluster boundary? */
4020:                				clst = (fp->fptr == 0) ?			/* On the top of the file? */
4021:                					fp->sclust : get_fat(fp->fs, fp->clust);
4022:                				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
4023:                				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
4024:                				fp->clust = clst;					/* Update current cluster */
4025:                			}
4026:                		}
4027:                		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
4028:                		if (!sect) ABORT(fp->fs, FR_INT_ERR);
4029:                		sect += csect;
4030:                		if (move_window(fp->fs, sect))				/* Move sector window */
4031:                			ABORT(fp->fs, FR_DISK_ERR);
4032:                		fp->dsect = sect;
4033:                		rcnt = SS(fp->fs) - (uint16_t)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
4034:                		if (rcnt > btf) rcnt = btf;
4035:                		rcnt = (*func)(&fp->fs->win[(uint16_t)fp->fptr % SS(fp->fs)], rcnt);
4036:                		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
4037:                	}
4038:                
4039:                	LEAVE_FF(fp->fs, FR_OK);
4040:                }
4041:                #endif /* _USE_FORWARD */
4042:                
4043:                
4044:                
4045:                #if _USE_MKFS && !_FS_READONLY
4046:                /*-----------------------------------------------------------------------*/
4047:                /* Create File System on the Drive                                       */
4048:                /*-----------------------------------------------------------------------*/
4049:                #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
4050:                #define N_FATS		1		/* Number of FAT copies (1 or 2) */
4051:                
4052:                
4053:                int f_mkfs (
4054:                	uint8_t vol,		/* Logical drive number */
4055:                	uint8_t sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
4056:                	uint32_t au			/* Allocation unit size [bytes] */
4057:                )
4058:                {
9D00232C  27BDFFB0   ADDIU SP, SP, -80
9D002330  AFBF004C   SW RA, 76(SP)
9D002334  AFBE0048   SW S8, 72(SP)
9D002338  AFB70044   SW S7, 68(SP)
9D00233C  AFB60040   SW S6, 64(SP)
9D002340  AFB5003C   SW S5, 60(SP)
9D002344  AFB40038   SW S4, 56(SP)
9D002348  AFB30034   SW S3, 52(SP)
9D00234C  AFB20030   SW S2, 48(SP)
9D002350  AFB1002C   SW S1, 44(SP)
9D002354  AFB00028   SW S0, 40(SP)
9D002358  308400FF   ANDI A0, A0, 255
9D00235C  30B000FF   ANDI S0, A1, 255
4059:                	static const uint16_t vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
4060:                	static const uint16_t cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
4061:                	uint8_t fmt = 0, md = 0, sys = 0, *tbl = NULL, pdrv = 0, part = 0;
4062:                	uint32_t n_clst = 0, vs = 0, n = 0, wsect = 0;
9D002360  AFA00010   SW ZERO, 16(SP)
4063:                	uint32_t i = 0;
4064:                	uint32_t b_vol = 0, b_fat = 0, b_dir = 0, b_data = 0;	/* LBA */
4065:                	uint32_t n_vol = 0, n_rsv = 0, n_fat = 0, n_dir = 0;	/* Size */
9D002364  AFA00014   SW ZERO, 20(SP)
4066:                	FATFS *fs = (FATFS *)NULL;
4067:                	DSTATUS stat = 0;
4068:                
4069:                
4070:                	/* Check mounted drive and clear work area */
4071:                	if (vol >= SYS_FS_VOLUME_NUMBER) return FR_INVALID_DRIVE;
9D002368  14800247   BNE A0, ZERO, 0x9D002C88
9D00236C  2403000B   ADDIU V1, ZERO, 11
4072:                	if (sfd > 1) return FR_INVALID_PARAMETER;
9D002370  2E020002   SLTIU V0, S0, 2
9D002374  10400244   BEQ V0, ZERO, 0x9D002C88
9D002378  24030013   ADDIU V1, ZERO, 19
4073:                	if (au & (au - 1)) return FR_INVALID_PARAMETER;
9D00237C  24C2FFFF   ADDIU V0, A2, -1
9D002380  00461024   AND V0, V0, A2
9D002384  14400240   BNE V0, ZERO, 0x9D002C88
9D002388  00C0A021   ADDU S4, A2, ZERO
4074:                	fs = FatFs[vol];
9D00238C  8F91805C   LW S1, -32676(GP)
4075:                	if (!fs) return FR_NOT_ENABLED;
9D002390  1220023D   BEQ S1, ZERO, 0x9D002C88
9D002394  2403000C   ADDIU V1, ZERO, 12
4076:                	fs->fs_type = 0;
9D002398  A2200000   SB ZERO, 0(S1)
4077:                	pdrv = LD2PD(vol);	/* Physical drive */
4078:                	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
9D00239C  939680B5   LBU S6, -32587(GP)
4079:                
4080:                	/* Get disk statics */
4081:                	stat = disk_initialize(pdrv);
9D0023A0  939280B4   LBU S2, -32588(GP)
9D0023A4  0F405BD7   JAL disk_initialize
9D0023A8  02402021   ADDU A0, S2, ZERO
4082:                	if (stat & STA_NOINIT) return FR_NOT_READY;
9D0023AC  30440001   ANDI A0, V0, 1
9D0023B0  14800235   BNE A0, ZERO, 0x9D002C88
9D0023B4  24030003   ADDIU V1, ZERO, 3
4083:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
9D0023B8  30420004   ANDI V0, V0, 4
9D0023BC  304200FF   ANDI V0, V0, 255
9D0023C0  14400231   BNE V0, ZERO, 0x9D002C88
9D0023C4  2403000A   ADDIU V1, ZERO, 10
4084:                #if FAT_FS_MAX_SS != 512					/* Get disk sector size */
4085:                	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > FAT_FS_MAX_SS)
4086:                		return FR_DISK_ERR;
4087:                #endif
4088:                	if (_MULTI_PARTITION && part) {
9D0023C8  12C0002B   BEQ S6, ZERO, 0x9D002478
9D0023CC  02402021   ADDU A0, S2, ZERO
4089:                		/* Get partition information from partition table in the MBR */
4090:                		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
9D0023D0  26250038   ADDIU A1, S1, 56
9D0023D4  00003021   ADDU A2, ZERO, ZERO
9D0023D8  0F40561B   JAL disk_read
9D0023DC  24070001   ADDIU A3, ZERO, 1
9D0023E0  14400229   BNE V0, ZERO, 0x9D002C88
9D0023E4  24030001   ADDIU V1, ZERO, 1
4091:                		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
9D0023E8  92240237   LBU A0, 567(S1)
9D0023EC  00042200   SLL A0, A0, 8
9D0023F0  92220236   LBU V0, 566(S1)
9D0023F4  00822025   OR A0, A0, V0
9D0023F8  7C042620   SEH A0, A0
9D0023FC  2402AA55   ADDIU V0, ZERO, -21931
9D002400  14820221   BNE A0, V0, 0x9D002C88
9D002404  2403000E   ADDIU V1, ZERO, 14
4092:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
9D002408  00161100   SLL V0, S6, 4
9D00240C  244201E6   ADDIU V0, V0, 486
9D002410  02221021   ADDU V0, S1, V0
4093:                		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
9D002414  90440004   LBU A0, 4(V0)
9D002418  5080021C   BEQL A0, ZERO, 0x9D002C8C
9D00241C  00601021   ADDU V0, V1, ZERO
4094:                		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
9D002420  9053000B   LBU S3, 11(V0)
9D002424  00139E00   SLL S3, S3, 24
9D002428  9043000A   LBU V1, 10(V0)
9D00242C  00031C00   SLL V1, V1, 16
9D002430  02639825   OR S3, S3, V1
9D002434  90430008   LBU V1, 8(V0)
9D002438  02639825   OR S3, S3, V1
9D00243C  90430009   LBU V1, 9(V0)
9D002440  00031A00   SLL V1, V1, 8
9D002444  02639825   OR S3, S3, V1
4095:                		n_vol = LD_DWORD(tbl+12);	/* Volume size */
9D002448  9044000F   LBU A0, 15(V0)
9D00244C  00042600   SLL A0, A0, 24
9D002450  9043000E   LBU V1, 14(V0)
9D002454  00031C00   SLL V1, V1, 16
9D002458  00832025   OR A0, A0, V1
9D00245C  9043000C   LBU V1, 12(V0)
9D002460  00831825   OR V1, A0, V1
9D002464  9042000D   LBU V0, 13(V0)
9D002468  00021200   SLL V0, V0, 8
9D00246C  00621025   OR V0, V1, V0
9D002470  0B40092A   J 0x9D0024A8
9D002474  AFA20014   SW V0, 20(SP)
4096:                	} else {
4097:                		/* Create a partition in this function */
4098:                		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
9D002478  24050001   ADDIU A1, ZERO, 1
9D00247C  0F40553C   JAL disk_ioctl
9D002480  27A60014   ADDIU A2, SP, 20
9D002484  14400200   BNE V0, ZERO, 0x9D002C88
9D002488  24030001   ADDIU V1, ZERO, 1
9D00248C  8FA20014   LW V0, 20(SP)
9D002490  2C440080   SLTIU A0, V0, 128
9D002494  148001FC   BNE A0, ZERO, 0x9D002C88
9D002498  2413003F   ADDIU S3, ZERO, 63
4099:                			return FR_DISK_ERR;
4100:                		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
9D00249C  0010980B   MOVN S3, ZERO, S0
4101:                		n_vol -= b_vol;				/* Volume size */
9D0024A0  00531023   SUBU V0, V0, S3
9D0024A4  AFA20014   SW V0, 20(SP)
4102:                	}
4103:                
4104:                	if (!au) {				/* AU auto selection */
9D0024A8  5680001A   BNEL S4, ZERO, 0x9D002514
9D0024AC  0014A242   SRL S4, S4, 9
4105:                		vs = n_vol / (2000 / (SS(fs) / 512));
9D0024B0  8FA30014   LW V1, 20(SP)
9D0024B4  240207D0   ADDIU V0, ZERO, 2000
9D0024B8  0062001B   DIVU V1, V0
9D0024BC  004001F4   TEQ V0, ZERO
9D0024C0  00001012   MFLO V0
4106:                		for (i = 0; vs < vst[i]; i++) ;
9D0024C4  2C420400   SLTIU V0, V0, 1024
9D0024C8  1040000B   BEQ V0, ZERO, 0x9D0024F8
9D0024CC  00002012   MFLO A0
9D0024D0  3C039D01   LUI V1, -25343
9D0024D4  24631B52   ADDIU V1, V1, 6994
9D0024D8  00001021   ADDU V0, ZERO, ZERO
9D0024DC  24420001   ADDIU V0, V0, 1
9D0024E0  94650000   LHU A1, 0(V1)
9D0024E4  0085282B   SLTU A1, A0, A1
9D0024E8  14A0FFFC   BNE A1, ZERO, 0x9D0024DC
9D0024EC  24630002   ADDIU V1, V1, 2
9D0024F0  0B400940   J 0x9D002500
9D0024F4  00021040   SLL V0, V0, 1
9D0024F8  00001021   ADDU V0, ZERO, ZERO
4107:                		au = cst[i];
9D0024FC  00021040   SLL V0, V0, 1
9D002500  3C039D01   LUI V1, -25343
9D002504  24631B38   ADDIU V1, V1, 6968
9D002508  00431021   ADDU V0, V0, V1
9D00250C  94540000   LHU S4, 0(V0)
4108:                	}
4109:                	au /= SS(fs);		/* Number of sectors per cluster */
9D002510  0014A242   SRL S4, S4, 9
4110:                	if (au == 0) au = 1;
9D002514  24020001   ADDIU V0, ZERO, 1
9D002518  0054A00A   MOVZ S4, V0, S4
9D00251C  2E830081   SLTIU V1, S4, 129
9D002520  24020080   ADDIU V0, ZERO, 128
9D002524  0283100B   MOVN V0, S4, V1
9D002528  AFA20018   SW V0, 24(SP)
4111:                	if (au > 128) au = 128;
4112:                
4113:                	/* Pre-compute number of clusters and FAT sub-type */
4114:                	n_clst = n_vol / au;
9D00252C  8FA30014   LW V1, 20(SP)
9D002530  0062001B   DIVU V1, V0
9D002534  004001F4   TEQ V0, ZERO
9D002538  00001012   MFLO V0
4115:                	fmt = FS_FAT12;
4116:                	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
9D00253C  2C440FF6   SLTIU A0, V0, 4086
9D002540  108001C3   BEQ A0, ZERO, 0x9D002C50
9D002544  3404FFF6   ORI A0, ZERO, -10
9D002548  0B400B10   J 0x9D002C40
9D00254C  0044202B   SLTU A0, V0, A0
9D002584  24150002   ADDIU S5, ZERO, 2
4117:                	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
9D002C40  5080FE43   BEQL A0, ZERO, 0x9D002550
9D002C44  00021080   SLL V0, V0, 2
9D002C50  0044202B   SLTU A0, V0, A0
9D002C54  5080FE3E   BEQL A0, ZERO, 0x9D002550
9D002C58  00021080   SLL V0, V0, 2
4118:                
4119:                	/* Determine offset and size of FAT structure */
4120:                	if (fmt == FS_FAT32) {
4121:                		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
9D002550  24540207   ADDIU S4, V0, 519
9D002554  0014A242   SRL S4, S4, 9
9D002558  24150003   ADDIU S5, ZERO, 3
4122:                		n_rsv = 32;
4123:                		n_dir = 0;
9D00255C  0000F021   ADDU S8, ZERO, ZERO
9D002560  0B400966   J 0x9D002598
9D002564  24170020   ADDIU S7, ZERO, 32
4124:                	} else {
4125:                		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
9D002568  70441002   MUL V0, V0, A0
9D00256C  24420001   ADDIU V0, V0, 1
9D002570  00021042   SRL V0, V0, 1
9D002574  24420003   ADDIU V0, V0, 3
9D002578  0B400962   J 0x9D002588
9D00257C  24150001   ADDIU S5, ZERO, 1
9D002580  00021040   SLL V0, V0, 1
9D002C48  0B40095A   J 0x9D002568
9D002C4C  24040003   ADDIU A0, ZERO, 3
9D002C5C  0B400960   J 0x9D002580
9D002C60  24420002   ADDIU V0, V0, 2
4126:                		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
9D002588  244201FF   ADDIU V0, V0, 511
9D00258C  0002A242   SRL S4, V0, 9
4127:                		n_rsv = 1;
9D002594  24170001   ADDIU S7, ZERO, 1
4128:                		n_dir = (uint32_t)N_ROOTDIR * SZ_DIR / SS(fs);
9D002590  241E0020   ADDIU S8, ZERO, 32
4129:                	}
4130:                	b_fat = b_vol + n_rsv;				/* FAT area start sector */
9D002598  02F31021   ADDU V0, S7, S3
9D00259C  AFA20020   SW V0, 32(SP)
4131:                	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
9D0025A0  03D41021   ADDU V0, S8, S4
4132:                	b_data = b_dir + n_dir;				/* Data area start sector */
9D0025A4  8FA40020   LW A0, 32(SP)
9D0025A8  00441021   ADDU V0, V0, A0
9D0025AC  AFA2001C   SW V0, 28(SP)
4133:                	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
9D0025B0  8FA50018   LW A1, 24(SP)
9D0025B4  00B31023   SUBU V0, A1, S3
9D0025B8  8FA4001C   LW A0, 28(SP)
9D0025BC  00441021   ADDU V0, V0, A0
9D0025C0  0062102B   SLTU V0, V1, V0
9D0025C4  144001B0   BNE V0, ZERO, 0x9D002C88
9D0025C8  2403000E   ADDIU V1, ZERO, 14
4134:                
4135:                	/* Align data start sector to erase block boundary (for flash memory media) */
4136:                	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
9D0025CC  02402021   ADDU A0, S2, ZERO
9D0025D0  24050003   ADDIU A1, ZERO, 3
9D0025D4  0F40553C   JAL disk_ioctl
9D0025D8  27A60010   ADDIU A2, SP, 16
9D0025DC  14400008   BNE V0, ZERO, 0x9D002600
9D0025E0  24020001   ADDIU V0, ZERO, 1
9D0025E4  8FA30010   LW V1, 16(SP)
9D0025E8  2463FFFF   ADDIU V1, V1, -1
9D0025EC  34028000   ORI V0, ZERO, -32768
9D0025F0  0062102B   SLTU V0, V1, V0
9D0025F4  14400004   BNE V0, ZERO, 0x9D002608
9D0025F8  8FA20010   LW V0, 16(SP)
9D0025FC  24020001   ADDIU V0, ZERO, 1
9D002600  AFA20010   SW V0, 16(SP)
4137:                	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
9D002604  8FA20010   LW V0, 16(SP)
9D002608  2443FFFF   ADDIU V1, V0, -1
9D00260C  8FA5001C   LW A1, 28(SP)
9D002610  00651821   ADDU V1, V1, A1
9D002614  00021023   SUBU V0, ZERO, V0
9D002618  00621024   AND V0, V1, V0
4138:                	n = (n - b_data) / N_FATS;
9D00261C  00451023   SUBU V0, V0, A1
4139:                	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
9D002620  24030003   ADDIU V1, ZERO, 3
9D002624  16A30014   BNE S5, V1, 0x9D002678
9D002628  AFA20010   SW V0, 16(SP)
4140:                		n_rsv += n;
9D00262C  02E2B821   ADDU S7, S7, V0
4141:                		b_fat += n;
9D002630  8FA30020   LW V1, 32(SP)
9D002634  00621821   ADDU V1, V1, V0
9D002638  AFA30020   SW V1, 32(SP)
4142:                	} else {					/* FAT12/16: Expand FAT size */
4143:                		n_fat += n;
9D002678  0282A021   ADDU S4, S4, V0
4144:                	}
4145:                
4146:                	/* Determine number of clusters and final check of validity of the FAT sub-type */
4147:                	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
9D00263C  8FA20014   LW V0, 20(SP)
9D002640  00571023   SUBU V0, V0, S7
9D002644  00541023   SUBU V0, V0, S4
9D002648  005E1023   SUBU V0, V0, S8
9D00264C  8FA40018   LW A0, 24(SP)
9D002650  0044001B   DIVU V0, A0
9D002654  008001F4   TEQ A0, ZERO
9D002658  00001012   MFLO V0
9D00265C  AFA20024   SW V0, 36(SP)
9D00267C  8FA20014   LW V0, 20(SP)
9D002680  00571823   SUBU V1, V0, S7
9D002684  00741823   SUBU V1, V1, S4
9D002688  007E1823   SUBU V1, V1, S8
9D00268C  8FA50018   LW A1, 24(SP)
9D002690  0065001B   DIVU V1, A1
9D002694  00A001F4   TEQ A1, ZERO
9D002698  00001812   MFLO V1
4148:                	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
9D00269C  24040002   ADDIU A0, ZERO, 2
9D0026A0  16A40006   BNE S5, A0, 0x9D0026BC
9D0026A4  AFA30024   SW V1, 36(SP)
9D0026A8  2C640FF6   SLTIU A0, V1, 4086
9D0026AC  14800176   BNE A0, ZERO, 0x9D002C88
9D0026B0  2403000E   ADDIU V1, ZERO, 14
9D0026B4  0B4009B5   J 0x9D0026D4
9D0026B8  3C030001   LUI V1, 1
4149:                		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
9D002660  3403FFF6   ORI V1, ZERO, -10
9D002664  0043102B   SLTU V0, V0, V1
9D002668  14400187   BNE V0, ZERO, 0x9D002C88
9D00266C  2403000E   ADDIU V1, ZERO, 14
9D002670  0B4009BB   J 0x9D0026EC
9D002674  2402000C   ADDIU V0, ZERO, 12
4150:                		return FR_MKFS_ABORTED;
4151:                
4152:                	switch (fmt) {	/* Determine system ID for partition table */
9D0026BC  24030001   ADDIU V1, ZERO, 1
9D0026C0  12A3000C   BEQ S5, V1, 0x9D0026F4
9D0026C4  24030002   ADDIU V1, ZERO, 2
9D0026C8  56A30008   BNEL S5, V1, 0x9D0026EC
9D0026CC  2402000C   ADDIU V0, ZERO, 12
4153:                	case FS_FAT12:	sys = 0x01; break;
9D0026F4  24030001   ADDIU V1, ZERO, 1
9D0026F8  AFA3001C   SW V1, 28(SP)
4154:                	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
9D0026D0  3C030001   LUI V1, 1
9D0026D4  0043102B   SLTU V0, V0, V1
9D0026D8  24030004   ADDIU V1, ZERO, 4
9D0026DC  24040006   ADDIU A0, ZERO, 6
9D0026E0  0082180A   MOVZ V1, A0, V0
9D0026E4  0B4009BF   J 0x9D0026FC
9D0026E8  AFA3001C   SW V1, 28(SP)
4155:                	default: 		sys = 0x0C;
9D0026EC  0B4009BF   J 0x9D0026FC
9D0026F0  AFA2001C   SW V0, 28(SP)
4156:                	}
4157:                
4158:                	if (_MULTI_PARTITION && part) {
9D0026FC  12C0000E   BEQ S6, ZERO, 0x9D002738
9D002700  00161100   SLL V0, S6, 4
4159:                		/* Update system ID in the partition table */
4160:                		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
4161:                		tbl[4] = sys;
9D002704  02221021   ADDU V0, S1, V0
9D002708  8FA4001C   LW A0, 28(SP)
9D00270C  A04401EA   SB A0, 490(V0)
4162:                		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
9D002710  02402021   ADDU A0, S2, ZERO
9D002714  26250038   ADDIU A1, S1, 56
9D002718  00003021   ADDU A2, ZERO, ZERO
9D00271C  0F405432   JAL disk_write
9D002720  24070001   ADDIU A3, ZERO, 1
9D002724  24030001   ADDIU V1, ZERO, 1
9D002728  10400035   BEQ V0, ZERO, 0x9D002800
9D00272C  241600F8   ADDIU S6, ZERO, 248
9D002730  0B400B23   J 0x9D002C8C
9D002734  00601021   ADDU V0, V1, ZERO
4163:                		md = 0xF8;
4164:                	} else {
4165:                		if (sfd) {	/* No partition table (SFD) */
9D002738  16000031   BNE S0, ZERO, 0x9D002800
9D00273C  241600F0   ADDIU S6, ZERO, 240
4166:                			md = 0xF0;
4167:                		} else {	/* Create partition table (FDISK) */
4168:                			mem_set(fs->win, 0, SS(fs));
9D002740  26300038   ADDIU S0, S1, 56
9D002744  02002021   ADDU A0, S0, ZERO
9D002748  00002821   ADDU A1, ZERO, ZERO
9D00274C  0F405C30   JAL mem_set
9D002750  24060200   ADDIU A2, ZERO, 512
4169:                			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
4170:                			tbl[1] = 1;						/* Partition start head */
9D002754  24020001   ADDIU V0, ZERO, 1
9D002758  A22201F7   SB V0, 503(S1)
4171:                			tbl[2] = 1;						/* Partition start sector */
9D00275C  A22201F8   SB V0, 504(S1)
4172:                			tbl[3] = 0;						/* Partition start cylinder */
9D002760  A22001F9   SB ZERO, 505(S1)
4173:                			tbl[4] = sys;					/* System type */
9D002764  8FA5001C   LW A1, 28(SP)
9D002768  A22501FA   SB A1, 506(S1)
4174:                			tbl[5] = 254;					/* Partition end head */
9D00276C  2402FFFE   ADDIU V0, ZERO, -2
9D002770  A22201FB   SB V0, 507(S1)
4175:                			n = (b_vol + n_vol) / 63 / 255;
9D002774  8FA20014   LW V0, 20(SP)
9D002778  02622021   ADDU A0, S3, V0
9D00277C  24033EC1   ADDIU V1, ZERO, 16065
9D002780  0083001B   DIVU A0, V1
9D002784  006001F4   TEQ V1, ZERO
9D002788  00001812   MFLO V1
9D00278C  AFA30010   SW V1, 16(SP)
4176:                			tbl[6] = (uint8_t)((n >> 2) | 63);	/* Partition end sector */
9D002790  00032082   SRL A0, V1, 2
9D002794  3484003F   ORI A0, A0, 63
9D002798  A22401FC   SB A0, 508(S1)
4177:                			tbl[7] = (uint8_t)n;				/* End cylinder */
9D00279C  A22301FD   SB V1, 509(S1)
4178:                			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
9D0027A0  2403003F   ADDIU V1, ZERO, 63
9D0027A4  A22301FE   SB V1, 510(S1)
9D0027A8  A22001FF   SB ZERO, 511(S1)
9D0027AC  A2200200   SB ZERO, 512(S1)
9D0027B0  A2200201   SB ZERO, 513(S1)
4179:                			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
9D0027B4  A2220202   SB V0, 514(S1)
9D0027B8  7C433A00   EXT V1, V0, 8, 8
9D0027BC  A2230203   SB V1, 515(S1)
9D0027C0  00021C02   SRL V1, V0, 16
9D0027C4  A2230204   SB V1, 516(S1)
9D0027C8  00021602   SRL V0, V0, 24
9D0027CC  A2220205   SB V0, 517(S1)
4180:                			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
9D0027D0  24020055   ADDIU V0, ZERO, 85
9D0027D4  A2220236   SB V0, 566(S1)
9D0027D8  2402FFAA   ADDIU V0, ZERO, -86
9D0027DC  A2220237   SB V0, 567(S1)
4181:                			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
9D0027E0  02402021   ADDU A0, S2, ZERO
9D0027E4  02002821   ADDU A1, S0, ZERO
9D0027E8  00003021   ADDU A2, ZERO, ZERO
9D0027EC  0F405432   JAL disk_write
9D0027F0  24070001   ADDIU A3, ZERO, 1
9D0027F4  14400124   BNE V0, ZERO, 0x9D002C88
9D0027F8  24030001   ADDIU V1, ZERO, 1
4182:                				return FR_DISK_ERR;
4183:                			md = 0xF8;
9D0027FC  241600F8   ADDIU S6, ZERO, 248
4184:                		}
4185:                	}
4186:                
4187:                	/* Create BPB in the VBR */
4188:                	tbl = fs->win;							/* Clear sector */
9D002800  26300038   ADDIU S0, S1, 56
4189:                	mem_set(tbl, 0, SS(fs));
9D002804  02002021   ADDU A0, S0, ZERO
9D002808  00002821   ADDU A1, ZERO, ZERO
9D00280C  0F405C30   JAL mem_set
9D002810  24060200   ADDIU A2, ZERO, 512
4190:                	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
9D002814  02002021   ADDU A0, S0, ZERO
9D002818  3C059D01   LUI A1, -25343
9D00281C  24A51AE0   ADDIU A1, A1, 6880
9D002820  0F405BCE   JAL mem_cpy
9D002824  2406000B   ADDIU A2, ZERO, 11
4191:                	i = SS(fs);								/* Sector size */
4192:                	ST_WORD(tbl+BPB_BytsPerSec, i);
9D002828  A2200043   SB ZERO, 67(S1)
9D00282C  24020002   ADDIU V0, ZERO, 2
9D002830  A2220044   SB V0, 68(S1)
4193:                	tbl[BPB_SecPerClus] = (uint8_t)au;			/* Sectors per cluster */
9D002834  8FA20018   LW V0, 24(SP)
9D002838  A2220045   SB V0, 69(S1)
4194:                	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
9D00283C  A2370046   SB S7, 70(S1)
9D002840  7EF73A00   EXT S7, S7, 8, 8
9D002844  A2370047   SB S7, 71(S1)
4195:                	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
9D002848  24020001   ADDIU V0, ZERO, 1
9D00284C  A2220048   SB V0, 72(S1)
4196:                	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
9D002850  3AA30003   XORI V1, S5, 3
4197:                	ST_WORD(tbl+BPB_RootEntCnt, i);
9D002854  A2200049   SB ZERO, 73(S1)
9D002858  24020200   ADDIU V0, ZERO, 512
9D00285C  0003100A   MOVZ V0, ZERO, V1
9D002860  00021202   SRL V0, V0, 8
9D002864  A222004A   SB V0, 74(S1)
4198:                	if (n_vol < 0x10000) {					/* Number of total sectors */
9D002868  8FA20014   LW V0, 20(SP)
9D00286C  3C030001   LUI V1, 1
9D002870  0043182B   SLTU V1, V0, V1
9D002874  50600005   BEQL V1, ZERO, 0x9D00288C
9D002878  A2220058   SB V0, 88(S1)
4199:                		ST_WORD(tbl+BPB_TotSec16, n_vol);
9D00287C  A222004B   SB V0, 75(S1)
9D002880  7C423A00   EXT V0, V0, 8, 8
9D002884  0B400A29   J 0x9D0028A4
9D002888  A222004C   SB V0, 76(S1)
4200:                	} else {
4201:                		ST_DWORD(tbl+BPB_TotSec32, n_vol);
9D00288C  7C433A00   EXT V1, V0, 8, 8
9D002890  A2230059   SB V1, 89(S1)
9D002894  00021C02   SRL V1, V0, 16
9D002898  A223005A   SB V1, 90(S1)
9D00289C  00021602   SRL V0, V0, 24
9D0028A0  A222005B   SB V0, 91(S1)
4202:                	}
4203:                	tbl[BPB_Media] = md;					/* Media descriptor */
9D0028A4  A236004D   SB S6, 77(S1)
4204:                	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
9D0028A8  2402003F   ADDIU V0, ZERO, 63
9D0028AC  A2220050   SB V0, 80(S1)
9D0028B0  A2200051   SB ZERO, 81(S1)
4205:                	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
9D0028B4  2402FFFF   ADDIU V0, ZERO, -1
9D0028B8  A2220052   SB V0, 82(S1)
9D0028BC  A2200053   SB ZERO, 83(S1)
4206:                	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
9D0028C0  A2330054   SB S3, 84(S1)
9D0028C4  7E623A00   EXT V0, S3, 8, 8
9D0028C8  A2220055   SB V0, 85(S1)
9D0028CC  00131402   SRL V0, S3, 16
9D0028D0  A2220056   SB V0, 86(S1)
9D0028D4  00131602   SRL V0, S3, 24
4207:                	n = get_fattime();						/* Use current time as VSN */
9D0028D8  0F405C45   JAL get_fattime
9D0028DC  A2220057   SB V0, 87(S1)
4208:                	if (fmt == FS_FAT32) {
9D0028E0  24030003   ADDIU V1, ZERO, 3
9D0028E4  16A30030   BNE S5, V1, 0x9D0029A8
9D0028E8  AFA20010   SW V0, 16(SP)
4209:                		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
9D0028EC  A222007B   SB V0, 123(S1)
9D0028F0  7C433A00   EXT V1, V0, 8, 8
9D0028F4  A223007C   SB V1, 124(S1)
9D0028F8  00021C02   SRL V1, V0, 16
9D0028FC  A223007D   SB V1, 125(S1)
9D002900  00021602   SRL V0, V0, 24
9D002904  A222007E   SB V0, 126(S1)
4210:                		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
9D002908  A234005C   SB S4, 92(S1)
9D00290C  7E823A00   EXT V0, S4, 8, 8
9D002910  A222005D   SB V0, 93(S1)
9D002914  00141402   SRL V0, S4, 16
9D002918  A222005E   SB V0, 94(S1)
9D00291C  00141602   SRL V0, S4, 24
9D002920  A222005F   SB V0, 95(S1)
4211:                		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
9D002924  24020002   ADDIU V0, ZERO, 2
9D002928  A2220064   SB V0, 100(S1)
9D00292C  A2200065   SB ZERO, 101(S1)
9D002930  A2200066   SB ZERO, 102(S1)
9D002934  A2200067   SB ZERO, 103(S1)
4212:                		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
9D002938  24020001   ADDIU V0, ZERO, 1
9D00293C  A2220068   SB V0, 104(S1)
9D002940  A2200069   SB ZERO, 105(S1)
4213:                		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
9D002944  24020006   ADDIU V0, ZERO, 6
9D002948  A222006A   SB V0, 106(S1)
9D00294C  A220006B   SB ZERO, 107(S1)
4214:                		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
9D002950  2402FF80   ADDIU V0, ZERO, -128
9D002954  A2220078   SB V0, 120(S1)
4215:                		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
9D002958  24020029   ADDIU V0, ZERO, 41
9D00295C  A222007A   SB V0, 122(S1)
4216:                		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
9D002960  2624007F   ADDIU A0, S1, 127
9D002964  3C059D01   LUI A1, -25343
9D002968  24A51AEC   ADDIU A1, A1, 6892
9D00296C  0F405BCE   JAL mem_cpy
9D002970  24060013   ADDIU A2, ZERO, 19
4217:                	} else {
4218:                		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
9D0029A8  A222005F   SB V0, 95(S1)
9D0029AC  7C433A00   EXT V1, V0, 8, 8
9D0029B0  A2230060   SB V1, 96(S1)
9D0029B4  00021C02   SRL V1, V0, 16
9D0029B8  A2230061   SB V1, 97(S1)
9D0029BC  00021602   SRL V0, V0, 24
9D0029C0  A2220062   SB V0, 98(S1)
4219:                		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
9D0029C4  A234004E   SB S4, 78(S1)
9D0029C8  7E823A00   EXT V0, S4, 8, 8
9D0029CC  A222004F   SB V0, 79(S1)
4220:                		tbl[BS_DrvNum] = 0x80;				/* Drive number */
9D0029D0  2402FF80   ADDIU V0, ZERO, -128
9D0029D4  A222005C   SB V0, 92(S1)
4221:                		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
9D0029D8  24020029   ADDIU V0, ZERO, 41
9D0029DC  A222005E   SB V0, 94(S1)
4222:                		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
9D0029E0  26240063   ADDIU A0, S1, 99
9D0029E4  3C059D01   LUI A1, -25343
9D0029E8  24A51B00   ADDIU A1, A1, 6912
9D0029EC  0F405BCE   JAL mem_cpy
9D0029F0  24060013   ADDIU A2, ZERO, 19
4223:                	}
4224:                	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
9D002974  24020055   ADDIU V0, ZERO, 85
9D002978  A2220236   SB V0, 566(S1)
9D00297C  2402FFAA   ADDIU V0, ZERO, -86
9D002980  A2220237   SB V0, 567(S1)
9D0029F4  24020055   ADDIU V0, ZERO, 85
9D0029F8  A2220236   SB V0, 566(S1)
9D0029FC  2402FFAA   ADDIU V0, ZERO, -86
9D002A00  A2220237   SB V0, 567(S1)
4225:                	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
9D002984  02402021   ADDU A0, S2, ZERO
9D002988  02002821   ADDU A1, S0, ZERO
9D00298C  02603021   ADDU A2, S3, ZERO
9D002990  0F405432   JAL disk_write
9D002994  24070001   ADDIU A3, ZERO, 1
9D002998  10400023   BEQ V0, ZERO, 0x9D002A28
9D00299C  24030001   ADDIU V1, ZERO, 1
9D002A04  02402021   ADDU A0, S2, ZERO
9D002A08  02002821   ADDU A1, S0, ZERO
9D002A0C  02603021   ADDU A2, S3, ZERO
9D002A10  0F405432   JAL disk_write
9D002A14  24070001   ADDIU A3, ZERO, 1
9D002A18  10400092   BEQ V0, ZERO, 0x9D002C64
9D002A1C  24030001   ADDIU V1, ZERO, 1
4226:                		return FR_DISK_ERR;
4227:                	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
4228:                		disk_write(pdrv, tbl, b_vol + 6, 1);
9D002A28  02402021   ADDU A0, S2, ZERO
9D002A2C  02002821   ADDU A1, S0, ZERO
9D002A30  26660006   ADDIU A2, S3, 6
9D002A34  0F405432   JAL disk_write
9D002A38  24070001   ADDIU A3, ZERO, 1
4229:                
4230:                	/* Initialize FAT area */
4231:                	wsect = b_fat;
4232:                	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
4233:                		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
9D002A3C  02002021   ADDU A0, S0, ZERO
9D002A40  00002821   ADDU A1, ZERO, ZERO
9D002A44  0F405C30   JAL mem_set
9D002A48  24060200   ADDIU A2, ZERO, 512
9D002C64  02002021   ADDU A0, S0, ZERO
9D002C68  00002821   ADDU A1, ZERO, ZERO
9D002C6C  0F405C30   JAL mem_set
9D002C70  24060200   ADDIU A2, ZERO, 512
4234:                		n = md;								/* Media descriptor byte */
4235:                		if (fmt != FS_FAT32) {
4236:                			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
9D002A94  3C0200FF   LUI V0, 255
9D002A98  3442FF00   ORI V0, V0, -256
9D002A9C  00561025   OR V0, V0, S6
9D002AA0  AFA20010   SW V0, 16(SP)
9D002C74  24020001   ADDIU V0, ZERO, 1
9D002C78  12A2FF86   BEQ S5, V0, 0x9D002A94
9D002C7C  2402FF00   ADDIU V0, ZERO, -256
9D002C80  0B400AA8   J 0x9D002AA0
9D002C84  00561025   OR V0, V0, S6
4237:                			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
9D002AA4  A2220038   SB V0, 56(S1)
9D002AA8  2403FFFF   ADDIU V1, ZERO, -1
9D002AAC  A2230039   SB V1, 57(S1)
9D002AB0  A223003A   SB V1, 58(S1)
9D002AB4  00021602   SRL V0, V0, 24
9D002AB8  A222003B   SB V0, 59(S1)
4238:                		} else {
4239:                			n |= 0xFFFFFF00;
9D002A4C  2402FF00   ADDIU V0, ZERO, -256
9D002A50  02C2B025   OR S6, S6, V0
9D002A54  AFB60010   SW S6, 16(SP)
4240:                			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
9D002A58  A2360038   SB S6, 56(S1)
9D002A5C  2402FFFF   ADDIU V0, ZERO, -1
9D002A60  A2220039   SB V0, 57(S1)
9D002A64  A222003A   SB V0, 58(S1)
9D002A68  A222003B   SB V0, 59(S1)
4241:                			ST_DWORD(tbl+4, 0xFFFFFFFF);
9D002A6C  A222003C   SB V0, 60(S1)
9D002A70  A222003D   SB V0, 61(S1)
9D002A74  A222003E   SB V0, 62(S1)
9D002A78  A222003F   SB V0, 63(S1)
4242:                			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
9D002A7C  A2220040   SB V0, 64(S1)
9D002A80  A2220041   SB V0, 65(S1)
9D002A84  A2220042   SB V0, 66(S1)
9D002A88  2402000F   ADDIU V0, ZERO, 15
9D002A8C  0B400AAF   J 0x9D002ABC
9D002A90  A2220043   SB V0, 67(S1)
4243:                		}
4244:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
9D002ABC  8FA30020   LW V1, 32(SP)
9D002AC0  24760001   ADDIU S6, V1, 1
9D002AC4  02402021   ADDU A0, S2, ZERO
9D002AC8  02002821   ADDU A1, S0, ZERO
9D002ACC  00603021   ADDU A2, V1, ZERO
9D002AD0  0F405432   JAL disk_write
9D002AD4  24070001   ADDIU A3, ZERO, 1
9D002AD8  14400055   BNE V0, ZERO, 0x9D002C30
9D002ADC  02002021   ADDU A0, S0, ZERO
4245:                			return FR_DISK_ERR;
9D002C30  0B400B22   J 0x9D002C88
9D002C34  24030001   ADDIU V1, ZERO, 1
4246:                		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
9D002AE0  00002821   ADDU A1, ZERO, ZERO
9D002AE4  0F405C30   JAL mem_set
9D002AE8  24060200   ADDIU A2, ZERO, 512
4247:                		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
9D002AEC  24020001   ADDIU V0, ZERO, 1
9D002AF0  0B400AC8   J 0x9D002B20
9D002AF4  AFA20010   SW V0, 16(SP)
9D002B14  24420001   ADDIU V0, V0, 1
9D002B18  AFA20010   SW V0, 16(SP)
9D002B20  8FA20010   LW V0, 16(SP)
9D002B24  0054102B   SLTU V0, V0, S4
9D002B28  1440FFF3   BNE V0, ZERO, 0x9D002AF8
9D002B2C  26D70001   ADDIU S7, S6, 1
4248:                			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
9D002AF8  02402021   ADDU A0, S2, ZERO
9D002AFC  02002821   ADDU A1, S0, ZERO
9D002B00  02C03021   ADDU A2, S6, ZERO
9D002B04  0F405432   JAL disk_write
9D002B08  24070001   ADDIU A3, ZERO, 1
9D002B0C  1440004A   BNE V0, ZERO, 0x9D002C38
9D002B10  8FA20010   LW V0, 16(SP)
9D002B1C  02E0B021   ADDU S6, S7, ZERO
4249:                				return FR_DISK_ERR;
9D002C38  0B400B22   J 0x9D002C88
9D002C3C  24030001   ADDIU V1, ZERO, 1
4250:                		}
4251:                	}
4252:                
4253:                	/* Initialize root directory */
4254:                	i = (fmt == FS_FAT32) ? au : n_dir;
9D002B30  3AA20003   XORI V0, S5, 3
9D002B34  8FA40018   LW A0, 24(SP)
9D002B38  0082F00A   MOVZ S8, A0, V0
9D002B3C  03D6F021   ADDU S8, S8, S6
4255:                	do {
4256:                		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
9D002B40  26D40001   ADDIU S4, S6, 1
9D002B44  02402021   ADDU A0, S2, ZERO
9D002B48  02002821   ADDU A1, S0, ZERO
9D002B4C  02C03021   ADDU A2, S6, ZERO
9D002B50  0F405432   JAL disk_write
9D002B54  24070001   ADDIU A3, ZERO, 1
9D002B58  1440004B   BNE V0, ZERO, 0x9D002C88
9D002B5C  24030001   ADDIU V1, ZERO, 1
4257:                			return FR_DISK_ERR;
4258:                	} while (--i);
9D002B60  17D4FFF7   BNE S8, S4, 0x9D002B40
9D002B64  0280B021   ADDU S6, S4, ZERO
4259:                
4260:                #if _USE_ERASE	/* Erase data area if needed */
4261:                	{
4262:                		uint32_t eb[2];
4263:                
4264:                		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
4265:                		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
4266:                	}
4267:                #endif
4268:                
4269:                	/* Create FSInfo if needed */
4270:                	if (fmt == FS_FAT32) {
9D002B68  24020003   ADDIU V0, ZERO, 3
9D002B6C  16A2002B   BNE S5, V0, 0x9D002C1C
9D002B70  02402021   ADDU A0, S2, ZERO
4271:                		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
9D002B74  24020052   ADDIU V0, ZERO, 82
9D002B78  A2220038   SB V0, 56(S1)
9D002B7C  A2220039   SB V0, 57(S1)
9D002B80  24020061   ADDIU V0, ZERO, 97
9D002B84  A222003A   SB V0, 58(S1)
9D002B88  24030041   ADDIU V1, ZERO, 65
9D002B8C  A223003B   SB V1, 59(S1)
4272:                		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
9D002B90  24040072   ADDIU A0, ZERO, 114
9D002B94  A224021C   SB A0, 540(S1)
9D002B98  A224021D   SB A0, 541(S1)
9D002B9C  A223021E   SB V1, 542(S1)
9D002BA0  A222021F   SB V0, 543(S1)
4273:                		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
9D002BA4  8FA50024   LW A1, 36(SP)
9D002BA8  24A2FFFF   ADDIU V0, A1, -1
9D002BAC  A2220220   SB V0, 544(S1)
9D002BB0  7C423A00   EXT V0, V0, 8, 8
9D002BB4  A2220221   SB V0, 545(S1)
9D002BB8  24A2FFFF   ADDIU V0, A1, -1
9D002BBC  00021C02   SRL V1, V0, 16
9D002BC0  A2230222   SB V1, 546(S1)
9D002BC4  00021602   SRL V0, V0, 24
9D002BC8  A2220223   SB V0, 547(S1)
4274:                		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
9D002BCC  24020002   ADDIU V0, ZERO, 2
9D002BD0  A2220224   SB V0, 548(S1)
9D002BD4  A2200225   SB ZERO, 549(S1)
9D002BD8  A2200226   SB ZERO, 550(S1)
9D002BDC  A2200227   SB ZERO, 551(S1)
4275:                		ST_WORD(tbl+BS_55AA, 0xAA55);
9D002BE0  24020055   ADDIU V0, ZERO, 85
9D002BE4  A2220236   SB V0, 566(S1)
9D002BE8  2402FFAA   ADDIU V0, ZERO, -86
9D002BEC  A2220237   SB V0, 567(S1)
4276:                		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
9D002BF0  02402021   ADDU A0, S2, ZERO
9D002BF4  02002821   ADDU A1, S0, ZERO
9D002BF8  26660001   ADDIU A2, S3, 1
9D002BFC  0F405432   JAL disk_write
9D002C00  24070001   ADDIU A3, ZERO, 1
4277:                		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
9D002C04  02402021   ADDU A0, S2, ZERO
9D002C08  02002821   ADDU A1, S0, ZERO
9D002C0C  26660007   ADDIU A2, S3, 7
9D002C10  0F405432   JAL disk_write
9D002C14  24070001   ADDIU A3, ZERO, 1
4278:                	}
4279:                
4280:                	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
9D002C18  02402021   ADDU A0, S2, ZERO
9D002C1C  00002821   ADDU A1, ZERO, ZERO
9D002C20  0F40553C   JAL disk_ioctl
9D002C24  00003021   ADDU A2, ZERO, ZERO
9D002C28  0B400B22   J 0x9D002C88
9D002C2C  0002182B   SLTU V1, ZERO, V0
4281:                }
9D0029A0  0B400B23   J 0x9D002C8C
9D0029A4  00601021   ADDU V0, V1, ZERO
9D002A20  0B400B23   J 0x9D002C8C
9D002A24  00601021   ADDU V0, V1, ZERO
9D002C88  00601021   ADDU V0, V1, ZERO
4282:                
4283:                
4284:                #if _MULTI_PARTITION
4285:                /*-----------------------------------------------------------------------*/
4286:                /* Divide Physical Drive                                                 */
4287:                /*-----------------------------------------------------------------------*/
4288:                
4289:                int f_fdisk (
4290:                	uint8_t pdrv,			/* Physical drive number */
4291:                	const uint32_t szt[],	/* Pointer to the size table for each partitions */
4292:                	void* work			/* Pointer to the working buffer */
4293:                )
4294:                {
9D00C2D4  27BDFFC8   ADDIU SP, SP, -56
9D00C2D8  AFBF0034   SW RA, 52(SP)
9D00C2DC  AFB50030   SW S5, 48(SP)
9D00C2E0  AFB4002C   SW S4, 44(SP)
9D00C2E4  AFB30028   SW S3, 40(SP)
9D00C2E8  AFB20024   SW S2, 36(SP)
9D00C2EC  AFB10020   SW S1, 32(SP)
9D00C2F0  AFB0001C   SW S0, 28(SP)
9D00C2F4  00A09021   ADDU S2, A1, ZERO
9D00C2F8  00C08821   ADDU S1, A2, ZERO
9D00C2FC  309000FF   ANDI S0, A0, 255
4295:                	uint32_t i = 0, n = 0, sz_cyl = 0, tot_cyl = 0, b_cyl = 0, e_cyl = 0, p_cyl = 0;
4296:                	uint8_t s_hd = 0, e_hd = 0, *p = NULL, *buf = (uint8_t*)work;
4297:                	DSTATUS stat = 0;
4298:                	uint32_t sz_disk = 0, sz_part = 0, s_part = 0;
9D00C300  AFA00010   SW ZERO, 16(SP)
4299:                
4300:                
4301:                	stat = disk_initialize(pdrv);
9D00C304  0F405BD7   JAL disk_initialize
9D00C308  02002021   ADDU A0, S0, ZERO
4302:                	if (stat & STA_NOINIT) return FR_NOT_READY;
9D00C30C  30470001   ANDI A3, V0, 1
9D00C310  14E0007B   BNE A3, ZERO, 0x9D00C500
9D00C314  24030003   ADDIU V1, ZERO, 3
4303:                	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
9D00C318  30420004   ANDI V0, V0, 4
9D00C31C  304200FF   ANDI V0, V0, 255
9D00C320  14400077   BNE V0, ZERO, 0x9D00C500
9D00C324  2403000A   ADDIU V1, ZERO, 10
4304:                	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
9D00C328  02002021   ADDU A0, S0, ZERO
9D00C32C  24050001   ADDIU A1, ZERO, 1
9D00C330  0F40553C   JAL disk_ioctl
9D00C334  27A60010   ADDIU A2, SP, 16
9D00C338  14400071   BNE V0, ZERO, 0x9D00C500
9D00C33C  24030001   ADDIU V1, ZERO, 1
4305:                
4306:                	/* Determine CHS in the table regardless of the drive geometry */
4307:                	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
9D00C340  8FA30010   LW V1, 16(SP)
9D00C344  3C02000F   LUI V0, 15
9D00C348  3442C3F0   ORI V0, V0, -15376
9D00C34C  0062102B   SLTU V0, V1, V0
9D00C350  14400010   BNE V0, ZERO, 0x9D00C394
9D00C354  24020020   ADDIU V0, ZERO, 32
9D00C358  0B4030DB   J 0x9D00C36C
9D00C35C  3405FC3F   ORI A1, ZERO, -961
9D00C360  2C440100   SLTIU A0, V0, 256
9D00C364  50800008   BEQL A0, ZERO, 0x9D00C388
9D00C368  38450100   XORI A1, V0, 256
9D00C36C  0062001B   DIVU V1, V0
9D00C370  004001F4   TEQ V0, ZERO
9D00C374  00002012   MFLO A0
9D00C378  0085202B   SLTU A0, A0, A1
9D00C37C  5080FFF8   BEQL A0, ZERO, 0x9D00C360
9D00C380  00021040   SLL V0, V0, 1
9D00C394  24020010   ADDIU V0, ZERO, 16
4308:                	if (n == 256) n--;
9D00C384  38450100   XORI A1, V0, 256
9D00C388  240400FF   ADDIU A0, ZERO, 255
9D00C38C  0B4030E6   J 0x9D00C398
9D00C390  0085100A   MOVZ V0, A0, A1
4309:                	e_hd = n - 1;
9D00C398  2453FFFF   ADDIU S3, V0, -1
9D00C39C  327300FF   ANDI S3, S3, 255
4310:                	sz_cyl = 63 * n;
9D00C3A0  0002A180   SLL S4, V0, 6
9D00C3A4  0282A023   SUBU S4, S4, V0
4311:                	tot_cyl = sz_disk / sz_cyl;
9D00C3A8  0074001B   DIVU V1, S4
9D00C3AC  028001F4   TEQ S4, ZERO
9D00C3B0  0000A812   MFLO S5
4312:                
4313:                	/* Create partition table */
4314:                	mem_set(buf, 0, FAT_FS_MAX_SS);
9D00C3B4  02202021   ADDU A0, S1, ZERO
9D00C3B8  00002821   ADDU A1, ZERO, ZERO
9D00C3BC  0F405C30   JAL mem_set
9D00C3C0  24060200   ADDIU A2, ZERO, 512
4315:                	p = buf + MBR_Table; b_cyl = 0;
9D00C3C4  262301BE   ADDIU V1, S1, 446
9D00C3C8  262A01FE   ADDIU T2, S1, 510
9D00C3CC  00003021   ADDU A2, ZERO, ZERO
4316:                	for (i = 0; i < 4; i++, p += SZ_PTE) {
9D00C3D0  00002821   ADDU A1, ZERO, ZERO
9D00C4A8  24A50001   ADDIU A1, A1, 1
9D00C4AC  24630010   ADDIU V1, V1, 16
9D00C4B0  146AFFCB   BNE V1, T2, 0x9D00C3E0
9D00C4B4  26520004   ADDIU S2, S2, 4
4317:                		p_cyl = (szt[i] <= 100) ? (uint32_t)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
9D00C3D4  3C0C51EB   LUI T4, 20971
9D00C3D8  358C851F   ORI T4, T4, -31457
9D00C3E0  8E440000   LW A0, 0(S2)
9D00C3E4  2C820065   SLTIU V0, A0, 101
9D00C3E8  10400005   BEQ V0, ZERO, 0x9D00C400
9D00C3EC  70951002   MUL V0, A0, S5
9D00C3F0  004C0019   MULTU 0, V0, T4
9D00C3F4  00001010   MFHI V0
9D00C3F8  0B403103   J 0x9D00C40C
9D00C3FC  00021142   SRL V0, V0, 5
9D00C400  0094001B   DIVU A0, S4
9D00C404  028001F4   TEQ S4, ZERO
9D00C408  00001012   MFLO V0
4318:                		if (!p_cyl) continue;
9D00C40C  50400027   BEQL V0, ZERO, 0x9D00C4AC
9D00C410  24A50001   ADDIU A1, A1, 1
4319:                		s_part = (uint32_t)sz_cyl * b_cyl;
9D00C414  70D44002   MUL T0, A2, S4
4320:                		sz_part = (uint32_t)sz_cyl * p_cyl;
9D00C418  70543802   MUL A3, V0, S4
4321:                		if (i == 0) {	/* Exclude first track of cylinder 0 */
9D00C41C  14A00004   BNE A1, ZERO, 0x9D00C430
9D00C420  00005821   ADDU T3, ZERO, ZERO
4322:                			s_hd = 1;
9D00C42C  240B0001   ADDIU T3, ZERO, 1
4323:                			s_part += 63; sz_part -= 63;
9D00C424  2508003F   ADDIU T0, T0, 63
9D00C428  24E7FFC1   ADDIU A3, A3, -63
4324:                		} else {
4325:                			s_hd = 0;
4326:                		}
4327:                		e_cyl = b_cyl + p_cyl - 1;
9D00C430  00461021   ADDU V0, V0, A2
9D00C434  2449FFFF   ADDIU T1, V0, -1
4328:                		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
9D00C438  0135202B   SLTU A0, T1, S5
9D00C43C  1080002F   BEQ A0, ZERO, 0x9D00C4FC
9D00C440  00062082   SRL A0, A2, 2
9D00C4FC  24030013   ADDIU V1, ZERO, 19
4329:                
4330:                		/* Set partition table */
4331:                		p[1] = s_hd;						/* Start head */
9D00C444  A06B0001   SB T3, 1(V1)
4332:                		p[2] = (uint8_t)((b_cyl >> 2) + 1);	/* Start sector */
9D00C448  24840001   ADDIU A0, A0, 1
9D00C44C  A0640002   SB A0, 2(V1)
4333:                		p[3] = (uint8_t)b_cyl;					/* Start cylinder */
9D00C450  A0660003   SB A2, 3(V1)
4334:                		p[4] = 0x06;						/* System type (temporary setting) */
9D00C3DC  240D0006   ADDIU T5, ZERO, 6
9D00C454  A06D0004   SB T5, 4(V1)
4335:                		p[5] = e_hd;						/* End head */
9D00C458  A0730005   SB S3, 5(V1)
4336:                		p[6] = (uint8_t)((e_cyl >> 2) + 63);	/* End sector */
9D00C45C  00092082   SRL A0, T1, 2
9D00C460  2484003F   ADDIU A0, A0, 63
9D00C464  A0640006   SB A0, 6(V1)
4337:                		p[7] = (uint8_t)e_cyl;					/* End cylinder */
9D00C468  A0690007   SB T1, 7(V1)
4338:                		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
9D00C46C  A0680008   SB T0, 8(V1)
9D00C470  7D043A00   EXT A0, T0, 8, 8
9D00C474  A0640009   SB A0, 9(V1)
9D00C478  00082402   SRL A0, T0, 16
9D00C47C  A064000A   SB A0, 10(V1)
9D00C480  00084602   SRL T0, T0, 24
9D00C484  A068000B   SB T0, 11(V1)
4339:                		ST_DWORD(p + 12, sz_part);			/* Partition size */
9D00C488  A067000C   SB A3, 12(V1)
9D00C48C  7CE43A00   EXT A0, A3, 8, 8
9D00C490  A064000D   SB A0, 13(V1)
9D00C494  00072402   SRL A0, A3, 16
9D00C498  A064000E   SB A0, 14(V1)
9D00C49C  00073E02   SRL A3, A3, 24
9D00C4A0  A067000F   SB A3, 15(V1)
4340:                
4341:                		/* Next partition */
4342:                		b_cyl += p_cyl;
9D00C4A4  00403021   ADDU A2, V0, ZERO
4343:                	}
4344:                	ST_WORD(p, 0xAA55);
9D00C4B8  24020055   ADDIU V0, ZERO, 85
9D00C4BC  A0620000   SB V0, 0(V1)
9D00C4C0  2402FFAA   ADDIU V0, ZERO, -86
9D00C4C4  A0620001   SB V0, 1(V1)
4345:                
4346:                	/* Write it to the MBR */
4347:                	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
9D00C4C8  02002021   ADDU A0, S0, ZERO
9D00C4CC  02202821   ADDU A1, S1, ZERO
9D00C4D0  00003021   ADDU A2, ZERO, ZERO
9D00C4D4  0F405432   JAL disk_write
9D00C4D8  24070001   ADDIU A3, ZERO, 1
9D00C4DC  14400008   BNE V0, ZERO, 0x9D00C500
9D00C4E0  24030001   ADDIU V1, ZERO, 1
9D00C4E4  02002021   ADDU A0, S0, ZERO
9D00C4E8  00002821   ADDU A1, ZERO, ZERO
9D00C4EC  0F40553C   JAL disk_ioctl
9D00C4F0  00003021   ADDU A2, ZERO, ZERO
9D00C4F4  0B403140   J 0x9D00C500
9D00C4F8  0002182B   SLTU V1, ZERO, V0
4348:                }
9D00C500  00601021   ADDU V0, V1, ZERO
4349:                
4350:                
4351:                #endif /* _MULTI_PARTITION */
4352:                #endif /* _USE_MKFS && !_FS_READONLY */
4353:                
4354:                
4355:                
4356:                
4357:                #if _USE_STRFUNC
4358:                /*-----------------------------------------------------------------------*/
4359:                /* Get a string from the file                                            */
4360:                /*-----------------------------------------------------------------------*/
4361:                
4362:                TCHAR* f_gets (
4363:                	TCHAR* buff,	/* Pointer to the string buffer to read */
4364:                	int len,		/* Size of string buffer (characters) */
4365:                	uintptr_t handle			/* Pointer to the file object */
4366:                )
4367:                {
9D014170  27BDFFC8   ADDIU SP, SP, -56
9D014174  AFBF0034   SW RA, 52(SP)
9D014178  AFB50030   SW S5, 48(SP)
9D01417C  AFB4002C   SW S4, 44(SP)
9D014180  AFB30028   SW S3, 40(SP)
9D014184  AFB20024   SW S2, 36(SP)
9D014188  AFB10020   SW S1, 32(SP)
9D01418C  AFB0001C   SW S0, 28(SP)
9D014190  0080A821   ADDU S5, A0, ZERO
9D014194  00C09821   ADDU S3, A2, ZERO
4368:                	int n = 0;
9D0141A4  00008021   ADDU S0, ZERO, ZERO
4369:                	TCHAR c = 0, *p = buff;
9D0141A0  00808821   ADDU S1, A0, ZERO
4370:                	uint8_t s[2] = {};
9D014198  A7A00010   SH ZERO, 16(SP)
4371:                	uint32_t rc = 0;
9D01419C  AFA00014   SW ZERO, 20(SP)
4372:                
4373:                	while (n < len - 1) {			/* Read bytes until buffer gets filled */
9D0141A8  24B2FFFF   ADDIU S2, A1, -1
9D0141AC  0B405079   J 0x9D0141E4
9D0141B0  2414000A   ADDIU S4, ZERO, 10
9D0141E4  0212182A   SLT V1, S0, S2
9D0141E8  1460FFF2   BNE V1, ZERO, 0x9D0141B4
9D0141EC  02602021   ADDU A0, S3, ZERO
4374:                		f_read(handle, s, 1, &rc);
9D0141B4  27A50010   ADDIU A1, SP, 16
9D0141B8  24060001   ADDIU A2, ZERO, 1
9D0141BC  0F4024A1   JAL f_read
9D0141C0  27A70014   ADDIU A3, SP, 20
4375:                		if (rc != 1) break;			/* Break on EOF or error */
9D0141C4  24030001   ADDIU V1, ZERO, 1
9D0141C8  8FA20014   LW V0, 20(SP)
9D0141CC  14430008   BNE V0, V1, 0x9D0141F0
9D0141D0  83A30010   LB V1, 16(SP)
4376:                		c = s[0];
4377:                #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
4378:                		if (c >= 0x80) {
4379:                			if (c < 0xC0) continue;	/* Skip stray trailer */
4380:                			if (c < 0xE0) {			/* Two-byte sequence */
4381:                				f_read(fp, s, 1, &rc);
4382:                				if (rc != 1) break;
4383:                				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
4384:                				if (c < 0x80) c = '?';
4385:                			} else {
4386:                				if (c < 0xF0) {		/* Three-byte sequence */
4387:                					f_read(fp, s, 2, &rc);
4388:                					if (rc != 2) break;
4389:                					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
4390:                					if (c < 0x800) c = '?';
4391:                				} else {			/* Reject four-byte sequence */
4392:                					c = '?';
4393:                				}
4394:                			}
4395:                		}
4396:                #endif
4397:                #if _USE_STRFUNC >= 2
4398:                		if (c == '\r') continue;	/* Strip '\r' */
4399:                #endif
4400:                		*p++ = c;
9D0141D4  26310001   ADDIU S1, S1, 1
9D0141D8  A223FFFF   SB V1, -1(S1)
4401:                		n++;
4402:                		if (c == '\n') break;		/* Break on EOL */
9D0141DC  10740004   BEQ V1, S4, 0x9D0141F0
9D0141E0  26100001   ADDIU S0, S0, 1
4403:                	}
4404:                	*p = 0;
9D0141F0  A2200000   SB ZERO, 0(S1)
4405:                	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
4406:                }
9D0141F4  00001021   ADDU V0, ZERO, ZERO
4407:                
4408:                
4409:                
4410:                #if !_FS_READONLY
4411:                #include <stdarg.h>
4412:                /*-----------------------------------------------------------------------*/
4413:                /* Put a character to the file                                           */
4414:                /*-----------------------------------------------------------------------*/
4415:                
4416:                int f_putc (
4417:                	TCHAR c,	/* A character to be output */
4418:                	uintptr_t handle		/* Pointer to the file object */
4419:                )
4420:                {
9D0167B4  27BDFFE0   ADDIU SP, SP, -32
9D0167B8  AFBF001C   SW RA, 28(SP)
4421:                	uint32_t bw, btw;
4422:                	uint8_t s[3];
4423:                
4424:                
4425:                #if _USE_STRFUNC >= 2
4426:                	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
4427:                #endif
4428:                
4429:                #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
4430:                	if (c < 0x80) {			/* 7-bit */
4431:                		s[0] = (uint8_t)c;
4432:                		btw = 1;
4433:                	} else {
4434:                		if (c < 0x800) {	/* 11-bit */
4435:                			s[0] = (uint8_t)(0xC0 | (c >> 6));
4436:                			s[1] = (uint8_t)(0x80 | (c & 0x3F));
4437:                			btw = 2;
4438:                		} else {			/* 16-bit */
4439:                			s[0] = (uint8_t)(0xE0 | (c >> 12));
4440:                			s[1] = (uint8_t)(0x80 | ((c >> 6) & 0x3F));
4441:                			s[2] = (uint8_t)(0x80 | (c & 0x3F));
4442:                			btw = 3;
4443:                		}
4444:                	}
4445:                #else				/* Write the character without conversion */
4446:                	s[0] = (uint8_t)c;
9D0167BC  A3A40014   SB A0, 20(SP)
4447:                	btw = 1;
4448:                #endif
4449:                	f_write(handle, s, btw, &bw);		/* Write the char to the file */
9D0167C0  00A02021   ADDU A0, A1, ZERO
9D0167C4  27A50014   ADDIU A1, SP, 20
9D0167C8  24060001   ADDIU A2, ZERO, 1
9D0167CC  0F40215C   JAL f_write
9D0167D0  27A70010   ADDIU A3, SP, 16
4450:                	return (bw == btw) ? 1 : EOF;	/* Return the result */
9D0167D4  8FA40010   LW A0, 16(SP)
9D0167D8  38840001   XORI A0, A0, 1
4451:                }
9D0167DC  24030001   ADDIU V1, ZERO, 1
4452:                
4453:                
4454:                
4455:                
4456:                /*-----------------------------------------------------------------------*/
4457:                /* Put a string to the file                                              */
4458:                /*-----------------------------------------------------------------------*/
4459:                
4460:                int f_puts (
4461:                	const TCHAR* str,	/* Pointer to the string to be output */
4462:                	uintptr_t handle				/* Pointer to the file object */
4463:                )
4464:                {
9D01595C  27BDFFD8   ADDIU SP, SP, -40
9D015960  AFBF0024   SW RA, 36(SP)
9D015964  AFB30020   SW S3, 32(SP)
9D015968  AFB2001C   SW S2, 28(SP)
9D01596C  AFB10018   SW S1, 24(SP)
9D015970  AFB00014   SW S0, 20(SP)
9D015974  00808821   ADDU S1, A0, ZERO
4465:                	int n;
4466:                
4467:                
4468:                	for (n = 0; *str; str++, n++) {
9D015978  80840000   LB A0, 0(A0)
9D01597C  1080000C   BEQ A0, ZERO, 0x9D0159B0
9D015980  00A09021   ADDU S2, A1, ZERO
9D015984  02208021   ADDU S0, S1, ZERO
9D01599C  82040000   LB A0, 0(S0)
9D0159A0  1480FFFA   BNE A0, ZERO, 0x9D01598C
9D0159A4  02111023   SUBU V0, S0, S1
9D0159A8  0B40566E   J 0x9D0159B8
9D0159AC  8FBF0024   LW RA, 36(SP)
9D0159B0  00001021   ADDU V0, ZERO, ZERO
4469:                		if (f_putc(*str, handle) == EOF) return EOF;
9D015988  2413FFFF   ADDIU S3, ZERO, -1
9D01598C  0F4059ED   JAL f_putc
9D015990  02402821   ADDU A1, S2, ZERO
9D015994  10530007   BEQ V0, S3, 0x9D0159B4
9D015998  26100001   ADDIU S0, S0, 1
4470:                	}
4471:                	return n;
4472:                }
9D0159B4  8FBF0024   LW RA, 36(SP)
4473:                
4474:                
4475:                
4476:                
4477:                /*-----------------------------------------------------------------------*/
4478:                /* Put a formatted string to the file                                    */
4479:                /*-----------------------------------------------------------------------*/
4480:                
4481:                int f_printf (
4482:                	uintptr_t handle,			/* Pointer to the file object */
4483:                	const TCHAR* str,	/* Pointer to the format string */
4484:                	...					/* Optional arguments... */
4485:                )
4486:                {
9D005628  27BDFFA8   ADDIU SP, SP, -88
9D00562C  AFBF0054   SW RA, 84(SP)
9D005630  AFBE0050   SW S8, 80(SP)
9D005634  AFB7004C   SW S7, 76(SP)
9D005638  AFB60048   SW S6, 72(SP)
9D00563C  AFB50044   SW S5, 68(SP)
9D005640  AFB40040   SW S4, 64(SP)
9D005644  AFB3003C   SW S3, 60(SP)
9D005648  AFB20038   SW S2, 56(SP)
9D00564C  AFB10034   SW S1, 52(SP)
9D005650  AFB00030   SW S0, 48(SP)
9D005654  0080A021   ADDU S4, A0, ZERO
9D005658  AFA60060   SW A2, 96(SP)
9D00565C  AFA70064   SW A3, 100(SP)
9D005660  00A09821   ADDU S3, A1, ZERO
4487:                	va_list arp;
4488:                	uint8_t f, r;
4489:                	uint32_t i, j, w;
4490:                	uint32_t v;
4491:                	TCHAR c, d, s[16], *p;
4492:                	int res, chc, cc;
4493:                
4494:                
4495:                	va_start(arp, str);
9D005664  27A20060   ADDIU V0, SP, 96
9D005668  AFA20010   SW V0, 16(SP)
4496:                
4497:                	for (cc = res = 0; cc != EOF; res += cc) {
9D005678  00008821   ADDU S1, ZERO, ZERO
9D00567C  0000F021   ADDU S8, ZERO, ZERO
9D005AA4  2402FFFF   ADDIU V0, ZERO, -1
9D005AA8  1622FEF9   BNE S1, V0, 0x9D005690
9D005AAC  03D1F021   ADDU S8, S8, S1
9D005AB0  0B4016D2   J 0x9D005B48
9D005AB4  02201021   ADDU V0, S1, ZERO
9D005AB8  00111027   NOR V0, ZERO, S1
9D005ABC  0222F00A   MOVZ S8, S1, V0
9D005AC0  0B4016D2   J 0x9D005B48
9D005AC4  03C01021   ADDU V0, S8, ZERO
9D005AEC  02009821   ADDU S3, S0, ZERO
9D005AF8  0000F021   ADDU S8, ZERO, ZERO
4498:                		c = *str++;
9D00566C  80A40000   LB A0, 0(A1)
9D005690  82640000   LB A0, 0(S3)
4499:                		if (c == 0) break;			/* End of string */
9D005670  10800121   BEQ A0, ZERO, 0x9D005AF8
9D005674  24B00001   ADDIU S0, A1, 1
9D005694  10800119   BEQ A0, ZERO, 0x9D005AFC
9D005698  26700001   ADDIU S0, S3, 1
4500:                		if (c != '%') {				/* Non escape character */
9D00569C  24020025   ADDIU V0, ZERO, 37
9D0056A0  50820008   BEQL A0, V0, 0x9D0056C4
9D0056A4  82640001   LB A0, 1(S3)
4501:                			cc = f_putc(c, handle);
9D0056A8  0F4059ED   JAL f_putc
9D0056AC  02802821   ADDU A1, S4, ZERO
4502:                			if (cc != EOF) cc = 1;
9D0056B0  2403FFFF   ADDIU V1, ZERO, -1
9D0056B4  1443010D   BNE V0, V1, 0x9D005AEC
9D0056B8  27DE0001   ADDIU S8, S8, 1
9D0056BC  0B4016D3   J 0x9D005B4C
9D0056C0  8FBF0054   LW RA, 84(SP)
9D005AF0  0B4015A4   J 0x9D005690
9D005AF4  24110001   ADDIU S1, ZERO, 1
4503:                			continue;
4504:                		}
4505:                		w = f = 0;
4506:                		c = *str++;
9D0056E8  0B4015BF   J 0x9D0056FC
9D0056EC  26730002   ADDIU S3, S3, 2
4507:                		if (c == '0') {				/* Flag: '0' padding */
9D0056C4  24020030   ADDIU V0, ZERO, 48
9D0056C8  14820005   BNE A0, V0, 0x9D0056E0
9D0056CC  2402002D   ADDIU V0, ZERO, 45
4508:                			f = 1; c = *str++;
9D0056D0  82640002   LB A0, 2(S3)
9D0056D4  26730003   ADDIU S3, S3, 3
9D0056D8  0B4015BF   J 0x9D0056FC
9D0056DC  24080001   ADDIU T0, ZERO, 1
4509:                		} else {
4510:                			if (c == '-') {			/* Flag: left justified */
9D0056E0  10820003   BEQ A0, V0, 0x9D0056F0
9D0056E4  00004021   ADDU T0, ZERO, ZERO
4511:                				f = 2; c = *str++;
9D0056F0  82640002   LB A0, 2(S3)
9D0056F4  26730003   ADDIU S3, S3, 3
9D0056F8  24080002   ADDIU T0, ZERO, 2
4512:                			}
4513:                		}
4514:                		while (IsDigit(c)) {		/* Precision */
9D0056FC  2482FFD0   ADDIU V0, A0, -48
9D005700  304200FF   ANDI V0, V0, 255
9D005704  2C42000A   SLTIU V0, V0, 10
9D005708  1040000E   BEQ V0, ZERO, 0x9D005744
9D00570C  00009021   ADDU S2, ZERO, ZERO
9D005728  2482FFD0   ADDIU V0, A0, -48
9D00572C  304200FF   ANDI V0, V0, 255
9D005730  2C42000A   SLTIU V0, V0, 10
9D005734  1440FFF6   BNE V0, ZERO, 0x9D005710
9D005738  2652FFD0   ADDIU S2, S2, -48
9D00573C  0B4015D2   J 0x9D005748
9D005740  2403FFDF   ADDIU V1, ZERO, -33
4515:                			w = w * 10 + c - '0';
9D005710  00121040   SLL V0, S2, 1
9D005714  001290C0   SLL S2, S2, 3
9D005718  00529021   ADDU S2, V0, S2
9D00571C  02449021   ADDU S2, S2, A0
4516:                			c = *str++;
9D005720  26730001   ADDIU S3, S3, 1
9D005724  8264FFFF   LB A0, -1(S3)
4517:                		}
4518:                		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
9D005744  2403FFDF   ADDIU V1, ZERO, -33
9D005748  00831824   AND V1, A0, V1
9D00574C  2402004C   ADDIU V0, ZERO, 76
9D005750  14620004   BNE V1, V0, 0x9D005764
9D005754  00000000   NOP
4519:                			f |= 4; c = *str++;
9D005758  35080004   ORI T0, T0, 4
9D00575C  82640000   LB A0, 0(S3)
9D005760  26730001   ADDIU S3, S3, 1
4520:                		}
4521:                		if (!c) break;
9D005764  108000D4   BEQ A0, ZERO, 0x9D005AB8
9D005768  308300FF   ANDI V1, A0, 255
4522:                		d = c;
4523:                		if (IsLower(d)) d -= 0x20;
9D00576C  2465FF9F   ADDIU A1, V1, -97
9D005770  30A500FF   ANDI A1, A1, 255
9D005774  2CA5001A   SLTIU A1, A1, 26
9D005778  10A00003   BEQ A1, ZERO, 0x9D005788
9D00577C  00801021   ADDU V0, A0, ZERO
9D005780  2462FFE0   ADDIU V0, V1, -32
9D005784  7C021420   SEB V0, V0
4524:                		switch (d) {				/* Type is... */
9D005680  3C029D00   LUI V0, -25344
9D005684  244257B0   ADDIU V0, V0, 22448
9D005688  0B4015A7   J 0x9D00569C
9D00568C  AFA20028   SW V0, 40(SP)
9D005788  2443FFBE   ADDIU V1, V0, -66
9D00578C  306500FF   ANDI A1, V1, 255
9D005790  2CA50017   SLTIU A1, A1, 23
9D005794  10A00057   BEQ A1, ZERO, 0x9D0058F4
9D005798  306300FF   ANDI V1, V1, 255
9D00579C  00031880   SLL V1, V1, 2
9D0057A0  8FA50028   LW A1, 40(SP)
9D0057A4  7CA3180A   LWX V1, V1(A1)
9D0057A8  00600008   JR V1
9D0057AC  00000000   NOP
4525:                		case 'S' :					/* String */
4526:                			p = va_arg(arp, TCHAR*);
9D00580C  8FA20010   LW V0, 16(SP)
9D005810  24430004   ADDIU V1, V0, 4
9D005814  AFA30010   SW V1, 16(SP)
9D005818  8C550000   LW S5, 0(V0)
4527:                			for (j = 0; p[j]; j++) ;
9D00581C  82A20000   LB V0, 0(S5)
9D005820  10400007   BEQ V0, ZERO, 0x9D005840
9D005824  00008021   ADDU S0, ZERO, ZERO
9D005828  26100001   ADDIU S0, S0, 1
9D00582C  7EB0118A   LBUX V0, S0(S5)
9D005830  5440FFFE   BNEL V0, ZERO, 0x9D00582C
9D005834  26100001   ADDIU S0, S0, 1
9D005838  0B401611   J 0x9D005844
9D00583C  31020002   ANDI V0, T0, 2
4528:                			chc = 0;
4529:                			if (!(f & 2)) {
9D005840  31020002   ANDI V0, T0, 2
9D005844  304200FF   ANDI V0, V0, 255
9D005848  14400010   BNE V0, ZERO, 0x9D00588C
9D00584C  00008821   ADDU S1, ZERO, ZERO
4530:                				while (j++ < w) chc += (cc = f_putc(' ', handle));
9D005850  0212102B   SLTU V0, S0, S2
9D005854  1040000B   BEQ V0, ZERO, 0x9D005884
9D005858  26030001   ADDIU V1, S0, 1
9D00585C  24040020   ADDIU A0, ZERO, 32
9D005860  0F4059ED   JAL f_putc
9D005864  02802821   ADDU A1, S4, ZERO
9D005868  02228821   ADDU S1, S1, V0
9D00586C  26100001   ADDIU S0, S0, 1
9D005870  0212102B   SLTU V0, S0, S2
9D005874  1440FFFA   BNE V0, ZERO, 0x9D005860
9D005878  24040020   ADDIU A0, ZERO, 32
9D00587C  0B401623   J 0x9D00588C
9D005880  26500001   ADDIU S0, S2, 1
9D005884  00608021   ADDU S0, V1, ZERO
9D005888  00008821   ADDU S1, ZERO, ZERO
4531:                			}
4532:                			chc += (cc = f_puts(p, handle));
9D00588C  02A02021   ADDU A0, S5, ZERO
9D005890  0F405657   JAL f_puts
9D005894  02802821   ADDU A1, S4, ZERO
4533:                			while (j++ < w) chc += (cc = f_putc(' ', handle));
9D005898  0212182B   SLTU V1, S0, S2
9D00589C  10600008   BEQ V1, ZERO, 0x9D0058C0
9D0058A0  00518821   ADDU S1, V0, S1
9D0058A4  24040020   ADDIU A0, ZERO, 32
9D0058A8  0F4059ED   JAL f_putc
9D0058AC  02802821   ADDU A1, S4, ZERO
9D0058B0  26100001   ADDIU S0, S0, 1
9D0058B4  0212182B   SLTU V1, S0, S2
9D0058B8  1460FFFA   BNE V1, ZERO, 0x9D0058A4
9D0058BC  02228821   ADDU S1, S1, V0
4534:                			if (cc != EOF) cc = chc;
9D0058C0  2403FFFF   ADDIU V1, ZERO, -1
9D0058C4  54430078   BNEL V0, V1, 0x9D005AA8
9D0058C8  2402FFFF   ADDIU V0, ZERO, -1
9D0058CC  0B4016D3   J 0x9D005B4C
9D0058D0  8FBF0054   LW RA, 84(SP)
4535:                			continue;
4536:                		case 'C' :					/* Character */
4537:                			cc = f_putc((TCHAR)va_arg(arp, int), handle); continue;
9D0058D4  8FA20010   LW V0, 16(SP)
9D0058D8  24430004   ADDIU V1, V0, 4
9D0058DC  AFA30010   SW V1, 16(SP)
9D0058E0  80440000   LB A0, 0(V0)
9D0058E4  0F4059ED   JAL f_putc
9D0058E8  02802821   ADDU A1, S4, ZERO
9D0058EC  0B4016A9   J 0x9D005AA4
9D0058F0  00408821   ADDU S1, V0, ZERO
4538:                		case 'B' :					/* Binary */
4539:                			r = 2; break;
4540:                		case 'O' :					/* Octal */
4541:                			r = 8; break;
9D005AC8  0B4016B5   J 0x9D005AD4
9D005ACC  24060008   ADDIU A2, ZERO, 8
4542:                		case 'D' :					/* Signed decimal */
4543:                		case 'U' :					/* Unsigned decimal */
4544:                			r = 10; break;
4545:                		case 'X' :					/* Hexdecimal */
4546:                			r = 16; break;
9D005AD0  24060010   ADDIU A2, ZERO, 16
4547:                		default:					/* Unknown type (pass-through) */
4548:                			cc = f_putc(c, handle); continue;
9D0058F4  0F4059ED   JAL f_putc
9D0058F8  02802821   ADDU A1, S4, ZERO
9D0058FC  0B4016A9   J 0x9D005AA4
9D005900  00408821   ADDU S1, V0, ZERO
4549:                		}
4550:                
4551:                		/* Get an argument and put it in numeral */
4552:                		v = (f & 4) ? (uint32_t)va_arg(arp, long) : ((d == 'D') ? (uint32_t)(long)va_arg(arp, int) : (uint32_t)va_arg(arp, unsigned int));
9D005904  31030004   ANDI V1, T0, 4
9D005908  306300FF   ANDI V1, V1, 255
9D00590C  14600003   BNE V1, ZERO, 0x9D00591C
9D005910  2406000A   ADDIU A2, ZERO, 10
9D005914  0B40164F   J 0x9D00593C
9D005918  24030044   ADDIU V1, ZERO, 68
9D00591C  8FA30010   LW V1, 16(SP)
9D005920  24650004   ADDIU A1, V1, 4
9D005924  AFA50010   SW A1, 16(SP)
9D00593C  14430006   BNE V0, V1, 0x9D005958
9D005940  8FA20010   LW V0, 16(SP)
9D005944  24430004   ADDIU V1, V0, 4
9D005948  AFA30010   SW V1, 16(SP)
9D00594C  0B40165A   J 0x9D005968
9D005950  8C430000   LW V1, 0(V0)
9D005954  8FA20010   LW V0, 16(SP)
9D005958  24430004   ADDIU V1, V0, 4
9D00595C  AFA30010   SW V1, 16(SP)
9D005960  0B40165E   J 0x9D005978
9D005964  8C430000   LW V1, 0(V0)
9D005AD4  31030004   ANDI V1, T0, 4
9D005AD8  306300FF   ANDI V1, V1, 255
9D005ADC  5460FF90   BNEL V1, ZERO, 0x9D005920
9D005AE0  8FA30010   LW V1, 16(SP)
9D005AE4  0B401656   J 0x9D005958
9D005AE8  8FA20010   LW V0, 16(SP)
9D005B30  31030004   ANDI V1, T0, 4
9D005B34  306300FF   ANDI V1, V1, 255
9D005B38  1060FF86   BEQ V1, ZERO, 0x9D005954
9D005B3C  24060002   ADDIU A2, ZERO, 2
9D005B40  0B401648   J 0x9D005920
9D005B44  8FA30010   LW V1, 16(SP)
4553:                		if (d == 'D' && (v & 0x80000000)) {
9D005928  24050044   ADDIU A1, ZERO, 68
9D00592C  14450012   BNE V0, A1, 0x9D005978
9D005930  8C630000   LW V1, 0(V1)
9D005934  0B40165A   J 0x9D005968
9D005938  00000000   NOP
9D005968  04610004   BGEZ V1, 0x9D00597C
9D00596C  00003821   ADDU A3, ZERO, ZERO
4554:                			v = 0 - v;
9D005970  00031823   SUBU V1, ZERO, V1
4555:                			f |= 8;
9D005974  35080008   ORI T0, T0, 8
4556:                		}
4557:                		i = 0;
9D005978  00003821   ADDU A3, ZERO, ZERO
4558:                		do {
4559:                			d = (TCHAR)(v % r); v /= r;
9D005994  0066001B   DIVU V1, A2
9D005998  00C001F4   TEQ A2, ZERO
9D00599C  00002810   MFHI A1
9D0059A0  00001812   MFLO V1
9D0059A4  7C051420   SEB V0, A1
4560:                			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
9D00597C  38840078   XORI A0, A0, 120
9D005980  24020027   ADDIU V0, ZERO, 39
9D005984  24050007   ADDIU A1, ZERO, 7
9D005988  00A4100B   MOVN V0, A1, A0
9D00598C  00402021   ADDU A0, V0, ZERO
9D0059A8  2849000A   SLTI T1, V0, 10
9D0059AC  00852821   ADDU A1, A0, A1
9D0059B0  00A9100A   MOVZ V0, A1, T1
4561:                			s[i++] = d + '0';
9D0059B4  24F00001   ADDIU S0, A3, 1
9D0059B8  27A90014   ADDIU T1, SP, 20
9D0059BC  01302821   ADDU A1, T1, S0
9D0059C0  24420030   ADDIU V0, V0, 48
9D0059D4  0B401665   J 0x9D005994
9D0059D8  02003821   ADDU A3, S0, ZERO
9D0059DC  02001821   ADDU V1, S0, ZERO
4562:                		} while (v && i < sizeof s / sizeof s[0]);
9D005990  240A0010   ADDIU T2, ZERO, 16
9D0059C4  10600005   BEQ V1, ZERO, 0x9D0059DC
9D0059C8  A0A2FFFF   SB V0, -1(A1)
9D0059CC  520A0004   BEQL S0, T2, 0x9D0059E0
9D0059D0  02001821   ADDU V1, S0, ZERO
4563:                		if (f & 8) s[i++] = '-';
9D0059E0  31020008   ANDI V0, T0, 8
9D0059E4  304200FF   ANDI V0, V0, 255
9D0059E8  10400006   BEQ V0, ZERO, 0x9D005A04
9D0059EC  31040001   ANDI A0, T0, 1
9D0059F0  24F00002   ADDIU S0, A3, 2
9D0059F4  27A20010   ADDIU V0, SP, 16
9D0059F8  00431821   ADDU V1, V0, V1
9D0059FC  2402002D   ADDIU V0, ZERO, 45
9D005A00  A0620004   SB V0, 4(V1)
4564:                		j = i; d = (f & 1) ? '0' : ' ';
9D005A04  24020030   ADDIU V0, ZERO, 48
9D005A08  24030020   ADDIU V1, ZERO, 32
9D005A0C  0064100A   MOVZ V0, V1, A0
9D005A48  0200A821   ADDU S5, S0, ZERO
4565:                		chc = 0;
9D005A4C  00008821   ADDU S1, ZERO, ZERO
4566:                		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, handle));
9D005A10  31080002   ANDI T0, T0, 2
9D005A14  310800FF   ANDI T0, T0, 255
9D005A18  1500000B   BNE T0, ZERO, 0x9D005A48
9D005A1C  00402021   ADDU A0, V0, ZERO
9D005A20  26150001   ADDIU S5, S0, 1
9D005A24  0212102B   SLTU V0, S0, S2
9D005A28  10400009   BEQ V0, ZERO, 0x9D005A50
9D005A2C  00008821   ADDU S1, ZERO, ZERO
9D005A30  0B4016C6   J 0x9D005B18
9D005A34  0080B821   ADDU S7, A0, ZERO
9D005A38  16B60032   BNE S5, S6, 0x9D005B04
9D005A3C  02E02021   ADDU A0, S7, ZERO
9D005A40  0B401694   J 0x9D005A50
9D005A44  26550001   ADDIU S5, S2, 1
9D005B04  0F4059ED   JAL f_putc
9D005B08  02802821   ADDU A1, S4, ZERO
9D005B0C  02228821   ADDU S1, S1, V0
9D005B10  0B40168E   J 0x9D005A38
9D005B14  26B50001   ADDIU S5, S5, 1
9D005B18  0F4059ED   JAL f_putc
9D005B1C  02802821   ADDU A1, S4, ZERO
9D005B20  00408821   ADDU S1, V0, ZERO
9D005B24  26150002   ADDIU S5, S0, 2
9D005B28  0B40168E   J 0x9D005A38
9D005B2C  26560001   ADDIU S6, S2, 1
4567:                		do chc += (cc = f_putc(s[--i], handle)); while(i);
9D005A50  2610FFFF   ADDIU S0, S0, -1
9D005A54  27A30014   ADDIU V1, SP, 20
9D005A58  00701021   ADDU V0, V1, S0
9D005A5C  80440000   LB A0, 0(V0)
9D005A60  0F4059ED   JAL f_putc
9D005A64  02802821   ADDU A1, S4, ZERO
9D005A68  1600FFF9   BNE S0, ZERO, 0x9D005A50
9D005A6C  02228821   ADDU S1, S1, V0
4568:                		while (j++ < w) chc += (cc = f_putc(' ', handle));
9D005A70  02B2182B   SLTU V1, S5, S2
9D005A74  10600009   BEQ V1, ZERO, 0x9D005A9C
9D005A78  2403FFFF   ADDIU V1, ZERO, -1
9D005A7C  24040020   ADDIU A0, ZERO, 32
9D005A80  0F4059ED   JAL f_putc
9D005A84  02802821   ADDU A1, S4, ZERO
9D005A88  26B50001   ADDIU S5, S5, 1
9D005A8C  02B2182B   SLTU V1, S5, S2
9D005A90  1460FFFA   BNE V1, ZERO, 0x9D005A7C
9D005A94  02228821   ADDU S1, S1, V0
4569:                		if (cc != EOF) cc = chc;
9D005A98  2403FFFF   ADDIU V1, ZERO, -1
9D005A9C  1043002B   BEQ V0, V1, 0x9D005B4C
9D005AA0  8FBF0054   LW RA, 84(SP)
4570:                	}
4571:                
4572:                	va_end(arp);
9D005AFC  0B4016D2   J 0x9D005B48
9D005B00  03C01021   ADDU V0, S8, ZERO
4573:                	return (cc == EOF) ? cc : res;
4574:                }
9D005B48  8FBF0054   LW RA, 84(SP)
4575:                
4576:                #endif /* !_FS_READONLY */
4577:                #endif /* _USE_STRFUNC */
4578:                
4579:                /*********************************************************
4580:                 * Converted from macro to function
4581:                 *
4582:                 *********************************************************/
4583:                uint32_t f_tell(uintptr_t handle)
4584:                {
4585:                    FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
4586:                    FIL *fp = &ptr->fileObj;
4587:                    return(fp->fptr);
4588:                }
9D017390  03E00008   JR RA
4589:                /*********************************************************
4590:                 * Converted from macro to function
4591:                 *
4592:                 *********************************************************/
4593:                bool f_eof(uintptr_t handle)
4594:                {
4595:                    FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
4596:                    FIL *fp = &ptr->fileObj;
4597:                    return (((fp)->fptr == (fp)->fsize) ? 1 : 0);
9D01727C  8C83000C   LW V1, 12(A0)
9D017280  8C820010   LW V0, 16(A0)
9D017284  00621026   XOR V0, V1, V0
4598:                }
9D017288  03E00008   JR RA
4599:                /*********************************************************
4600:                 * Converted from macro to function
4601:                 *
4602:                 *********************************************************/
4603:                uint32_t f_size(uintptr_t handle)
4604:                {
4605:                    FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
4606:                    FIL *fp = &ptr->fileObj;
4607:                    return (fp->fsize);
4608:                }
9D017398  03E00008   JR RA
4609:                /*********************************************************
4610:                 * Converted from macro to function
4611:                 *
4612:                 *********************************************************/
4613:                bool f_error(uintptr_t handle)
4614:                {
4615:                    FATFS_FILE_OBJECT *ptr = (FATFS_FILE_OBJECT *)handle;
4616:                    FIL *fp = &ptr->fileObj;
4617:                    return (((fp)->flag & FA__ERROR) ? 1 : 0);
9D017320  9082000A   LBU V0, 10(A0)
4618:                }
9D017324  03E00008   JR RA
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/system/fs/diskio.c
1:                   /*-----------------------------------------------------------------------*/
2:                   /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2013        */
3:                   /*-----------------------------------------------------------------------*/
4:                   /* If a working storage control module is available, it should be        */
5:                   /* attached to the FatFs via a glue function rather than modifying it.   */
6:                   /* This is an example of glue functions to attach various exsisting      */
7:                   /* storage control module to the FatFs module with a defined API.        */
8:                   /*-----------------------------------------------------------------------*/
9:                   
10:                  #include "system/fs/fat_fs/src/hardware_access/diskio.h"		/* FatFs lower layer API */
11:                  #include "system/fs/sys_fs_media_manager.h"
12:                  
13:                  SYS_FS_MEDIA_COMMAND_STATUS gDiskCommandStatus = SYS_FS_MEDIA_COMMAND_UNKNOWN;
14:                  SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE gDiskCommandHandle = SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
15:                  
16:                  void diskEventHandler
17:                  (
18:                      SYS_FS_MEDIA_BLOCK_EVENT event,
19:                      SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE commandHandle,
20:                      uintptr_t context
21:                  )
22:                  {
23:                      switch(event)
9D016EC0  10800005   BEQ A0, ZERO, 0x9D016ED8
9D016EC4  24020001   ADDIU V0, ZERO, 1
9D016EC8  10820005   BEQ A0, V0, 0x9D016EE0
9D016ECC  2402FFFF   ADDIU V0, ZERO, -1
9D016ED0  03E00008   JR RA
9D016ED4  00000000   NOP
24:                      {
25:                          case SYS_FS_MEDIA_EVENT_BLOCK_COMMAND_COMPLETE:
26:                              gDiskCommandStatus = SYS_FS_MEDIA_COMMAND_COMPLETED;
27:                              break;
9D016ED8  03E00008   JR RA
9D016EDC  AF808014   SW ZERO, -32748(GP)
28:                          case SYS_FS_MEDIA_EVENT_BLOCK_COMMAND_ERROR:
29:                              gDiskCommandStatus= SYS_FS_MEDIA_COMMAND_UNKNOWN;
9D016EE0  03E00008   JR RA
30:                              break;
31:                          default:
32:                              break;
33:                      }
34:                  }
35:                  
36:                  /*-----------------------------------------------------------------------*/
37:                  /* Inidialize a Drive                                                    */
38:                  /* This function is left unchanged from what was implemted in FAT FS. This
39:                   is done to maintain compatibility with future versions of FAT FS. Also,
40:                   no task is done in this function. It is not required as Harmony File system
41:                   has its own media manager layer, which takes care of disk_initialization */
42:                  /*-----------------------------------------------------------------------*/
43:                  
44:                  DSTATUS disk_initialize (
45:                          uint8_t pdrv				/* Physical drive nmuber (0..) */
46:                          )
47:                  {
9D016F5C  27BDFFE8   ADDIU SP, SP, -24
9D016F60  AFBF0014   SW RA, 20(SP)
48:                      switch(pdrv)
49:                      {
50:                          case 0:
51:                              {
52:                                  break;
53:                              }
54:                          case 1:
55:                              {
56:                                  break;
57:                              }
58:                      }
59:                  
60:                      SYS_FS_MEDIA_MANAGER_RegisterTransferHandler (diskEventHandler);
9D016F64  3C049D01   LUI A0, -25343
9D016F68  0F405CC5   JAL SYS_FS_MEDIA_MANAGER_RegisterTransferHandler
9D016F6C  24846EC0   ADDIU A0, A0, 28352
61:                      return 0;
62:                  }
9D016F70  00001021   ADDU V0, ZERO, ZERO
63:                  
64:                  /*-----------------------------------------------------------------------*/
65:                  /* Get Disk Status                                                       */
66:                  /* This function is left unchanged from what was implemted in FAT FS. This
67:                   is done to maintain compatibility with future versions of FAT FS. Also,
68:                   no task is done in this function. It is not required as Harmony File system
69:                   has its own media manager layer, which takes care of disk_status        */
70:                  /*-----------------------------------------------------------------------*/
71:                  
72:                  DSTATUS disk_status (
73:                          uint8_t pdrv		/* Physical drive nmuber (0..) */
74:                          )
75:                  {
76:                      return 0;
77:                  }
9D0173A0  03E00008   JR RA
78:                  
79:                  /*****************************************************************************
80:                   * Function:
81:                   * DRESULT disk_read
82:                   *   (
83:                   *       uint8_t pdrv,
84:                   *       uint8_t *buff,
85:                   *       uint32_t sector,
86:                   *       uint8_t count
87:                   *   )
88:                   *
89:                   * Description:
90:                   * Function to read a sector of specified media (disk). This is the function
91:                   * called from ff.c. This function is block untill the read is complete.
92:                   * Since this function is called by ff.c, the name of function, parameter passed
93:                   * and return types are not changed. This is to avoid compatibility issues if we
94:                   * use future releases of ff.c
95:                   *
96:                   * Precondition:
97:                   *   None
98:                   *
99:                   * Parameters:
100:                  *   pdrv         - media number
101:                  *   buff         - pointer to buffer where data to be placed after read
102:                  *   sector       - Sector # which is to be read
103:                  *   count        - Number of sectors to read
104:                  *
105:                  * Returns:
106:                  *   DRESULT
107:                 */
108:                 
109:                 DRESULT disk_read
110:                 (
111:                     uint8_t pdrv,   /* Physical drive nmuber (0..) */
112:                     uint8_t *buff,  /* Data buffer to store read data */
113:                     uint32_t sector,/* Sector address (LBA) */
114:                     uint8_t count   /* Number of sectors to read (1..128) */
115:                 )
116:                 {
9D01586C  27BDFFE0   ADDIU SP, SP, -32
9D015870  AFBF001C   SW RA, 28(SP)
9D015874  AFB10018   SW S1, 24(SP)
9D015878  AFB00014   SW S0, 20(SP)
9D01587C  308400FF   ANDI A0, A0, 255
117:                     gDiskCommandHandle = SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
9D015880  2411FFFF   ADDIU S1, ZERO, -1
9D015884  AF918010   SW S1, -32752(GP)
118:                 
119:                     gDiskCommandStatus = SYS_FS_MEDIA_COMMAND_IN_PROGRESS;
9D015888  24020002   ADDIU V0, ZERO, 2
9D01588C  AF828014   SW V0, -32748(GP)
120:                     /* submit the read request */
121:                     gDiskCommandHandle = SYS_FS_MEDIA_MANAGER_SectorRead(pdrv /* DISK 0 */ ,
9D015890  00808021   ADDU S0, A0, ZERO
9D015894  0F405205   JAL SYS_FS_MEDIA_MANAGER_SectorRead
9D015898  30E700FF   ANDI A3, A3, 255
9D01589C  00401821   ADDU V1, V0, ZERO
9D0158A0  AF828010   SW V0, -32752(GP)
122:                             buff /* Destination Sector*/,
123:                             sector,
124:                             count /* Number of Sectors */);
125:                     
126:                     /* Buffer is invalid report error */
127:                     if (SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID == gDiskCommandHandle)
9D0158A4  1071000B   BEQ V1, S1, 0x9D0158D4
9D0158A8  24020004   ADDIU V0, ZERO, 4
128:                     {
129:                         return RES_PARERR;
130:                     }
131:                 
132:                     /* process the read request by blocking on the task routine that process the 
133:                      I/O request */
134:                     while (SYS_FS_MEDIA_COMMAND_IN_PROGRESS == gDiskCommandStatus)
9D0158AC  8F828014   LW V0, -32748(GP)
9D0158B0  24030002   ADDIU V1, ZERO, 2
9D0158B4  14430006   BNE V0, V1, 0x9D0158D0
9D0158B8  24110002   ADDIU S1, ZERO, 2
9D0158C4  8F828014   LW V0, -32748(GP)
9D0158C8  1051FFFC   BEQ V0, S1, 0x9D0158BC
9D0158CC  00000000   NOP
135:                     {
136:                         SYS_FS_MEDIA_MANAGER_TransferTask (pdrv);
9D0158BC  0F4058E0   JAL SYS_FS_MEDIA_MANAGER_TransferTask
9D0158C0  02002021   ADDU A0, S0, ZERO
137:                     }
138:                 
139:                     if (SYS_FS_MEDIA_COMMAND_COMPLETED == gDiskCommandStatus)
9D0158D0  0002102B   SLTU V0, ZERO, V0
140:                     {
141:                         /* Buffer processed successfully */
142:                         return RES_OK;
143:                     }        
144:                     else
145:                     {
146:                         /* Buffer processing failed */
147:                         return RES_ERROR;
148:                     }
149:                 }
9D0158D4  8FBF001C   LW RA, 28(SP)
150:                 
151:                 /*****************************************************************************
152:                  * Function:
153:                  * DRESULT disk_write
154:                  *   (
155:                  *       uint8_t pdrv,
156:                  *       uint8_t *buff,
157:                  *       uint32_t sector,
158:                  *       uint8_t count
159:                  *   )
160:                  *
161:                  * Description:
162:                  * Function to write to a sector of specified media (disk). This is the function
163:                  * called from ff.c. This function is block untill the write is complete.
164:                  * Since this function is called by ff.c, the name of function, parameter passed
165:                  * and return types are not changed. This is to avoid compatibility issues if we
166:                  * use future releases of ff.c
167:                  *
168:                  * Precondition:
169:                  *   None
170:                  *
171:                  * Parameters:
172:                  *   pdrv         - media number
173:                  *   buff         - pointer to buffer which holds the data to write
174:                  *   sector       - Sector # where data to be written
175:                  *   count        - Number of sectors to write
176:                  *
177:                  * Returns:
178:                  *   DRESULT
179:                 */
180:                 
181:                 #if _USE_WRITE
182:                 DRESULT disk_write
183:                 (
184:                     uint8_t pdrv,       /* Physical drive nmuber (0..) */
185:                     const uint8_t *buff,/* Data to be written */
186:                     uint32_t sector,    /* Sector address (LBA) */
187:                     uint8_t count       /* Number of sectors to write (1..128) */
188:                 )
189:                 {
9D0150C8  27BDFFE0   ADDIU SP, SP, -32
9D0150CC  AFBF001C   SW RA, 28(SP)
9D0150D0  AFB10018   SW S1, 24(SP)
9D0150D4  AFB00014   SW S0, 20(SP)
9D0150D8  00A01021   ADDU V0, A1, ZERO
9D0150DC  308400FF   ANDI A0, A0, 255
190:                     gDiskCommandHandle = SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID;
9D0150E0  2411FFFF   ADDIU S1, ZERO, -1
9D0150E4  AF918010   SW S1, -32752(GP)
191:                     gDiskCommandStatus = SYS_FS_MEDIA_COMMAND_IN_PROGRESS;
9D0150E8  24030002   ADDIU V1, ZERO, 2
9D0150EC  AF838014   SW V1, -32748(GP)
192:                 
193:                     /* Submit the write request to media */
194:                     gDiskCommandHandle = SYS_FS_MEDIA_MANAGER_SectorWrite(pdrv /* DISK 0 */ ,
9D0150F0  00808021   ADDU S0, A0, ZERO
9D0150F4  00C02821   ADDU A1, A2, ZERO
9D0150F8  00403021   ADDU A2, V0, ZERO
9D0150FC  0F4029D3   JAL SYS_FS_MEDIA_MANAGER_SectorWrite
9D015100  30E700FF   ANDI A3, A3, 255
9D015104  00401821   ADDU V1, V0, ZERO
9D015108  AF828010   SW V0, -32752(GP)
195:                             sector /* Destination Sector*/,
196:                             (uint8_t *)buff,
197:                             count /* Number of Sectors */);
198:                     /* Write request failed , return with error */
199:                     if(SYS_FS_MEDIA_BLOCK_COMMAND_HANDLE_INVALID == gDiskCommandHandle)
9D01510C  1071000B   BEQ V1, S1, 0x9D01513C
9D015110  24020004   ADDIU V0, ZERO, 4
200:                     {
201:                         return RES_PARERR;
202:                     }
203:                 
204:                     /* Run the task routine of media to process the request  */
205:                     while(SYS_FS_MEDIA_COMMAND_IN_PROGRESS == gDiskCommandStatus)
9D015114  8F828014   LW V0, -32748(GP)
9D015118  24030002   ADDIU V1, ZERO, 2
9D01511C  14430006   BNE V0, V1, 0x9D015138
9D015120  24110002   ADDIU S1, ZERO, 2
9D01512C  8F828014   LW V0, -32748(GP)
9D015130  1051FFFC   BEQ V0, S1, 0x9D015124
9D015134  00000000   NOP
206:                     {
207:                         SYS_FS_MEDIA_MANAGER_TransferTask (pdrv);
9D015124  0F4058E0   JAL SYS_FS_MEDIA_MANAGER_TransferTask
9D015128  02002021   ADDU A0, S0, ZERO
208:                     }
209:                     
210:                     if(SYS_FS_MEDIA_COMMAND_COMPLETED == gDiskCommandStatus)
9D015138  0002102B   SLTU V0, ZERO, V0
211:                     {
212:                         /* Buffer processed successfully */
213:                         return RES_OK;
214:                     }        
215:                     else
216:                     {
217:                         /* Buffer processing failed */
218:                         return RES_ERROR;
219:                     }
220:                 }
9D01513C  8FBF001C   LW RA, 28(SP)
221:                 #endif
222:                 
223:                 /*-----------------------------------------------------------------------*/
224:                 /* Miscellaneous Functions                                               */
225:                 /* This function is left unchanged from what was implemted in FAT FS. This
226:                  is done to maintain compatibility with future versions of FAT FS. Also,
227:                  no task is done in this function. This function will be implemented in
228:                  future                                                               */
229:                 /*-----------------------------------------------------------------------*/
230:                 
231:                 #if _USE_IOCTL
232:                 DRESULT disk_ioctl (
233:                         uint8_t pdrv,		/* Physical drive nmuber (0..) */
234:                         uint8_t cmd,		/* Control code */
235:                         void *buff		/* Buffer to send/receive control data */
236:                         )
237:                 {
9D0154F0  308400FF   ANDI A0, A0, 255
9D0154F4  30A500FF   ANDI A1, A1, 255
9D015504  27BDFFE8   ADDIU SP, SP, -24
9D015508  AFBF0014   SW RA, 20(SP)
9D01550C  AFB00010   SW S0, 16(SP)
238:                     if (cmd == GET_SECTOR_COUNT)
9D0154F8  24030001   ADDIU V1, ZERO, 1
9D0154FC  14A3001A   BNE A1, V1, 0x9D015568
9D015500  00001021   ADDU V0, ZERO, ZERO
239:                     {
240:                         uint32_t numSectors = 0;
241:                         uint32_t mediaBlockSize = 0;
242:                         uint32_t numBlocksPerSector = 1;
243:                         SYS_FS_MEDIA_GEOMETRY *mediaGeometry = NULL;
244:                 
245:                         mediaGeometry = SYS_FS_MEDIA_MANAGER_GetMediaGeometry (pdrv);
9D015510  0F405A3C   JAL SYS_FS_MEDIA_MANAGER_GetMediaGeometry
9D015514  00C08021   ADDU S0, A2, ZERO
246:                         if (mediaGeometry == NULL)
9D015518  50400010   BEQL V0, ZERO, 0x9D01555C
9D01551C  24020001   ADDIU V0, ZERO, 1
247:                         {
248:                             return RES_ERROR;
249:                         }
250:                         mediaBlockSize = mediaGeometry->geometryTable[0].blockSize;
9D015520  8C430010   LW V1, 16(V0)
9D015524  8C640000   LW A0, 0(V1)
251:                 
252:                         if (mediaBlockSize < 512)
9D015528  2C850200   SLTIU A1, A0, 512
9D01552C  10A00005   BEQ A1, ZERO, 0x9D015544
9D015530  24020001   ADDIU V0, ZERO, 1
253:                         {
254:                             /* Perform block to sector translation */
255:                             numBlocksPerSector = (512 / mediaBlockSize);
9D015534  24020200   ADDIU V0, ZERO, 512
9D015538  0044001B   DIVU V0, A0
9D01553C  008001F4   TEQ A0, ZERO
9D015540  00001012   MFLO V0
256:                         }
257:                 
258:                         numSectors = mediaGeometry->geometryTable[0].numBlocks / numBlocksPerSector;
9D015544  8C630004   LW V1, 4(V1)
9D015548  0062001B   DIVU V1, V0
9D01554C  004001F4   TEQ V0, ZERO
9D015550  00001012   MFLO V0
259:                 
260:                         *(uint32_t *)buff = numSectors;
9D015554  AE020000   SW V0, 0(S0)
9D015558  00001021   ADDU V0, ZERO, ZERO
261:                     }
262:                 
263:                     return RES_OK;
264:                 }
9D01555C  8FBF0014   LW RA, 20(SP)
265:                 #endif
266:                 
267:                 /****************************************************************************
268:                  The get_fattime function is used to know the present time, which is used by
269:                  FAT FS code. The present time should ideally be updated by a Real time clock
270:                  hardware module. Since this module is not integrated with Harmony FS framework,
271:                  a fixed time is set as given by the implementation of the function below   */
272:                 uint32_t get_fattime(void)
273:                 {
274:                     /* RTC should return time here */
275:                     /* For now, just a value */
276:                     SYS_FS_TIME time;
277:                     time.packedTime = 0;
278:                 
279:                     // All FAT FS times are calculated based on 0 = 1980
280:                     time.discreteTime.year = (2013 - 1980); // year is 2013
281:                     time.discreteTime.month = 8;    // August
282:                     time.discreteTime.day = 9;     // 9th date
9D017114  3C024309   LUI V0, 17161
283:                     time.discreteTime.hour = 15;    // 3pm afternoon
9D017118  2403000F   ADDIU V1, ZERO, 15
9D01711C  7C627AC4   INS V0, V1, 11, 5
284:                     time.discreteTime.minute = 06;  // 06 min
9D017120  24030006   ADDIU V1, ZERO, 6
9D017124  7C625144   INS V0, V1, 5, 6
285:                     time.discreteTime.second = 00;  // 00 sec
286:                 
287:                     return (time.packedTime);
288:                 }
9D017128  03E00008   JR RA
289:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/system/devcon/src/sys_devcon_pic32mz.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include <xc.h>
53:                  #include <cp0defs.h>
54:                  #include "sys_devcon_local.h"
55:                  #include "peripheral/int/plib_int.h"
56:                  #include "peripheral/pcache/plib_pcache.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  // Section: SYS DEVCON Client Setup Routines
73:                  // *****************************************************************************
74:                  // *****************************************************************************
75:                  
76:                  
77:                  // *****************************************************************************
78:                  /* Function:
79:                      void SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
80:                  
81:                    Summary:
82:                      Configures the PFM wait states and prefetch (cache) module for maximum 
83:                      performance.
84:                  
85:                    Description:
86:                      This function configures the PFM wait states and prefetch (cache) module 
87:                      for maximum performance.
88:                  
89:                    Remarks:
90:                      None.
91:                  */
92:                  
93:                  void __attribute__((nomips16)) SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
94:                  {
9D012280  27BDFFF8   ADDIU SP, SP, -8
9D012284  AFBF0004   SW RA, 4(SP)
95:                      bool int_flag = false;
96:                      bool ecc;
97:                  
98:                      /* Set the PFM wait states based on the system clock and ECC setting */
99:                      #if defined(PLIB_PCACHE_ExistsWaitState)    
100:                     if (PLIB_PCACHE_ExistsWaitState(PCACHE_ID_0))
101:                     {
102:                         int ws; /* number of wait states */
103:                 
104:                         /* Is ECC enabled? */
105:                         /* TODO: replace register read with plib when available */
106:                         ecc = (((CFGCON & 0x00000030) >> 4) < 2) ? true : false;
9D012288  3C02BF80   LUI V0, -16512
9D01228C  8C420000   LW V0, 0(V0)
9D012290  7C420900   EXT V0, V0, 4, 2
107:                         if (sysclk <= (ecc ? 60000000 : 74000000))
9D012294  2C420002   SLTIU V0, V0, 2
9D012298  5440002A   BNEL V0, ZERO, 0x9D012344
9D01229C  3C020393   LUI V0, 915
9D0122A0  0B4048D8   J 0x9D012360
9D0122A4  3C020469   LUI V0, 1129
9D012344  34428701   ORI V0, V0, -30975
9D012348  0082102B   SLTU V0, A0, V0
9D01234C  1440FFE0   BNE V0, ZERO, PLIB_INT_GetStateAndDisable
9D012350  00003021   ADDU A2, ZERO, ZERO
9D012360  24422681   ADDIU V0, V0, 9857
9D012364  0082102B   SLTU V0, A0, V0
9D012368  1440FFD9   BNE V0, ZERO, PLIB_INT_GetStateAndDisable
9D01236C  00003021   ADDU A2, ZERO, ZERO
108:                             ws = 0;
109:                         else if (sysclk <= (ecc ? 120000000 : 140000000))
9D0122A8  0044102B   SLTU V0, V0, A0
9D0122AC  10400008   BEQ V0, ZERO, PLIB_INT_GetStateAndDisable
9D0122B0  24060001   ADDIU A2, ZERO, 1
9D012354  3C020727   LUI V0, 1831
9D012358  0B4048AA   J 0x9D0122A8
9D01235C  24420E00   ADDIU V0, V0, 3584
9D012370  3C020858   LUI V0, 2136
9D012374  0B4048AA   J 0x9D0122A8
9D012378  24423B00   ADDIU V0, V0, 15104
110:                             ws = 1;
111:                         else if (sysclk <= 200000000)
9D0122B4  3C060BEB   LUI A2, 3051
9D0122B8  34C6C201   ORI A2, A2, -15871
9D0122BC  0086302B   SLTU A2, A0, A2
112:                             ws = 2;
9D0122C0  24020002   ADDIU V0, ZERO, 2
9D0122C4  24030004   ADDIU V1, ZERO, 4
9D0122C8  0066100A   MOVZ V0, V1, A2
9D0122CC  00403021   ADDU A2, V0, ZERO
113:                         else
114:                             ws = 4;
115:                 
116:                         /* Interrupts must be disabled when changing wait states */
117:                         int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D0122E8  30A50001   ANDI A1, A1, 1
118:                 
119:                         PLIB_PCACHE_WaitStateSet(PCACHE_ID_0, ws);
120:                 
121:                         if (int_flag)
9D0122EC  10A00005   BEQ A1, ZERO, SYS_DEVCON_PerformanceConfig::PLIB_INT_GetStateAndDisable
9D0122F0  00000000   NOP
122:                         {
123:                             PLIB_INT_Enable(INT_ID_0);
124:                             int_flag = false;
125:                         }
126:                     }
127:                     #endif // defined(PLIB_PCACHE_ExistsWaitState)
128:                     /* Interrupts must be disabled when enabling the Prefetch Cache Module */
129:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D012320  30820001   ANDI V0, A0, 1
130:                 
131:                     /* Enable Prefetch Cache Module */
132:                     #if defined(PLIB_PCACHE_ExistsPrefetchEnable)
133:                     if (PLIB_PCACHE_ExistsPrefetchEnable(PCACHE_ID_0))
134:                     {
135:                         PLIB_PCACHE_PrefetchEnableSet(PCACHE_ID_0, PLIB_PCACHE_PREFETCH_ENABLE_ALL);
136:                     }
137:                     #endif
138:                     
139:                     if (int_flag)
9D012324  50400015   BEQL V0, ZERO, 0x9D01237C
9D012328  8FBF0004   LW RA, 4(SP)
140:                     {
141:                         PLIB_INT_Enable(INT_ID_0);
142:                     }
143:                 }
9D01233C  0B4048DF   J 0x9D01237C
9D012340  8FBF0004   LW RA, 4(SP)
9D01237C  03E00008   JR RA
144:                 
145:                 
146:                 // *****************************************************************************
147:                 /* Function:
148:                     void SYS_DEVCON_CacheInit(SYS_CACHE_COHERENCY cacheCoherency)
149:                 
150:                   Summary:
151:                     Initializes the L1 cache. 
152:                 
153:                   Description:
154:                     Initializes both instruction and data caches. Invalidates all entries and
155:                     zeroes all tags. Sets coherency attribute for kseg0.
156:                 
157:                   Remarks:
158:                     Use with caution. Invalidates all cache lines without writing data
159:                     back to memory. Any dirty data in the cache will be lost.
160:                 */
161:                 
162:                 void SYS_DEVCON_CacheInit(SYS_CACHE_COHERENCY cacheCoherency)
163:                 {
00000000  00000000   NOP
164:                     _pic32_init_cache(cacheCoherency);
00000008  00000000   NOP
165:                 }
00000018  00000000   NOP
166:                 
167:                 
168:                 // *****************************************************************************
169:                 /* Function:
170:                     void SYS_DEVCON_CacheFlush(void)
171:                 
172:                   Summary:
173:                     Flushes the L1 cache. 
174:                 
175:                   Description:
176:                     Flushes both instruction and data caches. Invalidate entire instruction
177:                     cache; write back and invalidate entire data cache.
178:                 
179:                   Remarks:
180:                     Simplest way to sychnronize caches with memory, but not necessarily
181:                     the most efficient.
182:                 */
183:                 
184:                 void SYS_DEVCON_CacheFlush(void)
185:                 {
00000000  00000000   NOP
186:                     _pic32_flush_cache();
00000008  00000000   NOP
187:                 }
00000018  00000000   NOP
188:                 
189:                 
190:                 // *****************************************************************************
191:                 /* Function:
192:                     void SYS_DEVCON_DataCacheFlush(void)
193:                 
194:                   Summary:
195:                     Flushes the L1 data cache. 
196:                 
197:                   Description:
198:                     Write back and invalidate the entire data cache.
199:                 
200:                   Remarks:
201:                     None.
202:                 */
203:                 
204:                 void SYS_DEVCON_DataCacheFlush(void)
205:                 {
00000000  00000000   NOP
206:                     _pic32_flush_dcache();
00000008  00000000   NOP
207:                 }
00000018  00000000   NOP
208:                 
209:                 
210:                 // *****************************************************************************
211:                 /* Function:
212:                     void SYS_DEVCON_InstructionCacheFlush(void)
213:                 
214:                   Summary:
215:                     Flushes (invalidates) the L1 instruction cache.
216:                 
217:                   Description:
218:                     Invalidate entire instruction cache.
219:                 
220:                   Remarks:
221:                     None.
222:                 */
223:                 
224:                 void SYS_DEVCON_InstructionCacheFlush(void)
225:                 {
00000000  00000000   NOP
226:                     _pic32_flush_icache();
00000008  00000000   NOP
227:                 }
00000018  00000000   NOP
228:                 
229:                 
230:                 // *****************************************************************************
231:                 /* Function:
232:                     void SYS_DEVCON_CacheClean(uint32_t addr, size_t len)
233:                 
234:                   Summary:
235:                     Write back and invalidate an address range in either cache.
236:                 
237:                   Description:
238:                     Write back (data) and invalidate (data and address) an address range 
239:                     in either cache.
240:                 
241:                   Remarks:
242:                     None.
243:                 */
244:                 
245:                 void SYS_DEVCON_CacheClean(uint32_t addr, size_t len)
246:                 {
00000000  00000000   NOP
247:                     _pic32_clean_cache(addr, len);
00000008  00000000   NOP
248:                 }
00000018  00000000   NOP
249:                 
250:                 
251:                 // *****************************************************************************
252:                 /* Function:
253:                     void SYS_DEVCON_DataCacheClean(uint32_t addr, size_t len)
254:                 
255:                   Summary:
256:                     Write back and invalidate an address range in the data cache.
257:                 
258:                   Description:
259:                     Write back and invalidate an address range in the data cache.
260:                 
261:                   Remarks:
262:                     None.
263:                 */
264:                 
265:                 void SYS_DEVCON_DataCacheClean(uint32_t addr, size_t len)
266:                 {
00000000  00000000   NOP
267:                     _pic32_clean_dcache(addr, len);
00000008  00000000   NOP
268:                 }
00000018  00000000   NOP
269:                 
270:                 
271:                 // *****************************************************************************
272:                 /* Function:
273:                     void SYS_DEVCON_DataCacheInvalidate(uint32_t addr, size_t len)
274:                 
275:                   Summary:
276:                     Invalidate an address range in the data cache.
277:                 
278:                   Description:
279:                     Invalidate an address range in the data cache.
280:                 
281:                   Remarks:
282:                     None.
283:                 */
284:                 
285:                 void SYS_DEVCON_DataCacheInvalidate(uint32_t addr, size_t len)
286:                 {
00000000  00000000   NOP
287:                     _pic32_clean_dcache_nowrite(addr, len);
00000008  00000000   NOP
288:                 }
00000018  00000000   NOP
289:                 
290:                 
291:                 // *****************************************************************************
292:                 /* Function:
293:                     void SYS_DEVCON_InstructionCacheInvalidate(uint32_t addr, size_t len)
294:                 
295:                   Summary:
296:                     Invalidate an address range in the instruction cache.
297:                 
298:                   Description:
299:                     Invalidate an address range in the instruction cache.
300:                 
301:                   Remarks:
302:                     None.
303:                 */
304:                 
305:                 void SYS_DEVCON_InstructionCacheInvalidate(uint32_t addr, size_t len)
306:                 {
00000000  00000000   NOP
307:                     _pic32_clean_icache(addr, len);
00000008  00000000   NOP
308:                 }
00000018  00000000   NOP
309:                 
310:                 
311:                 // *****************************************************************************
312:                 /* Function:
313:                     void SYS_DEVCON_InstructionCacheLock(uint32_t addr, size_t len)
314:                 
315:                   Summary:
316:                     Fetch and lock a block of instructions in the instruction cache.
317:                 
318:                   Description:
319:                     Fetch and lock a block of instructions in the instruction cache.
320:                 
321:                   Remarks:
322:                     Global flush functions will invalidate and unlock any cache lines
323:                     locked with this function.
324:                 */
325:                 
326:                 void SYS_DEVCON_InstructionCacheLock(uint32_t addr, size_t len)
327:                 {
00000000  00000000   NOP
328:                     _pic32_lock_icache(addr, len);
00000008  00000000   NOP
329:                 }
00000018  00000000   NOP
330:                 
331:                 
332:                 // *****************************************************************************
333:                 /* Function:
334:                     void SYS_DEVCON_DataCacheLock(uint32_t addr, size_t len)
335:                 
336:                   Summary:
337:                     Fetch and lock a block of data in the data cache.
338:                 
339:                   Description:
340:                     Fetch and lock a block of data in the data cache.
341:                 
342:                   Remarks:
343:                     Global flush functions will invalidate and unlock any cache lines
344:                     locked with this function.
345:                 */
346:                 
347:                 void SYS_DEVCON_DataCacheLock(uint32_t addr, size_t len)
348:                 {
00000000  00000000   NOP
349:                     _pic32_lock_dcache(addr, len);
00000008  00000000   NOP
350:                 }
00000018  00000000   NOP
351:                 
352:                 
353:                 // *****************************************************************************
354:                 /* Function:
355:                     void SYS_DEVCON_CacheSync(uint32_t addr, size_t len)
356:                 
357:                   Summary:
358:                     Synchronize the instruction and data caches.
359:                 
360:                   Description:
361:                     Synchronize the instruction and data caches. Used when modifying
362:                     the instruction stream (breakpoints, self-modifying code, relocating
363:                     executable code to RAM). Flushes an address range from the data cache 
364:                     and invalidates that same range from the instruction cache.
365:                 
366:                   Remarks:
367:                     None.
368:                 */
369:                 
370:                 void SYS_DEVCON_CacheSync(uint32_t addr, size_t len)
371:                 {
00000000  00000000   NOP
372:                     _pic32_sync_icache(addr, len);
00000008  00000000   NOP
373:                 }
00000018  00000000   NOP
374:                 
375:                 
376:                 // *****************************************************************************
377:                 /* Function:
378:                     void SYS_DEVCON_CacheCoherencySet(SYS_CACHE_COHERENCY cacheCoherency)
379:                 
380:                   Summary:
381:                     Set the cache coherency attribute for kseg0.
382:                 
383:                   Description:
384:                     Set the cache coherency attribute for kseg0.
385:                 
386:                   Remarks:
387:                     Use with caution. May cause unpredictable behavior in a running
388:                     system.
389:                 */
390:                 
391:                 void SYS_DEVCON_CacheCoherencySet(SYS_CACHE_COHERENCY cacheCoherency)
392:                 {
00000000  00000000   NOP
393:                     uint32_t cp0;
394:                     cp0 = _mfc0(16, 0);
00000008  00000000   NOP
395:                     cp0 &= ~0x07;
0000000C  00000000   NOP
396:                     cp0 |= cacheCoherency;
00000014  00000000   NOP
397:                     _mtc0(16, 0, cp0);
00000018  00000000   NOP
398:                 }
00000020  00000000   NOP
399:                 
400:                 
401:                 // *****************************************************************************
402:                 /* Function:
403:                     SYS_CACHE_COHERENCY SYS_DEVCON_CacheCoherencyGet(void)
404:                 
405:                   Summary:
406:                     Returns the current cache coherency attribute for kseg0.
407:                 
408:                   Description:
409:                     Returns the current cache coherency attribute for kseg0.
410:                 
411:                   Remarks:
412:                     None.
413:                 */
414:                 
415:                 SYS_CACHE_COHERENCY SYS_DEVCON_CacheCoherencyGet(void)
416:                 {
00000000  00000000   NOP
417:                     return _mfc0(16, 0) & 0x03;
00000008  00000000   NOP
418:                 }
0000000C  00000000   NOP
419:                 
420:                 
421:                 // *****************************************************************************
422:                 /* Function:
423:                     size_t SYS_DEVCON_DataCacheAssociativityGet(void)
424:                 
425:                   Summary:
426:                     Returns the number of ways in the data cache.
427:                 
428:                   Description:
429:                     Returns the number of ways in the data cache.
430:                 
431:                   Remarks:
432:                     None.
433:                 */
434:                 
435:                 size_t SYS_DEVCON_DataCacheAssociativityGet(void)
436:                 {
00000000  00000000   NOP
437:                     return _pic32_get_dcache_associativity();
00000008  00000000   NOP
438:                 }
00000018  00000000   NOP
439:                 
440:                 
441:                 // *****************************************************************************
442:                 /* Function:
443:                     size_t SYS_DEVCON_InstructionCacheAssociativityGet(void)
444:                 
445:                   Summary:
446:                     Returns the number of ways in the instruction cache.
447:                 
448:                   Description:
449:                     Returns the number of ways in the instruction cache.
450:                 
451:                   Remarks:
452:                     None.
453:                 */
454:                 
455:                 size_t SYS_DEVCON_InstructionCacheAssociativityGet(void)
456:                 {
00000000  00000000   NOP
457:                     return _pic32_get_icache_associativity();
00000008  00000000   NOP
458:                 }
00000018  00000000   NOP
459:                 
460:                 
461:                 // *****************************************************************************
462:                 /* Function:
463:                     size_t SYS_DEVCON_DataCacheLineSizeGet(void)
464:                 
465:                   Summary:
466:                     Returns the data cache line size.
467:                 
468:                   Description:
469:                     Returns the data cache line size.
470:                 
471:                   Remarks:
472:                     None.
473:                 */
474:                 
475:                 size_t SYS_DEVCON_DataCacheLineSizeGet(void)
476:                 {
00000000  00000000   NOP
477:                     return _pic32_get_dcache_linesize();
00000008  00000000   NOP
478:                 }
00000018  00000000   NOP
479:                 
480:                 
481:                 // *****************************************************************************
482:                 /* Function:
483:                     size_t SYS_DEVCON_InstructionCacheLineSizeGet(void)
484:                 
485:                   Summary:
486:                     Returns the instruction cache line size.
487:                 
488:                   Description:
489:                     Returns the instruction cache line size.
490:                 
491:                   Remarks:
492:                     None.
493:                 */
494:                 
495:                 size_t SYS_DEVCON_InstructionCacheLineSizeGet(void)
496:                 {
00000000  00000000   NOP
497:                     return _pic32_get_icache_linesize();
00000008  00000000   NOP
498:                 }
00000018  00000000   NOP
499:                 
500:                 
501:                 // *****************************************************************************
502:                 /* Function:
503:                     size_t SYS_DEVCON_DataCacheLinesPerWayGet(void)
504:                 
505:                   Summary:
506:                     Returns the number of lines per way in the data cache.
507:                 
508:                   Description:
509:                     Returns the number of lines per way in the data cache.
510:                 
511:                   Remarks:
512:                     None.
513:                 */
514:                 
515:                 size_t SYS_DEVCON_DataCacheLinesPerWayGet(void)
516:                 {
00000000  00000000   NOP
517:                     return _pic32_get_dcache_lines_per_way();
00000008  00000000   NOP
518:                 }
00000018  00000000   NOP
519:                 
520:                 
521:                 // *****************************************************************************
522:                 /* Function:
523:                     size_t SYS_DEVCON_InstructionCacheLinesPerWayGet(void)
524:                 
525:                   Summary:
526:                     Returns the number of lines per way in the instruction cache.
527:                 
528:                   Description:
529:                     Returns the number of lines per way in the instruction cache.
530:                 
531:                   Remarks:
532:                     None.
533:                 */
534:                 
535:                 size_t SYS_DEVCON_InstructionCacheLinesPerWayGet(void)
536:                 {
00000000  00000000   NOP
537:                     return _pic32_get_icache_lines_per_way();
00000008  00000000   NOP
538:                 }
00000018  00000000   NOP
539:                 
540:                 
541:                 // *****************************************************************************
542:                 /* Function:
543:                     size_t SYS_DEVCON_DataCacheSizeGet(void)
544:                 
545:                   Summary:
546:                     Returns the total number of bytes in the data cache.
547:                 
548:                   Description:
549:                     Returns the total number of bytes in the data cache.
550:                 
551:                   Remarks:
552:                     None.
553:                 */
554:                 
555:                 size_t SYS_DEVCON_DataCacheSizeGet(void)
556:                 {
00000000  00000000   NOP
557:                     return _pic32_get_dcache_size();
00000008  00000000   NOP
558:                 }
00000018  00000000   NOP
559:                 
560:                 
561:                 // *****************************************************************************
562:                 /* Function:
563:                     size_t SYS_DEVCON_InstructionCacheSizeGet(void)
564:                 
565:                   Summary:
566:                     Returns the total number of bytes in the instruction cache.
567:                 
568:                   Description:
569:                     Returns the total number of bytes in the instruction cache.
570:                 
571:                   Remarks:
572:                     None.
573:                 */
574:                 
575:                 size_t SYS_DEVCON_InstructionCacheSizeGet(void)
576:                 {
00000000  00000000   NOP
577:                     return _pic32_get_icache_size();
00000008  00000000   NOP
578:                 }
00000018  00000000   NOP
579:                 
580:                 /*******************************************************************************
581:                  End of File
582:                 */
583:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/system/devcon/src/sys_devcon.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "system/devcon/src/sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/devcon/plib_devcon.h"
55:                  #include "peripheral/osc/plib_osc.h"
56:                  
57:                  // *****************************************************************************
58:                  // *****************************************************************************
59:                  // Section: File Scope or Global Constants
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: Variable Definitions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  /* System Device Control Instance */
70:                  SYS_DEVCON_OBJECT sysDevconObj;
71:                  
72:                  
73:                  // *****************************************************************************
74:                  // *****************************************************************************
75:                  // Section: SYS DEVCON Module Initialization Routines
76:                  // *****************************************************************************
77:                  // *****************************************************************************
78:                  
79:                  // *****************************************************************************
80:                  /* Function:
81:                      SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX           index,
82:                                                         const SYS_MODULE_INIT * const    init )
83:                  
84:                    Summary:
85:                      Initializes data for the instance of the Device Control module and opens
86:                      the specific module instance.
87:                  
88:                    Description:
89:                      This function initializes the instance of the Device Control module,
90:                      using the specified initialization data. It also initializes any
91:                      internal data structures.
92:                  
93:                    Remarks:
94:                      This routine should only be called once during system initialization
95:                      unless SYS_DEVCON_Deinitialize is first called to deinitialize the device
96:                      instance before reinitializing it. If the system was already initialized
97:                      it safely returns without causing any disturbance.
98:                  */
99:                  
100:                 SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX index,
101:                                                    const SYS_MODULE_INIT * const init )
102:                 {
103:                     sysDevconObj.status = SYS_STATUS_READY;
9D017268  24020002   ADDIU V0, ZERO, 2
9D01726C  AF828094   SW V0, -32620(GP)
104:                 
105:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
9D017270  AF808090   SW ZERO, -32624(GP)
106:                 
107:                     return (SYS_MODULE_OBJ)SYS_DEVCON_INDEX_0;
108:                 }
9D017274  03E00008   JR RA
109:                 
110:                 
111:                 // *****************************************************************************
112:                 /* Function:
113:                     void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ                  object,
114:                                                const SYS_MODULE_INIT * const   init )
115:                 
116:                    Summary:
117:                     Reinitializes and refreshes the hardware for the instance of the Device 
118:                     Control module.
119:                 
120:                    Description:
121:                     This function reinitializes the instance of the Device Control module using 
122:                     the supplied data. It modifies the internal data structure.
123:                 
124:                    Remarks:
125:                     This operation uses the same initialization data structure as the
126:                     SYS_DEVCON_Initialize operation. This operation can be used to change the
127:                     power state of a DEVCON module. This function can be called multiple times
128:                     to reinitialize the module. This operation uses the same initialization
129:                     data structure as the Initialize operation. This operation can also be
130:                     used to refresh the hardware registers as defined by the initialization
131:                     data.
132:                 */
133:                 
134:                 void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ object,
135:                                            const SYS_MODULE_INIT * const init )
136:                 {
137:                     sysDevconObj.status = SYS_STATUS_READY;
00000000  00000000   NOP
138:                 
139:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
00000008  00000000   NOP
140:                 }
141:                 
142:                 
143:                 // *****************************************************************************
144:                 /* Function:
145:                     void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
146:                 
147:                   Summary:
148:                     Deinitializes the specific module instance of the DEVCON module
149:                 
150:                   Description:
151:                     This function deinitializes the specific module instance disabling its operation 
152:                     (and any hardware for driver modules). Resets all of the internal data
153:                     structures and fields for the specified instance to the default settings.
154:                 
155:                   Remarks:
156:                     Once the Initialize operation has been called, the Deinitialize
157:                     operation must be called before the Initialize operation can be called
158:                     again.
159:                 */
160:                 
161:                 void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
162:                 {
163:                     sysDevconObj.status = SYS_STATUS_UNINITIALIZED;
164:                 }
165:                 
166:                 
167:                 // *****************************************************************************
168:                 /* Function:
169:                     SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
170:                 
171:                   Summary:
172:                     Returns status of the specific instance of the Device Control module.
173:                 
174:                   Description:
175:                     This function returns the status of the specific module instance.
176:                 
177:                   Remarks:
178:                     None.
179:                 */
180:                 
181:                 SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
182:                 {
183:                     return sysDevconObj.status; 
184:                 }
00000000  00000000   NOP
185:                 
186:                 
187:                 // *****************************************************************************
188:                 /* Function:
189:                     void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
190:                 
191:                   Summary:
192:                     Maintains the system Device Control state machine.
193:                 
194:                   Description:
195:                     This function is used to maintain the system Device Control internal state machine.
196:                 
197:                   Remarks:
198:                     This function is normally not called directly by an application.  It is
199:                     called by the system's Tasks routine (SYS_Tasks) or by the appropriate raw
200:                     ISR.
201:                 */
202:                 
203:                 void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
204:                 {
9D017380  03E00008   JR RA
205:                     switch (sysDevconObj.state)
206:                     {
207:                         case SYS_DEVCON_STATE_INIT:
208:                         case SYS_DEVCON_STATE_BUSY:
209:                         case SYS_DEVCON_STATE_READY:
210:                         default:
211:                             break;
212:                     }
213:                 }
214:                 
215:                     
216:                 // *****************************************************************************
217:                 // *****************************************************************************
218:                 // Section: SYS DEVCON Client Setup Routines
219:                 // *****************************************************************************
220:                 // *****************************************************************************
221:                 
222:                 // *****************************************************************************
223:                 /* Function:
224:                     void SYS_DEVCON_SystemUnlock( void )
225:                 
226:                   Summary:
227:                     Performs a system unlock sequence by writing to the SYSKEY register.
228:                 
229:                   Description:
230:                     Performs a system unlock sequence by writing to the SYSKEY register. A 
231:                     system unlock sequence is required before performing certain actions such
232:                     as changing a clock frequency or IO unlocking.
233:                 
234:                   Remarks:
235:                     None.
236:                 */
237:                 
238:                 void SYS_DEVCON_SystemUnlock( void )
239:                 {
9D016138  27BDFFF8   ADDIU SP, SP, -8
9D01613C  AFBF0004   SW RA, 4(SP)
240:                     bool int_flag = false;
241:                 
242:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D016168  30620001   ANDI V0, V1, 1
243:                 
244:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
245:                 
246:                     if (int_flag)
9D01616C  10400006   BEQ V0, ZERO, 0x9D016188
9D016170  8FBF0004   LW RA, 4(SP)
247:                     {
248:                         PLIB_INT_Enable(INT_ID_0);
249:                     }
250:                 }
9D016184  8FBF0004   LW RA, 4(SP)
251:                 
252:                 
253:                 // *****************************************************************************
254:                 /* Function:
255:                     void SYS_DEVCON_SystemLock( void )
256:                 
257:                   Summary:
258:                     Performs a system lock sequence by writing to the SYSKEY register.
259:                 
260:                   Description:
261:                     Performs a system lock sequence by writing to the SYSKEY register. A 
262:                     system lock sequence is required after performing the action that required
263:                     a system lock sequence.
264:                 
265:                   Remarks:
266:                     None.
267:                 */
268:                 
269:                 void SYS_DEVCON_SystemLock( void )
270:                 {
9D016588  27BDFFF8   ADDIU SP, SP, -8
9D01658C  AFBF0004   SW RA, 4(SP)
271:                     bool int_flag = false;
272:                    
273:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D0165A8  30420001   ANDI V0, V0, 1
274:                 
275:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
276:                 
277:                     if (int_flag)
9D0165AC  10400006   BEQ V0, ZERO, 0x9D0165C8
9D0165B0  8FBF0004   LW RA, 4(SP)
278:                     {
279:                         PLIB_INT_Enable(INT_ID_0);
280:                     }
281:                 }
9D0165C4  8FBF0004   LW RA, 4(SP)
282:                 
283:                 
284:                 // *****************************************************************************
285:                 /* Function:
286:                     void SYS_DEVCON_JTAGEnable( void )
287:                 
288:                   Summary:
289:                     Enables the JTAG port on the device.
290:                 
291:                   Description:
292:                     Enables the JTAG port on the device.
293:                 
294:                   Remarks:
295:                     None.
296:                 */
297:                 
298:                 void SYS_DEVCON_JTAGEnable( void )
299:                 {
300:                     PLIB_DEVCON_JTAGPortEnable(DEVCON_ID_0);
301:                 }
302:                 
303:                 
304:                 // *****************************************************************************
305:                 /* Function:
306:                     void SYS_DEVCON_JTAGDisable( void )
307:                 
308:                   Summary:
309:                     Disables the JTAG port on the device.
310:                 
311:                   Description:
312:                     Disables the JTAG port on the device.
313:                 
314:                   Remarks:
315:                     None.
316:                 */
317:                 
318:                 void SYS_DEVCON_JTAGDisable( void )
319:                 {
320:                     PLIB_DEVCON_JTAGPortDisable(DEVCON_ID_0);
321:                 }
322:                 
323:                 
324:                 // *****************************************************************************
325:                 /* Function:
326:                     void SYS_DEVCON_TraceEnable( void )
327:                 
328:                   Summary:
329:                     Enables the Trace output port on the device.
330:                 
331:                   Description:
332:                     Enables the Trace output port on the device.
333:                 
334:                   Remarks:
335:                     None.
336:                 */
337:                 
338:                 void SYS_DEVCON_TraceEnable( void )
339:                 {
340:                     #if defined PLIB_DEVCON_ExistsTraceOutput
341:                         if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
342:                         {
343:                             PLIB_DEVCON_TraceOutputEnable(DEVCON_ID_0);
344:                         }
345:                     #endif
346:                 }
347:                 
348:                 
349:                 // *****************************************************************************
350:                 /* Function:
351:                     void SYS_DEVCON_TraceDisable( void )
352:                 
353:                   Summary:
354:                     Disables the Trace output port on the device.
355:                 
356:                   Description:
357:                     Disables the Trace output port on the device.
358:                 
359:                   Remarks:
360:                     None.
361:                 */
362:                 
363:                 void SYS_DEVCON_TraceDisable( void )
364:                 {
365:                     #if defined PLIB_DEVCON_ExistsTraceOutput
366:                     if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
367:                     {
368:                         PLIB_DEVCON_TraceOutputDisable(DEVCON_ID_0);
369:                     }
370:                     #endif
371:                 }
372:                 
373:                 
374:                 // *****************************************************************************
375:                 /* Function:
376:                     void SYS_DEVCON_PowerModeEnter(SYS_POWER_MODE pwrMode)
377:                 
378:                   Summary:
379:                     Puts the device in a low-power state.
380:                 
381:                   Description:
382:                     This function puts the device in a low-power state.
383:                 
384:                   Remarks:
385:                     None.
386:                 */
387:                 
388:                 void __attribute__((nomips16)) SYS_DEVCON_PowerModeEnter( SYS_POWER_MODE pwrMode )
389:                 {
00000000  00000000   NOP
390:                     OSC_OPERATION_ON_WAIT op = SYS_POWER_MODE_IDLE;
0000000C  00000000   NOP
391:                 
392:                     switch (pwrMode)
393:                     {
394:                         case SYS_POWER_MODE_IDLE:
395:                             op = OSC_ON_WAIT_IDLE;
396:                             break;
397:                         case SYS_POWER_MODE_SLEEP:
398:                             op = OSC_ON_WAIT_SLEEP;
399:                             break;
400:                         default:
401:                             break;
402:                     }
403:                 
404:                     
405:                     #if defined PLIB_OSC_ExistsOnWaitAction
406:                     if(PLIB_OSC_ExistsOnWaitAction(OSC_ID_0))
407:                     {
408:                         SYS_DEVCON_SystemUnlock();
00000010  00000000   NOP
409:                         PLIB_OSC_OnWaitActionSet (OSC_ID_0, op);
410:                         SYS_DEVCON_SystemLock();
00000028  00000000   NOP
411:                     }
412:                     #endif
413:                     asm volatile ( "wait" );
00000030  00000000   NOP
414:                 }
00000034  00000000   NOP
415:                 
416:                 
417:                 /*******************************************************************************
418:                  End of File
419:                 */
420:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/system/clk/src/sys_clk_static.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_clk_static.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the oscillators
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Clock System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                      
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  //DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include "system_config.h"
59:                  #include "system_definitions.h"
60:                  #include "peripheral/osc/plib_osc.h"
61:                  #include "system/devcon/sys_devcon.h"
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: File Scope Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  /* Function:
71:                      void SYS_CLK_Static_Initialize ( const SYS_CLK_INIT const * clkInit )
72:                  
73:                    Summary:
74:                      Initializes hardware and internal data structure of the System Clock.
75:                  
76:                    Description:
77:                      This function initializes the hardware and internal data structure of System
78:                      Clock Service.
79:                  
80:                    Remarks:
81:                      This is configuration values for the static version of the Clock System Service 
82:                      module is determined by the user via the Microchip Harmony Configurator GUI.
83:                      This template will build a sys_clk_static.h and sys_clk_static.c file with 
84:                      the configuration per the user's choice.
85:                  
86:                      The objective is to eliminate the user's need to be knowledgeable in the function of
87:                      the 'configuration bits' to configure the system oscillators. 
88:                  */
89:                  
90:                  void SYS_CLK_Initialize( const SYS_CLK_INIT const * clkInit )
91:                  {
9D000010  27BDFFE8   ADDIU SP, SP, -24
9D000014  AFBF0014   SW RA, 20(SP)
92:                      SYS_DEVCON_SystemUnlock ( );
9D000018  0F40584E   JAL SYS_DEVCON_SystemUnlock
9D00001C  00000000   NOP
93:                      
94:                      OSCCONbits.FRCDIV = OSC_FRC_DIV_1; //0x00
9D000020  3C02BF80   LUI V0, -16512
9D000024  8C431200   LW V1, 4608(V0)
9D000028  7C03D604   INS V1, ZERO, 24, 3
9D00002C  AC431200   SW V1, 4608(V0)
95:                      
96:                      /* Enable Peripheral Bus 1 */
97:                      PB1DIVbits.PBDIV = 0b0000001;
9D000030  3C03BF80   LUI V1, -16512
9D000034  94641300   LHU A0, 4864(V1)
9D000038  24020001   ADDIU V0, ZERO, 1
9D00003C  7C443004   INS A0, V0, 0, 7
9D000040  A4641300   SH A0, 4864(V1)
98:                      //PB1DIVbits.ON = 1; //<- not a real instruction because PB1 is always on
99:                  
100:                     /* Enable Peripheral Bus 2 */ //For SPI
101:                     PB2DIVbits.PBDIV = 0b0000001;
9D000044  3C03BF80   LUI V1, -16512
9D000048  94641310   LHU A0, 4880(V1)
9D00004C  7C443004   INS A0, V0, 0, 7
9D000050  A4641310   SH A0, 4880(V1)
102:                     PB2DIVbits.ON = 1;
9D000054  94641310   LHU A0, 4880(V1)
9D000058  7C447BC4   INS A0, V0, 15, 1
9D00005C  A4641310   SH A0, 4880(V1)
103:                     /* Enable Peripheral Bus 3 */ //For Timers
104:                     PB3DIVbits.PBDIV = 0b0000001;
9D000060  3C03BF80   LUI V1, -16512
9D000064  94641320   LHU A0, 4896(V1)
9D000068  7C443004   INS A0, V0, 0, 7
9D00006C  A4641320   SH A0, 4896(V1)
105:                     PB3DIVbits.ON = 1;
9D000070  94641320   LHU A0, 4896(V1)
9D000074  7C447BC4   INS A0, V0, 15, 1
9D000078  A4641320   SH A0, 4896(V1)
106:                     /* Enable Peripheral Bus 4 */
107:                     PB4DIVbits.PBDIV = 0b0000001;
9D00007C  3C03BF80   LUI V1, -16512
9D000080  94641330   LHU A0, 4912(V1)
9D000084  7C443004   INS A0, V0, 0, 7
9D000088  A4641330   SH A0, 4912(V1)
108:                     PB4DIVbits.ON = 1;
9D00008C  94641330   LHU A0, 4912(V1)
9D000090  7C447BC4   INS A0, V0, 15, 1
9D000094  A4641330   SH A0, 4912(V1)
109:                     /* Enable Peripheral Bus 5 */
110:                     PB5DIVbits.PBDIV = 0b0000001;
9D000098  3C03BF80   LUI V1, -16512
9D00009C  94641340   LHU A0, 4928(V1)
9D0000A0  7C443004   INS A0, V0, 0, 7
9D0000A4  A4641340   SH A0, 4928(V1)
111:                     PB5DIVbits.ON = 1;
9D0000A8  94641340   LHU A0, 4928(V1)
9D0000AC  7C447BC4   INS A0, V0, 15, 1
9D0000B0  A4641340   SH A0, 4928(V1)
112:                     /* Enable Peripheral Bus 7 */
113:                     PB7DIVbits.PBDIV = 0b0000000;
9D0000B4  3C03BF80   LUI V1, -16512
9D0000B8  94641360   LHU A0, 4960(V1)
9D0000BC  7C043004   INS A0, ZERO, 0, 7
9D0000C0  A4641360   SH A0, 4960(V1)
114:                     PB7DIVbits.ON = 1;
9D0000C4  94641360   LHU A0, 4960(V1)
9D0000C8  7C447BC4   INS A0, V0, 15, 1
9D0000CC  A4641360   SH A0, 4960(V1)
115:                     /* Enable Peripheral Bus 8 */
116:                     PB8DIVbits.PBDIV = 0b0000001;
9D0000D0  3C03BF80   LUI V1, -16512
9D0000D4  94641370   LHU A0, 4976(V1)
9D0000D8  7C443004   INS A0, V0, 0, 7
9D0000DC  A4641370   SH A0, 4976(V1)
117:                     PB8DIVbits.ON = 1;
9D0000E0  94641370   LHU A0, 4976(V1)
9D0000E4  7C447BC4   INS A0, V0, 15, 1
9D0000E8  A4641370   SH A0, 4976(V1)
118:                 
119:                     SYS_DEVCON_SystemLock ( );
9D0000EC  0F405962   JAL SYS_DEVCON_SystemLock
9D0000F0  00000000   NOP
120:                 }
9D0000F4  8FBF0014   LW RA, 20(SP)
121:                 
122:                 //******************************************************************************
123:                 /* Function:
124:                     inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
125:                 
126:                   Summary:
127:                     Gets the system clock frequency in Hertz.
128:                 
129:                   Description:
130:                     This function gets the System clock frequency in Hertz.
131:                 
132:                   Precondition:
133:                     None.
134:                 
135:                   Parameters:
136:                     None.
137:                 
138:                   Returns:
139:                     System clock frequency in Hertz.
140:                 
141:                   Example:
142:                     <code>
143:                     uint32_t sysClockHz;
144:                 
145:                     sysClockHz = SYS_CLK_SystemFrequencyGet ( );
146:                     </code>
147:                 
148:                   Remarks:
149:                  */
150:                 
151:                 inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
152:                 {
153:                     return SYS_CLK_FREQ;
154:                 }
9D017308  3C020BEB   LUI V0, 3051
155:                 
156:                 //******************************************************************************
157:                 /* Function:
158:                     inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
159:                 
160:                   Summary:
161:                     Gets the selected clock peripheral bus frequency in Hertz.
162:                 
163:                   Description:
164:                     This function gets the selected peripheral bus clock frequency in Hertz.
165:                 
166:                   Precondition:
167:                     None.
168:                 
169:                   Parameters:
170:                 	peripheralBus - Reference clock bus selection. One of the possible value from
171:                 				CLK_BUSES_PERIPHERAL enum. For devices that do not have multiple
172:                 				clock channels for Reference clock, CLK_BUS_PERIPHERAL_1 should be
173:                 				the selection.
174:                 
175:                   Returns:
176:                     Clock frequency in Hertz.
177:                 
178:                   Example:
179:                     <code>
180:                     unsigned long peripheralClockHz;
181:                 
182:                     peripheralClockHz = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_5 );
183:                     </code>
184:                 
185:                   Remarks:
186:                 	Most of the devices doesn't have multiple Peripheral clock buses. In that case, 
187:                 	pass CLK_USB_PERIPHERAL_1 as the bus number.
188:                  */
189:                 
190:                 inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
191:                 {
192:                        uint32_t freq = 0;
9D016304  03E00008   JR RA
9D016308  00001021   ADDU V0, ZERO, ZERO
9D016314  03E00008   JR RA
9D016318  00001021   ADDU V0, ZERO, ZERO
193:                 
194:                     switch (peripheralBus)
9D0162E0  24020006   ADDIU V0, ZERO, 6
9D0162E4  1082000D   BEQ A0, V0, 0x9D01631C
9D0162E8  3C020BEB   LUI V0, 3051
9D0162EC  2C820007   SLTIU V0, A0, 7
9D0162F0  10400006   BEQ V0, ZERO, 0x9D01630C
9D0162F4  24020007   ADDIU V0, ZERO, 7
9D0162F8  2C840005   SLTIU A0, A0, 5
9D0162FC  54800009   BNEL A0, ZERO, 0x9D016324
9D016300  3C0205F5   LUI V0, 1525
9D01630C  50820005   BEQL A0, V0, 0x9D016324
9D016310  3C0205F5   LUI V0, 1525
195:                     {
196:                         case CLK_BUS_PERIPHERAL_1:
197:                                 freq = SYS_CLK_BUS_PERIPHERAL_1;
9D016324  3442E100   ORI V0, V0, -7936
198:                             break;
199:                         case CLK_BUS_PERIPHERAL_2:
200:                                 freq = SYS_CLK_BUS_PERIPHERAL_2;
201:                             break;
202:                         case CLK_BUS_PERIPHERAL_3:
203:                                 freq = SYS_CLK_BUS_PERIPHERAL_3;
204:                             break;
205:                         case CLK_BUS_PERIPHERAL_4:
206:                                 freq = SYS_CLK_BUS_PERIPHERAL_4;
207:                             break;
208:                         case CLK_BUS_PERIPHERAL_5:
209:                                 freq = SYS_CLK_BUS_PERIPHERAL_5;
210:                             break;
211:                         case CLK_BUS_PERIPHERAL_6:
212:                             break;
213:                         case CLK_BUS_PERIPHERAL_7:
214:                                 freq = SYS_CLK_BUS_PERIPHERAL_7;
215:                             break;
9D01631C  03E00008   JR RA
9D016320  3442C200   ORI V0, V0, -15872
216:                         case CLK_BUS_PERIPHERAL_8:
217:                                 freq = SYS_CLK_BUS_PERIPHERAL_8;
218:                             break;
219:                         default:
220:                             break;
221:                     }
222:                     
223:                     return freq;
224:                 }
9D016328  03E00008   JR RA
225:                 
226:                 
227:                 //******************************************************************************
228:                 /* Function:
229:                     inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
230:                 
231:                   Summary:
232:                     Gets the selected Reference clock bus frequency in Hertz.
233:                 
234:                   Description:
235:                     This function gets frequency of the selected Reference clock bus in Hertz.
236:                 
237:                   Precondition:
238:                     None.
239:                 
240:                   Parameters:
241:                 	peripheralBus - Reference clock bus selection. One of the possible value from
242:                 				CLK_BUSES_REFERENCE enum. For devices that do not have multiple
243:                 				clock channels for Reference clock, CLK_BUS_REFERENCE_1 should be
244:                 				the selection.
245:                 
246:                   Returns:
247:                     Clock frequency in Hz.
248:                 
249:                   Example:
250:                     <code>
251:                     unsigned long sysClockOutputHz;
252:                 
253:                     sysClockOutputHz = SYS_CLK_ReferenceFrequencyGet ( CLK_BUS_REFERENCE_3 );
254:                     </code>
255:                 
256:                   Remarks:
257:                     None.
258:                  */
259:                 
260:                 inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
261:                 {
262:                        uint32_t freq = 0;
263:                 
264:                     switch (referenceBus)
265:                     {
266:                         case CLK_BUS_REFERENCE_1:
267:                             break;
268:                         case CLK_BUS_REFERENCE_2:
269:                             break;
270:                         case CLK_BUS_REFERENCE_3:
271:                             break;
272:                         case CLK_BUS_REFERENCE_4:
273:                             break;
274:                         case CLK_BUS_REFERENCE_5:
275:                             break;
276:                         default:
277:                             break;
278:                     }
279:                     
280:                     return freq;
281:                 }
00000000  00000000   NOP
282:                 
283:                 /******************************************************************************
284:                   Function:
285:                     void SYS_CLK_SecondaryOscillatorEnable ( void )
286:                 
287:                   Summary:
288:                     Enables the secondary oscillator.
289:                 
290:                   Description:
291:                     This function enables the secondary oscillator.
292:                 
293:                   Remarks:
294:                     For more details refer sys_clk.h.
295:                 */
296:                 
297:                 void SYS_CLK_SecondaryOscillatorEnable ( void )
298:                 {
9D016554  27BDFFE8   ADDIU SP, SP, -24
9D016558  AFBF0014   SW RA, 20(SP)
299:                     /* Check for secondary oscillator status */
300:                     if (!PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
9D01654C  1440000C   BNE V0, ZERO, 0x9D016580
9D016550  00000000   NOP
301:                     {    
302:                         /* Unlock and enable secondary oscillator */
303:                         SYS_DEVCON_SystemUnlock();
9D01655C  0F40584E   JAL SYS_DEVCON_SystemUnlock
9D016560  00000000   NOP
304:                         
305:                         PLIB_OSC_SecondaryEnable(OSC_ID_0);
306:                         
307:                         SYS_DEVCON_SystemLock();
9D016570  0F405962   JAL SYS_DEVCON_SystemLock
9D016574  00000000   NOP
308:                     }
309:                 }
9D016578  8FBF0014   LW RA, 20(SP)
310:                 
311:                 /******************************************************************************
312:                   Function:
313:                     void SYS_CLK_SecondaryOscillatorDisable ( void )
314:                 
315:                   Summary:
316:                     Disables the secondary oscillator.
317:                 
318:                   Description:
319:                     This function disables the secondary oscillator.
320:                 
321:                   Remarks:
322:                     For more details refer sys_clk.h.
323:                 */
324:                 
325:                 void SYS_CLK_SecondaryOscillatorDisable ( void )
326:                 {
00000014  00000000   NOP
327:                     /* Check for secondary oscillator status */
328:                     if (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
0000000C  00000000   NOP
329:                     {    
330:                         /* Unlock and disable secondary oscillator*/
331:                         SYS_DEVCON_SystemUnlock();
0000001C  00000000   NOP
332:                         
333:                         PLIB_OSC_SecondaryDisable(OSC_ID_0);
334:                         
335:                         SYS_DEVCON_SystemLock();
00000030  00000000   NOP
336:                     }
337:                 }
00000038  00000000   NOP
338:                 
339:                 /******************************************************************************
340:                   Function:
341:                     bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
342:                 
343:                   Summary:
344:                     Identifies whether secondary oscillator is enabled or disabled.
345:                 
346:                   Description:
347:                     This function identifies whether the secondary oscillator is enabled or 
348:                     disabled.
349:                     
350:                   Remarks:
351:                     For more details refer sys_clk.h.
352:                 */
353:                 
354:                 bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
355:                 {
356:                     return (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0));
357:                 }
00000008  00000000   NOP
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_txepstatus_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_TxEPStatus_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TxEPStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_TxEPStatusGet
16:                          PLIB_USBHS_TxEPStatusClear
17:                          PLIB_USBHS_TxEPOUTTokenSend
18:                          PLIB_USBHS_ExistsTxEPStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USBHS_TXEPSTATUS_DEFAULT_H
49:                  #define _USBHS_TXEPSTATUS_DEFAULT_H
50:                  
51:                  #include "usbhs_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USBHS_TxEPStatusGet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USBHS_TxEPStatusGet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the 
61:                      PLIB_USBHS_TxEPStatusGet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE uint8_t USBHS_TxEPStatusGet_Default
65:                  ( 
66:                      USBHS_MODULE_ID index , 
67:                      uint8_t endpoint 
68:                  )
69:                  {
70:                      /* Returns the entire endpoint status register */
71:                      
72:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
73:                      return(usbhs->EPCSR[endpoint].TXCSRL_DEVICEbits.w);
9D006A54  90430102   LBU V1, 258(V0)
74:                  }
75:                  
76:                  //******************************************************************************
77:                  /* Function :  USBHS_TxEPStatusClear_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_USBHS_TxEPStatusClear 
81:                  
82:                    Description:
83:                      This template implements the Default variant of the 
84:                      PLIB_USBHS_TxEPStatusClear function.
85:                  */
86:                  
87:                  PLIB_TEMPLATE void USBHS_TxEPStatusClear_Default
88:                  ( 
89:                      USBHS_MODULE_ID index , 
90:                      uint8_t endpoint , 
91:                      USBHS_TXEP_ERROR error 
92:                  )
93:                  {
94:                      /* Clears the specified set of errors */
95:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
96:                      usbhs->EPCSR[endpoint].TXCSRL_DEVICEbits.w &= (~(error));
9D004F7C  92E20102   LBU V0, 258(S7)
9D004F80  3042005B   ANDI V0, V0, 91
9D004F84  A2E20102   SB V0, 258(S7)
9D006A70  90430102   LBU V1, 258(V0)
9D006A74  3063005B   ANDI V1, V1, 91
9D006A78  A0430102   SB V1, 258(V0)
9D006AD0  90430102   LBU V1, 258(V0)
9D006AD4  306300DF   ANDI V1, V1, 223
9D006AD8  A0430102   SB V1, 258(V0)
9D006B10  90430102   LBU V1, 258(V0)
9D006B14  3063007F   ANDI V1, V1, 127
9D006B18  A0430102   SB V1, 258(V0)
9D006B38  90430102   LBU V1, 258(V0)
9D006B3C  306300FB   ANDI V1, V1, 251
9D006B40  A0430102   SB V1, 258(V0)
9D008058  92020102   LBU V0, 258(S0)
9D00805C  3042005B   ANDI V0, V0, 91
9D008060  A2020102   SB V0, 258(S0)
97:                  }
98:                  
99:                  //******************************************************************************
100:                 /* Function :  USBHS_ExistsTxEPStatus_Default
101:                 
102:                   Summary:
103:                     Implements Default variant of PLIB_USBHS_ExistsTxEPStatus
104:                 
105:                   Description:
106:                     This template implements the Default variant of the 
107:                     PLIB_USBHS_ExistsTxEPStatus function.
108:                 */
109:                 
110:                 #define PLIB_USBHS_ExistsTxEPStatus PLIB_USBHS_ExistsTxEPStatus
111:                 PLIB_TEMPLATE bool USBHS_ExistsTxEPStatus_Default( USBHS_MODULE_ID index )
112:                 {
113:                     return true;
114:                 }
115:                 
116:                 
117:                 #endif /*_USBHS_TXEPSTATUS_DEFAULT_H*/
118:                 
119:                 /******************************************************************************
120:                  End of File
121:                 */
122:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_softreset_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_SoftReset_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SoftReset
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_SoftResetEnable
16:                          PLIB_USBHS_SoftResetDisable
17:                          PLIB_USBHS_ExistsSoftReset
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USBHS_SOFTRESET_DEFAULT_H
48:                  #define _USBHS_SOFTRESET_DEFAULT_H
49:                  
50:                  #include "usbhs_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USBHS_SoftResetEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USBHS_SoftResetEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the 
60:                      PLIB_USBHS_SoftResetEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USBHS_SoftResetEnable_Default( USBHS_MODULE_ID index )
64:                  {
65:                      /* This function enables the soft reset bits */
66:                  
67:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
68:                      usbhs->SOFTRSTbits.w = USBHS_SOFT_RST_NRST_SET|USBHS_SOFT_RST_NRSTX_SET;
9D00DF0C  24020003   ADDIU V0, ZERO, 3
9D00DF10  A242007F   SB V0, 127(S2)
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USBHS_SoftResetDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USBHS_SoftResetDisable 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the 
79:                      PLIB_USBHS_SoftResetDisable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void USBHS_SoftResetDisable_Default( USBHS_MODULE_ID index )
83:                  {   
84:                      /* This function will clear the NRST and NRSTX bits. */
85:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
86:                      usbhs->SOFTRSTbits.w = 0;
9D00DF30  A240007F   SB ZERO, 127(S2)
87:                  }
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USBHS_SoftResetNRSTXEnable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_USBHS_SoftResetNRSTXEnable 
94:                  
95:                    Description:
96:                      This template implements the Default variant of the
97:                      PLIB_USBHS_SoftResetNRSTXEnable function.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void USBHS_SoftResetNRSTXEnable_Default( USBHS_MODULE_ID index )
101:                 {   
102:                     /* This function sets the NRSTX bits. It is cleared automatically by
103:                      * hardware. */
104:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
105:                     usbhs->SOFTRSTbits.NRSTX = 1;
106:                 }
107:                 
108:                 
109:                 //******************************************************************************
110:                 /* Function :  USBHS_ExistsSoftReset_Default
111:                 
112:                   Summary:
113:                     Implements Default variant of PLIB_USBHS_ExistsSoftReset
114:                 
115:                   Description:
116:                     This template implements the Default variant of the PLIB_USBHS_ExistsSoftReset function.
117:                 */
118:                 
119:                 #define PLIB_USBHS_ExistsSoftReset PLIB_USBHS_ExistsSoftReset
120:                 PLIB_TEMPLATE bool USBHS_ExistsSoftReset_Default( USBHS_MODULE_ID index )
121:                 {
122:                     return true;
123:                 }
124:                 
125:                 
126:                 #endif /*_USBHS_SOFTRESET_DEFAULT_H*/
127:                 
128:                 /******************************************************************************
129:                  End of File
130:                 */
131:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_rxepstatus_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_RxEPStatus_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RxEPStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_RxEPStatusGet
16:                          PLIB_USBHS_RxEPStatusClear
17:                          PLIB_USBHS_ExistsRxEPStatus
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USBHS_RXEPSTATUS_DEFAULT_H
48:                  #define _USBHS_RXEPSTATUS_DEFAULT_H
49:                  
50:                  #include "usbhs_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USBHS_RxEPStatusGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USBHS_RxEPStatusGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the 
60:                      PLIB_USBHS_RxEPStatusGet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE uint8_t USBHS_RxEPStatusGet_Default
64:                  ( 
65:                      USBHS_MODULE_ID index, 
66:                      uint8_t endpoint 
67:                  )
68:                  {
69:                      /* Return the RX endpoint status */
70:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
71:                      return(usbhs->EPCSR[endpoint].RXCSRL_DEVICEbits.w);
9D006BB4  90430106   LBU V1, 262(V0)
72:                  }
73:                  
74:                  //******************************************************************************
75:                  /* Function :  USBHS_RxEPStatusClear_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_USBHS_RxEPStatusClear 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the 
82:                      PLIB_USBHS_RxEPStatusClear function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE void USBHS_RxEPStatusClear_Default
86:                  ( 
87:                      USBHS_MODULE_ID index, 
88:                      uint8_t endpoint, 
89:                      USBHS_RXEP_ERROR error 
90:                  )
91:                  {
92:                      /* Clear the error in the status register */
93:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
94:                      usbhs->EPCSR[endpoint].RXCSRL_DEVICEbits.w &= (~(error)); 
9D004F98  92E20106   LBU V0, 262(S7)
9D004F9C  304200B3   ANDI V0, V0, 179
9D004FA0  A2E20106   SB V0, 262(S7)
9D006BD0  90430106   LBU V1, 262(V0)
9D006BD4  306300B3   ANDI V1, V1, 179
9D006BD8  A0430106   SB V1, 262(V0)
9D006C34  90430106   LBU V1, 262(V0)
9D006C38  306300BF   ANDI V1, V1, 191
9D006C3C  A0430106   SB V1, 262(V0)
9D006CA4  90430106   LBU V1, 262(V0)
9D006CA8  306300F7   ANDI V1, V1, 247
9D006CAC  A0430106   SB V1, 262(V0)
9D006D00  90430106   LBU V1, 262(V0)
9D006D04  306300FB   ANDI V1, V1, 251
9D006D08  A0430106   SB V1, 262(V0)
9D007FE4  90430106   LBU V1, 262(V0)
9D007FE8  306300B3   ANDI V1, V1, 179
9D007FEC  A0430106   SB V1, 262(V0)
9D00C0DC  241EFFFE   ADDIU S8, ZERO, -2
9D00C19C  90650106   LBU A1, 262(V1)
9D00C1A0  30A500FF   ANDI A1, A1, 255
9D00C1A4  00BE2824   AND A1, A1, S8
9D00C1A8  A0650106   SB A1, 262(V1)
95:                  }
96:                  
97:                  //******************************************************************************
98:                  /* Function :  USBHS_RxEPINTokenSend_Default
99:                  
100:                   Summary:
101:                     Implements Default variant of PLIB_USBHS_RxEPINTokenSend 
102:                 
103:                   Description:
104:                     This template implements the Default variant of the 
105:                     PLIB_USBHS_RxEPINTokenSend function.
106:                 */
107:                 
108:                 PLIB_TEMPLATE void USBHS_RxEPINTokenSend_Default( USBHS_MODULE_ID index, uint8_t endpoint )
109:                 {
110:                     /* Causes the module to send an IN Token in host mode */
111:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
112:                     usbhs->EPCSR[endpoint].RXCSRL_HOSTbits.REQPKT = 1; 
9D006DB8  00021100   SLL V0, V0, 4
9D006DBC  02429021   ADDU S2, S2, V0
9D006DC0  92420006   LBU V0, 6(S2)
9D006DC4  24030001   ADDIU V1, ZERO, 1
9D006DC8  7C622944   INS V0, V1, 5, 1
9D006DCC  A2420006   SB V0, 6(S2)
9D006DFC  00108100   SLL S0, S0, 4
9D006E00  02509021   ADDU S2, S2, S0
9D006E04  92420006   LBU V0, 6(S2)
9D006E08  24030001   ADDIU V1, ZERO, 1
9D006E0C  7C622944   INS V0, V1, 5, 1
9D006E10  A2420006   SB V0, 6(S2)
9D00C21C  00021100   SLL V0, V0, 4
9D00C220  02A21021   ADDU V0, S5, V0
9D00C224  90430006   LBU V1, 6(V0)
9D00C228  7EE32944   INS V1, S7, 5, 1
9D00C22C  A0430006   SB V1, 6(V0)
9D00C230  0B4030A1   J 0x9D00C284
9D00C234  26100001   ADDIU S0, S0, 1
9D00C268  26C20010   ADDIU V0, S6, 16
9D00C26C  00021100   SLL V0, V0, 4
9D00C270  02A21021   ADDU V0, S5, V0
9D00C274  90430006   LBU V1, 6(V0)
9D00C278  7EE32944   INS V1, S7, 5, 1
9D00C27C  A0430006   SB V1, 6(V0)
9D00C280  26100001   ADDIU S0, S0, 1
113:                 }
114:                 
115:                 //******************************************************************************
116:                 /* Function :  USBHS_ExistsRxEPStatus_Default
117:                 
118:                   Summary:
119:                     Implements Default variant of PLIB_USBHS_ExistsRxEPStatus
120:                 
121:                   Description:
122:                     This template implements the Default variant of the PLIB_USBHS_ExistsRxEPStatus function.
123:                 */
124:                 
125:                 #define PLIB_USBHS_ExistsRxEPStatus PLIB_USBHS_ExistsRxEPStatus
126:                 PLIB_TEMPLATE bool USBHS_ExistsRxEPStatus_Default( USBHS_MODULE_ID index )
127:                 {
128:                     return true;
129:                 }
130:                 
131:                 
132:                 #endif /*_USBHS_RXEPSTATUS_DEFAULT_H*/
133:                 
134:                 /******************************************************************************
135:                  End of File
136:                 */
137:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_modulecontrol_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_ModuleControl_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ModuleControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_ResumeEnable
16:                          PLIB_USBHS_ResumeDisable
17:                          PLIB_USBHS_SuspendEnable
18:                          PLIB_USBHS_SuspendDisable
19:                          PLIB_USBHS_ResetEnable
20:                          PLIB_USBHS_ResetDisable
21:                          PLIB_USBHS_VBUSLevelGet
22:                          PLIB_USBHS_HostModeIsEnabled
23:                          PLIB_USBHS_IsBDevice
24:                          PLIB_USBHS_SessionEnable
25:                          PLIB_USBHS_SessionDisable
26:                          PLIB_USBHS_DeviceAddressSet
27:                          PLIB_USBHS_DeviceAttach
28:                          PLIB_USBHS_DeviceDetach
29:                          PLIB_USBHS_ExistsModuleControl
30:                  
31:                  *******************************************************************************/
32:                  
33:                  //DOM-IGNORE-BEGIN
34:                  /*******************************************************************************
35:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
36:                  
37:                  Microchip licenses to you the right to use, modify, copy and distribute
38:                  Software only when embedded on a Microchip microcontroller or digital signal
39:                  controller that is integrated into your product or third party product
40:                  (pursuant to the sublicense terms in the accompanying license agreement).
41:                  
42:                  You should refer to the license agreement accompanying this Software for
43:                  additional information regarding your rights and obligations.
44:                  
45:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
46:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
47:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
48:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
49:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
50:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
51:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
52:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
53:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
54:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
55:                  *******************************************************************************/
56:                  
57:                  //DOM-IGNORE-END
58:                  
59:                  #ifndef _USBHS_MODULECONTROL_DEFAULT_H
60:                  #define _USBHS_MODULECONTROL_DEFAULT_H
61:                  
62:                  #include "usbhs_registers.h"
63:                  
64:                  //******************************************************************************
65:                  /* Function :  USBHS_ResumeEnable_Default
66:                  
67:                    Summary:
68:                      Implements Default variant of PLIB_USBHS_ResumeEnable 
69:                  
70:                    Description:
71:                      This template implements the Default variant of the 
72:                      PLIB_USBHS_ResumeEnable function.
73:                  */
74:                  
75:                  PLIB_TEMPLATE void USBHS_ResumeEnable_Default( USBHS_MODULE_ID index )
76:                  {
77:                      /* Function enables resume signaling */
78:                      
79:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
80:                      usbhs->POWERbits.RESUME = 1;
0000000C  00000000   NOP
00000010  00000000   NOP
81:                  }
82:                  
83:                  //******************************************************************************
84:                  /* Function :  USBHS_ResumeDisable_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_USBHS_ResumeDisable 
88:                  
89:                    Description:
90:                      This template implements the Default variant of the 
91:                      PLIB_USBHS_ResumeDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void USBHS_ResumeDisable_Default( USBHS_MODULE_ID index )
95:                  {
96:                      /* Function disables resume signaling */
97:                      
98:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
99:                      usbhs->POWERbits.RESUME = 0;
00000024  00000000   NOP
100:                 }
101:                 
102:                 //******************************************************************************
103:                 /* Function :  USBHS_SuspendEnable_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_USBHS_SuspendEnable 
107:                 
108:                   Description:
109:                     This template implements the Default variant of the 
110:                     PLIB_USBHS_SuspendEnable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void USBHS_SuspendEnable_Default( USBHS_MODULE_ID index )
114:                 {
115:                     /* Function enables bus suspend  */
116:                     
117:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
0000000C  00000000   NOP
118:                     usbhs->POWERbits.SUSPMODE = 1;
00000010  00000000   NOP
119:                 }
120:                 
121:                 //******************************************************************************
122:                 /* Function :  USBHS_SuspendDisable_Default
123:                 
124:                   Summary:
125:                     Implements Default variant of PLIB_USBHS_SuspendDisable 
126:                 
127:                   Description:
128:                     This template implements the Default variant of the 
129:                     PLIB_USBHS_SuspendDisable function.
130:                 */
131:                 
132:                 PLIB_TEMPLATE void USBHS_SuspendDisable_Default( USBHS_MODULE_ID index )
133:                 {
134:                     /* Function disables bus suspend  */
135:                     
136:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
137:                     usbhs->POWERbits.SUSPMODE = 0;
138:                 }
139:                 
140:                 //******************************************************************************
141:                 /* Function :  USBHS_VBUSLevelGet_Default
142:                 
143:                   Summary:
144:                     Implements Default variant of PLIB_USBHS_VBUSLevelGet 
145:                 
146:                   Description:
147:                     This template implements the Default variant of the 
148:                     PLIB_USBHS_VBUSLevelGet function.
149:                 */
150:                 
151:                 PLIB_TEMPLATE USBHS_VBUS_LEVEL USBHS_VBUSLevelGet_Default( USBHS_MODULE_ID index )
152:                 {
153:                     /* Function returns the current VBUS level */
154:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
9D0169CC  8C83005C   LW V1, 92(A0)
155:                     return((USBHS_VBUS_LEVEL)((usbhs->DEVCTLbits.w) & 0x18));
9D00DFD0  92510060   LBU S1, 96(S2)
9D00DFD4  32310018   ANDI S1, S1, 24
9D011054  90430060   LBU V1, 96(V0)
9D0169D0  90650060   LBU A1, 96(V1)
156:                 }
157:                 
158:                 //******************************************************************************
159:                 /* Function :  USBHS_HostModeIsEnabled_Default
160:                 
161:                   Summary:
162:                     Implements Default variant of PLIB_USBHS_HostModeIsEnabled 
163:                 
164:                   Description:
165:                     This template implements the Default variant of the 
166:                     PLIB_USBHS_HostModeIsEnabled function.
167:                 */
168:                 
169:                 PLIB_TEMPLATE bool USBHS_HostModeIsEnabled_Default( USBHS_MODULE_ID index )
170:                 {
171:                     /* Returns true if the Host Mode is enabled. */
172:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
173:                     return((bool)(usbhs->DEVCTLbits.HOSTMODE));
174:                 }
175:                 
176:                 //******************************************************************************
177:                 /* Function :  USBHS_SessionEnable_Default
178:                 
179:                   Summary:
180:                     Implements Default variant of PLIB_USBHS_SessionEnable 
181:                 
182:                   Description:
183:                     This template implements the Default variant of the 
184:                     PLIB_USBHS_SessionEnable function.
185:                 */
186:                 
187:                 PLIB_TEMPLATE void USBHS_SessionEnable_Default( USBHS_MODULE_ID index )
188:                 {
189:                     /* Function enables a session  */
190:                     
191:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
9D011074  8C82005C   LW V0, 92(A0)
192:                     usbhs->DEVCTLbits.SESSION = 1;
9D011078  90430060   LBU V1, 96(V0)
9D01107C  24040001   ADDIU A0, ZERO, 1
9D011080  7C830004   INS V1, A0, 0, 1
9D011084  A0430060   SB V1, 96(V0)
9D0169E4  90620060   LBU V0, 96(V1)
9D0169E8  24040001   ADDIU A0, ZERO, 1
9D0169EC  7C820004   INS V0, A0, 0, 1
9D0169F0  A0620060   SB V0, 96(V1)
193:                 }
194:                 
195:                 
196:                 //******************************************************************************
197:                 /* Function :  USBHS_IsBDevice_Default
198:                 
199:                   Summary:
200:                     Implements Default variant of PLIB_USBHS_IsBDevice 
201:                 
202:                   Description:
203:                     This template implements the Default variant of the 
204:                     PLIB_USBHS_IsBDevice function.
205:                 */
206:                 
207:                 PLIB_TEMPLATE bool USBHS_IsBDevice_Default( USBHS_MODULE_ID index )
208:                 {
209:                     /* Returns true if the Host Mode is enabled. */
210:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
211:                     return((bool)(usbhs->DEVCTLbits.BDEV));
9D011044  8C430060   LW V1, 96(V0)
9D011048  30630080   ANDI V1, V1, 128
212:                 }
213:                 
214:                 //******************************************************************************
215:                 /* Function :  USBHS_SessionDisable_Default
216:                 
217:                   Summary:
218:                     Implements Default variant of PLIB_USBHS_SessionDisable 
219:                 
220:                   Description:
221:                     This template implements the Default variant of the 
222:                     PLIB_USBHS_SessionDisable function.
223:                 */
224:                 
225:                 PLIB_TEMPLATE void USBHS_SessionDisable_Default( USBHS_MODULE_ID index )
226:                 {
227:                     /* Clears the session bit */
228:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
229:                     usbhs->DEVCTLbits.SESSION = 0;
230:                 }
231:                 
232:                 //******************************************************************************
233:                 /* Function :  USBHS_ResetEnable_Default
234:                 
235:                   Summary:
236:                     Implements Default variant of PLIB_USBHS_ResetEnable 
237:                 
238:                   Description:
239:                     This template implements the Default variant of the PLIB_USBHS_ResetEnable function.
240:                 */
241:                 
242:                 PLIB_TEMPLATE void USBHS_ResetEnable_Default( USBHS_MODULE_ID index )
243:                 {
244:                     /* Sets the reset bit */
245:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
9D0127A4  8E02005C   LW V0, 92(S0)
9D016000  8C82005C   LW V0, 92(A0)
246:                     usbhs->POWERbits.RESET = 1;
9D0127A8  90430001   LBU V1, 1(V0)
9D0127AC  24040001   ADDIU A0, ZERO, 1
9D0127B0  7C8318C4   INS V1, A0, 3, 1
9D0127B4  A0430001   SB V1, 1(V0)
9D016004  90430001   LBU V1, 1(V0)
9D016008  7CA318C4   INS V1, A1, 3, 1
9D01600C  A0430001   SB V1, 1(V0)
00000018  00000000   NOP
247:                 }
248:                 
249:                 //******************************************************************************
250:                 /* Function :  USBHS_ResetDisable_Default
251:                 
252:                   Summary:
253:                     Implements Default variant of PLIB_USBHS_ResetDisable 
254:                 
255:                   Description:
256:                     This template implements the Default variant of the 
257:                     PLIB_USBHS_ResetDisable function.
258:                 */
259:                 
260:                 PLIB_TEMPLATE void USBHS_ResetDisable_Default( USBHS_MODULE_ID index )
261:                 {
262:                    /* Sets the reset bit */
263:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
9D0127D4  8E02005C   LW V0, 92(S0)
264:                     usbhs->POWERbits.RESET = 0;
9D0127D8  90430001   LBU V1, 1(V0)
9D0127DC  7C0318C4   INS V1, ZERO, 3, 1
9D0127E0  A0430001   SB V1, 1(V0)
00000030  00000000   NOP
265:                 }
266:                 
267:                 //******************************************************************************
268:                 /* Function :  USBHS_DeviceAddressSet_Default
269:                 
270:                   Summary:
271:                     Implements Default variant of PLIB_USBHS_DeviceAddressSet 
272:                 
273:                   Description:
274:                     This template implements the Default variant of the PLIB_USBHS_DeviceAddressSet function.
275:                 */
276:                 
277:                 PLIB_TEMPLATE void USBHS_DeviceAddressSet_Default
278:                 ( 
279:                     USBHS_MODULE_ID index, 
280:                     uint8_t address 
281:                 )
282:                 {
283:                     /* Clears the reset bit */
284:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
285:                     usbhs->FADDRbits.FUNC = address ;
286:                 }
287:                 
288:                 //******************************************************************************
289:                 /* Function :  USBHS_DeviceAttach_Default
290:                 
291:                   Summary:
292:                     Implements Default variant of PLIB_USBHS_DeviceAttach 
293:                 
294:                   Description:
295:                     This template implements the Default variant of the 
296:                     PLIB_USBHS_DeviceAttach function.
297:                 */
298:                 
299:                 PLIB_TEMPLATE void USBHS_DeviceAttach_Default( USBHS_MODULE_ID index, uint32_t speed )
300:                 {
301:                     /* Attach the device at the specified speed */
302:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
303:                 
304:                     /* Full speed value is 0x2 and high speed value is 0x1.
305:                      * So if high speed is specified, then HSEN will be 1
306:                      * and if full speed is specified, the HSEN will be 0 */
307:                     
308:                     usbhs->POWERbits.HSEN = (speed & 0x1);
309:                     usbhs->POWERbits.SOFTCONN = 1;
310:                 }
311:                 
312:                 //******************************************************************************
313:                 /* Function :  USBHS_DeviceDetach_Default
314:                 
315:                   Summary:
316:                     Implements Default variant of PLIB_USBHS_DeviceDetach 
317:                 
318:                   Description:
319:                     This template implements the Default variant of the PLIB_USBHS_DeviceDetach function.
320:                 */
321:                 
322:                 PLIB_TEMPLATE void USBHS_DeviceDetach_Default( USBHS_MODULE_ID index)
323:                 {
324:                    /* Detach the device. */
325:                     
326:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
327:                     usbhs->POWERbits.SOFTCONN = 0;
328:                 }
329:                 
330:                 //******************************************************************************
331:                 /* Function :  USBHS_ExistsModuleControl_Default
332:                 
333:                   Summary:
334:                     Implements Default variant of PLIB_USBHS_ExistsModuleControl
335:                 
336:                   Description:
337:                     This template implements the Default variant of the PLIB_USBHS_ExistsModuleControl function.
338:                 */
339:                 
340:                 #define PLIB_USBHS_ExistsModuleControl PLIB_USBHS_ExistsModuleControl
341:                 PLIB_TEMPLATE bool USBHS_ExistsModuleControl_Default( USBHS_MODULE_ID index )
342:                 {
343:                     return true;
344:                 }
345:                 
346:                 
347:                 #endif /*_USBHS_MODULECONTROL_DEFAULT_H*/
348:                 
349:                 /******************************************************************************
350:                  End of File
351:                 */
352:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_interrupts_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_Interrupts_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Interrupts
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_InterruptEnableSet
16:                          PLIB_USBHS_TxInterruptFlagsGet
17:                          PLIB_USBHS_RxInterruptFlagsGet
18:                          PLIB_USBHS_GenInterruptFlagsGet
19:                          PLIB_USBHS_ExistsInterrupts
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _USBHS_INTERRUPTS_DEFAULT_H
50:                  #define _USBHS_INTERRUPTS_DEFAULT_H
51:                  
52:                  #include "usbhs_registers.h"
53:                  
54:                  //******************************************************************************
55:                  /* Function :  USBHS_InterruptEnableSet_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_USBHS_InterruptEnableSet 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_USBHS_InterruptEnableSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USBHS_InterruptEnableSet_Default
65:                  ( 
66:                      USBHS_MODULE_ID index , 
67:                      USBHS_GEN_INTERRUPT generalInterrupts , 
68:                      USBHS_EPTXRX_INTERRUPT transmitInterrupts , 
69:                      USBHS_EPTXRX_INTERRUPT receiveInterrupts 
70:                  )
71:                  {
72:                      /* This function will update the general interrupt enable
73:                       * endpoint interrupts enable registers */
74:                      
75:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
9D013D6C  8E02005C   LW V0, 92(S0)
9D013DAC  8E02005C   LW V0, 92(S0)
76:                  
77:                      /* Update the transmit interrupts */
78:                      usbhs->INTRTXEbits.w = transmitInterrupts;
9D013D70  24030001   ADDIU V1, ZERO, 1
9D013D74  A4430006   SH V1, 6(V0)
9D013DB0  A4400006   SH ZERO, 6(V0)
9D015E00  A4400006   SH ZERO, 6(V0)
79:                      usbhs->INTRRXEbits.w = receiveInterrupts;
9D013D78  A4400008   SH ZERO, 8(V0)
9D013DB4  A4400008   SH ZERO, 8(V0)
9D015E04  A4400008   SH ZERO, 8(V0)
80:                      usbhs->INTRUSBEbits.w = generalInterrupts;
9D013D7C  2403FFB0   ADDIU V1, ZERO, -80
9D013D80  A043000B   SB V1, 11(V0)
9D013DB8  A040000B   SB ZERO, 11(V0)
9D015E08  A040000B   SB ZERO, 11(V0)
81:                  }
82:                  
83:                  //******************************************************************************
84:                  /* Function :  USBHS_TxInterruptFlagsGet_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_USBHS_TxInterruptFlagsGet 
88:                  
89:                    Description:
90:                      This template implements the Default variant of the 
91:                      PLIB_USBHS_TxInterruptFlagsGet function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE USBHS_EPTXRX_INTERRUPT USBHS_TxInterruptFlagsGet_Default
95:                  ( 
96:                      USBHS_MODULE_ID index
97:                  )
98:                  {
99:                      /* Returns the status of the Transmit endpoint interrupts. The entire
100:                      * register must read at once because this is a clear on read register. */
101:                     
102:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
103:                     return((USBHS_EPTXRX_INTERRUPT)(usbhs->INTRTX));
9D0111B8  96130002   LHU S3, 2(S0)
9D0111BC  3273FFFF   ANDI S3, S3, -1
104:                 }
105:                 
106:                 //******************************************************************************
107:                 /* Function :  USBHS_RxInterruptFlagsGet_Default
108:                 
109:                   Summary:
110:                     Implements Default variant of PLIB_USBHS_RxInterruptFlagsGet 
111:                 
112:                   Description:
113:                     This template implements the Default variant of the 
114:                     PLIB_USBHS_RxInterruptFlagsGet function.
115:                 */
116:                 
117:                 PLIB_TEMPLATE USBHS_EPTXRX_INTERRUPT USBHS_RxInterruptFlagsGet_Default
118:                 ( 
119:                     USBHS_MODULE_ID index 
120:                 )
121:                 {
122:                     /* Returns the status of the Receive endpoint interrupts. The entire
123:                      * register must read at once because this is a clear on read register. */
124:                     
125:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
126:                     return((USBHS_EPTXRX_INTERRUPT)(usbhs->INTRRX));
9D0111C0  96150004   LHU S5, 4(S0)
127:                 }
128:                 
129:                 //******************************************************************************
130:                 /* Function :  USBHS_GenInterruptFlagsGet_Default
131:                 
132:                   Summary:
133:                     Implements Default variant of PLIB_USBHS_GenInterruptFlagsGet 
134:                 
135:                   Description:
136:                     This template implements the Default variant of the PLIB_USBHS_GenInterruptFlagsGet function.
137:                 */
138:                 
139:                 PLIB_TEMPLATE USBHS_GEN_INTERRUPT USBHS_GenInterruptFlagsGet_Default
140:                 ( 
141:                     USBHS_MODULE_ID index 
142:                 )
143:                 {
144:                     /* Returns the status of the General endpoint interrupts. The entire
145:                      * register must read at once because this is a clear on read register. */
146:                     
147:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
9D011148  8C90005C   LW S0, 92(A0)
148:                     return((USBHS_GEN_INTERRUPT)(usbhs->INTRUSB));
9D01114C  9211000A   LBU S1, 10(S0)
9D011150  323100FF   ANDI S1, S1, 255
149:                 }
150:                 
151:                 //******************************************************************************
152:                 /* Function :  USBHS_TxInterruptEnable_Default
153:                 
154:                   Summary:
155:                     Implements Default variant of PLIB_USBHS_TxInterruptEnable 
156:                 
157:                   Description:
158:                     This template implements the Default variant of the 
159:                     PLIB_USBHS_TxInterruptEnable function.
160:                 */
161:                 
162:                 PLIB_TEMPLATE void USBHS_TxInterruptEnable_Default
163:                 (  
164:                     USBHS_MODULE_ID index , 
165:                     USBHS_EPTXRX_INTERRUPT interrupt
166:                 )
167:                 {
168:                    volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
169:                 
170:                     /* Update the Transmit endpoint interrupts */
171:                     usbhs->INTRTXEbits.w = interrupt;
172:                 }
173:                 
174:                 
175:                 //******************************************************************************
176:                 /* Function :  USBHS_RxInterruptEnable_Default
177:                 
178:                   Summary:
179:                     Implements Default variant of PLIB_USBHS_RxInterruptEnable 
180:                 
181:                   Description:
182:                     This template implements the Default variant of the 
183:                     PLIB_USBHS_RxInterruptEnable function.
184:                 */
185:                 
186:                 PLIB_TEMPLATE void USBHS_RxInterruptEnable_Default
187:                 ( 
188:                     USBHS_MODULE_ID index , 
189:                     USBHS_EPTXRX_INTERRUPT interrupt
190:                 )
191:                 {
192:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
193:                 
194:                     /* Update the Receive endpoint interrupts */
195:                     usbhs->INTRRXEbits.w = interrupt;
196:                 }
197:                 
198:                 //******************************************************************************
199:                 /* Function :  USBHS_TxInterruptDisable_Default
200:                 
201:                   Summary:
202:                     Implements Default variant of PLIB_USBHS_TxInterruptDisable 
203:                 
204:                   Description:
205:                     This template implements the Default variant of the 
206:                     PLIB_USBHS_TxInterruptDisable function.
207:                 */
208:                 
209:                 PLIB_TEMPLATE void USBHS_TxInterruptDisable_Default
210:                 ( 
211:                     USBHS_MODULE_ID index , 
212:                     USBHS_EPTXRX_INTERRUPT interrupt
213:                 )
214:                 {
215:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
216:                 
217:                     /* Disable the Transmit endpoint interrupts */
218:                     usbhs->INTRTXEbits.w &= (~(interrupt));
219:                 }
220:                 
221:                 
222:                 //******************************************************************************
223:                 /* Function :  USBHS_RxInterruptDisable_Default
224:                 
225:                   Summary:
226:                     Implements Default variant of PLIB_USBHS_RxInterruptDisable 
227:                 
228:                   Description:
229:                     This template implements the Default variant of the PLIB_USBHS_RxInterruptDisable function.
230:                 */
231:                 
232:                 PLIB_TEMPLATE void USBHS_RxInterruptDisable_Default
233:                 ( 
234:                     USBHS_MODULE_ID index , 
235:                     USBHS_EPTXRX_INTERRUPT interrupt
236:                 )
237:                 {
238:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
239:                 
240:                     /* Disable the Receive endpoint interrupts */
241:                     usbhs->INTRRXEbits.w &= (~(interrupt));
242:                 }
243:                 
244:                 //******************************************************************************
245:                 /* Function :  USBHS_ExistsInterrupts_Default
246:                 
247:                   Summary:
248:                     Implements Default variant of PLIB_USBHS_ExistsInterrupts
249:                 
250:                   Description:
251:                     This template implements the Default variant of the PLIB_USBHS_ExistsInterrupts function.
252:                 */
253:                 
254:                 #define PLIB_USBHS_ExistsInterrupts PLIB_USBHS_ExistsInterrupts
255:                 PLIB_TEMPLATE bool USBHS_ExistsInterrupts_Default( USBHS_MODULE_ID index )
256:                 {
257:                     return true;
258:                 }
259:                 
260:                 
261:                 #endif /*_USBHS_INTERRUPTS_DEFAULT_H*/
262:                 
263:                 /******************************************************************************
264:                  End of File
265:                 */
266:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_highspeedsupport_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_HighSpeedSupport_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : HighSpeedSupport
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_HighSpeedEnable
16:                          PLIB_USBHS_HighSpeedDisable
17:                          PLIB_USBHS_HighSpeedIsConnected
18:                          PLIB_USBHS_FullOrHighSpeedIsConnected
19:                          PLIB_USBHS_ExistsHighSpeedSupport
20:                          PLIB_USBHS_DMAErrorGet
21:                          PLIB_USBHS_DMAInterruptGet
22:                          PLIB_USBHS_DMAOperationEnable
23:                          PLIB_USBHS_LoadEPInIndex
24:                          PLIB_USBHS_GetEP0FIFOAddress
25:                          PLIB_USBHS_GetEP0CSRAddress
26:                          PLIB_USBHS_GetReceiveDataCount
27:                          PLIB_USBHS_TestModeEnter
28:                          PLIB_USBHS_TestModeExit
29:                  
30:                  *******************************************************************************/
31:                  
32:                  //DOM-IGNORE-BEGIN
33:                  /*******************************************************************************
34:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
35:                  
36:                  Microchip licenses to you the right to use, modify, copy and distribute
37:                  Software only when embedded on a Microchip microcontroller or digital signal
38:                  controller that is integrated into your product or third party product
39:                  (pursuant to the sublicense terms in the accompanying license agreement).
40:                  
41:                  You should refer to the license agreement accompanying this Software for
42:                  additional information regarding your rights and obligations.
43:                  
44:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
45:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
46:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
47:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
48:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
49:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
50:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
51:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
52:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
53:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
54:                  *******************************************************************************/
55:                  
56:                  //DOM-IGNORE-END
57:                  
58:                  #ifndef _USBHS_HIGHSPEEDSUPPORT_DEFAULT_H
59:                  #define _USBHS_HIGHSPEEDSUPPORT_DEFAULT_H
60:                  
61:                  #include <sys/kmem.h>
62:                  #include "usbhs_registers.h"
63:                  
64:                  /* This table maps the Test Mode values defined by the USB 2.0 specification
65:                   * to values that can be written directly to the Test mode register. So for
66:                   * example, if the test mode is Test_K, the specification value for this is 
67:                   * 0x02 and the bit position in Testmode register is D2. Hence 
68:                   * PLIB_USBHS_TestModeMapping[2] = 0x4 (bit D2 is set). */
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USBHS_HighSpeedEnable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USBHS_HighSpeedEnable 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the 
79:                      PLIB_USBHS_HighSpeedEnable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void USBHS_HighSpeedEnable_Default( USBHS_MODULE_ID index )
83:                  {
84:                      /* This function enables high speed support */
85:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
86:                      usbhs->POWERbits.HSEN = 1;
9D015E1C  90430001   LBU V1, 1(V0)
9D015E20  24050001   ADDIU A1, ZERO, 1
9D015E24  7CA32944   INS V1, A1, 5, 1
9D015E28  A0430001   SB V1, 1(V0)
87:                  }
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USBHS_HighSpeedDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_USBHS_HighSpeedDisable 
94:                  
95:                    Description:
96:                      This template implements the Default variant of the 
97:                      PLIB_USBHS_HighSpeedDisable function.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void USBHS_HighSpeedDisable_Default( USBHS_MODULE_ID index )
101:                 {
102:                     /* This function disables high speed support */
103:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
104:                     usbhs->POWERbits.HSEN = 0;
9D015E34  90430001   LBU V1, 1(V0)
9D015E38  7C032944   INS V1, ZERO, 5, 1
9D015E3C  A0430001   SB V1, 1(V0)
105:                 }
106:                 
107:                 //******************************************************************************
108:                 /* Function :  USBHS_HighSpeedIsConnected_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_USBHS_HighSpeedIsConnected 
112:                 
113:                   Description:
114:                     This template implements the Default variant of the 
115:                     PLIB_USBHS_HighSpeedIsConnected function.
116:                 */
117:                 
118:                 PLIB_TEMPLATE bool USBHS_HighSpeedIsConnected_Default( USBHS_MODULE_ID index )
119:                 {
120:                     /* Returns true if the connected device is high speed
121:                      * else returns false. */
122:                 
123:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
9D0127EC  8E02005C   LW V0, 92(S0)
124:                     return((bool)(usbhs->POWERbits.HSMODE));
9D0127F0  8C430000   LW V1, 0(V0)
9D0127F4  30631000   ANDI V1, V1, 4096
0000003C  00000000   NOP
125:                 }
126:                 
127:                 //******************************************************************************
128:                 /* Function :  USBHS_DMAErrorGet_Default
129:                 
130:                   Summary:
131:                     Implements Default variant of PLIB_USBHS_DMAErrorGet 
132:                 
133:                   Description:
134:                     This template implements the Default variant of the 
135:                     PLIB_USBHS_DMAErrorGet function.
136:                 */
137:                 
138:                 PLIB_TEMPLATE bool USBHS_DMAErrorGet_Default
139:                 ( 
140:                     USBHS_MODULE_ID index, 
141:                     uint8_t dmaChannel 
142:                 )
143:                 {
144:                     /* Returns true the specified DMA channel is in an error condition
145:                      * and then clears the error flag. */
146:                     
147:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
148:                     bool result = false;
149:                     
150:                     if( usbhs->DMA_CHANNEL[dmaChannel - 1].DMACNTLbits.DMAERR == 1)
9D00C0D8  24170001   ADDIU S7, ZERO, 1
9D00C0F4  00101080   SLL V0, S0, 2
9D00C0F8  00102100   SLL A0, S0, 4
9D00C0FC  00821023   SUBU V0, A0, V0
9D00C100  02A21021   ADDU V0, S5, V0
9D00C104  8C420204   LW V0, 516(V0)
9D00C108  7C420200   EXT V0, V0, 8, 1
9D00C10C  54570061   BNEL V0, S7, 0x9D00C294
9D00C110  9222000D   LBU V0, 13(S1)
151:                     {
152:                         /* Clear the error flag*/
153:                         result = true;
154:                         usbhs->DMA_CHANNEL[dmaChannel - 1].DMACNTLbits.DMAERR = 0;
9D00C114  00101080   SLL V0, S0, 2
9D00C118  00821823   SUBU V1, A0, V0
9D00C11C  02A31821   ADDU V1, S5, V1
9D00C120  8C620204   LW V0, 516(V1)
9D00C124  7C024204   INS V0, ZERO, 8, 1
9D00C128  AC620204   SW V0, 516(V1)
9D00C12C  0B4030A1   J 0x9D00C284
9D00C130  26100001   ADDIU S0, S0, 1
155:                         
156:                     }
157:                   
158:                     return result;
159:                 }
160:                 
161:                 //******************************************************************************
162:                 /* Function :  USBHS_DMAInterruptGet_Default
163:                 
164:                   Summary:
165:                     Implements Default variant of PLIB_USBHS_DMAInterruptGet 
166:                 
167:                   Description:
168:                     This template implements the Default variant of the 
169:                     PLIB_USBHS_DMAInterruptGet function.
170:                 */
171:                 
172:                 PLIB_TEMPLATE uint8_t USBHS_DMAInterruptGet_Default( USBHS_MODULE_ID index)
173:                 {
174:                     /* Returns the status the DMA channel interrupts. Calling this function
175:                      * also clears the interrupt flags. */
176:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
177:                     volatile uint8_t * dmaInterruptRegAddress = (uint8_t *)(&usbhs->DMA_INTR);
178:                     return (*dmaInterruptRegAddress);
9D00C0C8  90540200   LBU S4, 512(V0)
9D00C0CC  329400FF   ANDI S4, S4, 255
9D00C0D0  00808821   ADDU S1, A0, ZERO
9D00C0D4  00008021   ADDU S0, ZERO, ZERO
179:                 }
180:                 
181:                 //******************************************************************************
182:                 /* Function :  USBHS_DMAOperationEnable_Default
183:                 
184:                   Summary:
185:                     Implements Default variant of PLIB_USBHS_DMAOperationEnable
186:                 
187:                   Description:
188:                     This template implements the Default variant of the 
189:                     PLIB_USBHS_DMAOperationEnable function.
190:                 */
191:                 
192:                 PLIB_TEMPLATE void USBHS_DMAOperationEnable_Default
193:                 (
194:                     USBHS_MODULE_ID index,
195:                     uint8_t endpoint,
196:                     uint8_t dmaChannel,
197:                     void * address,
198:                     uint32_t count,
199:                     bool direction
200:                 )
201:                 {
202:                     /* Configures the DMA channel for specified endpoint and transfer 
203:                      * direction */
204:                     
205:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
206:                    
207:                     /* DMA ADDR register program */
208:                     usbhs->DMA_CHANNEL[dmaChannel - 1].DMAADDR = KVA_TO_PA(address);
9D00D3A0  2463FFFF   ADDIU V1, V1, -1
9D00D3A4  7E10E000   EXT S0, S0, 0, 29
9D00D3A8  00032080   SLL A0, V1, 2
9D00D3AC  00031900   SLL V1, V1, 4
9D00D3B0  00641823   SUBU V1, V1, A0
9D00D3B4  02439021   ADDU S2, S2, V1
9D00D3B8  AE500208   SW S0, 520(S2)
9D00E89C  2442FFFF   ADDIU V0, V0, -1
9D00E8A0  7E94E000   EXT S4, S4, 0, 29
9D00E8A4  00021880   SLL V1, V0, 2
9D00E8A8  00021100   SLL V0, V0, 4
9D00E8AC  00431023   SUBU V0, V0, V1
9D00E8B0  02429021   ADDU S2, S2, V0
9D00E8B4  AE540208   SW S4, 520(S2)
209:                    
210:                     /* DMA COUNT register program */
211:                     usbhs->DMA_CHANNEL[dmaChannel - 1].DMACOUNT = (uint32_t)(count);
9D00D3BC  AE42020C   SW V0, 524(S2)
9D00E8B8  AE51020C   SW S1, 524(S2)
212:                     
213:                     /* Set up the rest of the DMA channel */
214:                     usbhs->DMA_CHANNEL[dmaChannel - 1].DMACNTLbits.DMABRSTM = 3;
9D00D3C0  8E430204   LW V1, 516(S2)
9D00D3C4  24040003   ADDIU A0, ZERO, 3
9D00D3C8  7C835244   INS V1, A0, 9, 2
9D00D3CC  AE430204   SW V1, 516(S2)
9D00E8BC  8E420204   LW V0, 516(S2)
9D00E8C0  24030003   ADDIU V1, ZERO, 3
9D00E8C4  7C625244   INS V0, V1, 9, 2
9D00E8C8  AE420204   SW V0, 516(S2)
215:                     usbhs->DMA_CHANNEL[dmaChannel - 1].DMACNTLbits.DMAIE = 1;
9D00D3D0  8E440204   LW A0, 516(S2)
9D00D3D4  24030001   ADDIU V1, ZERO, 1
9D00D3D8  7C6418C4   INS A0, V1, 3, 1
9D00D3DC  AE440204   SW A0, 516(S2)
9D00E8CC  8E430204   LW V1, 516(S2)
9D00E8D0  24020001   ADDIU V0, ZERO, 1
9D00E8D4  7C4318C4   INS V1, V0, 3, 1
9D00E8D8  AE430204   SW V1, 516(S2)
216:                     usbhs->DMA_CHANNEL[dmaChannel - 1].DMACNTLbits.DMAMODE = 0;
9D00D3E0  8E440204   LW A0, 516(S2)
9D00D3E4  7C041084   INS A0, ZERO, 2, 1
9D00D3E8  AE440204   SW A0, 516(S2)
9D00E8DC  8E430204   LW V1, 516(S2)
9D00E8E0  7C031084   INS V1, ZERO, 2, 1
9D00E8E4  AE430204   SW V1, 516(S2)
217:                 	usbhs->DMA_CHANNEL[dmaChannel - 1].DMACNTLbits.DMAEP = endpoint;
9D00D3EC  8E440204   LW A0, 516(S2)
9D00D3F0  7E843904   INS A0, S4, 4, 4
9D00D3F4  AE440204   SW A0, 516(S2)
9D00E8E8  8E430204   LW V1, 516(S2)
9D00E8EC  7E633904   INS V1, S3, 4, 4
9D00E8F0  AE430204   SW V1, 516(S2)
218:                     
219:                     /* The input direction bit is a complement of the DMA channel direction
220:                      * bit. */
221:                     usbhs->DMA_CHANNEL[dmaChannel - 1].DMACNTLbits.DMADIR = !direction;
9D00D3F8  8E440204   LW A0, 516(S2)
9D00D3FC  7C040844   INS A0, ZERO, 1, 1
9D00D400  AE440204   SW A0, 516(S2)
9D00E8F4  8E430204   LW V1, 516(S2)
9D00E8F8  7C430844   INS V1, V0, 1, 1
9D00E8FC  AE430204   SW V1, 516(S2)
222:                     usbhs->DMA_CHANNEL[dmaChannel - 1].DMACNTLbits.DMAEN = 1;
9D00D404  8E440204   LW A0, 516(S2)
9D00D408  7C640004   INS A0, V1, 0, 1
9D00D40C  AE440204   SW A0, 516(S2)
9D00E900  8E430204   LW V1, 516(S2)
9D00E904  7C430004   INS V1, V0, 0, 1
9D00E908  AE430204   SW V1, 516(S2)
223:                 
224:                 }
225:                 
226:                 //******************************************************************************
227:                 /* Function :  USBHS_LoadEPInIndex_Default
228:                 
229:                   Summary:
230:                     Implements Default variant of PLIB_USBHS_LoadEPInIndex 
231:                 
232:                   Description:
233:                     This template implements the Default variant of the 
234:                     PLIB_USBHS_LoadEPInIndex function.
235:                 */
236:                 
237:                 PLIB_TEMPLATE void USBHS_LoadEPInIndex_Default
238:                 (
239:                     USBHS_MODULE_ID index, 
240:                     uint8_t endpoint
241:                 )
242:                 {
243:                     /* Load the index register. This defines which endpoint control status
244:                      * register set appears in the EPCSR window. */
245:                     
246:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
247:                     usbhs->INDEXbits.ENDPOINT = endpoint; 
248:                 }
249:                 
250:                 //******************************************************************************
251:                 /* Function :  USBHS_GetEP0FIFOAddress_Default
252:                 
253:                   Summary:
254:                     Implements Default variant of PLIB_USBHS_GetEP0FIFOAddress 
255:                 
256:                   Description:
257:                     This template implements the Default variant of the 
258:                     PLIB_USBHS_GetEP0FIFOAddress function.
259:                 */
260:                 
261:                 PLIB_TEMPLATE uint8_t * USBHS_GetEP0FIFOAddress_Default(USBHS_MODULE_ID index)
262:                 {
263:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
264:                     return ((uint8_t *)(&usbhs->FIFO[0]));
265:                 }
266:                 
267:                 //******************************************************************************
268:                 /* Function :  USBHS_GetEP0CSRAddress_Default
269:                 
270:                   Summary:
271:                     Implements Default variant of PLIB_USBHS_GetEP0CSRAddress 
272:                 
273:                   Description:
274:                     This template implements the Default variant of the 
275:                     PLIB_USBHS_GetEP0CSRAddress function.
276:                 */
277:                 
278:                 PLIB_TEMPLATE uint8_t * USBHS_GetEP0CSRAddress_Default(USBHS_MODULE_ID index)
279:                 {
280:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
281:                     return ((uint8_t *)(&usbhs->INDEXED_EPCSR.CSR0L_DEVICEbits));
282:                 }
283:                 
284:                 //******************************************************************************
285:                 /* Function :  USBHS_GetReceiveDataCount_Default
286:                 
287:                   Summary:
288:                     Implements Default variant of PLIB_USBHS_GetReceiveDataCount 
289:                 
290:                   Description:
291:                     This template implements the Default variant of the PLIB_USBHS_GetReceiveDataCount function.
292:                 */
293:                 
294:                 PLIB_TEMPLATE uint32_t USBHS_GetReceiveDataCount_Default
295:                 (
296:                     USBHS_MODULE_ID index, 
297:                     uint8_t endpoint
298:                 )
299:                 {
300:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
301:                     uint32_t count;
302:                     
303:                     count = usbhs->EPCSR[endpoint].RXCOUNTbits.w;
9D00D380  00141100   SLL V0, S4, 4
9D00D384  02421021   ADDU V0, S2, V0
9D00D388  94420108   LHU V0, 264(V0)
9D00D38C  3042FFFF   ANDI V0, V0, -1
304:                     return(count);
305:                 }
306:                 
307:                 
308:                 //******************************************************************************
309:                 /* Function :  USBHS_FullOrHighSpeedIsConnected_Default
310:                 
311:                   Summary:
312:                     Implements Default variant of PLIB_USBHS_FullOrHighSpeedIsConnected 
313:                 
314:                   Description:
315:                     This template implements the Default variant of the PLIB_USBHS_FullOrHighSpeedIsConnected function.
316:                 */
317:                 
318:                 PLIB_TEMPLATE bool USBHS_FullOrHighSpeedIsConnected_Default( USBHS_MODULE_ID index )
319:                 {
320:                     /* Function returns true is high or full speed device is connected.
321:                      * Return false if low speed or no device is connected */
322:                 
323:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
324:                     bool result = false;
325:                     
326:                     if(usbhs->DEVCTLbits.FSDEV == 1)
9D01280C  8C430060   LW V1, 96(V0)
9D012820  30630040   ANDI V1, V1, 64
00000058  00000000   NOP
0000006C  00000000   NOP
327:                     {
328:                         result = true;
329:                     }
330:                     
331:                     if(usbhs->DEVCTLbits.LSDEV == 1)
9D012810  8C420060   LW V0, 96(V0)
9D012814  30420020   ANDI V0, V0, 32
9D012818  14400007   BNE V0, ZERO, 0x9D012838
9D01281C  24020003   ADDIU V0, ZERO, 3
0000005C  00000000   NOP
332:                     {
333:                         result = false;
334:                     }
335:                     
336:                     return result;
337:                 }
338:                 
339:                 //******************************************************************************
340:                 /* Function :  USBHS_ExistsHighSpeedSupport_Default
341:                 
342:                   Summary:
343:                     Implements Default variant of PLIB_USBHS_ExistsHighSpeedSupport
344:                 
345:                   Description:
346:                     This template implements the Default variant of the 
347:                     PLIB_USBHS_ExistsHighSpeedSupport function.
348:                 */
349:                 
350:                 #define PLIB_USBHS_ExistsHighSpeedSupport PLIB_USBHS_ExistsHighSpeedSupport
351:                 PLIB_TEMPLATE bool USBHS_ExistsHighSpeedSupport_Default( USBHS_MODULE_ID index )
352:                 {
353:                     return true;
354:                 }
355:                 
356:                 //******************************************************************************
357:                 /* Function :  USBHS_TestModeEnter_Default
358:                 
359:                   Summary:
360:                     Implements Default variant of PLIB_USBHS_TestModeEnter 
361:                 
362:                   Description:
363:                     This template implements the Default variant of the PLIB_USBHS_TestModeEnter function.
364:                 */
365:                 
366:                 PLIB_TEMPLATE bool USBHS_TestModeEnter_Default
367:                 ( 
368:                     USBHS_MODULE_ID index, 
369:                     uint8_t testMode 
370:                 )
371:                 {
372:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
373:                     bool result = false;
374:                 	
375:                 	uint8_t PLIB_USBHS_TestModeMapping[5] = 
376:                     {
377:                         0x0, /* Not used */ 
378:                         0x2, /* Test_J */ 
379:                         0x4, /* Test_K */
380:                         0x1, /* Test_SE0_NAK */
381:                         0x8  /* Test Packet */
382:                     };
383:                     
384:                     if((usbhs->TESTMODEbits.w & 0x7F) == 0x0)
385:                     {
386:                         /* We can proceed only if bits D6-D0 are are all 0. Now check if 
387:                          * testMode is not zero and is not greater than 5. This is not a valid test 
388:                          * mode */
389:                         
390:                         if((testMode != 0) && (testMode < 5))
391:                         {
392:                             usbhs->TESTMODEbits.w |= PLIB_USBHS_TestModeMapping[testMode];
393:                             result = true;
394:                         }
395:                     }
396:                   
397:                 	return result;
398:                 }
399:                 
400:                 
401:                 //******************************************************************************
402:                 /* Function :  USBHS_TestModeExit_Default
403:                 
404:                   Summary:
405:                     Implements Default variant of PLIB_USBHS_TestModeExit 
406:                 
407:                   Description:
408:                     This template implements the Default variant of the 
409:                     PLIB_USBHS_TestModeExit function.
410:                 */
411:                 
412:                 PLIB_TEMPLATE bool USBHS_TestModeExit_Default( USBHS_MODULE_ID index , uint8_t testMode )
413:                 {
414:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
415:                     bool result = false;
416:                 	
417:                 	uint8_t PLIB_USBHS_TestModeMapping[5] = 
418:                     {
419:                         0x0, /* Not used */ 
420:                         0x2, /* Test_J */ 
421:                         0x4, /* Test_K */
422:                         0x1, /* Test_SE0_NAK */
423:                         0x8  /* Test Packet */
424:                     };
425:                     
426:                     /* We can proceed only if bits D6-D0 are are all 0. Now check if 
427:                      * testMode is not zero and is not greater than 5. This is not a valid test 
428:                      * mode */
429:                 
430:                     if((testMode != 0) && (testMode < 5))
431:                     {
432:                         usbhs->TESTMODEbits.w &= (~(PLIB_USBHS_TestModeMapping[testMode]));
433:                         result = true;
434:                     }
435:                    
436:                 	return result;
437:                 }
438:                 
439:                 
440:                 #endif /*_USBHS_HIGHSPEEDSUPPORT_DEFAULT_H*/
441:                 
442:                 /******************************************************************************
443:                  End of File
444:                 */
445:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_ep0status_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_EP0Status_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EP0Status
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_EP0StatusGet
16:                          PLIB_USBHS_EP0StatusClear
17:                          PLIB_USBHS_EP0INHandshakeSend
18:                          PLIB_USBHS_EP0INTokenSend
19:                          PLIB_USBHS_EP0OUTHandshakeSend
20:                          PLIB_USBHS_EP0INHandshakeClear
21:                          PLIB_USBHS_ExistsEP0Status
22:                  
23:                  *******************************************************************************/
24:                  
25:                  //DOM-IGNORE-BEGIN
26:                  /*******************************************************************************
27:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
28:                  
29:                  Microchip licenses to you the right to use, modify, copy and distribute
30:                  Software only when embedded on a Microchip microcontroller or digital signal
31:                  controller that is integrated into your product or third party product
32:                  (pursuant to the sublicense terms in the accompanying license agreement).
33:                  
34:                  You should refer to the license agreement accompanying this Software for
35:                  additional information regarding your rights and obligations.
36:                  
37:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
38:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
39:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
40:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
41:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
42:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
43:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
44:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
46:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                  *******************************************************************************/
48:                  
49:                  //DOM-IGNORE-END
50:                  
51:                  #ifndef _USBHS_EP0STATUS_DEFAULT_H
52:                  #define _USBHS_EP0STATUS_DEFAULT_H
53:                  
54:                  #include "usbhs_registers.h"
55:                  
56:                  //******************************************************************************
57:                  /* Function :  USBHS_EP0StatusGet_Default
58:                  
59:                    Summary:
60:                      Implements Default variant of PLIB_USBHS_EP0StatusGet 
61:                  
62:                    Description:
63:                      This template implements the Default variant of the 
64:                      PLIB_USBHS_EP0StatusGet function.
65:                  */
66:                  
67:                  PLIB_TEMPLATE uint8_t USBHS_EP0StatusGet_Default( USBHS_MODULE_ID index )
68:                  {
69:                      /* Returns the entire CSR0L register contents */
70:                      
71:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
72:                      return(usbhs->EPCSR[0].CSR0L_HOSTbits.w);
9D008248  92420102   LBU V0, 258(S2)
73:                  }
74:                  
75:                  //******************************************************************************
76:                  /* Function :  USBHS_EP0StatusClear_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_USBHS_EP0StatusClear 
80:                  
81:                    Description:
82:                      This template implements the Default variant of the 
83:                      PLIB_USBHS_EP0StatusClear function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void USBHS_EP0StatusClear_Default
87:                  ( 
88:                      USBHS_MODULE_ID index , 
89:                      USBHS_EP0_ERROR error
90:                  )
91:                  {
92:                      /* This function clears the specified error */
93:                      
94:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
95:                      usbhs->EPCSR[0].CSR0L_HOSTbits.w &= (~(error));
9D008264  92420102   LBU V0, 258(S2)
9D008268  3042006B   ANDI V0, V0, 107
9D00826C  A2420102   SB V0, 258(S2)
9D0082C0  92420102   LBU V0, 258(S2)
9D0082C4  304200FB   ANDI V0, V0, 251
9D0082C8  A2420102   SB V0, 258(S2)
9D0082E4  92420102   LBU V0, 258(S2)
9D0082E8  3042007F   ANDI V0, V0, 127
9D0082EC  A2420102   SB V0, 258(S2)
9D00830C  92420102   LBU V0, 258(S2)
9D008310  304200EF   ANDI V0, V0, 239
9D008314  A2420102   SB V0, 258(S2)
96:                  }
97:                  
98:                  //******************************************************************************
99:                  /* Function :  USBHS_EP0SentStallClear_Default
100:                 
101:                   Summary:
102:                     Implements Default variant of PLIB_USBHS_EP0SentStallClear 
103:                 
104:                   Description:
105:                     This template implements the Default variant of the 
106:                     PLIB_USBHS_EP0SentStallClear function.
107:                 */
108:                 
109:                 PLIB_TEMPLATE void USBHS_EP0SentStallClear_Default( USBHS_MODULE_ID index)
110:                 {
111:                     /* This function clears sent stall bit */
112:                 
113:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
114:                     usbhs->EPCSR[0].CSR0L_HOSTbits.RXSTALL = 0;
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USBHS_EP0SetupEndServiced_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USBHS_EP0SetupEndServiced 
122:                 
123:                   Description:
124:                     This template implements the Default variant of the 
125:                     PLIB_USBHS_EP0SetupEndServiced function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE void USBHS_EP0SetupEndServiced_Default( USBHS_MODULE_ID index)
129:                 {
130:                     /* This function sets the "Serviced Setup End" bit
131:                      * which then clears the setup end bit */
132:                 
133:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
134:                     usbhs->EPCSR[0].CSR0L_DEVICEbits.SVSSETEND = 1;
135:                 }
136:                 
137:                 //******************************************************************************
138:                 /* Function :  USBHS_EP0RxPktRdyServiced_Default
139:                 
140:                   Summary:
141:                     Implements Default variant of PLIB_USBHS_EP0RxPktRdyServiced 
142:                 
143:                   Description:
144:                     This template implements the Default variant of the 
145:                     PLIB_USBHS_EP0RxPktRdyServiced function.
146:                 */
147:                 
148:                 PLIB_TEMPLATE void USBHS_EP0RxPktRdyServiced_Default( USBHS_MODULE_ID index)
149:                 {
150:                     /* This function sets the Serviced RxPktRdy bit */
151:                 
152:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
153:                     usbhs->EPCSR[0].CSR0L_DEVICEbits.SVCRPR = 1;
154:                 }
155:                 
156:                 //******************************************************************************
157:                 /* Function :  USBHS_EP0RxPktRdyServicedDataEnd_Default
158:                 
159:                   Summary:
160:                     Implements Default variant of PLIB_USBHS_EP0RxPktRdyServicedDataEnd 
161:                 
162:                   Description:
163:                     This template implements the Default variant of the 
164:                     PLIB_USBHS_EP0RxPktRdyServicedDataEnd function.
165:                 */
166:                 
167:                 PLIB_TEMPLATE void USBHS_EP0RxPktRdyServicedDataEnd_Default( USBHS_MODULE_ID index)
168:                 {
169:                     /* This function sets the RxPktRdy serviced bit and the Data End bit. */
170:                     
171:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
172:                     usbhs->EPCSR[0].CSR0L_DEVICEbits.w = (USBHS_EP0_DEVICE_SERVICED_RXPKTRDY| USBHS_EP0_DEVICE_DATAEND);
173:                 }
174:                 
175:                 //******************************************************************************
176:                 /* Function :  USBHS_EP0TxPktRdyDataEnd_Default
177:                 
178:                   Summary:
179:                     Implements Default variant of PLIB_USBHS_EP0TxPktRdyDataEnd 
180:                 
181:                   Description:
182:                     This template implements the Default variant of the 
183:                     PLIB_USBHS_EP0TxPktRdyDataEnd function.
184:                 */
185:                 
186:                 PLIB_TEMPLATE void USBHS_EP0TxPktRdyDataEnd_Default( USBHS_MODULE_ID index)
187:                 {
188:                     /* This function sets the TxPktRdy bit and the Data End bit. */
189:                 
190:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
191:                     usbhs->EPCSR[0].CSR0L_DEVICEbits.w = (USBHS_EP0_DEVICE_TXPKTRDY| USBHS_EP0_DEVICE_DATAEND);
192:                 }
193:                 
194:                 //******************************************************************************
195:                 /* Function :  USBHS_EP0TxPktRdy_Default
196:                 
197:                   Summary:
198:                     Implements Default variant of PLIB_USBHS_EP0TxPktRdy 
199:                 
200:                   Description:
201:                     This template implements the Default variant of the 
202:                     PLIB_USBHS_EP0TxPktRdy function.
203:                 */
204:                 
205:                 PLIB_TEMPLATE void USBHS_EP0TxPktRdy_Default( USBHS_MODULE_ID index)
206:                 {
207:                     /* This function sets the TxPktRdy bit. */
208:                 
209:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
210:                     usbhs->EPCSR[0].CSR0L_DEVICEbits.TXPKTRDY = 1;
211:                 }
212:                 
213:                 //******************************************************************************
214:                 /* Function :  USBHS_EP0DataEndSet_Default
215:                 
216:                   Summary:
217:                     Implements Default variant of PLIB_USBHS_EP0DataEndSet 
218:                 
219:                   Description:
220:                     This template implements the Default variant of the 
221:                     PLIB_USBHS_EP0DataEndSet function.
222:                 */
223:                 
224:                 PLIB_TEMPLATE void USBHS_EP0DataEndSet_Default( USBHS_MODULE_ID index)
225:                 {
226:                     /* This function sets the data end bit */
227:                 
228:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
229:                     usbhs->EPCSR[0].CSR0L_DEVICEbits.DATAEND = 1;
230:                 }
231:                 
232:                 //******************************************************************************
233:                 /* Function :  USBHS_EP0INHandshakeSend_Default
234:                 
235:                   Summary:
236:                     Implements Default variant of PLIB_USBHS_EP0INHandshakeSend 
237:                 
238:                   Description:
239:                     This template implements the Default variant of the 
240:                     PLIB_USBHS_EP0INHandshakeSend function.
241:                 */
242:                 
243:                 PLIB_TEMPLATE void USBHS_EP0INHandshakeSend_Default( USBHS_MODULE_ID index )
244:                 {
245:                     /* Starts the IN Handshake stage of a control transfer on EP0 in 
246:                      * Host mode. */
247:                     
248:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
249:                     usbhs->EPCSR[0].CSR0L_HOSTbits.w = (USBHS_EP0_HOST_STATUS_STAGE_START | USBHS_EP0_HOST_REQPKT);
9D008358  24020060   ADDIU V0, ZERO, 96
9D00835C  A2420102   SB V0, 258(S2)
9D008448  24020060   ADDIU V0, ZERO, 96
9D00844C  A2420102   SB V0, 258(S2)
250:                 }
251:                 
252:                 
253:                 //******************************************************************************
254:                 /* Function :  USBHS_EP0INTokenSend_Default
255:                 
256:                   Summary:
257:                     Implements Default variant of PLIB_USBHS_EP0INTokenSend 
258:                 
259:                   Description:
260:                     This template implements the Default variant of the 
261:                     PLIB_USBHS_EP0INTokenSend function.
262:                 */
263:                 
264:                 PLIB_TEMPLATE void USBHS_EP0INTokenSend_Default( USBHS_MODULE_ID index )
265:                 {
266:                     /* Sends an IN token on EP0 in Host mode */
267:                     
268:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
269:                     usbhs->EPCSR[0].CSR0L_HOSTbits.REQPKT = 1;
9D00837C  92420102   LBU V0, 258(S2)
9D008380  24030001   ADDIU V1, ZERO, 1
9D008384  7C622944   INS V0, V1, 5, 1
9D008388  A2420102   SB V0, 258(S2)
9D008404  92420102   LBU V0, 258(S2)
9D008408  24030001   ADDIU V1, ZERO, 1
9D00840C  7C622944   INS V0, V1, 5, 1
9D008410  A2420102   SB V0, 258(S2)
270:                 }
271:                 
272:                 //******************************************************************************
273:                 /* Function :  USBHS_EP0StallEnable_Default
274:                 
275:                   Summary:
276:                     Implements Default variant of PLIB_USBHS_EP0StallEnable 
277:                 
278:                   Description:
279:                     This template implements the Default variant of the 
280:                     PLIB_USBHS_EP0StallEnable function.
281:                 */
282:                 
283:                 PLIB_TEMPLATE void USBHS_EP0StallEnable_Default( USBHS_MODULE_ID index )
284:                 {
285:                     /* Causes a stall to be sent on EP0 in device mode */
286:                     
287:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
288:                     usbhs->EPCSR[0].CSR0L_DEVICEbits.SENDSTALL = 1;
289:                 }
290:                 
291:                 //******************************************************************************
292:                 /* Function :  USBHS_EP0StallDisable_Default
293:                 
294:                   Summary:
295:                     Implements Default variant of PLIB_USBHS_EP0StallDisable 
296:                 
297:                   Description:
298:                     This template implements the Default variant of the 
299:                     PLIB_USBHS_EP0StallDisable function.
300:                 */
301:                 
302:                 PLIB_TEMPLATE void USBHS_EP0StallDisable_Default( USBHS_MODULE_ID index )
303:                 {
304:                     /* Clear the SENDSTALL bit */
305:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
306:                     usbhs->EPCSR[0].CSR0L_DEVICEbits.SENDSTALL = 0;
307:                 }
308:                 
309:                 //******************************************************************************
310:                 /* Function :  USBHS_EP0OUTHandshakeSend_Default
311:                 
312:                   Summary:
313:                     Implements Default variant of PLIB_USBHS_EP0OUTHandshakeSend 
314:                 
315:                   Description:
316:                     This template implements the Default variant of the 
317:                     PLIB_USBHS_EP0OUTHandshakeSend function.
318:                 */
319:                 
320:                 PLIB_TEMPLATE void USBHS_EP0OUTHandshakeSend_Default( USBHS_MODULE_ID index )
321:                 {
322:                     /* Starts an OUT Handshake stage on EP0 in host mode. */
323:                     
324:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
325:                     usbhs->EPCSR[0].CSR0L_HOSTbits.w = (USBHS_EP0_HOST_STATUS_STAGE_START | USBHS_EP0_HOST_TXPKTRDY);
9D0083F4  24020042   ADDIU V0, ZERO, 66
9D0083F8  A2420102   SB V0, 258(S2)
326:                 }
327:                 
328:                 //******************************************************************************
329:                 /* Function :  USBHS_EP0INHandshakeClear_Default
330:                 
331:                   Summary:
332:                     Implements Default variant of PLIB_USBHS_EP0INHandshakeClear 
333:                 
334:                   Description:
335:                     This template implements the Default variant of the 
336:                     PLIB_USBHS_EP0INHandshakeClear function.
337:                 */
338:                 
339:                 PLIB_TEMPLATE void USBHS_EP0INHandshakeClear_Default( USBHS_MODULE_ID index )
340:                 {
341:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
342:                     usbhs->EPCSR[0].CSR0L_HOSTbits.w &= (~(USBHS_EP0_HOST_STATUS_STAGE_START | USBHS_EP0_HOST_RXPKTRDY));
9D00848C  92420102   LBU V0, 258(S2)
9D008490  304200BE   ANDI V0, V0, 190
9D008494  A2420102   SB V0, 258(S2)
343:                 }
344:                 
345:                 //******************************************************************************
346:                 /* Function :  USBHS_ExistsEP0Status_Default
347:                 
348:                   Summary:
349:                     Implements Default variant of PLIB_USBHS_ExistsEP0Status
350:                 
351:                   Description:
352:                     This template implements the Default variant of the PLIB_USBHS_ExistsEP0Status function.
353:                 */
354:                 
355:                 #define PLIB_USBHS_ExistsEP0Status PLIB_USBHS_ExistsEP0Status
356:                 PLIB_TEMPLATE bool USBHS_ExistsEP0Status_Default( USBHS_MODULE_ID index )
357:                 {
358:                     return true;
359:                 }
360:                 
361:                 
362:                 #endif /*_USBHS_EP0STATUS_DEFAULT_H*/
363:                 
364:                 /******************************************************************************
365:                  End of File
366:                 */
367:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_endpointoperations_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_EndpointOperations_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EndpointOperations
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_EndpointRxRequestEnable
16:                          PLIB_USBHS_EndpointRxRequestClear
17:                          PLIB_USBHS_HostRxEndpointConfigure
18:                          PLIB_USBHS_HostTxEndpointConfigure
19:                          PLIB_USBHS_HostTxEndpointDataToggleClear
20:                          PLIB_USBHS_HostRxEndpointDataToggleClear
21:                          PLIB_USBHS_DeviceRxEndpointConfigure
22:                          PLIB_USBHS_DeviceTxEndpointConfigure
23:                          PLIB_USBHS_DeviceRxEndpointStallEnable
24:                          PLIB_USBHS_DeviceTxEndpointStallEnable
25:                          PLIB_USBHS_DeviceRxEndpointStallDisable
26:                          PLIB_USBHS_DeviceTxEndpointStallDisable
27:                          PLIB_USBHS_DeviceTxEndpointPacketReady
28:                          PLIB_USBHS_ExistsEndpointOperations
29:                  
30:                  *******************************************************************************/
31:                  
32:                  //DOM-IGNORE-BEGIN
33:                  /*******************************************************************************
34:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
35:                  
36:                  Microchip licenses to you the right to use, modify, copy and distribute
37:                  Software only when embedded on a Microchip microcontroller or digital signal
38:                  controller that is integrated into your product or third party product
39:                  (pursuant to the sublicense terms in the accompanying license agreement).
40:                  
41:                  You should refer to the license agreement accompanying this Software for
42:                  additional information regarding your rights and obligations.
43:                  
44:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
45:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
46:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
47:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
48:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
49:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
50:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
51:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
52:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
53:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
54:                  *******************************************************************************/
55:                  
56:                  //DOM-IGNORE-END
57:                  
58:                  #ifndef _USBHS_ENDPOINTOPERATIONS_DEFAULT_H
59:                  #define _USBHS_ENDPOINTOPERATIONS_DEFAULT_H
60:                  
61:                  #include "usbhs_registers.h"
62:                  
63:                  //******************************************************************************
64:                  /* Function :  USBHS_EndpointRxRequestEnable_Default
65:                  
66:                    Summary:
67:                      Implements Default variant of PLIB_USBHS_EndpointRxRequestEnable 
68:                  
69:                    Description:
70:                      This template implements the Default variant of the
71:                      PLIB_USBHS_EndpointRxRequestEnable function.
72:                  */
73:                  
74:                  PLIB_TEMPLATE void USBHS_EndpointRxRequestEnable_Default
75:                  ( 
76:                      USBHS_MODULE_ID index, 
77:                      uint8_t endpoint 
78:                  )
79:                  {
80:                      /* Sets the Receive Packet Request bit causing an IN endpoint to send an IN
81:                       * token. This function is to be called in the host mode operation. */
82:                  
83:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
84:                      usbhs->EPCSR[endpoint].RXCSRL_HOSTbits.REQPKT = 1;
9D00DBD0  26A20010   ADDIU V0, S5, 16
9D00DBD4  00021100   SLL V0, V0, 4
9D00DBD8  0282A021   ADDU S4, S4, V0
9D00DBDC  92820006   LBU V0, 6(S4)
9D00DBE0  24030001   ADDIU V1, ZERO, 1
9D00DBE4  7C622944   INS V0, V1, 5, 1
9D00DBE8  A2820006   SB V0, 6(S4)
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USBHS_EndpointRxRequestClear_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USBHS_EndpointRxRequestClear 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the
95:                      PLIB_USBHS_EndpointRxRequestClear function.
96:                  */
97:                  
98:                  PLIB_TEMPLATE void USBHS_EndpointRxRequestClear_Default
99:                  ( 
100:                     USBHS_MODULE_ID index, 
101:                     uint8_t endpoint 
102:                 )
103:                 {
104:                     /* This function clear the IN Request Packet bit. This function should be
105:                      * called in host mode only. */
106:                 
107:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
108:                     usbhs->EPCSR[endpoint].RXCSRL_HOSTbits.RXPKTRDY = 0;
9D007FF0  92420032   LBU V0, 50(S2)
9D007FF4  24420010   ADDIU V0, V0, 16
9D007FF8  00021100   SLL V0, V0, 4
9D007FFC  02028021   ADDU S0, S0, V0
9D008000  92020006   LBU V0, 6(S0)
9D008004  7C020004   INS V0, ZERO, 0, 1
9D008008  A2020006   SB V0, 6(S0)
109:                 }
110:                 
111:                 //******************************************************************************
112:                 /* Function :  USBHS_HostRxEndpointConfigure_Default
113:                 
114:                   Summary:
115:                     Implements Default variant of PLIB_USBHS_HostRxEndpointConfigure 
116:                 
117:                   Description:
118:                     This template implements the Default variant of the
119:                     PLIB_USBHS_HostRxEndpointConfigure function.
120:                 */
121:                 
122:                 PLIB_TEMPLATE void USBHS_HostRxEndpointConfigure_Default
123:                 ( 
124:                     USBHS_MODULE_ID index, 
125:                     uint8_t hostEndpoint, 
126:                     uint32_t speed, 
127:                     uint32_t pipeType, 
128:                     uint16_t endpointSize, 
129:                     uint16_t receiveFIFOAddress, 
130:                     uint8_t fifoSize, 
131:                     uint8_t  targetEndpoint, 
132:                     uint8_t  targetDevice, 
133:                     uint8_t  targetHub, 
134:                     uint8_t  targetHubPort, 
135:                     uint8_t nakInterval 
136:                 )
137:                 {
138:                     /* This function sets up the endpoint size, receive FIFO address, receive
139:                      * FIFO size, pipe type, speed, target endpoint, target device target hub
140:                      * and target hub port for host receive endpoint. This function is called by
141:                      * the driver pipe setup function. This function also clears up the receive
142:                      * fifo if there is any stale data, nak interval and then finally enables
143:                      * the interrupt */
144:                     
145:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
146:                     uint8_t indexBackup;
147:                 
148:                     /* Backup the index register and set it to the host endpoint that is to be
149:                      * configured. The indexedEPControlRegisters will now point to the endpoint
150:                      * to be configured */
151:                 
152:                     indexBackup = usbhs->INDEXbits.ENDPOINT;
9D004D44  8EE5000C   LW A1, 12(S7)
9D004D48  7CA51C00   EXT A1, A1, 16, 4
153:                     usbhs->INDEXbits.ENDPOINT = hostEndpoint;
9D004D4C  92E3000E   LBU V1, 14(S7)
9D004D50  8FA70010   LW A3, 16(SP)
9D004D54  7CE31804   INS V1, A3, 0, 4
9D004D58  A2E3000E   SB V1, 14(S7)
154:                 
155:                     /* Setup the endpoint size */
156:                     usbhs->INDEXED_EPCSR.RXMAXPbits.RXMAXP = endpointSize;
9D004D5C  96E30014   LHU V1, 20(S7)
9D004D60  7E035004   INS V1, S0, 0, 11
9D004D64  A6E30014   SH V1, 20(S7)
157:                 
158:                     /* Setup the receive fifo address */
159:                     usbhs->RXFIFOADDbits.RXFIFOAD = receiveFIFOAddress;
9D004D68  96E30066   LHU V1, 102(S7)
9D004D6C  7CC36004   INS V1, A2, 0, 13
9D004D70  A6E30066   SH V1, 102(S7)
160:                 
161:                     /* Setup the receive FIFO size */
162:                     usbhs->RXFIFOSZbits.RXFIFOSZ = fifoSize;
9D004D74  92E30063   LBU V1, 99(S7)
9D004D78  7C831804   INS V1, A0, 0, 4
9D004D7C  A2E30063   SB V1, 99(S7)
163:                 
164:                     /* Setup the pipe type, speed and target endpoint */
165:                      usbhs->INDEXED_EPCSR.RXTYPEbits.w = ((speed << 6) | (pipeType << 4) | (targetEndpoint));
9D004D80  8FA4005C   LW A0, 92(SP)
9D004D84  00041900   SLL V1, A0, 4
9D004D88  00431025   OR V0, V0, V1
9D004D8C  8FA60068   LW A2, 104(SP)
9D004D90  00061980   SLL V1, A2, 6
9D004D94  00431025   OR V0, V0, V1
9D004D98  304200FF   ANDI V0, V0, 255
9D004D9C  A2E2001C   SB V0, 28(S7)
166:                 
167:                     /* Setup device address */
168:                     usbhs->TADDR[hostEndpoint].RXFUNCADDRbits.RXFADDR = targetDevice;
9D004DA0  8FA70014   LW A3, 20(SP)
9D004DA4  24E20010   ADDIU V0, A3, 16
9D004DA8  000210C0   SLL V0, V0, 3
9D004DAC  02E21021   ADDU V0, S7, V0
9D004DB0  90430004   LBU V1, 4(V0)
9D004DB4  7EC33004   INS V1, S6, 0, 7
9D004DB8  A0430004   SB V1, 4(V0)
169:                 
170:                     /* Setup target Hub address */
171:                     usbhs->TADDR[hostEndpoint].RXHUBADDRbits.RXHUBADDR = targetHub;
9D004DBC  90430006   LBU V1, 6(V0)
9D004DC0  7EA33004   INS V1, S5, 0, 7
9D004DC4  A0430006   SB V1, 6(V0)
172:                 
173:                     /* Setup target Hub port */
174:                     usbhs->TADDR[hostEndpoint].RXHUBPORTbits.RXHUBPRT = targetHubPort;
9D004DC8  90430007   LBU V1, 7(V0)
9D004DCC  7E833004   INS V1, S4, 0, 7
9D004DD0  A0430007   SB V1, 7(V0)
175:                 
176:                     /* Clear the data toggle */
177:                     usbhs->INDEXED_EPCSR.RXCSRL_HOSTbits.CLRDT = 1;
9D004DD4  92E20016   LBU V0, 22(S7)
9D004DD8  24030001   ADDIU V1, ZERO, 1
9D004DDC  7C6239C4   INS V0, V1, 7, 1
9D004DE0  A2E20016   SB V0, 22(S7)
178:                 
179:                     /* If there is stale data in the fifo, then flush the fifo */
180:                     if(usbhs->INDEXED_EPCSR.RXCSRL_HOSTbits.RXPKTRDY == 1)
9D004DE4  8EE20014   LW V0, 20(S7)
9D004DE8  7C420400   EXT V0, V0, 16, 1
9D004DEC  10400004   BEQ V0, ZERO, 0x9D004E00
9D004DF0  00000000   NOP
181:                     {
182:                         /* Flush the fifo */
183:                         usbhs->INDEXED_EPCSR.RXCSRL_HOSTbits.FLUSH = 1; 
9D004DF4  92E20016   LBU V0, 22(S7)
9D004DF8  7C622104   INS V0, V1, 4, 1
9D004DFC  A2E20016   SB V0, 22(S7)
184:                     }
185:                 
186:                     /* For bulk pipes setup up the NAK interval and
187:                      * for interrupt pipes set up the transaction 
188:                      * interval */
189:                 
190:                     usbhs->INDEXED_EPCSR.RXINTERVALbits.RXINTERV = nakInterval;
9D004E00  A2F2001D   SB S2, 29(S7)
191:                 
192:                     /* Enable the RX endpoint interrupt */
193:                     usbhs->INTRRXEbits.w |= (1 << hostEndpoint);
9D004E04  96E20008   LHU V0, 8(S7)
9D004E08  24040001   ADDIU A0, ZERO, 1
9D004E0C  8FA60014   LW A2, 20(SP)
9D004E10  00C41804   SLLV V1, A0, A2
9D004E14  00621025   OR V0, V1, V0
9D004E18  3042FFFF   ANDI V0, V0, -1
9D004E1C  A6E20008   SH V0, 8(S7)
194:                 
195:                     /* Restore the index register before exiting */
196:                     usbhs->INDEXbits.ENDPOINT = indexBackup;
9D004E20  92E2000E   LBU V0, 14(S7)
9D004E24  7CA21804   INS V0, A1, 0, 4
9D004E28  A2E2000E   SB V0, 14(S7)
197:                 
198:                 }
199:                 
200:                 //******************************************************************************
201:                 /* Function :  USBHS_HostTxEndpointConfigure_Default
202:                 
203:                   Summary:
204:                     Implements Default variant of PLIB_USBHS_HostTxEndpointConfigure 
205:                 
206:                   Description:
207:                     This template implements the Default variant of the 
208:                     PLIB_USBHS_HostTxEndpointConfigure function.
209:                 */
210:                 
211:                 PLIB_TEMPLATE void USBHS_HostTxEndpointConfigure_Default
212:                 (
213:                     USBHS_MODULE_ID index , 
214:                     uint8_t hostEndpoint , 
215:                     uint32_t speed , 
216:                     uint32_t pipeType , 
217:                     uint16_t endpointSize , 
218:                     uint16_t fifoAddress , 
219:                     uint8_t  fifoSize , 
220:                     uint8_t  targetEndpoint , 
221:                     uint8_t  targetDevice , 
222:                     uint8_t  targetHub , 
223:                     uint8_t  targetHubPort,
224:                     uint8_t  nakInterval
225:                 )
226:                 {
227:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
228:                     uint8_t indexBackup;
229:                 
230:                     /* Backup the index register and set it to the
231:                      * host endpoint that is to be configured */
232:                 
233:                     indexBackup = usbhs->INDEXbits.ENDPOINT;
9D004E50  8EE5000C   LW A1, 12(S7)
9D004E54  7CA51C00   EXT A1, A1, 16, 4
234:                     
235:                     usbhs->INDEXbits.ENDPOINT = hostEndpoint;
9D004E58  92E3000E   LBU V1, 14(S7)
9D004E5C  8FA70010   LW A3, 16(SP)
9D004E60  7CE31804   INS V1, A3, 0, 4
9D004E64  A2E3000E   SB V1, 14(S7)
236:                 
237:                     /* Setup the endpoint size */
238:                     usbhs->INDEXED_EPCSR.TXMAXPbits.TXMAXP = endpointSize;
9D004E68  96E30010   LHU V1, 16(S7)
9D004E6C  7E035004   INS V1, S0, 0, 11
9D004E70  A6E30010   SH V1, 16(S7)
239:                 
240:                     /* Setup the transmit fifo address */
241:                     usbhs->TXFIFOADDbits.TXFIFOAD = fifoAddress;
9D004E74  96E30064   LHU V1, 100(S7)
9D004E78  7CC36004   INS V1, A2, 0, 13
9D004E7C  A6E30064   SH V1, 100(S7)
242:                 
243:                     /* Setup the transmit FIFO size */
244:                     usbhs->TXFIFOSZbits.TXFIFOSZ = fifoSize;
9D004E80  92E30062   LBU V1, 98(S7)
9D004E84  7C831804   INS V1, A0, 0, 4
9D004E88  A2E30062   SB V1, 98(S7)
245:                  
246:                     /* Setup the pipe type, speed and target endpoint */
247:                     usbhs->INDEXED_EPCSR.TXTYPEbits.w = (( speed << 6) | (pipeType << 4) | (targetEndpoint));
9D004E8C  8FA4005C   LW A0, 92(SP)
9D004E90  00041900   SLL V1, A0, 4
9D004E94  00431025   OR V0, V0, V1
9D004E98  8FA60068   LW A2, 104(SP)
9D004E9C  00061980   SLL V1, A2, 6
9D004EA0  00431025   OR V0, V0, V1
9D004EA4  304200FF   ANDI V0, V0, 255
9D004EA8  A2E2001A   SB V0, 26(S7)
248:                 
249:                     /* Setup device address */
250:                     usbhs->TADDR[hostEndpoint].TXFUNCADDRbits.TXFADDR = targetDevice;
9D004EAC  8FA70014   LW A3, 20(SP)
9D004EB0  24E20010   ADDIU V0, A3, 16
9D004EB4  000210C0   SLL V0, V0, 3
9D004EB8  02E21021   ADDU V0, S7, V0
9D004EBC  90430000   LBU V1, 0(V0)
9D004EC0  7EC33004   INS V1, S6, 0, 7
9D004EC4  A0430000   SB V1, 0(V0)
251:                 
252:                     /* Setup target Hub address */
253:                     usbhs->TADDR[hostEndpoint].TXHUBADDRbits.TXHUBADDR = targetHub;
9D004EC8  90430002   LBU V1, 2(V0)
9D004ECC  7EA33004   INS V1, S5, 0, 7
9D004ED0  A0430002   SB V1, 2(V0)
254:                 
255:                     /* Setup target Hub port */
256:                     usbhs->TADDR[hostEndpoint].TXHUBPORTbits.TXHUBPRT = targetHubPort;
9D004ED4  90430003   LBU V1, 3(V0)
9D004ED8  7E833004   INS V1, S4, 0, 7
9D004EDC  A0430003   SB V1, 3(V0)
257:                 
258:                     /* Clear the data toggle if it is set */
259:                     usbhs->INDEXED_EPCSR.TXCSRL_HOSTbits.CLRDT = 1;
9D004EE0  92E20012   LBU V0, 18(S7)
9D004EE4  24030001   ADDIU V1, ZERO, 1
9D004EE8  7C623184   INS V0, V1, 6, 1
9D004EEC  A2E20012   SB V0, 18(S7)
260:                 
261:                     /* If there is stale data in the fifo, then flush the fifo */
262:                     if(usbhs->INDEXED_EPCSR.TXCSRL_HOSTbits.FIFONE == 1)
9D004EF0  8EE20010   LW V0, 16(S7)
9D004EF4  7C420440   EXT V0, V0, 17, 1
9D004EF8  10400004   BEQ V0, ZERO, 0x9D004F0C
9D004EFC  00000000   NOP
263:                     {
264:                         /* Flush the fifo */
265:                         usbhs->INDEXED_EPCSR.TXCSRL_HOSTbits.FLUSH = 1;
9D004F00  92E20012   LBU V0, 18(S7)
9D004F04  7C6218C4   INS V0, V1, 3, 1
9D004F08  A2E20012   SB V0, 18(S7)
266:                     }
267:                 
268:                     /* For bulk pipes setup up the NAK interval and
269:                      * for interrupt pipes set up the transaction 
270:                      * interval */
271:                 
272:                     usbhs->INDEXED_EPCSR.TXINTERVALbits.TXINTERV = nakInterval;
9D004F0C  A2F2001B   SB S2, 27(S7)
273:                 
274:                     /* Enable the TX endpoint interrupt */
275:                     usbhs->INTRTXEbits.w |= (1 << hostEndpoint);
9D004F10  96E20006   LHU V0, 6(S7)
9D004F14  24040001   ADDIU A0, ZERO, 1
9D004F18  8FA60014   LW A2, 20(SP)
9D004F1C  00C41804   SLLV V1, A0, A2
9D004F20  00621025   OR V0, V1, V0
9D004F24  3042FFFF   ANDI V0, V0, -1
9D004F28  A6E20006   SH V0, 6(S7)
276:                 
277:                     /* Restore the index register before exiting */
278:                     usbhs->INDEXbits.ENDPOINT = indexBackup;
9D004F2C  92E2000E   LBU V0, 14(S7)
9D004F30  7CA21804   INS V0, A1, 0, 4
9D004F34  A2E2000E   SB V0, 14(S7)
279:                 
280:                 }
281:                 
282:                 //******************************************************************************
283:                 /* Function :  USBHS_HostTxEndpointDataToggleClear_Default
284:                 
285:                   Summary:
286:                     Implements Default variant of PLIB_USBHS_HostTxEndpointDataToggleClear 
287:                 
288:                   Description:
289:                     This template implements the Default variant of the 
290:                     PLIB_USBHS_HostTxEndpointDataToggleClear function.
291:                 */
292:                 
293:                 PLIB_TEMPLATE void USBHS_HostTxEndpointDataToggleClear_Default
294:                 ( 
295:                     USBHS_MODULE_ID index , 
296:                     uint8_t hostEndpoint 
297:                 )
298:                 {
299:                     /* Clear the Data toggle on the TX endpoint in host mode. */
300:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
301:                     usbhs->EPCSR[hostEndpoint].TXCSRL_HOSTbits.CLRDT = 1;
9D004F38  24C20010   ADDIU V0, A2, 16
9D004F3C  00021100   SLL V0, V0, 4
9D004F40  02E21021   ADDU V0, S7, V0
9D004F44  90430002   LBU V1, 2(V0)
9D004F48  7C833184   INS V1, A0, 6, 1
9D004F4C  A0430002   SB V1, 2(V0)
9D006ADC  26020010   ADDIU V0, S0, 16
9D006AE0  00021100   SLL V0, V0, 4
9D006AE4  02421021   ADDU V0, S2, V0
9D006AE8  90430002   LBU V1, 2(V0)
9D006AEC  24040001   ADDIU A0, ZERO, 1
9D006AF0  7C833184   INS V1, A0, 6, 1
9D006AF4  A0430002   SB V1, 2(V0)
302:                 }
303:                 
304:                 //******************************************************************************
305:                 /* Function :  USBHS_HostRxEndpointDataToggleClear_Default
306:                 
307:                   Summary:
308:                     Implements Default variant of PLIB_USBHS_HostRxEndpointDataToggleClear 
309:                 
310:                   Description:
311:                     This template implements the Default variant of the 
312:                     PLIB_USBHS_HostRxEndpointDataToggleClear function.
313:                 */
314:                 
315:                 PLIB_TEMPLATE void USBHS_HostRxEndpointDataToggleClear_Default
316:                 ( 
317:                     USBHS_MODULE_ID index , 
318:                     uint8_t hostEndpoint 
319:                 )
320:                 {
321:                     /* Clear the Data toggle on the RX endpoint in host mode. Writing
322:                      * a one to this bit will clear the data toggle. */
323:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
324:                     usbhs->EPCSR[hostEndpoint].RXCSRL_HOSTbits.CLRDT = 1;
9D004E2C  24C20010   ADDIU V0, A2, 16
9D004E30  00021100   SLL V0, V0, 4
9D004E34  02E21021   ADDU V0, S7, V0
9D004E38  90430006   LBU V1, 6(V0)
9D004E3C  7C8339C4   INS V1, A0, 7, 1
9D004E40  A0430006   SB V1, 6(V0)
9D004E44  0B4013E4   J 0x9D004F90
9D004E48  8FA40010   LW A0, 16(SP)
9D004E4C  97C60004   LHU A2, 4(S8)
9D006C40  26020010   ADDIU V0, S0, 16
9D006C44  00021100   SLL V0, V0, 4
9D006C48  02421021   ADDU V0, S2, V0
9D006C4C  90440006   LBU A0, 6(V0)
9D006C50  24030001   ADDIU V1, ZERO, 1
9D006C54  7C6439C4   INS A0, V1, 7, 1
9D006C58  A0440006   SB A0, 6(V0)
325:                 }
326:                 
327:                 //******************************************************************************
328:                 /* Function :  USBHS_DeviceTxEndpointConfigure_Default
329:                 
330:                   Summary:
331:                     Implements Default variant of PLIB_USBHS_DeviceTxEndpointConfigure 
332:                 
333:                   Description:
334:                     This template implements the Default variant of the 
335:                     PLIB_USBHS_DeviceTxEndpointConfigure function.
336:                 */
337:                 
338:                 PLIB_TEMPLATE void USBHS_DeviceTxEndpointConfigure_Default
339:                 (
340:                     USBHS_MODULE_ID index,
341:                     uint8_t endpoint,
342:                     uint16_t endpointSize,
343:                     uint16_t fifoAddress,
344:                     uint8_t fifoSize,
345:                     uint32_t transferType
346:                 )
347:                 {
348:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
349:                     
350:                     uint8_t indexBackup;
351:                 
352:                     /* This function configures the TX endpoint for device mode
353:                      * operation. Start by setting up the index register */
354:                 
355:                     indexBackup = usbhs->INDEXbits.ENDPOINT;
356:                         
357:                     usbhs->INDEXbits.ENDPOINT = endpoint;
358:                     
359:                     /* Configure the Endpoint size */
360:                     usbhs->INDEXED_EPCSR.TXMAXPbits.TXMAXP = endpointSize;
361:                     
362:                     /* Set up the fifo address */
363:                     usbhs->TXFIFOADDbits.TXFIFOAD = fifoAddress;
364:                     
365:                     /* Clear the data toggle */
366:                     usbhs->INDEXED_EPCSR.TXCSRL_DEVICEbits.CLRDT = 1;
367:                    
368:                     /* Set up the FIFO size */
369:                     usbhs->TXFIFOSZbits.TXFIFOSZ = fifoSize;
370:                     
371:                     if(1 == transferType)
372:                     {
373:                         /* Enable ISOC operation */
374:                         usbhs->INDEXED_EPCSR.TXCSRH_DEVICEbits.ISO = 1;
375:                     }
376:                     else
377:                     {
378:                         /* Enable handshake */
379:                         usbhs->INDEXED_EPCSR.TXCSRH_DEVICEbits.ISO = 0;
380:                        
381:                     }
382:                 
383:                     /* Restore the index register */
384:                     usbhs->INDEXbits.ENDPOINT = indexBackup;
385:                   
386:                     /* Enable the interrupt */
387:                     usbhs->INTRTXEbits.w |=  (1 << endpoint);
388:                     
389:                 }
390:                 
391:                 //******************************************************************************
392:                 /* Function :  USBHS_DeviceRxEndpointConfigure_Default
393:                 
394:                   Summary:
395:                     Implements Default variant of PLIB_USBHS_DeviceTxEndpointConfigure 
396:                 
397:                   Description:
398:                     This template implements the Default variant of the 
399:                     PLIB_USBHS_DeviceTxEndpointConfigure function.
400:                 */
401:                 
402:                 PLIB_TEMPLATE void USBHS_DeviceRxEndpointConfigure_Default
403:                 (
404:                     USBHS_MODULE_ID index,
405:                     uint8_t endpoint,
406:                     uint16_t endpointSize,
407:                     uint16_t fifoAddress,
408:                     uint8_t fifoSize,
409:                     uint32_t transferType
410:                 )
411:                 {
412:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
413:                     uint8_t indexBackup;
414:                 
415:                     /* This function configures the RX endpoint for device mode
416:                      * operation. Start by setting up the index register */
417:                 
418:                     indexBackup = usbhs->INDEXbits.ENDPOINT;
419:                      
420:                     usbhs->INDEXbits.ENDPOINT = endpoint;
421:                  
422:                     /* Configure the Endpoint size */
423:                     usbhs->INDEXED_EPCSR.RXMAXPbits.RXMAXP = endpointSize;
424:                 
425:                     /* Set up the fifo address */
426:                     usbhs->RXFIFOADDbits.RXFIFOAD = fifoAddress;
427:                   
428:                     /* Clear the data toggle */
429:                     usbhs->INDEXED_EPCSR.RXCSRL_DEVICEbits.CLRDT = 1;
430:                 
431:                     /* Set up the FIFO size */
432:                     usbhs->RXFIFOSZbits.RXFIFOSZ = fifoSize;
433:                     
434:                     if(transferType == 1)
435:                     {
436:                         /* For Isochronous endpoints, handshaking must
437:                          * be disabled*/
438:                 
439:                         usbhs->INDEXED_EPCSR.RXCSRH_DEVICEbits.ISO = 1;
440:                 
441:                     }
442:                     else if(transferType == 3)
443:                     {
444:                         /* For interrupt endpoints, handshaking must
445:                          * be enabled by NYET should be disabled */
446:                 
447:                         usbhs->INDEXED_EPCSR.RXCSRH_DEVICEbits.DISNYET = 1;
448:                         usbhs->INDEXED_EPCSR.RXCSRH_DEVICEbits.ISO = 0;
449:                     }
450:                     else
451:                     {
452:                         /* For bulk endpoints, handshaking must
453:                          * enabled and NYET should be enabled */
454:                 
455:                         usbhs->INDEXED_EPCSR.RXCSRH_DEVICEbits.DISNYET = 0;
456:                         usbhs->INDEXED_EPCSR.RXCSRH_DEVICEbits.ISO = 0;
457:                     }
458:                 
459:                     /* Restore the index register */
460:                     usbhs->INDEXbits.ENDPOINT = indexBackup;
461:                    
462:                     /* Enable the endpoint interrupt */
463:                     usbhs->INTRRXEbits.w |= (1 << endpoint);
464:                     
465:                 }
466:                 
467:                 //******************************************************************************
468:                 /* Function :  USBHS_DeviceRxEndpointStallEnable_Default
469:                 
470:                   Summary:
471:                     Implements Default variant of PLIB_USBHS_DeviceTxEndpointStallEnable 
472:                 
473:                   Description:
474:                     This template implements the Default variant of the 
475:                     PLIB_USBHS_DeviceTxEndpointStallEnable function.
476:                 */
477:                 
478:                 PLIB_TEMPLATE void USBHS_DeviceRxEndpointStallEnable_Default
479:                 (
480:                     USBHS_MODULE_ID index, 
481:                     uint8_t endpoint
482:                 )
483:                 {
484:                     /* Stalls the RX direction on specified endpoint. */
485:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
486:                     usbhs->EPCSR[endpoint].RXCSRL_DEVICEbits.SENDSTALL = 1;
487:                 }
488:                 
489:                 //******************************************************************************
490:                 /* Function :  USBHS_DeviceTxEndpointStallEnable_Default
491:                 
492:                   Summary:
493:                     Implements Default variant of PLIB_USBHS_DeviceTxEndpointStallEnable 
494:                 
495:                   Description:
496:                     This template implements the Default variant of the 
497:                     PLIB_USBHS_DeviceTxEndpointStallEnable function.
498:                 */
499:                 
500:                 PLIB_TEMPLATE void USBHS_DeviceTxEndpointStallEnable_Default
501:                 (
502:                     USBHS_MODULE_ID index, 
503:                     uint8_t endpoint
504:                 )
505:                 {
506:                     /* Stalls the TX direction on specified endpoint. */
507:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
508:                     usbhs->EPCSR[endpoint].TXCSRL_DEVICEbits.SENDSTALL = 1;
509:                 }
510:                 
511:                 //******************************************************************************
512:                 /* Function :  USBHS_DeviceRxEndpointStallDisable_Default
513:                 
514:                   Summary:
515:                     Implements Default variant of PLIB_USBHS_DeviceTxEndpointStallDisable 
516:                 
517:                   Description:
518:                     This template implements the Default variant of the 
519:                     PLIB_USBHS_DeviceTxEndpointStallDisable function.
520:                 */
521:                 
522:                 PLIB_TEMPLATE void USBHS_DeviceRxEndpointStallDisable_Default
523:                 (
524:                     USBHS_MODULE_ID index, 
525:                     uint8_t endpoint
526:                 )
527:                 {
528:                     /* Disable the stall and reset the data toggle */
529:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
530:                     usbhs->EPCSR[endpoint].RXCSRL_DEVICEbits.w &= (~(USBHS_EP_DEVICE_RX_SENT_STALL|USBHS_EP_DEVICE_RX_SEND_STALL));
531:                     usbhs->EPCSR[endpoint].RXCSRL_DEVICEbits.CLRDT = 1;
532:                 }
533:                 
534:                 //******************************************************************************
535:                 /* Function :  USBHS_DeviceTxEndpointStallDisable_Default
536:                 
537:                   Summary:
538:                     Implements Default variant of PLIB_USBHS_DeviceTxEndpointStallDisable 
539:                 
540:                   Description:
541:                     This template implements the Default variant of the 
542:                     PLIB_USBHS_DeviceTxEndpointStallDisable function.
543:                 */
544:                 
545:                 PLIB_TEMPLATE void USBHS_DeviceTxEndpointStallDisable_Default
546:                 (
547:                     USBHS_MODULE_ID index, 
548:                     uint8_t endpoint
549:                 )
550:                 {
551:                     /* Disable the stall and reset the data toggle */
552:                          
553:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
554:                     usbhs->EPCSR[endpoint].TXCSRL_DEVICEbits.w &= (~(USBHS_EP_DEVICE_TX_SENT_STALL|USBHS_EP_DEVICE_TX_SEND_STALL));
555:                     usbhs->EPCSR[endpoint].TXCSRL_DEVICEbits.CLRDT = 1;
556:                 }
557:                 
558:                 //******************************************************************************
559:                 /* Function :  USBHS_DeviceTxEndpointPacketReady_Default
560:                 
561:                   Summary:
562:                     Implements Default variant of PLIB_USBHS_DeviceTxEndpointPacketReady 
563:                 
564:                   Description:
565:                     This template implements the Default variant of the 
566:                     PLIB_USBHS_DeviceTxEndpointPacketReady function.
567:                 */
568:                 
569:                 PLIB_TEMPLATE void USBHS_DeviceTxEndpointPacketReady_Default
570:                 (
571:                     USBHS_MODULE_ID index, 
572:                     uint8_t endpoint
573:                 )
574:                 {
575:                     /* Set the TX Packet Ready bit. */
576:                     
577:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
578:                     usbhs->EPCSR[endpoint].TXCSRL_DEVICEbits.TXPKTRDY = 1;
9D00C154  26D60010   ADDIU S6, S6, 16
9D00C158  0016B100   SLL S6, S6, 4
9D00C15C  02B6B021   ADDU S6, S5, S6
9D00C160  92C20002   LBU V0, 2(S6)
9D00C164  7EE20004   INS V0, S7, 0, 1
9D00C168  A2C20002   SB V0, 2(S6)
9D00C16C  0B4030A0   J 0x9D00C280
9D00C170  A220000C   SB ZERO, 12(S1)
579:                 }
580:                 
581:                 
582:                 //******************************************************************************
583:                 /* Function :  USBHS_ExistsEndpointOperations_Default
584:                 
585:                   Summary:
586:                     Implements Default variant of PLIB_USBHS_ExistsEndpointOperations
587:                 
588:                   Description:
589:                     This template implements the Default variant of the 
590:                     PLIB_USBHS_ExistsEndpointOperations function.
591:                 */
592:                 
593:                 #define PLIB_USBHS_ExistsEndpointOperations PLIB_USBHS_ExistsEndpointOperations
594:                 PLIB_TEMPLATE bool USBHS_ExistsEndpointOperations_Default( USBHS_MODULE_ID index )
595:                 {
596:                     return true;
597:                 }
598:                 
599:                 
600:                 #endif /*_USBHS_ENDPOINTOPERATIONS_DEFAULT_H*/
601:                 
602:                 /******************************************************************************
603:                  End of File
604:                 */
605:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_endpointfifo_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_EndpointFIFO_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EndpointFIFO
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_EndpointFIFOLoad
16:                          PLIB_USBHS_EndpointFIFOUnload
17:                          PLIB_USBHS_Endpoint0SetupPacketLoad
18:                          PLIB_USBHS_ExistsEndpointFIFO
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USBHS_ENDPOINTFIFO_DEFAULT_H
49:                  #define _USBHS_ENDPOINTFIFO_DEFAULT_H
50:                  
51:                  #include "usbhs_registers.h"
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  USBHS_EndpointFIFOLoad_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_USBHS_EndpointFIFOLoad 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the
62:                      PLIB_USBHS_EndpointFIFOLoad function.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void USBHS_EndpointFIFOLoad_Default
66:                  ( 
67:                      USBHS_MODULE_ID index , 
68:                      uint8_t endpoint , 
69:                      void * source , 
70:                      size_t nBytes 
71:                  )
72:                  {
73:                      /* This function loads the FIFO and then sends the packet */
74:                      
75:                      volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
76:                      volatile uint8_t * endpointFIFO;
77:                      size_t i;
78:                  
79:                      /* Obtain pointers to the endpoint specific FIFO and control registers */
80:                      endpointFIFO = (uint8_t *)(&usbhs->FIFO[endpoint]);
9D00E85C  26640008   ADDIU A0, S3, 8
9D00E860  00042080   SLL A0, A0, 2
81:                      
82:                      /* Load the endpoint FIFO with the user data */
83:                      for(i = 0; i < nBytes; i ++)
9D00E80C  12200041   BEQ S1, ZERO, _DRV_USBHS_HOST_IRPTransmitFIFOLoad::PLIB_USBHS_EndpointFIFOLoad
9D00E810  00802821   ADDU A1, A0, ZERO
9D00E814  02801021   ADDU V0, S4, ZERO
9D00E818  02913021   ADDU A2, S4, S1
9D00E828  5446FFFD   BNEL V0, A2, 0x9D00E820
9D00E82C  90430000   LBU V1, 0(V0)
9D00E830  0B403A45   J _DRV_USBHS_HOST_IRPTransmitFIFOLoad::PLIB_USBHS_EndpointFIFOLoad
9D00E834  00000000   NOP
9D00E864  12200031   BEQ S1, ZERO, _DRV_USBHS_HOST_IRPTransmitFIFOLoad::PLIB_USBHS_EndpointFIFOLoad
9D00E868  02442021   ADDU A0, S2, A0
9D00E86C  02801021   ADDU V0, S4, ZERO
9D00E870  02918821   ADDU S1, S4, S1
9D00E880  5451FFFD   BNEL V0, S1, 0x9D00E878
9D00E884  90430000   LBU V1, 0(V0)
84:                      {
85:                          *endpointFIFO = *((uint8_t *)(source) + i);
9D00E81C  90430000   LBU V1, 0(V0)
9D00E820  A0A30020   SB V1, 32(A1)
9D00E824  24420001   ADDIU V0, V0, 1
9D00E874  90430000   LBU V1, 0(V0)
9D00E878  A0830000   SB V1, 0(A0)
9D00E87C  24420001   ADDIU V0, V0, 1
86:                      }
87:                  
88:                      /* Set the TXPKTRDY bit. The position of this bit is different for endpoint
89:                       * 0 and other endpoints. */
90:                      if(endpoint == 0)
91:                      {
92:                          usbhs->EPCSR[0].CSR0L_DEVICEbits.TXPKTRDY = 1;
9D00E914  92420102   LBU V0, 258(S2)
9D00E918  24030001   ADDIU V1, ZERO, 1
9D00E91C  7C620844   INS V0, V1, 1, 1
9D00E920  A2420102   SB V0, 258(S2)
93:                      }
94:                      else
95:                      {
96:                          usbhs->EPCSR[endpoint].TXCSRL_DEVICEbits.TXPKTRDY = 1;
9D00E888  0B403A4C   J 0x9D00E930
9D00E88C  26730010   ADDIU S3, S3, 16
9D00E92C  26730010   ADDIU S3, S3, 16
9D00E930  00139900   SLL S3, S3, 4
9D00E934  02539021   ADDU S2, S2, S3
9D00E938  92420002   LBU V0, 2(S2)
9D00E93C  24030001   ADDIU V1, ZERO, 1
9D00E940  7C620004   INS V0, V1, 0, 1
9D00E944  A2420002   SB V0, 2(S2)
97:                      }
98:                  }
99:                  
100:                 //******************************************************************************
101:                 /* Function :  USBHS_DeviceEPFIFOLoad_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_USBHS_DeviceEPFIFOLoad 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the
108:                     PLIB_USBHS_DeviceEPFIFOLoad function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE void USBHS_DeviceEPFIFOLoad_Default
112:                 ( 
113:                     USBHS_MODULE_ID index , 
114:                     uint8_t endpoint, 
115:                     void * source, 
116:                     size_t nBytes 
117:                 )
118:                 {
119:                     /* This function loads the FIFO */ 
120:                 
121:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
122:                     volatile uint8_t * endpointFIFO;
123:                     size_t i;
124:                 
125:                     /* Obtain pointers to the endpoint specific FIFO and control registers */
126:                     endpointFIFO = (uint8_t *)(&usbhs->FIFO[endpoint]);
127:                     
128:                     /* Load the endpoint FIFO with the user data */
129:                     for(i = 0; i < nBytes; i ++)
130:                     {
131:                         *endpointFIFO = *((uint8_t *)(source) + i);
132:                     }
133:                 }
134:                 
135:                 //******************************************************************************
136:                 /* Function :  USBHS_EndpointFIFOUnload_Default
137:                 
138:                   Summary:
139:                     Implements Default variant of PLIB_USBHS_EndpointFIFOUnload 
140:                 
141:                   Description:
142:                     This template implements the Default variant of the
143:                     PLIB_USBHS_EndpointFIFOUnload function.
144:                 */
145:                 
146:                 PLIB_TEMPLATE int USBHS_EndpointFIFOUnload_Default
147:                 ( 
148:                     USBHS_MODULE_ID index, 
149:                     uint8_t endpoint, 
150:                     void * dest
151:                 )
152:                 {
153:                     /* This function unloads the FIFO and then clears the RX packet ready bit */
154:                 
155:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
156:                     volatile uint8_t * fifo, * data;
157:                     volatile unsigned int count;
158:                     size_t i;
159:                 
160:                     /* Get the pointer to endpoint specific FIFO and control registers. The
161:                      * pointer are obtained by adding an offset to the EP0 FIFO and EP0 Control
162:                      * Register addresses. The offset is based on the input endpoint. */
163:                 
164:                     fifo = (uint8_t *)(&usbhs->FIFO[endpoint]);
9D00D2C4  24840020   ADDIU A0, A0, 32
9D00D328  26850008   ADDIU A1, S4, 8
9D00D32C  00052880   SLL A1, A1, 2
9D00D330  02452821   ADDU A1, S2, A1
165:                     
166:                     /* This is the size of the data contained in the FIFO */
167:                     count = usbhs->EPCSR[endpoint].RXCOUNTbits.RXCNT;
9D00D2C8  8E420108   LW V0, 264(S2)
9D00D2CC  30423FFF   ANDI V0, V0, 16383
9D00D2D0  AFA20014   SW V0, 20(SP)
9D00D334  00141100   SLL V0, S4, 4
9D00D338  02421021   ADDU V0, S2, V0
9D00D33C  8C420108   LW V0, 264(V0)
9D00D340  30423FFF   ANDI V0, V0, 16383
9D00D344  AFA20010   SW V0, 16(SP)
168:                     data = (uint8_t *) dest;
169:                 
170:                     /* fifo now has the FIFO address for this endpoint.  Now unload the FIFO
171:                      * into data */
172:                 
173:                     for(i = 0; i < count; i ++)
9D00D2D4  8FA20014   LW V0, 20(SP)
9D00D2D8  1040004F   BEQ V0, ZERO, _DRV_USBHS_HOST_IRPReceiveFIFOUnload::PLIB_USBHS_EndpointFIFOUnload
9D00D2DC  00000000   NOP
9D00D2E0  00001021   ADDU V0, ZERO, ZERO
9D00D2E4  02021821   ADDU V1, S0, V0
9D00D2F4  24420001   ADDIU V0, V0, 1
9D00D2F8  8FA30014   LW V1, 20(SP)
9D00D2FC  0043182B   SLTU V1, V0, V1
9D00D300  1460FFF9   BNE V1, ZERO, 0x9D00D2E8
9D00D304  02021821   ADDU V1, S0, V0
9D00D308  0B403506   J _DRV_USBHS_HOST_IRPReceiveFIFOUnload::PLIB_USBHS_EndpointFIFOUnload
9D00D30C  00000000   NOP
9D00D348  8FA20010   LW V0, 16(SP)
9D00D34C  1040003B   BEQ V0, ZERO, _DRV_USBHS_HOST_IRPReceiveFIFOUnload::PLIB_USBHS_EndpointFIFOUnload
9D00D350  00001021   ADDU V0, ZERO, ZERO
9D00D354  02021821   ADDU V1, S0, V0
9D00D364  24420001   ADDIU V0, V0, 1
9D00D368  8FA30010   LW V1, 16(SP)
9D00D36C  0043182B   SLTU V1, V0, V1
9D00D370  1460FFF9   BNE V1, ZERO, 0x9D00D358
9D00D374  02021821   ADDU V1, S0, V0
174:                     {
175:                         data[i] = *(fifo + (i & 3));
9D00D2E8  30460003   ANDI A2, V0, 3
9D00D2EC  7C86318A   LBUX A2, A2(A0)
9D00D2F0  A0660000   SB A2, 0(V1)
9D00D358  30440003   ANDI A0, V0, 3
9D00D35C  7CA4218A   LBUX A0, A0(A1)
9D00D360  A0640000   SB A0, 0(V1)
176:                     }
177:                 
178:                     /* The offset of the RX endpoint control register is different for endpoint
179:                      * 0 and other endpoints. Clear the RXPKDTRY bits after unloading the FIFO */
180:                 
181:                     if(endpoint == 0)
182:                     {
183:                         usbhs->EPCSR[0].CSR0L_DEVICEbits.RXPKTRDY = 0;
9D00D418  92420102   LBU V0, 258(S2)
9D00D41C  7C020004   INS V0, ZERO, 0, 1
9D00D420  A2420102   SB V0, 258(S2)
184:                     }
185:                     else
186:                     {
187:                         usbhs->EPCSR[endpoint].RXCSRL_DEVICEbits.RXPKTRDY = 0;
9D00D378  0B403510   J 0x9D00D440
9D00D37C  26940010   ADDIU S4, S4, 16
9D00D43C  26940010   ADDIU S4, S4, 16
9D00D440  0014A100   SLL S4, S4, 4
9D00D444  02549021   ADDU S2, S2, S4
9D00D448  92420006   LBU V0, 6(S2)
9D00D44C  7C020004   INS V0, ZERO, 0, 1
9D00D450  A2420006   SB V0, 6(S2)
188:                     }
189:                        
190:                     return(count);
9D00D424  8FA20014   LW V0, 20(SP)
9D00D454  8FA20010   LW V0, 16(SP)
191:                 }
192:                 
193:                 //******************************************************************************
194:                 /* Function :  USBHS_DeviceEPFIFOUnload_Default
195:                 
196:                   Summary:
197:                     Implements Default variant of PLIB_USBHS_DeviceEPFIFOUnload 
198:                 
199:                   Description:
200:                     This template implements the Default variant of the
201:                     PLIB_USBHS_DeviceEPFIFOUnload function.
202:                 */
203:                 
204:                 PLIB_TEMPLATE int USBHS_DeviceEPFIFOUnload_Default
205:                 ( 
206:                     USBHS_MODULE_ID index, 
207:                     uint8_t endpoint, 
208:                     void * dest
209:                 )
210:                 {
211:                     /* This function unloads the FIFO and then clears the RX packet ready bit */
212:                 
213:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
214:                     volatile uint8_t * fifo, * data;
215:                     volatile unsigned int count;
216:                     size_t i;
217:                 
218:                     /* Get the pointer to endpoint specific FIFO and control registers. The
219:                      * pointer are obtained by adding an offset to the EP0 FIFO and EP0 Control
220:                      * Register addresses. The offset is based on the input endpoint. */
221:                 
222:                     fifo = (uint8_t *)(&usbhs->FIFO[endpoint]);
223:                     
224:                     /* This is the size of the data contained in the FIFO */
225:                     count = usbhs->EPCSR[endpoint].RXCOUNTbits.RXCNT;
226:                     data = (uint8_t *) dest;
227:                 
228:                     /* fifo now has the FIFO address for this endpoint.  Now unload the FIFO
229:                      * into data */
230:                 
231:                     for(i = 0; i < count; i ++)
232:                     {
233:                         data[i] = *(fifo + (i & 3));
234:                     }
235:                     
236:                     return(count);
237:                 }
238:                 
239:                 //******************************************************************************
240:                 /* Function :  USBHS_Endpoint0SetupPacketLoad_Default
241:                 
242:                   Summary:
243:                     Implements Default variant of PLIB_USBHS_Endpoint0SetupPacketLoad 
244:                 
245:                   Description:
246:                     This template implements the Default variant of the
247:                     PLIB_USBHS_Endpoint0SetupPacketLoad function.
248:                 */
249:                 
250:                 PLIB_TEMPLATE void USBHS_Endpoint0SetupPacketLoad_Default
251:                 ( 
252:                     USBHS_MODULE_ID index, 
253:                     void * setupPacket, 
254:                     uint8_t deviceAddress, 
255:                     uint8_t hubAddress, 
256:                     uint8_t hubPortAddress, 
257:                     uint32_t speed 
258:                 )
259:                 {
260:                     volatile uint8_t * endpointFIFO;
261:                     volatile uint8_t * data;
262:                     unsigned int i;
263:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
9D015488  00803021   ADDU A2, A0, ZERO
264:                     
265:                     data = (uint8_t *)setupPacket;
266:                 
267:                     /* Pointer to EP0 FIFO */
268:                     endpointFIFO = (uint8_t *)(&usbhs->FIFO[0]);
269:                 
270:                     /* Load the endpoint FIFO with the setup packet */
271:                     for(i = 0; i < 8; i++)
9D01548C  00001021   ADDU V0, ZERO, ZERO
9D015490  24050008   ADDIU A1, ZERO, 8
9D01549C  24420001   ADDIU V0, V0, 1
9D0154A0  1445FFFC   BNE V0, A1, 0x9D015494
9D0154A4  00000000   NOP
272:                     {
273:                         *endpointFIFO = *(data + i);
9D015494  7CE2198A   LBUX V1, V0(A3)
9D015498  A0C30020   SB V1, 32(A2)
274:                     }
275:                 
276:                     /* Set up the target device address, hub address and the hub port address
277:                      * and the target device speed. */
278:                     usbhs->TADDR[0].TXFUNCADDRbits.TXFADDR = deviceAddress;
9D0154A8  90820080   LBU V0, 128(A0)
9D0154AC  7D623004   INS V0, T3, 0, 7
9D0154B0  A0820080   SB V0, 128(A0)
279:                     usbhs->TADDR[0].TXHUBADDRbits.TXHUBADDR = hubAddress;
9D0154B4  90820082   LBU V0, 130(A0)
9D0154B8  7D423004   INS V0, T2, 0, 7
9D0154BC  A0820082   SB V0, 130(A0)
280:                     usbhs->TADDR[0].TXHUBPORTbits.TXHUBPRT = hubPortAddress;
9D0154C0  90820083   LBU V0, 131(A0)
9D0154C4  7D223004   INS V0, T1, 0, 7
9D0154C8  A0820083   SB V0, 131(A0)
281:                     usbhs->EPCSR[0].TYPE0bits.SPEED = speed;
9D0154CC  9082010A   LBU V0, 266(A0)
9D0154D0  7D023984   INS V0, T0, 6, 2
9D0154D4  A082010A   SB V0, 266(A0)
282:                     
283:                     /* Schedule the packet for transfer. The TXPKTRDY and SETUPKT bits should
284:                      * be set together. */
285:                     usbhs->EPCSR[0].CSR0L_HOSTbits.w |= (USBHS_HOST_EP0_TXPKTRDY_SET|USBHS_HOST_EP0_SETUPKT_SET);
9D0154D8  90820102   LBU V0, 258(A0)
286:                 }
287:                 
288:                 //******************************************************************************
289:                 /* Function :  USBHS_Endpoint0SetupPacketUnload_Default
290:                 
291:                   Summary:
292:                     Implements Default variant of PLIB_USBHS_Endpoint0SetupPacketUnload 
293:                 
294:                   Description:
295:                     This template implements the Default variant of the
296:                     PLIB_USBHS_Endpoint0SetupPacketUnload function.
297:                 */
298:                 
299:                 PLIB_TEMPLATE void USBHS_Endpoint0SetupPacketUnload_Default
300:                 ( 
301:                     USBHS_MODULE_ID index, 
302:                     void * dest 
303:                 )
304:                 {
305:                     /* Unloads a setup packet from endpoint 0 fifo. Get the endpoint 0 FIFO and
306:                      * control register addresses. */
307:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
308:                     uint8_t * data = (uint8_t *)dest;
309:                 
310:                     /* Read the 8 byte packet as 2 4-byte words */
311:                     *((uint32_t *)(data)) = usbhs->FIFO[0];
312:                     *((uint32_t *)(data + 4)) = usbhs->FIFO[0];
313:                 
314:                     /* Let the hardware know that the packet has been unloaded */
315:                     usbhs->EPCSR[0].CSR0L_DEVICEbits.SVCRPR = 1;
316:                 }
317:                 
318:                 //******************************************************************************
319:                 /* Function :  USBHS_Endpoint0FIFOFlush_Default
320:                 
321:                   Summary:
322:                     Implements Default variant of PLIB_USBHS_Endpoint0FIFOFlush 
323:                 
324:                   Description:
325:                     This template implements the Default variant of the
326:                     PLIB_USBHS_Endpoint0FIFOFlush function.
327:                 */
328:                 
329:                 PLIB_TEMPLATE void USBHS_Endpoint0FIFOFlush_Default( USBHS_MODULE_ID index )
330:                 {
331:                     /* This function flushes the EP0 FIFO. The FIFO can be flushed only if it
332:                      * contains data. Hence the check for TXPKTRDY or RXPKTRDY */
333:                 
334:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
335:                  
336:                     /* Check if transmit packet ready or if the receive packet ready is set. If
337:                      * so then clear the flush */
338:                     
339:                     if((usbhs->EPCSR[0].CSR0L_DEVICEbits.TXPKTRDY) || (usbhs->EPCSR[0].CSR0L_DEVICEbits.RXPKTRDY))
9D008270  8E420100   LW V0, 256(S2)
9D008274  7C420440   EXT V0, V0, 17, 1
9D008278  14400005   BNE V0, ZERO, 0x9D008290
9D00827C  00000000   NOP
9D008280  8E420100   LW V0, 256(S2)
9D008284  7C420400   EXT V0, V0, 16, 1
9D008288  504000AC   BEQL V0, ZERO, 0x9D00853C
9D00828C  8E220018   LW V0, 24(S1)
340:                     {
341:                         usbhs->EPCSR[0].CSR0H_DEVICEbits.FLSHFIFO = 1;
9D008290  92420103   LBU V0, 259(S2)
9D008294  24030001   ADDIU V1, ZERO, 1
9D008298  7C620004   INS V0, V1, 0, 1
9D00829C  A2420103   SB V0, 259(S2)
342:                     }
343:                 }
344:                 
345:                 //******************************************************************************
346:                 /* Function :  USBHS_EndpointTxFIFOFlush_Default
347:                 
348:                   Summary:
349:                     Implements Default variant of PLIB_USBHS_EndpointTxFIFOFlush 
350:                 
351:                   Description:
352:                     This template implements the Default variant of the
353:                     PLIB_USBHS_EndpointTxFIFOFlush function.
354:                 */
355:                 
356:                 PLIB_TEMPLATE void USBHS_EndpointTxFIFOFlush_Default
357:                 ( 
358:                     USBHS_MODULE_ID index, 
359:                     uint8_t endpoint 
360:                 )
361:                 {
362:                     /* This function will clear the FIFO for a non-zero endpoint */
363:                    
364:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
365:                     if(usbhs->EPCSR[endpoint].TXCSRL_DEVICEbits.TXPKTRDY)
9D006A7C  26020010   ADDIU V0, S0, 16
9D006A80  00021100   SLL V0, V0, 4
9D006A84  7E42100A   LWX V0, V0(S2)
9D006A88  7C420400   EXT V0, V0, 16, 1
9D006A8C  504000E4   BEQL V0, ZERO, 0x9D006E20
9D006A90  8E620024   LW V0, 36(S3)
9D008014  92420032   LBU V0, 50(S2)
9D008018  24430010   ADDIU V1, V0, 16
9D00801C  00031900   SLL V1, V1, 4
9D008020  7E03180A   LWX V1, V1(S0)
9D008024  7C630400   EXT V1, V1, 16, 1
9D008028  5060000A   BEQL V1, ZERO, 0x9D008054
9D00802C  00021100   SLL V0, V0, 4
366:                     {
367:                         usbhs->EPCSR[endpoint].TXCSRL_DEVICEbits.FLUSH = 1;
9D006A94  26020010   ADDIU V0, S0, 16
9D006A98  00021100   SLL V0, V0, 4
9D006A9C  02421021   ADDU V0, S2, V0
9D006AA0  90430002   LBU V1, 2(V0)
9D006AA4  24040001   ADDIU A0, ZERO, 1
9D006AA8  7C8318C4   INS V1, A0, 3, 1
9D006AAC  A0430002   SB V1, 2(V0)
9D008030  24420010   ADDIU V0, V0, 16
9D008034  00021100   SLL V0, V0, 4
9D008038  02021021   ADDU V0, S0, V0
9D00803C  90430002   LBU V1, 2(V0)
9D008040  24040001   ADDIU A0, ZERO, 1
9D008044  7C8318C4   INS V1, A0, 3, 1
9D008048  A0430002   SB V1, 2(V0)
9D00804C  92420032   LBU V0, 50(S2)
9D008050  00021100   SLL V0, V0, 4
9D008054  02028021   ADDU S0, S0, V0
368:                     }
369:                 }
370:                 
371:                 //******************************************************************************
372:                 /* Function :  USBHS_EndpointRxFIFOFlush_Default
373:                 
374:                   Summary:
375:                     Implements Default variant of PLIB_USBHS_EndpointRxFIFOFlush 
376:                 
377:                   Description:
378:                     This template implements the Default variant of the
379:                     PLIB_USBHS_EndpointRxFIFOFlush function.
380:                 */
381:                 
382:                 PLIB_TEMPLATE void USBHS_EndpointRxFIFOFlush_Default
383:                 ( 
384:                     USBHS_MODULE_ID index, 
385:                     uint8_t endpoint 
386:                 )
387:                 {
388:                     /* Get the pointer to the endpoint Receive Control and Status register */
389:                     volatile usbhs_registers_t * usbhs = (usbhs_registers_t *)(index);
390:                     
391:                     if(usbhs->EPCSR[endpoint].RXCSRL_DEVICEbits.RXPKTRDY == 1)
9D006BDC  26020010   ADDIU V0, S0, 16
9D006BE0  00021100   SLL V0, V0, 4
9D006BE4  02421021   ADDU V0, S2, V0
9D006BE8  8C420004   LW V0, 4(V0)
9D006BEC  7C420400   EXT V0, V0, 16, 1
9D006BF0  50400092   BEQL V0, ZERO, 0x9D006E3C
9D006BF4  8E620024   LW V0, 36(S3)
9D006C5C  8C420004   LW V0, 4(V0)
9D006C60  7C420400   EXT V0, V0, 16, 1
9D006C64  54430075   BNEL V0, V1, 0x9D006E3C
9D006C68  8E620024   LW V0, 36(S3)
9D006CB0  26020010   ADDIU V0, S0, 16
9D006CB4  00021100   SLL V0, V0, 4
9D006CB8  02421021   ADDU V0, S2, V0
9D006CBC  8C420004   LW V0, 4(V0)
9D006CC0  7C420400   EXT V0, V0, 16, 1
9D006CC4  5040005D   BEQL V0, ZERO, 0x9D006E3C
9D006CC8  8E620024   LW V0, 36(S3)
9D006D0C  26020010   ADDIU V0, S0, 16
9D006D10  00021100   SLL V0, V0, 4
9D006D14  02421021   ADDU V0, S2, V0
9D006D18  8C420004   LW V0, 4(V0)
9D006D1C  7C420400   EXT V0, V0, 16, 1
9D006D20  50400046   BEQL V0, ZERO, 0x9D006E3C
9D006D24  8E620024   LW V0, 36(S3)
9D007F9C  92420032   LBU V0, 50(S2)
9D007FA0  24430010   ADDIU V1, V0, 16
9D007FA4  00031900   SLL V1, V1, 4
9D007FA8  02031821   ADDU V1, S0, V1
9D007FAC  8C630004   LW V1, 4(V1)
9D007FB0  7C630400   EXT V1, V1, 16, 1
9D007FB4  5060000A   BEQL V1, ZERO, 0x9D007FE0
9D007FB8  00021100   SLL V0, V0, 4
392:                     {
393:                         usbhs->EPCSR[endpoint].RXCSRL_DEVICEbits.FLUSH = 1;
9D006BF8  26020010   ADDIU V0, S0, 16
9D006BFC  00021100   SLL V0, V0, 4
9D006C00  02421021   ADDU V0, S2, V0
9D006C04  90430006   LBU V1, 6(V0)
9D006C08  24040001   ADDIU A0, ZERO, 1
9D006C0C  7C832104   INS V1, A0, 4, 1
9D006C10  A0430006   SB V1, 6(V0)
9D006C6C  26020010   ADDIU V0, S0, 16
9D006C70  00021100   SLL V0, V0, 4
9D006C74  02421021   ADDU V0, S2, V0
9D006C78  90430006   LBU V1, 6(V0)
9D006C7C  24040001   ADDIU A0, ZERO, 1
9D006C80  7C832104   INS V1, A0, 4, 1
9D006C84  A0430006   SB V1, 6(V0)
9D006CCC  26020010   ADDIU V0, S0, 16
9D006CD0  00021100   SLL V0, V0, 4
9D006CD4  02421021   ADDU V0, S2, V0
9D006CD8  90430006   LBU V1, 6(V0)
9D006CDC  24040001   ADDIU A0, ZERO, 1
9D006CE0  7C832104   INS V1, A0, 4, 1
9D006CE4  A0430006   SB V1, 6(V0)
9D006D28  26020010   ADDIU V0, S0, 16
9D006D2C  00021100   SLL V0, V0, 4
9D006D30  02421021   ADDU V0, S2, V0
9D006D34  90430006   LBU V1, 6(V0)
9D006D38  24040001   ADDIU A0, ZERO, 1
9D006D3C  7C832104   INS V1, A0, 4, 1
9D006D40  A0430006   SB V1, 6(V0)
9D007FBC  24420010   ADDIU V0, V0, 16
9D007FC0  00021100   SLL V0, V0, 4
9D007FC4  02021021   ADDU V0, S0, V0
9D007FC8  90430006   LBU V1, 6(V0)
9D007FCC  24040001   ADDIU A0, ZERO, 1
9D007FD0  7C832104   INS V1, A0, 4, 1
9D007FD4  A0430006   SB V1, 6(V0)
9D007FD8  92420032   LBU V0, 50(S2)
9D007FDC  00021100   SLL V0, V0, 4
9D007FE0  02021021   ADDU V0, S0, V0
394:                     }
395:                 }
396:                 
397:                 //******************************************************************************
398:                 /* Function :  USBHS_ExistsEndpointFIFO_Default
399:                 
400:                   Summary:
401:                     Implements Default variant of PLIB_USBHS_ExistsEndpointFIFO
402:                 
403:                   Description:
404:                     This template implements the Default variant of the
405:                     PLIB_USBHS_ExistsEndpointFIFO function.
406:                 */
407:                 
408:                 #define PLIB_USBHS_ExistsEndpointFIFO PLIB_USBHS_ExistsEndpointFIFO
409:                 PLIB_TEMPLATE bool USBHS_ExistsEndpointFIFO_Default( USBHS_MODULE_ID index )
410:                 {
411:                     return true;
412:                 }
413:                 
414:                 
415:                 #endif /*_USBHS_ENDPOINTFIFO_DEFAULT_H*/
416:                 
417:                 /******************************************************************************
418:                  End of File
419:                 */
420:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/usbhs/templates/usbhs_clockresetcontrol_default.h
1:                   /*******************************************************************************
2:                     USBHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usbhs_ClockResetControl_Default.h
6:                   
7:                     Summary:
8:                       USBHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockResetControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USBHS_ExistsClockResetControl
16:                          PLIB_USBHS_GlobalInterruptEnable
17:                          PLIB_USBHS_GlobalInterruptDisable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USBHS_CLOCKRESETCONTROL_DEFAULT_H
48:                  #define _USBHS_CLOCKRESETCONTROL_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  USBHS_ExistsClockResetControl_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_USBHS_ExistsClockResetControl
55:                  
56:                    Description:
57:                      This template implements the Default variant of the 
58:                      PLIB_USBHS_ExistsClockResetControl function.
59:                  */
60:                  
61:                  #define PLIB_USBHS_ExistsClockResetControl PLIB_USBHS_ExistsClockResetControl
62:                  PLIB_TEMPLATE bool USBHS_ExistsClockResetControl_Default( USBHS_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  //******************************************************************************
68:                  /* Function :  USBHS_GlobalInterruptEnable_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_USBHS_GlobalInterruptEnable 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the 
75:                      PLIB_USBHS_GlobalInterruptEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USBHS_GlobalInterruptEnable_Default( USBHS_MODULE_ID index )
79:                  {
80:                      /* Get pointer to the USBCRCON register and enable the global interrupt
81:                       * register */
82:                      volatile __USBCRCONbits_t * usbcrcon = (__USBCRCONbits_t *)(index - 0x5F000);
9D00DEDC  3C02FFFA   LUI V0, -6
9D00DEE0  24421000   ADDIU V0, V0, 4096
9D00DEE4  02421021   ADDU V0, S2, V0
83:                      usbcrcon->USBIE = 1;
9D00DEE8  8C430000   LW V1, 0(V0)
9D00DEEC  24040001   ADDIU A0, ZERO, 1
9D00DEF0  7C831084   INS V1, A0, 2, 1
9D00DEF4  AC430000   SW V1, 0(V0)
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USBHS_GlobalInterruptDisable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USBHS_GlobalInterruptDisable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the 
94:                      PLIB_USBHS_GlobalInterruptDisable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void USBHS_GlobalInterruptDisable_Default( USBHS_MODULE_ID index )
98:                  {
99:                      /* Get pointer to the USBCRCON register and disable the global interrupt
100:                      * register */
101:                     volatile __USBCRCONbits_t * usbcrcon = (__USBCRCONbits_t *)(index - 0x5F000);
102:                     usbcrcon->USBIE = 0;
103:                 }
104:                 
105:                 #endif /*_USBHS_CLOCKRESETCONTROL_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_prescale_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Prescale_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Prescale
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_PrescaleSelect
16:                          PLIB_TMR_PrescaleGet
17:                          PLIB_TMR_ExistsPrescale
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PRESCALE_DEFAULT_H
48:                  #define _TMR_PRESCALE_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_PrescaleSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_TMR_PrescaleSelect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_TMR_PrescaleSelect function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_PrescaleSelect_Default( TMR_MODULE_ID index , TMR_PRESCALE prescale )
63:                  {
64:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
65:                      
66:                      if(TMR_ID_1 == index)
9D013AE8  3C02BF84   LUI V0, -16508
9D013AEC  14820029   BNE A0, V0, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D013AF0  00000000   NOP
67:                      {
68:                          switch(prescale)
9D013AF4  24020003   ADDIU V0, ZERO, 3
9D013AF8  10A20014   BEQ A1, V0, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D013AFC  00000000   NOP
9D013B00  2CA20004   SLTIU V0, A1, 4
9D013B04  10400005   BEQ V0, ZERO, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D013B08  24020006   ADDIU V0, ZERO, 6
9D013B0C  10A0000A   BEQ A1, ZERO, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D013B10  00000000   NOP
9D013B1C  10A20011   BEQ A1, V0, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D013B20  00000000   NOP
9D013B24  24020007   ADDIU V0, ZERO, 7
9D013B28  10A20014   BEQ A1, V0, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D013B2C  00000000   NOP
69:                          {
70:                              case TMR_PRESCALE_VALUE_1:  tmr->TxCON.TCKPS = 0;
9D013B38  94820000   LHU V0, 0(A0)
9D013B3C  7C023104   INS V0, ZERO, 4, 3
9D013B40  A4820000   SH V0, 0(A0)
71:                                                          break;
72:                              case TMR_PRESCALE_VALUE_8:  tmr->TxCON.TCKPS = 1;
9D013B4C  94820000   LHU V0, 0(A0)
9D013B50  24030001   ADDIU V1, ZERO, 1
9D013B54  7C623104   INS V0, V1, 4, 3
9D013B58  A4820000   SH V0, 0(A0)
73:                                                          break;
74:                              case TMR_PRESCALE_VALUE_64: tmr->TxCON.TCKPS = 2;
9D013B64  94820000   LHU V0, 0(A0)
9D013B68  24030002   ADDIU V1, ZERO, 2
9D013B6C  7C623104   INS V0, V1, 4, 3
9D013B70  A4820000   SH V0, 0(A0)
75:                                                          break;
76:                              case TMR_PRESCALE_VALUE_256: tmr->TxCON.TCKPS = 3;
9D013B7C  94820000   LHU V0, 0(A0)
9D013B80  24030003   ADDIU V1, ZERO, 3
9D013B84  7C623104   INS V0, V1, 4, 3
9D013B88  A4820000   SH V0, 0(A0)
77:                                                          break;
78:                              default: PLIB_ASSERT(false, " Given Prescale value is not supported for Timer1");
79:                          }
80:                      }
81:                      else
82:                      {
83:                          tmr->TxCON.TCKPS = prescale;
9D013B94  94820000   LHU V0, 0(A0)
9D013B98  7CA23104   INS V0, A1, 4, 3
9D013B9C  A4820000   SH V0, 0(A0)
84:                      }
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  TMR_PrescaleGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_TMR_PrescaleGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_TMR_PrescaleGet function.
96:                  */
97:                  
98:                  PLIB_TEMPLATE uint16_t TMR_PrescaleGet_Default( TMR_MODULE_ID index )
99:                  {
100:                     tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
101:                     uint8_t temp_prescaler;
102:                     uint16_t preScaler;
103:                 
104:                     temp_prescaler = tmr->TxCON.TCKPS;
9D0133EC  8C830000   LW V1, 0(A0)
00000028  00000000   NOP
105:                                           
106:                     if(TMR_ID_1 == index)
9D0133F0  3C05BF84   LUI A1, -16508
9D0133F4  14850010   BNE A0, A1, DRV_TMR_CounterFrequencyGet::PLIB_TMR_PrescaleGet
9D0133F8  7C631100   EXT V1, V1, 4, 3
0000002C  00000000   NOP
107:                     {
108:                         /* 1, 8, 64, 256 */
109:                         switch(temp_prescaler)
9D0133FC  24040001   ADDIU A0, ZERO, 1
9D013400  50640013   BEQL V1, A0, 0x9D013450
9D013404  24030008   ADDIU V1, ZERO, 8
9D013408  10600007   BEQ V1, ZERO, 0x9D013428
9D01340C  24040002   ADDIU A0, ZERO, 2
9D013410  10640007   BEQ V1, A0, 0x9D013430
9D013414  24040100   ADDIU A0, ZERO, 256
00000038  00000000   NOP
110:                         {
111:                             case 0x00u: preScaler = 1u;
9D013428  0B404D14   J 0x9D013450
9D01342C  24030001   ADDIU V1, ZERO, 1
00000080  00000000   NOP
112:                                         break;
113:                             case 0x01u: preScaler = 8u;
114:                                         break;
115:                             case 0x02u: preScaler = 64u;
9D013430  0B404D14   J 0x9D013450
9D013434  24030040   ADDIU V1, ZERO, 64
116:                                         break;
117:                             case 0x03u: preScaler = 256u;
118:                                         break;
119:                             default:    preScaler = 0u;
9D013418  38630003   XORI V1, V1, 3
9D01341C  0003200B   MOVN A0, ZERO, V1
9D013420  0B404D14   J 0x9D013450
9D013424  00801821   ADDU V1, A0, ZERO
120:                         }
121:                     }
122:                     else
123:                     {
124:                         /* 1, 2, 4, 8, 16, 32, 64, 256 */
125:                         if ( temp_prescaler == 7u )
126:                         {
127:                             temp_prescaler++;
9D013438  38650007   XORI A1, V1, 7
9D01343C  24040008   ADDIU A0, ZERO, 8
9D013440  0085180A   MOVZ V1, A0, A1
00000064  00000000   NOP
128:                         }
129:                         preScaler = (uint16_t)(0x01u << temp_prescaler);
9D013444  24040001   ADDIU A0, ZERO, 1
9D013448  00641804   SLLV V1, A0, V1
9D01344C  3063FFFF   ANDI V1, V1, -1
00000070  00000000   NOP
130:                     }
131:                     return preScaler;
132:                 
133:                 }
134:                 
135:                 
136:                 //******************************************************************************
137:                 /* Function :  TMR_ExistsPrescale_Default
138:                 
139:                   Summary:
140:                     Implements Default variant of PLIB_TMR_ExistsPrescale
141:                 
142:                   Description:
143:                     This template implements the Default variant of the PLIB_TMR_ExistsPrescale function.
144:                 */
145:                 
146:                 #define PLIB_TMR_ExistsPrescale PLIB_TMR_ExistsPrescale
147:                 PLIB_TEMPLATE bool TMR_ExistsPrescale_Default( TMR_MODULE_ID index )
148:                 {
149:                     return true;
150:                 }
151:                 
152:                 
153:                 #endif /*_TMR_PRESCALE_DEFAULT_H*/
154:                 
155:                 /******************************************************************************
156:                  End of File
157:                 */
158:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_period32bit_in16bitregister_pic32.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Period32Bit_In16BitRegister_pic32.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Period32Bit
13:                      and its Variant : In16BitRegister_pic32
14:                      For following APIs :
15:                          PLIB_TMR_Period32BitSet
16:                          PLIB_TMR_Period32BitGet
17:                          PLIB_TMR_ExistsPeriod32Bit
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PERIOD32BIT_IN16BITREGISTER_PIC32_H
48:                  #define _TMR_PERIOD32BIT_IN16BITREGISTER_PIC32_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_Period32BitSet_In16BitRegister_pic32
54:                  
55:                    Summary:
56:                      Implements In16BitRegister_pic32 variant of PLIB_TMR_Period32BitSet 
57:                  
58:                    Description:
59:                      This template implements the In16BitRegister_pic32 variant of the PLIB_TMR_Period32BitSet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_Period32BitSet_In16BitRegister_pic32( TMR_MODULE_ID index , uint32_t period )
63:                  {
64:                      tmr_registers_t volatile * tmrX = ((tmr_registers_t *)(index));
65:                      tmr_registers_t volatile * tmrY = ((tmr_registers_t *)(index + 0x0200u));
66:                  
67:                  	if( _TMR_MODULE_ID_IS_EVEN(index) )
9D011938  30850200   ANDI A1, A0, 512
9D01193C  10A0000B   BEQ A1, ZERO, 0x9D01196C
9D011940  3065FFFF   ANDI A1, V1, -1
00000058  00000000   NOP
68:                  	{
69:                          /* Lower 16 bits to Even Timer and higher 16 bits to Odd Timer */
70:                          tmrX->PRx = ( period & 0xFFFFu );
9D011944  AC850020   SW A1, 32(A0)
00000064  00000000   NOP
71:                          tmrY->PRx = ( (period >> 16u) & 0xFFFFu );
9D011948  00031C02   SRL V1, V1, 16
9D01194C  AC830220   SW V1, 544(A0)
9D011950  0B40465B   J 0x9D01196C
9D011954  00000000   NOP
0000006C  00000000   NOP
72:                  	}
73:                  	else
74:                  	{
75:                  		PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_Period32BitSet");
76:                  	}
77:                  }
78:                  
79:                  
80:                  //******************************************************************************
81:                  /* Function :  TMR_Period32BitGet_In16BitRegister_pic32
82:                  
83:                    Summary:
84:                      Implements In16BitRegister_pic32 variant of PLIB_TMR_Period32BitGet 
85:                  
86:                    Description:
87:                      This template implements the In16BitRegister_pic32 variant of the PLIB_TMR_Period32BitGet function.
88:                  */
89:                  
90:                  PLIB_TEMPLATE uint32_t TMR_Period32BitGet_In16BitRegister_pic32( TMR_MODULE_ID index )
91:                  {
92:                      tmr_registers_t volatile * tmrX = ((tmr_registers_t *)(index));
93:                      tmr_registers_t volatile * tmrY = ((tmr_registers_t *)(index + 0x0200u));
94:                      uint32_t val1 = 0u, val2 = 0u;
95:                  
96:                  	if( _TMR_MODULE_ID_IS_EVEN(index) )
97:                  	{
98:                          val1 = (uint32_t)(tmrX->PRx);
99:                          val2 = (uint32_t)(tmrY->PRx << 16u);
100:                 	}
101:                 	else
102:                 	{
103:                 		PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_Period32BitGet");
104:                 	}	
105:                 
106:                     return ( val1 | val2 );
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  TMR_ExistsPeriod32Bit_In16BitRegister_pic32
112:                 
113:                   Summary:
114:                     Implements In16BitRegister_pic32 variant of PLIB_TMR_ExistsPeriod32Bit
115:                 
116:                   Description:
117:                     This template implements the In16BitRegister_pic32 variant of the PLIB_TMR_ExistsPeriod32Bit function.
118:                 */
119:                 
120:                 #define PLIB_TMR_ExistsPeriod32Bit PLIB_TMR_ExistsPeriod32Bit
121:                 PLIB_TEMPLATE bool TMR_ExistsPeriod32Bit_In16BitRegister_pic32( TMR_MODULE_ID index )
122:                 {
123:                     if (TMR_ID_1 == index)
124:                     {
125:                         return false;
126:                     }
127:                     else
128:                     {
129:                         return true;
130:                     }
131:                 }
132:                 
133:                 
134:                 #endif /*_TMR_PERIOD32BIT_IN16BITREGISTER_PIC32_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_period16bit_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Period16Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Period16Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Period16BitSet
16:                          PLIB_TMR_Period16BitGet
17:                          PLIB_TMR_ExistsPeriod16Bit
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PERIOD16BIT_Default_H
48:                  #define _TMR_PERIOD16BIT_Default_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Period16BitSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_TMR_Period16BitSet
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_TMR_Period16BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Period16BitSet_Default( TMR_MODULE_ID index , uint16_t period )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
9D01195C  8C63000C   LW V1, 12(V1)
0000007C  00000000   NOP
66:                      tmr->PRx = period;
9D011964  3231FFFF   ANDI S1, S1, -1
9D011968  AC710020   SW S1, 32(V1)
00000080  00000000   NOP
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  TMR_Period16BitGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_TMR_Period16BitGet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_TMR_Period16BitGet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t TMR_Period16BitGet_Default( TMR_MODULE_ID index )
81:                  {
82:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
83:                      return (uint16_t)tmr->PRx;
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  TMR_ExistsPeriod16Bit_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_TMR_ExistsPeriod16Bit
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_TMR_ExistsPeriod16Bit function.
95:                  */
96:                  
97:                  #define PLIB_TMR_ExistsPeriod16Bit PLIB_TMR_ExistsPeriod16Bit
98:                  PLIB_TEMPLATE bool TMR_ExistsPeriod16Bit_Default( TMR_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_TMR_PERIOD16BIT_Default_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_mode32bit_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Mode32Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Mode32Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Mode32BitEnable
16:                          PLIB_TMR_ExistsMode32Bit
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_MODE32BIT_DEFAULT_H
47:                  #define _TMR_MODE32BIT_DEFAULT_H
48:                  
49:                  #include "tmr_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  TMR_Mode32BitEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_TMR_Mode32BitEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_TMR_Mode32BitEnable function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void TMR_Mode32BitEnable_Default( TMR_MODULE_ID index )
62:                  {
63:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
64:                      
65:                      if ( _TMR_MODULE_ID_IS_EVEN(index) )
66:                      {
67:                          tmr->TxCONSET = TxCON_T32_MASK;
9D00EF8C  24020008   ADDIU V0, ZERO, 8
9D00EF90  AE020008   SW V0, 8(S0)
68:                      }
69:                      else
70:                      {
71:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_Mode32BitEnable");
72:                      }
73:                  }
74:                  
75:                  
76:                  //******************************************************************************
77:                  /* Function :  TMR_ExistsMode32Bit_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_TMR_ExistsMode32Bit
81:                  
82:                    Description:
83:                      This template implements the Default variant of the PLIB_TMR_ExistsMode32Bit function.
84:                  */
85:                  
86:                  #define PLIB_TMR_ExistsMode32Bit PLIB_TMR_ExistsMode32Bit
87:                  PLIB_TEMPLATE bool TMR_ExistsMode32Bit_Default( TMR_MODULE_ID index )
88:                  {
89:                      if ( _TMR_MODULE_ID_IS_EVEN(index) )
9D00EF80  32020200   ANDI V0, S0, 512
90:                      {
91:                          return true;
92:                      }
93:                      else
94:                      {
95:                          PLIB_ASSERT(false, "This Timer instance does not support Mode32BitControl feature");
96:                          return false;
97:                      }
98:                  }
99:                  
100:                 
101:                 #endif /*_TMR_MODE32BIT_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_mode16bit_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Mode16Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Mode16Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Mode16BitEnable
16:                          PLIB_TMR_ExistsMode16Bit
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_MODE16BIT_DEFAULT_H
47:                  #define _TMR_MODE16BIT_DEFAULT_H
48:                  
49:                  #include "tmr_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  TMR_Mode16BitEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_TMR_Mode16BitEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_TMR_Mode16BitEnable function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void TMR_Mode16BitEnable_Default( TMR_MODULE_ID index )
62:                  {
63:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
64:                      
65:                      if (_TMR_MODULE_ID_IS_EVEN(index))
9D00EF5C  32020200   ANDI V0, S0, 512
9D00EF60  50400019   BEQL V0, ZERO, DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D00EF64  3C02BF84   LUI V0, -16508
66:                      {
67:                          tmr->TxCONCLR = TxCON_T32_MASK;
9D00EF68  24020008   ADDIU V0, ZERO, 8
9D00EF6C  AE020004   SW V0, 4(S0)
68:                      }
69:                      else
70:                      {
71:                          PLIB_ASSERT(false, "Other timers are by default in 16 bit mode");
72:                      }
73:                  }
74:                  
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  TMR_ExistsMode16Bit_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_TMR_ExistsMode16Bit
82:                  
83:                    Description:
84:                      This template implements the Default variant of the PLIB_TMR_ExistsMode16Bit function.
85:                  */
86:                  
87:                  #define PLIB_TMR_ExistsMode16Bit PLIB_TMR_ExistsMode16Bit
88:                  PLIB_TEMPLATE bool TMR_ExistsMode16Bit_Default( TMR_MODULE_ID index )
89:                  {
90:                      /* 16 bit mode always exists */
91:                      return true;
92:                  }
93:                  
94:                  
95:                  #endif /*_TMR_MODE16BIT_DEFAULT_H*/
96:                  
97:                  /******************************************************************************
98:                   End of File
99:                  */
100:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_gatedtimeaccumulation_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_GatedTimeAccumulation_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GatedTimeAccumulation
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_GateEnable
16:                          PLIB_TMR_GateDisable
17:                          PLIB_TMR_ExistsGatedTimeAccumulation
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_GATEDTIMEACCUMULATION_DEFAULT_H
48:                  #define _TMR_GATEDTIMEACCUMULATION_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_GateEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_TMR_GateEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_TMR_GateEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_GateEnable_Default( TMR_MODULE_ID index )
63:                  {
64:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
00000038  00000000   NOP
65:                  
66:                      tmr->TxCONSET = TxCON_TGATE_MASK;
0000003C  00000000   NOP
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  TMR_GateDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_TMR_GateDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_TMR_GateDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void TMR_GateDisable_Default( TMR_MODULE_ID index )
81:                  {
82:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
00000038  00000000   NOP
83:                  
84:                      tmr->TxCONCLR = TxCON_TGATE_MASK;
0000003C  00000000   NOP
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  TMR_ExistsGatedTimeAccumulation_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_TMR_ExistsGatedTimeAccumulation
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_TMR_ExistsGatedTimeAccumulation function.
95:                  */
96:                  
97:                  #define PLIB_TMR_ExistsGatedTimeAccumulation PLIB_TMR_ExistsGatedTimeAccumulation
98:                  PLIB_TEMPLATE bool TMR_ExistsGatedTimeAccumulation_Default( TMR_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_TMR_GATEDTIMEACCUMULATION_DEFAULT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_enablecontrol_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Start
16:                          PLIB_TMR_Stop
17:                          PLIB_TMR_ExistsEnableControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_ENABLECONTROL_DEFAULT_H
48:                  #define _TMR_ENABLECONTROL_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Start_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_TMR_Start 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_TMR_Start function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Start_Default( TMR_MODULE_ID index )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
9D015C4C  8C42000C   LW V0, 12(V0)
66:                  
67:                      tmr->TxCONSET = TxCON_ON_MASK;
9D015C50  34038000   ORI V1, ZERO, -32768
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  TMR_Stop_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_TMR_Stop 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_TMR_Stop function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void TMR_Stop_Default( TMR_MODULE_ID index )
82:                  {
83:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
9D0162C0  8C42000C   LW V0, 12(V0)
84:                  
85:                      tmr->TxCONCLR = TxCON_ON_MASK;
9D0162C4  34038000   ORI V1, ZERO, -32768
9D0162C8  AC430004   SW V1, 4(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  TMR_ExistsEnableControl_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_TMR_ExistsEnableControl
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_TMR_ExistsEnableControl function.
97:                  */
98:                  
99:                  #define PLIB_TMR_ExistsEnableControl PLIB_TMR_ExistsEnableControl
100:                 PLIB_TEMPLATE bool TMR_ExistsEnableControl_Default( TMR_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_TMR_ENABLECONTROL_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_counterasyncwritecontrol_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_CounterAsyncWriteControl_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CounterAsyncWriteControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_CounterAsyncWriteEnable
16:                          PLIB_TMR_CounterAsyncWriteDisable
17:                          PLIB_TMR_ExistsCounterAsyncWriteControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_COUNTERASYNCWRITECONTROL_DEFAULT_H
48:                  #define _TMR_COUNTERASYNCWRITECONTROL_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_CounterAsyncWriteEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_TMR_CounterAsyncWriteEnable
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_TMR_CounterAsyncWriteEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_CounterAsyncWriteEnable_Default( TMR_MODULE_ID index )
63:                  {
64:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
65:                      
66:                      if(TMR_ID_1 == index)
67:                      {
68:                          tmr->TxCONCLR = TxCON_TWDIS_MASK; 
9D00EFA8  3C02BF84   LUI V0, -16508
9D00EFAC  AC430004   SW V1, 4(V0)
69:                      }
70:                      else
71:                      {
72:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_CounterAsyncWriteEnable");
73:                      }
74:                  }
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  TMR_CounterAsyncWriteDisable_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_TMR_CounterAsyncWriteDisable
82:                  
83:                    Description:
84:                      This template implements the Default variant of the PLIB_TMR_CounterAsyncWriteDisable function.
85:                  */
86:                  
87:                  PLIB_TEMPLATE void TMR_CounterAsyncWriteDisable_Default( TMR_MODULE_ID index )
88:                  {
89:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
90:                      
91:                      if(TMR_ID_1 == index)
92:                      {
93:                          tmr->TxCONSET = TxCON_TWDIS_MASK;
9D00EFB8  3C02BF84   LUI V0, -16508
9D00EFBC  AC430008   SW V1, 8(V0)
94:                      }
95:                      else
96:                      {
97:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_CounterAsyncWriteDisable");
98:                      }
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  TMR_ExistsCounterAsyncWriteControl_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_TMR_ExistsCounterAsyncWriteControl
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_TMR_ExistsCounterAsyncWriteControl function.
110:                 */
111:                 
112:                 #define PLIB_TMR_ExistsCounterAsyncWriteControl PLIB_TMR_ExistsCounterAsyncWriteControl
113:                 PLIB_TEMPLATE bool TMR_ExistsCounterAsyncWriteControl_Default( TMR_MODULE_ID index )
114:                 {
115:                     if(TMR_ID_1 == index)
116:                     {
117:                         return true;
118:                     }
119:                     else
120:                     {
121:                         PLIB_ASSERT(false, "This Timer instance does not support CounterAsyncWrite feature");
122:                         return false;
123:                     }
124:                 }
125:                 
126:                 
127:                 #endif /*_TMR_COUNTERASYNCWRITECONTROL_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_counter32bit_in16bitregister.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Counter32Bit_In16BitRegister.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Counter32Bit
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_TMR_Counter32BitSet
16:                          PLIB_TMR_Counter32BitGet
17:                          PLIB_TMR_Counter32BitClear
18:                          PLIB_TMR_ExistsCounter32Bit
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _TMR_COUNTER32BIT_IN16BITREGISTER_H
49:                  #define _TMR_COUNTER32BIT_IN16BITREGISTER_H
50:                  
51:                  #include "tmr_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Counter32BitSet_In16BitRegister
55:                  
56:                    Summary:
57:                      Implements In16BitRegister variant of PLIB_TMR_Counter32BitSet
58:                  
59:                    Description:
60:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter32BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Counter32BitSet_In16BitRegister( TMR_MODULE_ID index , uint32_t value )
64:                  {
65:                      tmr_registers_t volatile * tmrX = ((tmr_registers_t *)(index));
66:                      tmr_registers_t volatile * tmrY = ((tmr_registers_t *)(index + 0x0200u));
67:                  
68:                      if( _TMR_MODULE_ID_IS_EVEN(index) )
00000040  00000000   NOP
69:                      {
70:                          /* Lower 16 bits to Even Timer and higher 16 bits to Odd Timer */
71:                          tmrX->TMRx = ( value & 0xFFFFu );
0000004C  00000000   NOP
72:                          tmrY->TMRx = ( (value >> 16u) & 0xFFFFu );
73:                      }
74:                      else
75:                      {
76:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_Counter32BitSet");
77:                      }
78:                          
79:                  
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  TMR_Counter32BitGet_In16BitRegister
85:                  
86:                    Summary:
87:                      Implements In16BitRegister variant of PLIB_TMR_Counter32BitGet
88:                  
89:                    Description:
90:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter32BitGet function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE uint32_t TMR_Counter32BitGet_In16BitRegister( TMR_MODULE_ID index )
94:                  {
95:                      tmr_registers_t volatile * tmrX = ((tmr_registers_t *)(index));
96:                      tmr_registers_t volatile * tmrY = ((tmr_registers_t *)(index + 0x0200u));
97:                      uint32_t val1 = 0u, val2 = 0u;
00000050  00000000   NOP
98:                  
99:                      if( _TMR_MODULE_ID_IS_EVEN(index) )
00000034  00000000   NOP
100:                     {
101:                         val1 = (uint32_t)(tmrX->TMRx);
00000040  00000000   NOP
102:                         val2 = (uint32_t)(tmrY->TMRx << 16u);
00000044  00000000   NOP
103:                     }
104:                     else
105:                     {
106:                         PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_Counter32BitGet");
107:                     }
108:                 
109:                     return ( val1 | val2 );
110:                 }
111:                 
112:                 
113:                 //******************************************************************************
114:                 /* Function :  TMR_Counter32BitClear_In16BitRegister
115:                 
116:                   Summary:
117:                     Implements In16BitRegister variant of PLIB_TMR_Counter32BitClear
118:                 
119:                   Description:
120:                     This template implements the In16BitRegister variant of the PLIB_TMR_Counter32BitClear function.
121:                 */
122:                 
123:                 PLIB_TEMPLATE void TMR_Counter32BitClear_In16BitRegister( TMR_MODULE_ID index )
124:                 {
125:                     tmr_registers_t volatile * tmrX = ((tmr_registers_t *)(index));
126:                     tmr_registers_t volatile * tmrY = ((tmr_registers_t *)(index + 0x0200u));
127:                 
128:                     if( _TMR_MODULE_ID_IS_EVEN(index) )
0000003C  00000000   NOP
129:                     {
130:                         tmrX->TMRxCLR = 0xFFFF;
00000048  00000000   NOP
131:                         tmrY->TMRxCLR = 0xFFFF;
0000004C  00000000   NOP
132:                     }
133:                     else
134:                     {
135:                         PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_Counter32BitClear");
136:                     }
137:                 }
138:                 
139:                 
140:                 //******************************************************************************
141:                 /* Function :  TMR_ExistsCounter32Bit_In16BitRegister
142:                 
143:                   Summary:
144:                     Implements In16BitRegister variant of PLIB_TMR_ExistsCounter32Bit
145:                 
146:                   Description:
147:                     This template implements the In16BitRegister variant of the PLIB_TMR_ExistsCounter32Bit function.
148:                 */
149:                 
150:                 #define PLIB_TMR_ExistsCounter32Bit PLIB_TMR_ExistsCounter32Bit
151:                 PLIB_TEMPLATE bool TMR_ExistsCounter32Bit_In16BitRegister( TMR_MODULE_ID index )
152:                 {
153:                     if (TMR_ID_1 == index)
154:                     {
155:                         return false;
156:                     }
157:                     else
158:                     {
159:                         return true;
160:                     }
161:                 }
162:                 
163:                 
164:                 #endif /*_TMR_COUNTER32BIT_IN16BITREGISTER_H*/
165:                 
166:                 /******************************************************************************
167:                  End of File
168:                 */
169:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_counter16bit_in16bitregister.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Counter16Bit_In16BitRegister.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Counter16Bit
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_TMR_Counter16BitSet
16:                          PLIB_TMR_Counter16BitGet
17:                          PLIB_TMR_Counter16BitClear
18:                          PLIB_TMR_ExistsCounter16Bit
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _TMR_COUNTER16BIT_IN16BITREGISTER_H
49:                  #define _TMR_COUNTER16BIT_IN16BITREGISTER_H
50:                  
51:                  #include "tmr_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Counter16BitSet_In16BitRegister
55:                  
56:                    Summary:
57:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitSet
58:                  
59:                    Description:
60:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Counter16BitSet_In16BitRegister( TMR_MODULE_ID index , uint16_t value )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
66:                      
67:                      tmr->TMRx = value;
00000034  00000000   NOP
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  TMR_Counter16BitGet_In16BitRegister
73:                  
74:                    Summary:
75:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitGet
76:                  
77:                    Description:
78:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitGet function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE uint16_t TMR_Counter16BitGet_In16BitRegister( TMR_MODULE_ID index )
82:                  {
83:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
84:                  
85:                      return (uint16_t)tmr->TMRx;
0000005C  00000000   NOP
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  TMR_Counter16BitClear_In16BitRegister
91:                  
92:                    Summary:
93:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitClear
94:                  
95:                    Description:
96:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitClear function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void TMR_Counter16BitClear_In16BitRegister( TMR_MODULE_ID index )
100:                 {
101:                     tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
102:                     
103:                     tmr->TMRx = 0u;
00000030  00000000   NOP
104:                 }
105:                 
106:                 
107:                 //******************************************************************************
108:                 /* Function :  TMR_ExistsCounter16Bit_In16BitRegister
109:                 
110:                   Summary:
111:                     Implements In16BitRegister variant of PLIB_TMR_ExistsCounter16Bit
112:                 
113:                   Description:
114:                     This template implements the In16BitRegister variant of the PLIB_TMR_ExistsCounter16Bit function.
115:                 */
116:                 
117:                 #define PLIB_TMR_ExistsCounter16Bit PLIB_TMR_ExistsCounter16Bit
118:                 PLIB_TEMPLATE bool TMR_ExistsCounter16Bit_In16BitRegister( TMR_MODULE_ID index )
119:                 {
120:                     return true;
121:                 }
122:                 
123:                 
124:                 #endif /*_TMR_COUNTER16BIT_IN16BITREGISTER_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_clocksourcesync_inverted.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_ClockSourceSync_Inverted.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockSourceSync
13:                      and its Variant : Inverted
14:                      For following APIs :
15:                          PLIB_TMR_ClockSourceExternalSyncEnable
16:                          PLIB_TMR_ClockSourceExternalSyncDisable
17:                          PLIB_TMR_ExistsClockSourceSync
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_CLOCKSOURCESYNC_INVERTED_H
48:                  #define _TMR_CLOCKSOURCESYNC_INVERTED_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_ClockSourceExternalSyncEnable_Inverted
54:                  
55:                    Summary:
56:                      Implements Inverted variant of PLIB_TMR_ClockSourceExternalSyncEnable 
57:                  
58:                    Description:
59:                      This template implements the Inverted variant of the PLIB_TMR_ClockSourceExternalSyncEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_ClockSourceExternalSyncEnable_Inverted( TMR_MODULE_ID index )
63:                  {
64:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
65:                  
66:                      /* This feature is present in Timer 1 only */
67:                      if(TMR_ID_1 == index)
68:                      {
69:                          tmr->TxCONSET = TxCON_TSYNC_MASK; 
9D0128AC  0B404A43   J _DRV_TMR_ClockSourceSet::PLIB_TMR_ClockSourceExternalSyncEnable
9D0128B0  24030004   ADDIU V1, ZERO, 4
9D01290C  3C02BF84   LUI V0, -16508
9D012910  AC430008   SW V1, 8(V0)
70:                      }
71:                      else
72:                      {
73:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_ClockSourceExternalSyncEnable");
74:                      }
75:                  }
76:                  
77:                  
78:                  //******************************************************************************
79:                  /* Function :  TMR_ClockSourceExternalSyncDisable_Inverted
80:                  
81:                    Summary:
82:                      Implements Inverted variant of PLIB_TMR_ClockSourceExternalSyncDisable 
83:                  
84:                    Description:
85:                      This template implements the Inverted variant of the PLIB_TMR_ClockSourceExternalSyncDisable function.
86:                  */
87:                  
88:                  PLIB_TEMPLATE void TMR_ClockSourceExternalSyncDisable_Inverted( TMR_MODULE_ID index )
89:                  {
90:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
91:                  
92:                      /* This feature is present in Timer 1 only */
93:                      if(TMR_ID_1 == index)
94:                      {
95:                          tmr->TxCONCLR = TxCON_TSYNC_MASK; 
9D012904  0B404A47   J _DRV_TMR_ClockSourceSet::PLIB_TMR_ClockSourceExternalSyncDisable
9D012908  24030004   ADDIU V1, ZERO, 4
9D01291C  3C02BF84   LUI V0, -16508
9D012920  AC430004   SW V1, 4(V0)
96:                      }
97:                      else
98:                      {
99:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_ClockSourceExternalSyncEnable");
100:                     }
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  TMR_ExistsClockSourceSync_Inverted
106:                 
107:                   Summary:
108:                     Implements Inverted variant of PLIB_TMR_ExistsClockSourceSync
109:                 
110:                   Description:
111:                     This template implements the Inverted variant of the PLIB_TMR_ExistsClockSourceSync function.
112:                 */
113:                 
114:                 #define PLIB_TMR_ExistsClockSourceSync PLIB_TMR_ExistsClockSourceSync
115:                 PLIB_TEMPLATE bool TMR_ExistsClockSourceSync_Inverted( TMR_MODULE_ID index )
116:                 {
117:                     if(TMR_ID_1 == index)
118:                     {
119:                         return true; 
120:                     }
121:                     else
122:                     {
123:                         return false;
124:                     } 
125:                 }
126:                 
127:                 
128:                 #endif /*_TMR_CLOCKSOURCESYNC_INVERTED_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/tmr/templates/tmr_clocksource_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_ClockSource_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockSource
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_ClockSourceSelect
16:                          PLIB_TMR_ExistsClockSource
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_CLOCKSOURCE_DEFAULT_H
47:                  #define _TMR_CLOCKSOURCE_DEFAULT_H
48:                  
49:                  #include "tmr_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  TMR_ClockSourceSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_TMR_ClockSourceSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_TMR_ClockSourceSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void TMR_ClockSourceSelect_Default( TMR_MODULE_ID index , TMR_CLOCK_SOURCE source )
62:                  {
63:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
64:                  
65:                      tmr->TxCON.TCS = source;
9D012858  94820000   LHU V0, 0(A0)
9D01285C  7C020844   INS V0, ZERO, 1, 1
9D012860  A4820000   SH V0, 0(A0)
9D012884  94430000   LHU V1, 0(V0)
9D012888  24040001   ADDIU A0, ZERO, 1
9D01288C  7C830844   INS V1, A0, 1, 1
9D012890  A4430000   SH V1, 0(V0)
9D0128BC  94820000   LHU V0, 0(A0)
9D0128C0  7C620844   INS V0, V1, 1, 1
9D0128C4  A4820000   SH V0, 0(A0)
9D0128D8  3C02BF84   LUI V0, -16508
9D0128DC  94430000   LHU V1, 0(V0)
9D0128E0  24040001   ADDIU A0, ZERO, 1
9D0128E4  7C830844   INS V1, A0, 1, 1
9D0128E8  A4430000   SH V1, 0(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  TMR_ExistsClockSource_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_TMR_ExistsClockSource
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_TMR_ExistsClockSource function.
77:                  */
78:                  
79:                  #define PLIB_TMR_ExistsClockSource PLIB_TMR_ExistsClockSource
80:                  PLIB_TEMPLATE bool TMR_ExistsClockSource_Default( TMR_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_TMR_CLOCKSOURCE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_slewratecontrol_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_SlewRateControl_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlewRateControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChannelSlewRateSelect
16:                          PLIB_PORTS_PinSlewRateGet
17:                          PLIB_PORTS_ExistsSlewRateControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_SLEWRATECONTROL_DEFAULT_H
48:                  #define _PORTS_SLEWRATECONTROL_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_ChannelSlewRateSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_ChannelSlewRateSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_ChannelSlewRateSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_ChannelSlewRateSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK   channelMask , PORTS_PIN_SLEW_RATE slewRate )
62:                  {
63:                          
64:                      *(&SRCON0B + (slewRate & 0x03) + (channel - 1) * 0x40) = channelMask;
9D000118  24024700   ADDIU V0, ZERO, 18176
9D00011C  3C03BF86   LUI V1, -16506
9D000120  246301C0   ADDIU V1, V1, 448
9D000124  AC620008   SW V0, 8(V1)
65:                      *(&SRCON1B + ((slewRate & 0x0C) >> 2) + (channel - 1) * 0x40) = channelMask;
9D000128  3C03BF86   LUI V1, -16506
9D00012C  246301D0   ADDIU V1, V1, 464
9D000130  AC620004   SW V0, 4(V1)
66:                  }
67:                  
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinSlewRateGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_PORTS_PinSlewRateGet 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_PORTS_PinSlewRateGet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE PORTS_PIN_SLEW_RATE PORTS_PinSlewRateGet_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS bitPos )
81:                  {
82:                      unsigned int srcon0Bit, srcon1Bit;
83:                      srcon0Bit = (unsigned int)(*(&SRCON0B + ((channel - 1) * 0x40)) >> bitPos) & 1;
84:                      srcon1Bit = (unsigned int)(*(&SRCON1B + ((channel - 1) * 0x40)) >> bitPos) & 1;
85:                      
86:                      return (PORTS_PIN_SLEW_RATE)(((srcon1Bit+1) << 2)+(srcon0Bit + 1));
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  PORTS_ExistsSlewRateControl_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_PORTS_ExistsSlewRateControl
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_PORTS_ExistsSlewRateControl function.
98:                  */
99:                  
100:                 #define PLIB_PORTS_ExistsSlewRateControl PLIB_PORTS_ExistsSlewRateControl
101:                 PLIB_TEMPLATE bool PORTS_ExistsSlewRateControl_Default( PORTS_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_PORTS_SLEWRATECONTROL_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_remapoutput_pic32_1.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_RemapOutput_PIC32_1.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RemapOutput
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_PORTS_RemapOutput
16:                          PLIB_PORTS_ExistsRemapOutput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_REMAPOUTPUT_PIC32_1_H
47:                  #define _PORTS_REMAPOUTPUT_PIC32_1_H
48:                  
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PORTS_RemapOutput_PIC32_1
52:                  
53:                    Summary:
54:                      Implements PIC32_1 variant of PLIB_PORTS_RemapOutput 
55:                  
56:                    Description:
57:                      This template implements the PIC32_1 variant of the PLIB_PORTS_RemapOutput function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void PORTS_RemapOutput_PIC32_1( PORTS_MODULE_ID      index , PORTS_REMAP_OUTPUT_FUNCTION outputFunction , PORTS_REMAP_OUTPUT_PIN      remapOutputPin )
61:                  {
62:                      *(&RPB0R - 2 + remapOutputPin) = ( ( *((SFR_TYPE *)(&RPB0R - 2 + remapOutputPin)) ) & ~(_RPB0R_RPB0R_MASK) ) | ( (_RPB0R_RPB0R_MASK) & ((outputFunction)<<(_RPB0R_RPB0R_POSITION)) );
00000034  00000000   NOP
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PORTS_ExistsRemapOutput_PIC32_1
68:                  
69:                    Summary:
70:                      Implements PIC32_1 variant of PLIB_PORTS_ExistsRemapOutput
71:                  
72:                    Description:
73:                      This template implements the PIC32_1 variant of the PLIB_PORTS_ExistsRemapOutput function.
74:                  */
75:                  
76:                  #define PLIB_PORTS_ExistsRemapOutput PLIB_PORTS_ExistsRemapOutput
77:                  PLIB_TEMPLATE bool PORTS_ExistsRemapOutput_PIC32_1( PORTS_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  #endif /*_PORTS_REMAPOUTPUT_PIC32_1_H*/
84:                  
85:                  /******************************************************************************
86:                   End of File
87:                  */
88:                  
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_RemapInput_default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RemapInput
13:                      and its Variant : default
14:                      For following APIs :
15:                          PLIB_PORTS_RemapInput
16:                          PLIB_PORTS_ExistsRemapInput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_REMAPINPUT_DEFAULT_H
47:                  #define _PORTS_REMAPINPUT_DEFAULT_H
48:                  
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PORTS_RemapInput_default
52:                  
53:                    Summary:
54:                      Implements default variant of PLIB_PORTS_RemapInput 
55:                  
56:                    Description:
57:                      This template implements the default variant of the PLIB_PORTS_RemapInput function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void PORTS_RemapInput_default( PORTS_MODULE_ID      index , PORTS_REMAP_INPUT_FUNCTION inputFunction , PORTS_REMAP_INPUT_PIN      remapInputPin )
61:                  {
62:                      *(&INT1R + inputFunction) = ( ( *((SFR_TYPE *)(&INT1R + inputFunction)) ) & ~(_INT1R_INT1R_MASK) ) | ( (_INT1R_INT1R_MASK) & ((remapInputPin)<<(_INT1R_INT1R_POSITION)) );
00000034  00000000   NOP
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PORTS_ExistsRemapInput_default
68:                  
69:                    Summary:
70:                      Implements default variant of PLIB_PORTS_ExistsRemapInput
71:                  
72:                    Description:
73:                      This template implements the default variant of the PLIB_PORTS_ExistsRemapInput function.
74:                  */
75:                  
76:                  #define PLIB_PORTS_ExistsRemapInput PLIB_PORTS_ExistsRemapInput
77:                  PLIB_TEMPLATE bool PORTS_ExistsRemapInput_default( PORTS_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  #endif /*_PORTS_REMAPINPUT_DEFAULT_H*/
84:                  
85:                  /******************************************************************************
86:                   End of File
87:                  */
88:                  
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_portswrite_mcu32_pps.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsWrite_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsWrite
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinWrite
16:                          PLIB_PORTS_PinSet
17:                          PLIB_PORTS_PinClear
18:                          PLIB_PORTS_PinToggle
19:                          PLIB_PORTS_Write
20:                          PLIB_PORTS_Set
21:                          PLIB_PORTS_Toggle
22:                          PLIB_PORTS_Clear
23:                          PLIB_PORTS_ExistsPortsWrite
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _PORTS_PORTSWRITE_MCU32_PPS_H
54:                  #define _PORTS_PORTSWRITE_MCU32_PPS_H
55:                  
56:                  
57:                  //******************************************************************************
58:                  /* Function :  PORTS_PinWrite_MCU32_PPS
59:                  
60:                    Summary:
61:                      Implements MCU32_PPS variant of PLIB_PORTS_PinWrite 
62:                  
63:                    Description:
64:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinWrite function.
65:                  */
66:                  
67:                  PLIB_TEMPLATE void PORTS_PinWrite_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos , bool            value )
68:                  {
69:                      /* Atomic Implementation */
70:                      if(value == true)
9D01699C  10A00006   BEQ A1, ZERO, 0x9D0169B8
9D0169A0  24032000   ADDIU V1, ZERO, 8192
00000000  00000000   NOP
00000004  00000000   NOP
00000030  00000000   NOP
000000B0  00000000   NOP
71:                      {
72:                          *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
9D0169A4  3C02BF86   LUI V0, -16506
9D0169A8  24420138   ADDIU V0, V0, 312
9D0169AC  AC430500   SW V1, 1280(V0)
9D0169B0  03E00008   JR RA
9D0169B4  00000000   NOP
00000008  00000000   NOP
0000000C  00000000   NOP
00000038  00000000   NOP
000000BC  00000000   NOP
73:                      }
74:                      else
75:                      {
76:                          *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;
9D000134  24032000   ADDIU V1, ZERO, 8192
9D0169B8  3C02BF86   LUI V0, -16506
0000001C  00000000   NOP
00000038  00000000   NOP
00000068  00000000   NOP
000000E8  00000000   NOP
77:                      }
78:                  }
79:                  
80:                  
81:                  //******************************************************************************
82:                  /* Function :  PORTS_PinSet_MCU32_PPS
83:                  
84:                    Summary:
85:                      Implements MCU32_PPS variant of PLIB_PORTS_PinSet 
86:                  
87:                    Description:
88:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinSet function.
89:                  */
90:                  
91:                  PLIB_TEMPLATE void PORTS_PinSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
92:                  {
93:                  
94:                      *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
9D01423C  3C039D01   LUI V1, -25343
9D014240  246364E0   ADDIU V1, V1, 25824
9D014244  7C64180A   LWX V1, A0(V1)
9D014248  3C0203FF   LUI V0, 1023
9D01424C  3442FFFF   ORI V0, V0, -1
9D014250  00621821   ADDU V1, V1, V0
9D014254  00031A00   SLL V1, V1, 8
9D014258  3C02BF86   LUI V0, -16506
9D01425C  24420138   ADDIU V0, V0, 312
9D014260  00431021   ADDU V0, V0, V1
9D014264  3C039D01   LUI V1, -25343
9D014268  246364C8   ADDIU V1, V1, 25800
9D01426C  7C64200A   LWX A0, A0(V1)
9D014270  24030001   ADDIU V1, ZERO, 1
9D014274  00832004   SLLV A0, V1, A0
9D014278  AC440000   SW A0, 0(V0)
9D01427C  03E00008   JR RA
9D014280  00000000   NOP
9D014330  3C039D01   LUI V1, -25343
00000000  00000000   NOP
95:                      
96:                  }
97:                  
98:                  
99:                  //******************************************************************************
100:                 /* Function :  PORTS_PinClear_MCU32_PPS
101:                 
102:                   Summary:
103:                     Implements MCU32_PPS variant of PLIB_PORTS_PinClear 
104:                 
105:                   Description:
106:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinClear function.
107:                 */
108:                 
109:                 PLIB_TEMPLATE void PORTS_PinClear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
110:                 {
111:                 	
112:                     *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;	
9D014284  3C039D01   LUI V1, -25343
9D0142E8  3C039D01   LUI V1, -25343
9D0142EC  246364E0   ADDIU V1, V1, 25824
9D0142F0  7C64180A   LWX V1, A0(V1)
9D0142F4  3C0203FF   LUI V0, 1023
9D0142F8  3442FFFF   ORI V0, V0, -1
9D0142FC  00621821   ADDU V1, V1, V0
9D014300  00031A00   SLL V1, V1, 8
9D014304  3C02BF86   LUI V0, -16506
9D014308  24420134   ADDIU V0, V0, 308
9D01430C  00431021   ADDU V0, V0, V1
9D014310  3C039D01   LUI V1, -25343
9D014314  246364C8   ADDIU V1, V1, 25800
9D014318  7C64200A   LWX A0, A0(V1)
9D01431C  24030001   ADDIU V1, ZERO, 1
9D014320  00832004   SLLV A0, V1, A0
9D014324  AC440000   SW A0, 0(V0)
9D014328  03E00008   JR RA
9D01432C  00000000   NOP
113:                 						   
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_PinToggle_MCU32_PPS
119:                 
120:                   Summary:
121:                     Implements MCU32_PPS variant of PLIB_PORTS_PinToggle 
122:                 
123:                   Description:
124:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinToggle function.
125:                 */
126:                 
127:                 PLIB_TEMPLATE void PORTS_PinToggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
128:                 {
129:                 
130:                     *(&LATBINV + (channel - 1) * 0x40) = 1<<bitPos;
00000000  00000000   NOP
00000004  00000000   NOP
131:                 						   
132:                 }
133:                 
134:                 
135:                 //******************************************************************************
136:                 /* Function :  PORTS_Write_MCU32_PPS
137:                 
138:                   Summary:
139:                     Implements MCU32_PPS variant of PLIB_PORTS_Write 
140:                 
141:                   Description:
142:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Write function.
143:                 */
144:                 
145:                 PLIB_TEMPLATE void PORTS_Write_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value )
146:                 {
147:                     *(&LATB + (channel - 1) * 0x40) = value;
9D0100F0  3C19BF86   LUI T9, -16506
9D0100F4  27290130   ADDIU T1, T9, 304
9D0100F8  AD20FF00   SW ZERO, -256(T1)
9D010158  AF200130   SW ZERO, 304(T9)
9D010180  AD200100   SW ZERO, 256(T1)
9D0101A0  AD200200   SW ZERO, 512(T1)
9D0101C4  AD200300   SW ZERO, 768(T1)
9D0101EC  AD200400   SW ZERO, 1024(T1)
9D010210  AD200500   SW ZERO, 1280(T1)
00000000  00000000   NOP
148:                 }
149:                 
150:                 
151:                 //******************************************************************************
152:                 /* Function :  PORTS_Set_MCU32_PPS
153:                 
154:                   Summary:
155:                     Implements MCU32_PPS variant of PLIB_PORTS_Set 
156:                 
157:                   Description:
158:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Set function.
159:                 */
160:                 
161:                 PLIB_TEMPLATE void PORTS_Set_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value , PORTS_DATA_MASK mask )
162:                 {
163:                     
164:                     *(&LATBSET + (channel - 1) * 0x40) = (value & mask);
165:                 	
166:                 }
167:                 
168:                 
169:                 //******************************************************************************
170:                 /* Function :  PORTS_Toggle_MCU32_PPS
171:                 
172:                   Summary:
173:                     Implements MCU32_PPS variant of PLIB_PORTS_Toggle 
174:                 
175:                   Description:
176:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Toggle function.
177:                 */
178:                 
179:                 PLIB_TEMPLATE void PORTS_Toggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK toggleMask )
180:                 {
181:                     *(&LATBINV + (channel - 1) * 0x40) = toggleMask;
182:                 }
183:                 
184:                 
185:                 //******************************************************************************
186:                 /* Function :  PORTS_Clear_MCU32_PPS
187:                 
188:                   Summary:
189:                     Implements MCU32_PPS variant of PLIB_PORTS_Clear 
190:                 
191:                   Description:
192:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Clear function.
193:                 */
194:                 
195:                 PLIB_TEMPLATE void PORTS_Clear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK clearMask )
196:                 {
197:                     
198:                     *(&LATBCLR + (channel - 1) * 0x40) = clearMask;	
00000004  00000000   NOP
199:                 						 
200:                 }
201:                 
202:                 
203:                 //******************************************************************************
204:                 /* Function :  PORTS_ExistsPortsWrite_MCU32_PPS
205:                 
206:                   Summary:
207:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsWrite
208:                 
209:                   Description:
210:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsWrite function.
211:                 */
212:                 
213:                 #define PLIB_PORTS_ExistsPortsWrite PLIB_PORTS_ExistsPortsWrite
214:                 PLIB_TEMPLATE bool PORTS_ExistsPortsWrite_MCU32_PPS( PORTS_MODULE_ID index )
215:                 {
216:                     return true;
217:                 }
218:                 
219:                 
220:                 #endif /*_PORTS_PORTSWRITE_MCU32_PPS_H*/
221:                 
222:                 /******************************************************************************
223:                  End of File
224:                 */
225:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_portsread_mcu32_pps.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsRead_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsRead
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinGet
16:                          PLIB_PORTS_Read
17:                          PLIB_PORTS_ExistsPortsRead
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PORTSREAD_MCU32_PPS_H
48:                  #define _PORTS_PORTSREAD_MCU32_PPS_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinGet_MCU32_PPS
53:                  
54:                    Summary:
55:                      Implements MCU32_PPS variant of PLIB_PORTS_PinGet 
56:                  
57:                    Description:
58:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool PORTS_PinGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
62:                  {
63:                      return (bool)((*(&PORTB + ((channel - 1) * 0x40)) >> bitPos) & 1);
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_Read_MCU32_PPS
69:                  
70:                    Summary:
71:                      Implements MCU32_PPS variant of PLIB_PORTS_Read 
72:                  
73:                    Description:
74:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_Read function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE PORTS_DATA_TYPE PORTS_Read_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
78:                  {
79:                      return (*(&PORTB + ((channel - 1) * 0x40)));
00000000  00000000   NOP
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsPortsRead_MCU32_PPS
85:                  
86:                    Summary:
87:                      Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsRead
88:                  
89:                    Description:
90:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsRead function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsPortsRead PLIB_PORTS_ExistsPortsRead
94:                  PLIB_TEMPLATE bool PORTS_ExistsPortsRead_MCU32_PPS( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_PORTSREAD_MCU32_PPS_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsOpenDrain_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsOpenDrain
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinOpenDrainEnable
16:                          PLIB_PORTS_PinOpenDrainDisable
17:                          PLIB_PORTS_OpenDrainEnable
18:                          PLIB_PORTS_OpenDrainDisable
19:                          PLIB_PORTS_ExistsPortsOpenDrain
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
50:                  #define _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
51:                  
52:                  
53:                  
54:                  
55:                  //******************************************************************************
56:                  /* Function :  PORTS_PinOpenDrainEnable_MCU32_PPS
57:                  
58:                    Summary:
59:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainEnable 
60:                  
61:                    Description:
62:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainEnable function.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void PORTS_PinOpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
66:                  {
67:                      *(&ODCBSET + (channel - 1) * 0x40) = 1<<bitPos;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  PORTS_PinOpenDrainDisable_MCU32_PPS
73:                  
74:                    Summary:
75:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainDisable 
76:                  
77:                    Description:
78:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainDisable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void PORTS_PinOpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
82:                  {
83:                      *(&ODCBCLR + (channel - 1) * 0x40) = 1<<bitPos;
00000000  00000000   NOP
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  PORTS_OpenDrainEnable_MCU32_PPS
89:                  
90:                    Summary:
91:                      Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainEnable 
92:                  
93:                    Description:
94:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainEnable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void PORTS_OpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
98:                  {
99:                      *(&ODCBSET + (channel - 1) * 0x40) = mask;
9D0100E4  3C10BF86   LUI S0, -16506
9D0100E8  260A0148   ADDIU T2, S0, 328
9D0100EC  AD40FF00   SW ZERO, -256(T2)
9D010154  AE000148   SW ZERO, 328(S0)
9D01017C  AD400100   SW ZERO, 256(T2)
9D01019C  AD400200   SW ZERO, 512(T2)
9D0101C0  AD400300   SW ZERO, 768(T2)
9D0101E8  AD400400   SW ZERO, 1024(T2)
9D01020C  AD400500   SW ZERO, 1280(T2)
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  PORTS_OpenDrainDisable_MCU32_PPS
105:                 
106:                   Summary:
107:                     Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainDisable 
108:                 
109:                   Description:
110:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainDisable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void PORTS_OpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
114:                 {
115:                     *(&ODCBCLR + (channel - 1) * 0x40) = mask;
00000004  00000000   NOP
116:                 }
117:                 
118:                 
119:                 //******************************************************************************
120:                 /* Function :  PORTS_ExistsPortsOpenDrain_MCU32_PPS
121:                 
122:                   Summary:
123:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsOpenDrain
124:                 
125:                   Description:
126:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsOpenDrain function.
127:                 */
128:                 
129:                 #define PLIB_PORTS_ExistsPortsOpenDrain PLIB_PORTS_ExistsPortsOpenDrain
130:                 PLIB_TEMPLATE bool PORTS_ExistsPortsOpenDrain_MCU32_PPS( PORTS_MODULE_ID index )
131:                 {
132:                     return true;
133:                 }
134:                 
135:                 
136:                 #endif /*_PORTS_PORTSOPENDRAIN_MCU32_PPS_H*/
137:                 
138:                 /******************************************************************************
139:                  End of File
140:                 */
141:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_portsdirection_mcu32_pps.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsDirection_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsDirection
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinDirectionInputSet
16:                          PLIB_PORTS_PinDirectionOutputSet
17:                          PLIB_PORTS_DirectionInputSet
18:                          PLIB_PORTS_DirectionOutputSet
19:                          PLIB_PORTS_DirectionGet
20:                          PLIB_PORTS_ExistsPortsDirection
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _PORTS_PORTSDIRECTION_MCU32_PPS_H
51:                  #define _PORTS_PORTSDIRECTION_MCU32_PPS_H
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinDirectionInputSet_MCU32_PPS
56:                  
57:                    Summary:
58:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionInputSet 
59:                  
60:                    Description:
61:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionInputSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinDirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
65:                  {
66:                      *(&TRISBSET + (channel - 1) * 0x40) = 1<<bitPos;
00000034  00000000   NOP
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinDirectionOutputSet_MCU32_PPS
72:                  
73:                    Summary:
74:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionOutputSet 
75:                  
76:                    Description:
77:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionOutputSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinDirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
81:                  {
82:                      *(&TRISBCLR + (channel - 1) * 0x40) = 1<<bitPos;
00000008  00000000   NOP
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_DirectionInputSet_MCU32_PPS
88:                  
89:                    Summary:
90:                      Implements MCU32_PPS variant of PLIB_PORTS_DirectionInputSet 
91:                  
92:                    Description:
93:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionInputSet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_DirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
97:                  {
98:                      *(&TRISBSET + (channel - 1) * 0x40) = mask;
0000000C  00000000   NOP
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_DirectionOutputSet_MCU32_PPS
104:                 
105:                   Summary:
106:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionOutputSet 
107:                 
108:                   Description:
109:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionOutputSet function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_DirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
113:                 {
114:                     *(&TRISBCLR + (channel - 1) * 0x40) = mask;
9D0100FC  3C18BF86   LUI T8, -16506
9D010100  27080114   ADDIU T0, T8, 276
9D010104  24020021   ADDIU V0, ZERO, 33
9D010108  AD02FF00   SW V0, -256(T0)
9D01015C  3419C023   ORI T9, ZERO, -16349
9D010160  AF190114   SW T9, 276(T8)
9D010184  AD000100   SW ZERO, 256(T0)
9D0101A4  AD000200   SW ZERO, 512(T0)
9D0101C8  240B00D8   ADDIU T3, ZERO, 216
9D0101CC  AD0B0300   SW T3, 768(T0)
9D0101F0  AD000400   SW ZERO, 1024(T0)
9D010214  24092000   ADDIU T1, ZERO, 8192
9D010218  AD090500   SW T1, 1280(T0)
00000034  00000000   NOP
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_DirectionGet_MCU32_PPS
120:                 
121:                   Summary:
122:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionGet 
123:                 
124:                   Description:
125:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE PORTS_DATA_MASK PORTS_DirectionGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
129:                 {
130:                     return ( *(&TRISB + (channel - 1) * 0x40) );
00000000  00000000   NOP
131:                 }
132:                 
133:                 
134:                 //******************************************************************************
135:                 /* Function :  PORTS_ExistsPortsDirection_MCU32_PPS
136:                 
137:                   Summary:
138:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsDirection
139:                 
140:                   Description:
141:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsDirection function.
142:                 */
143:                 
144:                 #define PLIB_PORTS_ExistsPortsDirection PLIB_PORTS_ExistsPortsDirection
145:                 PLIB_TEMPLATE bool PORTS_ExistsPortsDirection_MCU32_PPS( PORTS_MODULE_ID index )
146:                 {
147:                     return true;
148:                 }
149:                 
150:                 
151:                 #endif /*_PORTS_PORTSDIRECTION_MCU32_PPS_H*/
152:                 
153:                 /******************************************************************************
154:                  End of File
155:                 */
156:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_pinmodeperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinModePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinModePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinModePerPortSelect
16:                          PLIB_PORTS_ChannelModeSelect
17:                          PLIB_PORTS_ExistsPinModePerPort
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PINMODEPERPORT_DEFAULT_H
48:                  #define _PORTS_PINMODEPERPORT_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinModePerPortSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_PinModePerPortSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_PinModePerPortSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_PinModePerPortSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos , PORTS_PIN_MODE   mode )
62:                  {
63:                      if ( mode == PORTS_PIN_MODE_ANALOG )
64:                  	{
65:                          *(&ANSELBSET + (channel - 1) * 0x40) = 1<<bitPos;	
66:                  	}
67:                  	else
68:                  	{
69:                          *(&ANSELBCLR + (channel - 1) * 0x40) = 1<<bitPos;
70:                  	}
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  PORTS_ChannelModeSelect_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_PORTS_ChannelModeSelect 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the PLIB_PORTS_ChannelModeSelect function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void PORTS_ChannelModeSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK   modeMask , PORTS_PIN_MODE mode )
85:                  {
86:                      if ( mode == PORTS_PIN_MODE_ANALOG )
87:                  	{
88:                          *(&ANSELBSET + (channel - 1) * 0x40) = modeMask;	
89:                  	}
90:                  	else
91:                  	{
92:                          *(&ANSELBCLR + (channel - 1) * 0x40) = modeMask;
9D01011C  3C0EBF86   LUI T6, -16506
9D010120  25C60104   ADDIU A2, T6, 260
9D010124  3403C0FD   ORI V1, ZERO, -16131
9D010128  ACC3FF00   SW V1, -256(A2)
9D010168  240F0023   ADDIU T7, ZERO, 35
9D01016C  ADCF0104   SW T7, 260(T6)
9D01018C  ACC00100   SW ZERO, 256(A2)
9D0101AC  240B3E3F   ADDIU T3, ZERO, 15935
9D0101B0  ACCB0200   SW T3, 512(A2)
9D0101D4  240B005F   ADDIU T3, ZERO, 95
9D0101D8  ACCB0300   SW T3, 768(A2)
9D0101F8  240B013F   ADDIU T3, ZERO, 319
9D0101FC  ACCB0400   SW T3, 1024(A2)
9D010220  24027003   ADDIU V0, ZERO, 28675
9D010224  ACC20500   SW V0, 1280(A2)
93:                  	}
94:                  }
95:                  
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PORTS_ExistsPinModePerPort_Default
99:                  
100:                   Summary:
101:                     Implements Default variant of PLIB_PORTS_ExistsPinModePerPort
102:                 
103:                   Description:
104:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinModePerPort function.
105:                 */
106:                 
107:                 #define PLIB_PORTS_ExistsPinModePerPort PLIB_PORTS_ExistsPinModePerPort
108:                 PLIB_TEMPLATE bool PORTS_ExistsPinModePerPort_Default( PORTS_MODULE_ID index )
109:                 {
110:                     return true;
111:                 }
112:                 
113:                 
114:                 #endif /*_PORTS_PINMODEPERPORT_DEFAULT_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_pinmode_pps.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinMode_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinMode
13:                      and its Variant : PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinModeSelect
16:                          PLIB_PORTS_ExistsPinMode
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_PINMODE_PPS_H
47:                  #define _PORTS_PINMODE_PPS_H
48:                  
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinModeSelect_PPS
53:                  
54:                    Summary:
55:                      Implements PPS variant of PLIB_PORTS_PinModeSelect 
56:                  
57:                    Description:
58:                      This template implements the PPS variant of the PLIB_PORTS_PinModeSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_PinModeSelect_PPS( PORTS_MODULE_ID  index , PORTS_ANALOG_PIN pin , PORTS_PIN_MODE   mode )
62:                  {
63:                  
64:                  uint8_t channel, bitPos;
65:                  
66:                      channel = pin/16;
00000000  00000000   NOP
67:                      bitPos = pin % 16;
68:                  
69:                      if ( mode == PORTS_PIN_MODE_ANALOG )
00000004  00000000   NOP
70:                  	{
71:                          *(&ANSELBSET + (channel - 1) * 0x40) = 1<<bitPos;
00000010  00000000   NOP
72:                  	}
73:                  	else
74:                  	{
75:                          *(&ANSELBCLR + (channel - 1) * 0x40) = 1<<bitPos;
0000003C  00000000   NOP
76:                  	}
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  PORTS_ExistsPinMode_PPS
81:                  
82:                    Summary:
83:                      Implements PPS variant of PLIB_PORTS_ExistsPinMode
84:                  
85:                    Description:
86:                      This template implements the PPS variant of the PLIB_PORTS_ExistsPinMode function.
87:                  */
88:                  
89:                  #define PLIB_PORTS_ExistsPinMode PLIB_PORTS_ExistsPinMode
90:                  PLIB_TEMPLATE bool PORTS_ExistsPinMode_PPS( PORTS_MODULE_ID index )
91:                  {
92:                      return true;
93:                  }
94:                  
95:                  
96:                  #endif /*_PORTS_PINMODE_PPS_H*/
97:                  
98:                  /******************************************************************************
99:                   End of File
100:                 */
101:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_pinchangenoticeperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinChangeNoticePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinChangeNoticePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinChangeNoticePerPortEnable
16:                          PLIB_PORTS_PinChangeNoticePerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticeEnable
18:                          PLIB_PORTS_ChannelChangeNoticeDisable
19:                          PLIB_PORTS_ExistsPinChangeNoticePerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
50:                  #define _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
51:                  
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinChangeNoticePerPortEnable_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortEnable 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortEnable function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
65:                  {
66:                      *(&CNENBSET + (channel - 1) * 0x40) = 1<<bitPos;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinChangeNoticePerPortDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
81:                  {
82:                      *(&CNENBCLR + (channel - 1) * 0x40) = 1<<bitPos;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_ChannelChangeNoticeEnable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticeEnable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeEnable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticeEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
97:                  {
98:                      *(&CNENBSET + (channel - 1) * 0x40) = mask;
9D01012C  3C0DBF86   LUI T5, -16506
9D010130  25A50188   ADDIU A1, T5, 392
9D010134  ACA0FF00   SW ZERO, -256(A1)
9D010170  ADA00188   SW ZERO, 392(T5)
9D010190  ACA00100   SW ZERO, 256(A1)
9D0101B4  ACA00200   SW ZERO, 512(A1)
9D0101DC  ACA00300   SW ZERO, 768(A1)
9D010200  ACA00400   SW ZERO, 1024(A1)
9D010228  ACA00500   SW ZERO, 1280(A1)
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_ChannelChangeNoticeDisable_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticeDisable 
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeDisable function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticeDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
113:                 {
114:                     *(&CNENBCLR + (channel - 1) * 0x40) = mask;
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_ExistsPinChangeNoticePerPort_Default
120:                 
121:                   Summary:
122:                     Implements Default variant of PLIB_PORTS_ExistsPinChangeNoticePerPort
123:                 
124:                   Description:
125:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinChangeNoticePerPort function.
126:                 */
127:                 
128:                 #define PLIB_PORTS_ExistsPinChangeNoticePerPort PLIB_PORTS_ExistsPinChangeNoticePerPort
129:                 PLIB_TEMPLATE bool PORTS_ExistsPinChangeNoticePerPort_Default( PORTS_MODULE_ID index )
130:                 {
131:                     return true;
132:                 }
133:                 
134:                 
135:                 #endif /*_PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H*/
136:                 
137:                 /******************************************************************************
138:                  End of File
139:                 */
140:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_latchread_mcu32_pps.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_LatchRead_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LatchRead
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinGetLatched
16:                          PLIB_PORTS_ReadLatched
17:                          PLIB_PORTS_ExistsLatchRead
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_LATCHREAD_MCU32_PPS_H
48:                  #define _PORTS_LATCHREAD_MCU32_PPS_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinGetLatched_MCU32_PPS
53:                  
54:                    Summary:
55:                      Implements MCU32_PPS variant of PLIB_PORTS_PinGetLatched 
56:                  
57:                    Description:
58:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinGetLatched function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool PORTS_PinGetLatched_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
62:                  {
63:                      return (bool)((*(&LATB + ((channel - 1) * 0x40)) >> bitPos) & 1);
00000004  00000000   NOP
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_ReadLatched_MCU32_PPS
69:                  
70:                    Summary:
71:                      Implements MCU32_PPS variant of PLIB_PORTS_ReadLatched 
72:                  
73:                    Description:
74:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_ReadLatched function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE PORTS_DATA_TYPE PORTS_ReadLatched_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
78:                  {
79:                      return (*(&LATB + ((channel - 1) * 0x40)));
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsLatchRead_MCU32_PPS
85:                  
86:                    Summary:
87:                      Implements MCU32_PPS variant of PLIB_PORTS_ExistsLatchRead
88:                  
89:                    Description:
90:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsLatchRead function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsLatchRead PLIB_PORTS_ExistsLatchRead
94:                  PLIB_TEMPLATE bool PORTS_ExistsLatchRead_MCU32_PPS( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_LATCHREAD_MCU32_PPS_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_changenoticepullupperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullUpPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullUpPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullUpPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullUpPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullUpEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullUpDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullUpPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullUpPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPUBSET + (channel - 1) * 0x40) = 1<<bitPos;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullUpPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPUBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  //******************************************************************************
85:                  /* Function :  PORTS_ChannelChangeNoticePullUpEnable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpEnable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpEnable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
95:                  {
96:                      *(&CNPUBSET + (channel - 1) * 0x40) = mask;
9D010138  3C0CBF86   LUI T4, -16506
9D01013C  25840158   ADDIU A0, T4, 344
9D010140  2403001C   ADDIU V1, ZERO, 28
9D010144  AC83FF00   SW V1, -256(A0)
9D010174  AD800158   SW ZERO, 344(T4)
9D010194  AC800100   SW ZERO, 256(A0)
9D0101B8  AC800200   SW ZERO, 512(A0)
9D0101E0  AC800300   SW ZERO, 768(A0)
9D010204  AC800400   SW ZERO, 1024(A0)
9D01022C  24021000   ADDIU V0, ZERO, 4096
9D010230  AC820500   SW V0, 1280(A0)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  PORTS_ChannelChangeNoticePullUpDisable_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpDisable 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpDisable function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
111:                 {
112:                     *(&CNPUBCLR + (channel - 1) * 0x40) = mask;
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  PORTS_ExistsChangeNoticePullUpPerPort_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullUpPerPort
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullUpPerPort function.
124:                 */
125:                 
126:                 #define PLIB_PORTS_ExistsChangeNoticePullUpPerPort PLIB_PORTS_ExistsChangeNoticePullUpPerPort
127:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullUpPerPort_Default( PORTS_MODULE_ID index )
128:                 {
129:                     return true;
130:                 }
131:                 
132:                 
133:                 #endif /*_PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_changenoticepulldownperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullDownPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullDownPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullDownPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullDownPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullDownEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullDownDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullDownPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullDownPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPDBSET + (channel - 1) * 0x40) = 1<<bitPos;
9D012ACC  24030008   ADDIU V1, ZERO, 8
9D012AD0  3C02BF86   LUI V0, -16506
9D012AD4  24420168   ADDIU V0, V0, 360
9D012AD8  AC430400   SW V1, 1024(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullDownPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPDBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  PORTS_ChannelChangeNoticePullDownEnable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownEnable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownEnable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
96:                  {
97:                      *(&CNPDBSET + (channel - 1) * 0x40) = mask;
9D010148  3C0BBF86   LUI T3, -16506
9D01014C  25630168   ADDIU V1, T3, 360
9D010150  AC60FF00   SW ZERO, -256(V1)
9D010178  AD600168   SW ZERO, 360(T3)
9D010198  AC600100   SW ZERO, 256(V1)
9D0101BC  AC600200   SW ZERO, 512(V1)
9D0101E4  AC600300   SW ZERO, 768(V1)
9D010208  AC600400   SW ZERO, 1024(V1)
9D010234  AC600500   SW ZERO, 1280(V1)
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  PORTS_ChannelChangeNoticePullDownDisable_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownDisable 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownDisable function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
112:                 {
113:                     *(&CNPDBCLR + (channel - 1) * 0x40) = mask;
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_ExistsChangeNoticePullDownPerPort_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullDownPerPort
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullDownPerPort function.
125:                 */
126:                 
127:                 #define PLIB_PORTS_ExistsChangeNoticePullDownPerPort PLIB_PORTS_ExistsChangeNoticePullDownPerPort
128:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullDownPerPort_Default( PORTS_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/ports/templates/ports_changenoticeperportturnon_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePerPortTurnOn_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePerPortTurnOn
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePerPortTurnOn
16:                          PLIB_PORTS_ChangeNoticePerPortTurnOff
17:                          PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
48:                  #define _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_ChangeNoticePerPortTurnOn_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOn 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOn function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
62:                  {
63:                      *(&CNCONBSET + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
9D01010C  3C0FBF86   LUI T7, -16506
9D010110  25E70178   ADDIU A3, T7, 376
9D010114  34028000   ORI V0, ZERO, -32768
9D010118  ACE2FF00   SW V0, -256(A3)
9D010164  ADE20178   SW V0, 376(T7)
9D010188  ACE20100   SW V0, 256(A3)
9D0101A8  ACE20200   SW V0, 512(A3)
9D0101D0  ACE20300   SW V0, 768(A3)
9D0101F4  ACE20400   SW V0, 1024(A3)
9D01021C  ACE20500   SW V0, 1280(A3)
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_ChangeNoticePerPortTurnOff_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOff 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOff function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOff_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
78:                  {
79:                      *(&CNCONBCLR + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsChangeNoticePerPortTurnOn_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePerPortTurnOn function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsChangeNoticePerPortTurnOn PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
94:                  PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/pcache/templates/pcache_waitstate_mz.h
1:                   /*******************************************************************************
2:                     PCACHE Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pcache_WaitState_MZ.h
6:                   
7:                     Summary:
8:                       PCACHE PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : WaitState
13:                      and its Variant : MZ
14:                      For following APIs :
15:                          PLIB_PCACHE_ExistsWaitState
16:                          PLIB_PCACHE_WaitStateSet
17:                          PLIB_PCACHE_WaitStateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PCACHE_WAITSTATE_MZ_H
48:                  #define _PCACHE_WAITSTATE_MZ_H
49:                  
50:                  #include "pcache_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  PCACHE_ExistsWaitState_MZ
54:                  
55:                    Summary:
56:                      Implements MZ variant of PLIB_PCACHE_ExistsWaitState
57:                  
58:                    Description:
59:                      This template implements the MZ variant of the PLIB_PCACHE_ExistsWaitState function.
60:                  */
61:                  
62:                  #define PLIB_PCACHE_ExistsWaitState PLIB_PCACHE_ExistsWaitState
63:                  #define PLIB_PCACHE_ExistsWaitState PLIB_PCACHE_ExistsWaitState
64:                  PLIB_TEMPLATE bool PCACHE_ExistsWaitState_MZ( PCACHE_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PCACHE_WaitStateSet_MZ
72:                  
73:                    Summary:
74:                      Implements MZ variant of PLIB_PCACHE_WaitStateSet 
75:                  
76:                    Description:
77:                      This template implements the MZ variant of the PLIB_PCACHE_WaitStateSet function.
78:                      Operation is not atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void PCACHE_WaitStateSet_MZ( PCACHE_MODULE_ID index , uint32_t clocks )
82:                  {
83:                      volatile pfm_register_t *regs = (pfm_register_t *)index;
84:                      regs->PRECON.PFMWS = clocks;
9D0122D8  3C02BF8E   LUI V0, -16498
9D0122DC  8C430000   LW V1, 0(V0)
9D0122E0  7CC31004   INS V1, A2, 0, 3
9D0122E4  AC430000   SW V1, 0(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  PCACHE_WaitStateGet_MZ
90:                  
91:                    Summary:
92:                      Implements MZ variant of PLIB_PCACHE_WaitStateGet 
93:                  
94:                    Description:
95:                      This template implements the MZ variant of the PLIB_PCACHE_WaitStateGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE uint32_t PCACHE_WaitStateGet_MZ( PCACHE_MODULE_ID index )
100:                 {
101:                     volatile pfm_register_t *regs = (pfm_register_t *)index;
102:                     return (uint32_t)(regs->PRECON.PFMWS);
103:                 }
104:                 
105:                 
106:                 #endif /*_PCACHE_WAITSTATE_MZ_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/pcache/templates/pcache_prefetchenable_mz.h
1:                   /*******************************************************************************
2:                     PCACHE Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pcache_PrefetchEnable_MZ.h
6:                   
7:                     Summary:
8:                       PCACHE PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PrefetchEnable
13:                      and its Variant : MZ
14:                      For following APIs :
15:                          PLIB_PCACHE_ExistsPrefetchEnable
16:                          PLIB_PCACHE_PrefetchEnableSet
17:                          PLIB_PCACHE_PrefetchEnableGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PCACHE_PREFETCHENABLE_MZ_H
48:                  #define _PCACHE_PREFETCHENABLE_MZ_H
49:                  
50:                  #include "pcache_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  PCACHE_ExistsPrefetchEnable_MZ
54:                  
55:                    Summary:
56:                      Implements MZ variant of PLIB_PCACHE_ExistsPrefetchEnable
57:                  
58:                    Description:
59:                      This template implements the MZ variant of the PLIB_PCACHE_ExistsPrefetchEnable function.
60:                  */
61:                  
62:                  #define PLIB_PCACHE_ExistsPrefetchEnable PLIB_PCACHE_ExistsPrefetchEnable
63:                  #define PLIB_PCACHE_ExistsPrefetchEnable PLIB_PCACHE_ExistsPrefetchEnable
64:                  PLIB_TEMPLATE bool PCACHE_ExistsPrefetchEnable_MZ( PCACHE_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PCACHE_PrefetchEnableSet_MZ
72:                  
73:                    Summary:
74:                      Implements MZ variant of PLIB_PCACHE_PrefetchEnableSet 
75:                  
76:                    Description:
77:                      This template implements the MZ variant of the PLIB_PCACHE_PrefetchEnableSet function.
78:                      Operation is not atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void PCACHE_PrefetchEnableSet_MZ( PCACHE_MODULE_ID index , PLIB_PCACHE_PREFETCH_ENABLE region )
82:                  {
83:                      volatile pfm_register_t *regs = (pfm_register_t *)index;
84:                      regs->PRECON.PREFEN = region;
9D01230C  3C02BF8E   LUI V0, -16498
9D012310  8C430000   LW V1, 0(V0)
9D012314  24050003   ADDIU A1, ZERO, 3
9D012318  7CA32904   INS V1, A1, 4, 2
9D01231C  AC430000   SW V1, 0(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  PCACHE_PrefetchEnableGet_MZ
90:                  
91:                    Summary:
92:                      Implements MZ variant of PLIB_PCACHE_PrefetchEnableGet 
93:                  
94:                    Description:
95:                      This template implements the MZ variant of the PLIB_PCACHE_PrefetchEnableGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE PLIB_PCACHE_PREFETCH_ENABLE PCACHE_PrefetchEnableGet_MZ( PCACHE_MODULE_ID index )
100:                 {
101:                     volatile pfm_register_t *regs = (pfm_register_t *)index;
102:                     return (PLIB_PCACHE_PREFETCH_ENABLE)(regs->PRECON.PREFEN);
103:                 }
104:                 
105:                 
106:                 #endif /*_PCACHE_PREFETCHENABLE_MZ_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/osc/templates/osc_secondaryenable_default.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_SecondaryEnable_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SecondaryEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsSecondaryEnable
16:                          PLIB_OSC_SecondaryEnable
17:                          PLIB_OSC_SecondaryDisable
18:                          PLIB_OSC_SecondaryIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_SECONDARYENABLE_DEFAULT_H
49:                  #define _OSC_SECONDARYENABLE_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsSecondaryEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OSC_ExistsSecondaryEnable
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OSC_ExistsSecondaryEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsSecondaryEnable PLIB_OSC_ExistsSecondaryEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsSecondaryEnable_Default( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_SecondaryEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_OSC_SecondaryEnable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_OSC_SecondaryEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_SecondaryEnable_Default( OSC_MODULE_ID index )
79:                  {
80:                      OSCCONSET = _OSCCON_SOSCEN_MASK;
9D016564  24030002   ADDIU V1, ZERO, 2
9D016568  3C02BF80   LUI V0, -16512
9D01656C  AC431208   SW V1, 4616(V0)
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_SecondaryDisable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_OSC_SecondaryDisable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_OSC_SecondaryDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_SecondaryDisable_Default( OSC_MODULE_ID index )
95:                  {
96:                      OSCCONCLR = _OSCCON_SOSCEN_MASK;
00000024  00000000   NOP
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_SecondaryIsEnabled_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_OSC_SecondaryIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_OSC_SecondaryIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_SecondaryIsEnabled_Default( OSC_MODULE_ID index )
111:                 {
112:                    return (bool)OSCCONbits.SOSCEN;
9D016540  3C02BF80   LUI V0, -16512
9D016544  8C421200   LW V0, 4608(V0)
9D016548  30420002   ANDI V0, V0, 2
00000000  00000000   NOP
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_SECONDARYENABLE_DEFAULT_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/osc/templates/osc_onwaitaction_default.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_OnWaitAction_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OnWaitAction
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsOnWaitAction
16:                          PLIB_OSC_OnWaitActionSet
17:                          PLIB_OSC_OnWaitActionGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_ONWAITACTION_DEFAULT_H
48:                  #define _OSC_ONWAITACTION_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  OSC_ExistsOnWaitAction_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_OSC_ExistsOnWaitAction
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_OSC_ExistsOnWaitAction function.
58:                  */
59:                  
60:                  #define PLIB_OSC_ExistsOnWaitAction PLIB_OSC_ExistsOnWaitAction
61:                  PLIB_TEMPLATE bool OSC_ExistsOnWaitAction_Default( OSC_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OSC_OnWaitActionSet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OSC_OnWaitActionSet 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OSC_OnWaitActionSet function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OSC_OnWaitActionSet_Default( OSC_MODULE_ID index , OSC_OPERATION_ON_WAIT onWait )
78:                  {
79:                      OSCCONbits.SLPEN = onWait;
00000018  00000000   NOP
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_OnWaitActionGet_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OSC_OnWaitActionGet 
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OSC_OnWaitActionGet function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE OSC_OPERATION_ON_WAIT OSC_OnWaitActionGet_Default( OSC_MODULE_ID index )
94:                  {
95:                      return (OSC_OPERATION_ON_WAIT)OSCCONbits.SLPEN;
96:                  }
97:                  
98:                  
99:                  #endif /*_OSC_ONWAITACTION_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/int/templates/int_vectorselect_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorSelect
16:                          PLIB_INT_MultiVectorSelect
17:                          PLIB_INT_SingleVectorSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_VECTORSELECT_DEFAULT_H
48:                  #define _INT_VECTORSELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  INT_ExistsVectorSelect_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_INT_ExistsVectorSelect
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_INT_ExistsVectorSelect function.
58:                  */
59:                  #define PLIB_INT_ExistsVectorSelect PLIB_INT_ExistsVectorSelect
60:                  PLIB_TEMPLATE bool INT_ExistsVectorSelect_Default( INT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  INT_MultiVectorSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_INT_MultiVectorSelect 
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_INT_MultiVectorSelect function.
73:                  */
74:                  PLIB_TEMPLATE void INT_MultiVectorSelect_Default( INT_MODULE_ID index )
75:                  {
76:                      INTCONSET = _INTCON_MVEC_MASK;
9D017290  24031000   ADDIU V1, ZERO, 4096
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  INT_SingleVectorSelect_Default
81:                  
82:                    Summary:
83:                      Implements Default variant of PLIB_INT_SingleVectorSelect 
84:                  
85:                    Description:
86:                      This template implements the Default variant of the PLIB_INT_SingleVectorSelect function.
87:                  */
88:                  PLIB_TEMPLATE void INT_SingleVectorSelect_Default( INT_MODULE_ID index )
89:                  {
90:                      INTCONCLR = _INTCON_MVEC_MASK;
91:                  }
92:                  
93:                  #endif /*_INT_VECTORSELECT_DEFAULT_H*/
94:                  
95:                  /******************************************************************************
96:                   End of File
97:                  */
98:                  
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/int/templates/int_vectorpriority_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorPriority_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorPriority
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorPriority
16:                          PLIB_INT_VectorPrioritySet
17:                          PLIB_INT_VectorPriorityGet
18:                          PLIB_INT_VectorSubPrioritySet
19:                          PLIB_INT_VectorSubPriorityGet
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _INT_VECTORPRIORITY_DEFAULT_H
50:                  #define _INT_VECTORPRIORITY_DEFAULT_H
51:                  
52:                  //******************************************************************************
53:                  /* Function :  INT_ExistsVectorPriority_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_INT_ExistsVectorPriority
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_INT_ExistsVectorPriority function.
60:                  */
61:                  #define PLIB_INT_ExistsVectorPriority PLIB_INT_ExistsVectorPriority
62:                  PLIB_TEMPLATE bool INT_ExistsVectorPriority_Default( INT_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  //******************************************************************************
68:                  /* Function :  INT_VectorPrioritySet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_INT_VectorPrioritySet 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_INT_VectorPrioritySet function.
75:                  
76:                    Note:
77:                      The algorithm to calculate and write the field location has changed to use
78:                      actual vector numbers. The enumeration for INT_VECTOR should now match the
79:                      names to the actual vector numbers.
80:                  */
81:                  PLIB_TEMPLATE void INT_VectorPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_PRIORITY_LEVEL priority )
82:                  {
83:                      volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
84:                      uint32_t mask = 0x07 << ((vector & 0x03) * 8 + 2);
85:                      uint32_t position = (vector & 0x03) * 8 + 2;
86:                  
87:                      /* read-modify-write */
88:                      *IPCx &= ~mask;
9D00CC94  26100140   ADDIU S0, S0, 320
9D00CC98  8E020020   LW V0, 32(S0)
9D00CC9C  2413E3FF   ADDIU S3, ZERO, -7169
9D00CCA0  00531024   AND V0, V0, S3
9D00CCA4  AE020020   SW V0, 32(S0)
9D00CCCC  8E0201F0   LW V0, 496(S0)
9D00CCD0  2415FFE3   ADDIU S5, ZERO, -29
9D00CCD4  00551024   AND V0, V0, S5
9D00CCD8  AE0201F0   SW V0, 496(S0)
9D00CD00  8E030030   LW V1, 48(S0)
9D00CD04  3C02FFE3   LUI V0, -29
9D00CD08  3442FFFF   ORI V0, V0, -1
9D00CD0C  00621024   AND V0, V1, V0
9D00CD10  AE020030   SW V0, 48(S0)
9D00CD40  8E030040   LW V1, 64(S0)
9D00CD44  3C02E3FF   LUI V0, -7169
9D00CD48  3442FFFF   ORI V0, V0, -1
9D00CD4C  00621024   AND V0, V1, V0
9D00CD50  AE020040   SW V0, 64(S0)
9D00CDCC  8E020210   LW V0, 528(S0)
9D00CDD0  0055A824   AND S5, V0, S5
9D00CDD4  AE150210   SW S5, 528(S0)
9D00CDF8  8E020210   LW V0, 528(S0)
9D00CDFC  00539824   AND S3, V0, S3
9D00CE00  AE130210   SW S3, 528(S0)
0000038C  00000000   NOP
89:                      *IPCx |= (priority << position) & mask;
9D00CCA8  8E020020   LW V0, 32(S0)
9D00CCAC  34421000   ORI V0, V0, 4096
9D00CCB0  AE020020   SW V0, 32(S0)
9D00CCDC  8E0201F0   LW V0, 496(S0)
9D00CCE0  34420004   ORI V0, V0, 4
9D00CCE4  AE0201F0   SW V0, 496(S0)
9D00CD14  8E030030   LW V1, 48(S0)
9D00CD18  3C020018   LUI V0, 24
9D00CD1C  00621025   OR V0, V1, V0
9D00CD20  AE020030   SW V0, 48(S0)
9D00CD54  8E030040   LW V1, 64(S0)
9D00CD58  3C020400   LUI V0, 1024
9D00CD5C  00621025   OR V0, V1, V0
9D00CD60  AE020040   SW V0, 64(S0)
9D00CDD8  8E020210   LW V0, 528(S0)
9D00CDDC  34420010   ORI V0, V0, 16
9D00CDE0  AE020210   SW V0, 528(S0)
9D00CE04  8E020210   LW V0, 528(S0)
9D00CE08  34421000   ORI V0, V0, 4096
9D00CE0C  AE020210   SW V0, 528(S0)
000003A4  00000000   NOP
90:                  }
91:                  
92:                  //******************************************************************************
93:                  /* Function :  INT_VectorPriorityGet_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_INT_VectorPriorityGet 
97:                  
98:                    Description:
99:                      This template implements the Default variant of the PLIB_INT_VectorPriorityGet function.
100:                 
101:                   Note:
102:                     The algorithm to calculate and write the field location has changed to use
103:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
104:                     names to the actual vector numbers.
105:                 */
106:                 PLIB_TEMPLATE INT_PRIORITY_LEVEL INT_VectorPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
107:                 {
108:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
109:                     uint32_t mask = 0x07 << (((vector & 0x03) * 8) + 2);
110:                     uint32_t position = (((vector & 0x03) * 8) + 2);
111:                 
112:                     return (INT_PRIORITY_LEVEL) ((*IPCx & mask) >> position);
113:                 }
114:                 
115:                 //******************************************************************************
116:                 /* Function :  INT_VectorSubPrioritySet_Default
117:                 
118:                   Summary:
119:                     Implements Default variant of PLIB_INT_VectorSubPrioritySet 
120:                 
121:                   Description:
122:                     This template implements the Default variant of the PLIB_INT_VectorSubPrioritySet function.
123:                 
124:                   Note:
125:                     The algorithm to calculate and write the field location has changed to use
126:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
127:                     names to the actual vector numbers.
128:                 */
129:                 PLIB_TEMPLATE void INT_VectorSubPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_SUBPRIORITY_LEVEL subPriority )
130:                 {
131:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
132:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
133:                     uint32_t position = (vector & 0x03) * 8;
134:                 
135:                     /* read-modify-write */
136:                     *IPCx &= ~mask; /* zeroed mask */
9D00CCB4  8E020020   LW V0, 32(S0)
9D00CCB8  2412FCFF   ADDIU S2, ZERO, -769
9D00CCBC  00521024   AND V0, V0, S2
9D00CCC0  AE020020   SW V0, 32(S0)
9D00CCE8  8E0201F0   LW V0, 496(S0)
9D00CCEC  2414FFFC   ADDIU S4, ZERO, -4
9D00CCF0  00541024   AND V0, V0, S4
9D00CCF4  AE0201F0   SW V0, 496(S0)
9D00CD24  8E030030   LW V1, 48(S0)
9D00CD28  3C02FFFC   LUI V0, -4
9D00CD2C  3442FFFF   ORI V0, V0, -1
9D00CD30  00621024   AND V0, V1, V0
9D00CD34  AE020030   SW V0, 48(S0)
9D00CD64  8E030040   LW V1, 64(S0)
9D00CD68  3C02FCFF   LUI V0, -769
9D00CD6C  3442FFFF   ORI V0, V0, -1
9D00CD70  00621024   AND V0, V1, V0
9D00CD74  AE020040   SW V0, 64(S0)
9D00CDE4  8E020210   LW V0, 528(S0)
9D00CDE8  0054A024   AND S4, V0, S4
9D00CDEC  AE140210   SW S4, 528(S0)
9D00CE10  8E020210   LW V0, 528(S0)
9D00CE14  00529024   AND S2, V0, S2
9D00CE18  AE120210   SW S2, 528(S0)
000003B0  00000000   NOP
137:                     *IPCx |= (subPriority << position) & mask; /* set value */
9D00CCC4  8E020020   LW V0, 32(S0)
9D00CCC8  AE020020   SW V0, 32(S0)
9D00CCF8  8E0201F0   LW V0, 496(S0)
9D00CCFC  AE0201F0   SW V0, 496(S0)
9D00CD38  8E020030   LW V0, 48(S0)
9D00CD3C  AE020030   SW V0, 48(S0)
9D00CD78  8E020040   LW V0, 64(S0)
9D00CD7C  AE020040   SW V0, 64(S0)
9D00CDF0  8E020210   LW V0, 528(S0)
9D00CDF4  AE020210   SW V0, 528(S0)
9D00CE1C  8E020210   LW V0, 528(S0)
9D00CE20  AE020210   SW V0, 528(S0)
000003C0  00000000   NOP
138:                 }
139:                 
140:                 //******************************************************************************
141:                 /* Function :  INT_VectorSubPriorityGet_Default
142:                 
143:                   Summary:
144:                     Implements Default variant of PLIB_INT_VectorSubPriorityGet 
145:                 
146:                   Description:
147:                     This template implements the Default variant of the PLIB_INT_VectorSubPriorityGet function.
148:                 
149:                   Note:
150:                     The algorithm to calculate and write the field location has changed to use
151:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
152:                     names to the actual vector numbers.
153:                 */
154:                 PLIB_TEMPLATE INT_SUBPRIORITY_LEVEL INT_VectorSubPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
155:                 {
156:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
157:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
158:                     uint32_t position = (vector & 0x03) * 8;
159:                 
160:                     return (INT_SUBPRIORITY_LEVEL) ((*IPCx & mask) >> position);
161:                 }
162:                 
163:                 #endif /*_INT_VECTORPRIORITY_DEFAULT_H*/
164:                 
165:                 /******************************************************************************
166:                  End of File
167:                 */
168:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/int/templates/int_sourceflag_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceFlag_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceFlag
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceFlag
16:                          PLIB_INT_SourceFlagGet
17:                          PLIB_INT_SourceFlagSet
18:                          PLIB_INT_SourceFlagClear
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCEFLAG_DEFAULT_H
49:                  #define _INT_SOURCEFLAG_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceFlag_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceFlag
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceFlag function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceFlag PLIB_INT_ExistsSourceFlag
61:                  PLIB_TEMPLATE bool INT_ExistsSourceFlag_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceFlagGet_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceFlagGet 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceFlagGet function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE bool INT_SourceFlagGet_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IFSx = (volatile uint32_t *)(&IFS0 + ((0x10 * (source / 32)) / 4));
9D0138B0  00022142   SRL A0, V0, 5
82:                  
83:                      return (bool)((*IFSx >> (source & 0x1f)) & 0x1);
9D0138C4  8C640000   LW A0, 0(V1)
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  INT_SourceFlagSet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_INT_SourceFlagSet 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_INT_SourceFlagSet function.
94:                  
95:                    Note:
96:                      The source enum encoding is (x * 32) + y, where x is the register number 
97:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
98:                  */
99:                  PLIB_TEMPLATE void INT_SourceFlagSet_Default( INT_MODULE_ID index , INT_SOURCE source )
100:                 {
101:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
102:                     volatile uint32_t *IFSxSET = (volatile uint32_t *)(IFSx + 2);
103:                 
104:                     *IFSxSET = 1 << (source & 0x1f);
105:                 }
106:                 
107:                 //******************************************************************************
108:                 /* Function :  INT_SourceFlagClear_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_INT_SourceFlagClear 
112:                 
113:                   Description:
114:                     This template implements the Default variant of the PLIB_INT_SourceFlagClear function.
115:                 
116:                   Note:
117:                     The source enum encoding is (x * 32) + y, where x is the register number 
118:                     (IFSx) and y is the bit position. 0b0xxy_yyyy
119:                 */
120:                 PLIB_TEMPLATE void INT_SourceFlagClear_Default( INT_MODULE_ID index , INT_SOURCE source )
121:                 {
122:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
9D00DF54  00023942   SRL A3, V0, 5
9D00DF58  00073900   SLL A3, A3, 4
9D00DF5C  3C06BF81   LUI A2, -16511
9D00DF60  24C60040   ADDIU A2, A2, 64
9D00DF64  00C71821   ADDU V1, A2, A3
9D00DF88  00021942   SRL V1, V0, 5
9D00DF8C  00031900   SLL V1, V1, 4
9D00DF90  00C33021   ADDU A2, A2, V1
9D013D8C  00022142   SRL A0, V0, 5
9D013D90  00042100   SLL A0, A0, 4
9D013D94  3C03BF81   LUI V1, -16511
9D013D98  24630040   ADDIU V1, V1, 64
9D013D9C  00641821   ADDU V1, V1, A0
9D015334  00022142   SRL A0, V0, 5
9D015338  00042100   SLL A0, A0, 4
9D01533C  3C03BF81   LUI V1, -16511
9D015340  24630040   ADDIU V1, V1, 64
9D015344  00641821   ADDU V1, V1, A0
9D0153BC  00022142   SRL A0, V0, 5
9D0153C0  00042100   SLL A0, A0, 4
9D0153C4  3C03BF81   LUI V1, -16511
9D0153C8  24630040   ADDIU V1, V1, 64
9D0153CC  00641821   ADDU V1, V1, A0
9D015C08  00021942   SRL V1, V0, 5
9D015C0C  00031900   SLL V1, V1, 4
9D015C10  24A50040   ADDIU A1, A1, 64
9D015C14  00A32821   ADDU A1, A1, V1
00000040  00000000   NOP
00000044  00000000   NOP
123:                     volatile uint32_t *IFSxCLR = (volatile uint32_t *)(IFSx + 1);
124:                 
125:                     *IFSxCLR = 1 << (source & 0x1f);
9D00DF68  24050001   ADDIU A1, ZERO, 1
9D00DF6C  00451004   SLLV V0, A1, V0
9D00DF70  AC620004   SW V0, 4(V1)
9D00DF94  00451004   SLLV V0, A1, V0
9D00DF98  ACC20004   SW V0, 4(A2)
9D0138DC  24040001   ADDIU A0, ZERO, 1
9D013DA0  24040001   ADDIU A0, ZERO, 1
9D013DA4  00441004   SLLV V0, A0, V0
9D013DA8  AC620004   SW V0, 4(V1)
9D015348  24040001   ADDIU A0, ZERO, 1
9D01534C  00441004   SLLV V0, A0, V0
9D015350  AC620004   SW V0, 4(V1)
9D0153D0  24040001   ADDIU A0, ZERO, 1
9D0153D4  00441004   SLLV V0, A0, V0
9D0153D8  AC620004   SW V0, 4(V1)
9D015C18  24030001   ADDIU V1, ZERO, 1
9D015C1C  00431004   SLLV V0, V1, V0
9D015C20  ACA20004   SW V0, 4(A1)
00000054  00000000   NOP
00000058  00000000   NOP
00000374  00000000   NOP
126:                 }
127:                 
128:                 #endif /*_INT_SOURCEFLAG_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/int/templates/int_sourcecontrol_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceControl_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceControl
16:                          PLIB_INT_SourceEnable
17:                          PLIB_INT_SourceDisable
18:                          PLIB_INT_SourceIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCECONTROL_DEFAULT_H
49:                  #define _INT_SOURCECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceControl_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceControl
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceControl function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceControl PLIB_INT_ExistsSourceControl
61:                  PLIB_TEMPLATE bool INT_ExistsSourceControl_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceEnable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceEnable 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceEnable function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IECx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE void INT_SourceEnable_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D008198  00021942   SRL V1, V0, 5
9D00819C  00031900   SLL V1, V1, 4
9D0081A0  3C04BF81   LUI A0, -16511
9D0081A4  248400C0   ADDIU A0, A0, 192
9D0081A8  00831821   ADDU V1, A0, V1
9D00DC24  00022142   SRL A0, V0, 5
9D00DC28  00042100   SLL A0, A0, 4
9D00DC2C  3C03BF81   LUI V1, -16511
9D00DC30  246300C0   ADDIU V1, V1, 192
9D00DC34  00641821   ADDU V1, V1, A0
9D00DF74  3C04BF81   LUI A0, -16511
9D00DF78  248400C0   ADDIU A0, A0, 192
9D00DF7C  00873821   ADDU A3, A0, A3
9D00DF9C  00831821   ADDU V1, A0, V1
9D0110DC  00022142   SRL A0, V0, 5
9D0110E0  00042100   SLL A0, A0, 4
9D0110E4  3C03BF81   LUI V1, -16511
9D0110E8  246300C0   ADDIU V1, V1, 192
9D0110EC  00641821   ADDU V1, V1, A0
9D011848  00022142   SRL A0, V0, 5
9D01184C  00042100   SLL A0, A0, 4
9D011850  3C03BF81   LUI V1, -16511
9D011854  246300C0   ADDIU V1, V1, 192
9D011858  00641821   ADDU V1, V1, A0
9D015C2C  00023142   SRL A2, V0, 5
9D015C30  00063100   SLL A2, A2, 4
9D015C34  3C05BF81   LUI A1, -16511
9D015C38  24A500C0   ADDIU A1, A1, 192
9D015C3C  00A62821   ADDU A1, A1, A2
9D015DAC  00022142   SRL A0, V0, 5
9D015DB0  00042100   SLL A0, A0, 4
9D015DB4  246300C0   ADDIU V1, V1, 192
9D015DB8  00641821   ADDU V1, V1, A0
00000038  00000000   NOP
82:                      volatile uint32_t *IECxSET = (volatile uint32_t *)(IECx + 2);
83:                  
84:                      *IECxSET = 1 << (source & 0x1f);
9D0081AC  24040001   ADDIU A0, ZERO, 1
9D0081B0  00441004   SLLV V0, A0, V0
9D0081B4  AC620008   SW V0, 8(V1)
9D00DC38  24040001   ADDIU A0, ZERO, 1
9D00DC3C  00441004   SLLV V0, A0, V0
9D00DC40  AC620008   SW V0, 8(V1)
9D00DF80  ACE20008   SW V0, 8(A3)
9D00DFA0  AC620008   SW V0, 8(V1)
9D0110F0  24040001   ADDIU A0, ZERO, 1
9D0110F4  00441004   SLLV V0, A0, V0
9D0110F8  AC620008   SW V0, 8(V1)
9D01185C  24040001   ADDIU A0, ZERO, 1
9D011860  00441004   SLLV V0, A0, V0
9D011864  AC620008   SW V0, 8(V1)
9D015C40  00431004   SLLV V0, V1, V0
9D015C44  ACA20008   SW V0, 8(A1)
9D015DBC  24040001   ADDIU A0, ZERO, 1
9D015DC0  00441004   SLLV V0, A0, V0
9D015DC4  AC620008   SW V0, 8(V1)
9D015DC8  03E00008   JR RA
9D015DCC  00000000   NOP
00000048  00000000   NOP
00000380  00000000   NOP
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  INT_SourceDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_INT_SourceDisable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_INT_SourceDisable function.
95:                  
96:                    Note:
97:                      The source enum encoding is (x * 32) + y, where x is the register number
98:                      (IECx) and y is the bit position. 0b0xxy_yyyy
99:                  */
100:                 PLIB_TEMPLATE void INT_SourceDisable_Default( INT_MODULE_ID index , INT_SOURCE source )
101:                 {
102:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
103:                     volatile uint32_t *IECxCLR = (volatile uint32_t *)(IECx + 1);
104:                 
105:                     *IECxCLR = 1 << (source & 0x1f);
9D016268  24060001   ADDIU A2, ZERO, 1
9D01626C  00863004   SLLV A2, A2, A0
9D016270  AC660004   SW A2, 4(V1)
106:                 }
107:                 
108:                 //******************************************************************************
109:                 /* Function :  INT_SourceIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_INT_SourceIsEnabled 
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_INT_SourceIsEnabled function.
116:                 
117:                   Note:
118:                     The source enum encoding is (x * 32) + y, where x is the register number 
119:                     (IECx) and y is the bit position. 0b0xxy_yyyy
120:                 */
121:                 PLIB_TEMPLATE bool INT_SourceIsEnabled_Default( INT_MODULE_ID index , INT_SOURCE source )
122:                 {
123:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D01624C  00041142   SRL V0, A0, 5
9D016250  00021100   SLL V0, V0, 4
9D016254  3C03BF81   LUI V1, -16511
9D016258  246300C0   ADDIU V1, V1, 192
9D01625C  00621821   ADDU V1, V1, V0
124:                 
125:                     return (bool)((*IECx >> (source & 0x1f)) & 0x01);
9D016260  8C620000   LW V0, 0(V1)
9D016264  3084001F   ANDI A0, A0, 31
9D01627C  00821006   SRLV V0, V0, A0
126:                 }
127:                 
128:                 #endif /*_INT_SOURCECONTROL_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/int/templates/int_externalintedgeselect_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_ExternalINTEdgeSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ExternalINTEdgeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsExternalINTEdgeSelect
16:                          PLIB_INT_ExternalRisingEdgeSelect
17:                          PLIB_INT_ExternalFallingEdgeSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_EXTERNALINTEDGESELECT_DEFAULT_H
48:                  #define _INT_EXTERNALINTEDGESELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  INT_ExistsExternalINTEdgeSelect_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_INT_ExistsExternalINTEdgeSelect
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_INT_ExistsExternalINTEdgeSelect function.
58:                  */
59:                  #define PLIB_INT_ExistsExternalINTEdgeSelect PLIB_INT_ExistsExternalINTEdgeSelect
60:                  PLIB_TEMPLATE bool INT_ExistsExternalINTEdgeSelect_Default( INT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  INT_ExternalRisingEdgeSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_INT_ExternalRisingEdgeSelect
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_INT_ExternalRisingEdgeSelect function.
73:                  */
74:                  
75:                  PLIB_TEMPLATE void INT_ExternalRisingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
76:                  {
77:                      INTCONSET = source << _INTCON_INT0EP_POSITION;
0000000C  00000000   NOP
78:                  }
79:                  
80:                  //******************************************************************************
81:                  /* Function :  INT_ExternalFallingEdgeSelect_Default
82:                  
83:                    Summary:
84:                      Implements Default variant of PLIB_INT_ExternalFallingEdgeSelect
85:                  
86:                    Description:
87:                      This template implements the Default variant of the PLIB_INT_ExternalFallingEdgeSelect function.
88:                  */
89:                  PLIB_TEMPLATE void INT_ExternalFallingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
90:                  {
91:                      INTCONCLR = source << _INTCON_INT0EP_POSITION;
0000001C  00000000   NOP
92:                  }
93:                  
94:                  #endif /*_INT_EXTERNALINTEDGESELECT_DEFAULT_H*/
95:                  
96:                  /******************************************************************************
97:                   End of File
98:                  */
99:                  
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/int/templates/int_enablecontrol_pic32.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_EnableControl_PIC32.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_INT_ExistsEnableControl
16:                          PLIB_INT_Enable
17:                          PLIB_INT_Disable
18:                          PLIB_INT_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_ENABLECONTROL_PIC32_H
49:                  #define _INT_ENABLECONTROL_PIC32_H
50:                  
51:                  #include "peripheral/int/plib_int_private_pic32.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  INT_ExistsEnableControl_PIC32
55:                  
56:                    Summary:
57:                      Implements PIC32 variant of PLIB_INT_ExistsEnableControl
58:                  
59:                    Description:
60:                      This template implements the PIC32 variant of the PLIB_INT_ExistsEnableControl function.
61:                  */
62:                  #define PLIB_INT_ExistsEnableControl PLIB_INT_ExistsEnableControl
63:                  PLIB_TEMPLATE bool INT_ExistsEnableControl_PIC32( INT_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  INT_Enable_PIC32
70:                  
71:                    Summary:
72:                      Implements PIC32 variant of PLIB_INT_Enable 
73:                  
74:                    Description:
75:                      This template implements the PIC32 variant of the PLIB_INT_Enable function.
76:                  */
77:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_Enable_PIC32( INT_MODULE_ID index )
78:                  {
79:                      __builtin_mtc0(12, 0,(__builtin_mfc0(12, 0) | 0x0001));
9D001870  40026000   MFC0 V0, Status
9D001874  34420001   ORI V0, V0, 1
9D001878  40826000   MTC0 V0, Status
9D00187C  000000C0   EHB
9D00CE24  40026000   MFC0 V0, Status
9D00CE28  34420001   ORI V0, V0, 1
9D00CE2C  40826000   MTC0 V0, Status
9D00CE30  000000C0   EHB
9D00D220  40026000   MFC0 V0, Status
9D00D224  34420001   ORI V0, V0, 1
9D00D228  40826000   MTC0 V0, Status
9D00D22C  000000C0   EHB
9D00D924  40026000   MFC0 V0, Status
9D00D928  34420001   ORI V0, V0, 1
9D00D92C  40826000   MTC0 V0, Status
9D00D930  000000C0   EHB
9D01064C  40026000   MFC0 V0, Status
9D010650  34420001   ORI V0, V0, 1
9D010654  40826000   MTC0 V0, Status
9D010658  000000C0   EHB
9D0122F4  40026000   MFC0 V0, Status
9D0122F8  34420001   ORI V0, V0, 1
9D0122FC  40826000   MTC0 V0, Status
9D012300  000000C0   EHB
9D01232C  40026000   MFC0 V0, Status
9D012330  34420001   ORI V0, V0, 1
9D012334  40826000   MTC0 V0, Status
9D012338  000000C0   EHB
9D016174  40026000   MFC0 V0, Status
9D016178  34420001   ORI V0, V0, 1
9D01617C  40826000   MTC0 V0, Status
9D016180  000000C0   EHB
9D0165B4  40026000   MFC0 V0, Status
9D0165B8  34420001   ORI V0, V0, 1
9D0165BC  40826000   MTC0 V0, Status
9D0165C0  000000C0   EHB
80:                      
81:                  }
82:                  
83:                  //******************************************************************************
84:                  /* Function :  INT_Disable_PIC32
85:                  
86:                    Summary:
87:                      Implements PIC32 variant of PLIB_INT_Disable 
88:                  
89:                    Description:
90:                      This template implements the PIC32 variant of the PLIB_INT_Disable function.
91:                  */
92:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline))void INT_Disable_PIC32( INT_MODULE_ID index )
93:                  {
94:                      __builtin_disable_interrupts();
95:                  }
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PLIB_INT_SetState_PIC32
99:                  
100:                   Summary:
101:                     Implements PIC32 variant of PLIB_INT_Enable 
102:                 
103:                   Description:
104:                     This template implements the PIC32 variant of the PLIB_INT_Enable function.
105:                 */
106:                 PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_SetState_PIC32( INT_MODULE_ID index, INT_STATE_GLOBAL interrupt_state )
107:                 {
108:                     __builtin_mtc0(12, 0, interrupt_state);
9D016274  40856000   MTC0 A1, Status
9D016278  000000C0   EHB
00000008  00000000   NOP
109:                 }
110:                 
111:                 //******************************************************************************
112:                 /* Function :  PLIB_INT_GetStateAndDisable_PIC32
113:                 
114:                   Summary:
115:                     Implements PIC32 variant of PLIB_INT_Disable 
116:                 
117:                   Description:
118:                     This template implements the PIC32 variant of the PLIB_INT_Disable function.
119:                 */
120:                 INT_STATE_GLOBAL PLIB_TEMPLATE __attribute__((nomips16,always_inline)) INT_GetStateAndDisable_PIC32( INT_MODULE_ID index )
121:                 {
122:                     return (INT_STATE_GLOBAL)__builtin_disable_interrupts();
9D0122D0  41656000   DI A1
9D0122D4  000000C0   EHB
9D012304  41646000   DI A0
9D012308  000000C0   EHB
9D016140  41636000   DI V1
9D016144  000000C0   EHB
9D016244  41656000   DI A1
9D016248  000000C0   EHB
9D016590  41626000   DI V0
9D016594  000000C0   EHB
9D017034  41626000   DI V0
9D017038  000000C0   EHB
00000008  00000000   NOP
123:                 }
124:                 
125:                 //******************************************************************************
126:                 /* Function :  INT_IsEnabled_PIC32
127:                 
128:                   Summary:
129:                     Implements PIC32 variant of PLIB_INT_IsEnabled 
130:                 
131:                   Description:
132:                     This template implements the PIC32 variant of the PLIB_INT_IsEnabled function.
133:                 */
134:                 PLIB_TEMPLATE bool __attribute__((nomips16,always_inline)) INT_IsEnabled_PIC32( INT_MODULE_ID index )
135:                 {
136:                     return (bool)(_CP0_GET_STATUS() & 0x01);
137:                 }
138:                 
139:                 #endif /*_INT_ENABLECONTROL_PIC32_H*/
140:                 
141:                 /******************************************************************************
142:                  End of File
143:                 */
144:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/devcon/templates/devcon_traceoutput_default.h
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_TraceOutput_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TraceOutput
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_TraceOutputEnable
16:                          PLIB_DEVCON_TraceOutputDisable
17:                          PLIB_DEVCON_ExistsTraceOutput
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_TRACEOUTPUT_DEFAULT_H
48:                  #define _DEVCON_TRACEOUTPUT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  DEVCON_TraceOutputEnable_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_DEVCON_TraceOutputEnable
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_DEVCON_TraceOutputEnable function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void DEVCON_TraceOutputEnable_Default( DEVCON_MODULE_ID index )
61:                  {
62:                  	CFGCONbits.TROEN = 1;
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  DEVCON_TraceOutputDisable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_DEVCON_TraceOutputDisable
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_DEVCON_TraceOutputDisable function.
74:                  */
75:                  
76:                  PLIB_TEMPLATE void DEVCON_TraceOutputDisable_Default( DEVCON_MODULE_ID index )
77:                  {
78:                  	CFGCONbits.TROEN = 0;
00000000  00000000   NOP
79:                  }
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  DEVCON_ExistsTraceOutput_Default
84:                  
85:                    Summary:
86:                      Implements Default variant of PLIB_DEVCON_ExistsTraceOutput
87:                  
88:                    Description:
89:                      This template implements the Default variant of the PLIB_DEVCON_ExistsTraceOutput function.
90:                  */
91:                  
92:                  #define PLIB_DEVCON_ExistsTraceOutput PLIB_DEVCON_ExistsTraceOutput
93:                  PLIB_TEMPLATE bool DEVCON_ExistsTraceOutput_Default( DEVCON_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  #endif /*_DEVCON_TRACEOUTPUT_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/devcon/templates/devcon_syslockunlock_default.h
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_SysLockUnlock_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SysLockUnlock
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_SystemUnlock
16:                          PLIB_DEVCON_SystemLock
17:                          PLIB_DEVCON_ExistsSystemLockUnlock
18:                          PLIB_DEVCON_ExistsDeviceVerAndId
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
49:                  #define _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DEVCON_SystemUnlock_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DEVCON_SystemUnlock 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DEVCON_SystemUnlock function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void DEVCON_SystemUnlock_Default( DEVCON_MODULE_ID index )
62:                  {	
63:                  	SYSKEY = 0x00000000;
9D016148  3C02BF80   LUI V0, -16512
9D01614C  AC400030   SW ZERO, 48(V0)
00000000  00000000   NOP
64:                  	SYSKEY = 0xAA996655;
9D016150  3C04AA99   LUI A0, -21863
9D016154  24846655   ADDIU A0, A0, 26197
9D016158  AC440030   SW A0, 48(V0)
00000008  00000000   NOP
65:                  	SYSKEY = 0x556699AA;
9D01615C  3C045566   LUI A0, 21862
9D016160  348499AA   ORI A0, A0, -26198
9D016164  AC440030   SW A0, 48(V0)
00000014  00000000   NOP
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DEVCON_SystemLock_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DEVCON_SystemLock 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DEVCON_SystemLock function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DEVCON_SystemLock_Default( DEVCON_MODULE_ID index )
80:                  {
81:                  	SYSKEY = 0x33333333;
9D016598  3C043333   LUI A0, 13107
9D01659C  24843333   ADDIU A0, A0, 13107
9D0165A0  3C03BF80   LUI V1, -16512
9D0165A4  AC640030   SW A0, 48(V1)
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  DEVCON_ExistsSystemLockUnlock_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_DEVCON_ExistsSystemLockUnlock
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_DEVCON_ExistsSystemLockUnlock function.
93:                  */
94:                  
95:                  #define PLIB_DEVCON_ExistsSystemLockUnlock PLIB_DEVCON_ExistsSystemLockUnlock
96:                  PLIB_TEMPLATE bool DEVCON_ExistsSystemLockUnlock_Default( DEVCON_MODULE_ID index )
97:                  {
98:                      return true;
99:                  }
100:                 
101:                 #endif /*_DEVCON_SYSLOCKUNLOCK_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/devcon/templates/devcon_jtagenable_default.h
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_JTAGEnable_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : JTAGEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_JTAGPortEnable
16:                          PLIB_DEVCON_JTAGPortDisable
17:                          PLIB_DEVCON_ExistsJTAGEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_JTAGENABLE_DEFAULT_H
48:                  #define _DEVCON_JTAGENABLE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  DEVCON_JTAGPortEnable_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_DEVCON_JTAGPortEnable
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_DEVCON_JTAGPortEnable function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void DEVCON_JTAGPortEnable_Default( DEVCON_MODULE_ID index )
61:                  {
62:                      *((SFR_TYPE *)(&CFGCON)) |=  1u<< _CFGCON_JTAGEN_POSITION;
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  DEVCON_JTAGPortDisable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_DEVCON_JTAGPortDisable
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_DEVCON_JTAGPortDisable function.
74:                  */
75:                  
76:                  PLIB_TEMPLATE void DEVCON_JTAGPortDisable_Default( DEVCON_MODULE_ID index )
77:                  {
78:                      *((SFR_TYPE *)(&CFGCON)) &= ~(1 << _CFGCON_JTAGEN_POSITION);
00000000  00000000   NOP
79:                  }
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  DEVCON_ExistsJTAGEnable_Default
84:                  
85:                    Summary:
86:                      Implements Default variant of PLIB_DEVCON_ExistsJTAGEnable
87:                  
88:                    Description:
89:                      This template implements the Default variant of the PLIB_DEVCON_ExistsJTAGEnable function.
90:                  */
91:                  
92:                  #define PLIB_DEVCON_ExistsJTAGEnable PLIB_DEVCON_ExistsJTAGEnable
93:                  PLIB_TEMPLATE bool DEVCON_ExistsJTAGEnable_Default( DEVCON_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  #endif /*_DEVCON_JTAGENABLE_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/devcon/templates/devcon_deviceregslockunlock_pic32mz.h
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_DeviceRegsLockUnlock_PIC32MZ.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DeviceRegsLockUnlock
13:                      and its Variant : PIC32MZ
14:                      For following APIs :
15:                          PLIB_DEVCON_DeviceRegistersLock
16:                          PLIB_DEVCON_DeviceRegistersUnlock
17:                          PLIB_DEVCON_ExistsDeviceRegsLockUnlock
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_DEVICEREGSLOCKUNLOCK_PIC32MZ_H
48:                  #define _DEVCON_DEVICEREGSLOCKUNLOCK_PIC32MZ_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  DEVCON_DeviceRegistersLock_PIC32MZ
52:                  
53:                    Summary:
54:                      Implements PIC32MZ variant of PLIB_DEVCON_DeviceRegistersLock
55:                  
56:                    Description:
57:                      This template implements the PIC32MZ variant of the PLIB_DEVCON_DeviceRegistersLock function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void DEVCON_DeviceRegistersLock_PIC32MZ( DEVCON_MODULE_ID index , DEVCON_REGISTER_SET registersToLock )
61:                  {
62:                  	*((SFR_TYPE *)(&CFGCON)) |= ((_CFGCON_IOLOCK_MASK | _CFGCON_PMDLOCK_MASK | _CFGCON_PGLOCK_MASK ) & (registersToLock << _CFGCON_PGLOCK_POSITION));
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  DEVCON_DeviceRegistersUnlock_PIC32MZ
68:                  
69:                    Summary:
70:                      Implements PIC32MZ variant of PLIB_DEVCON_DeviceRegistersUnlock
71:                  
72:                    Description:
73:                      This template implements the PIC32MZ variant of the PLIB_DEVCON_DeviceRegistersUnlock function.
74:                  */
75:                  
76:                  PLIB_TEMPLATE void DEVCON_DeviceRegistersUnlock_PIC32MZ( DEVCON_MODULE_ID index , DEVCON_REGISTER_SET registersToLock )
77:                  {
78:                  	*((SFR_TYPE *)(&CFGCON)) &= ~((_CFGCON_IOLOCK_MASK | _CFGCON_PMDLOCK_MASK | _CFGCON_PGLOCK_MASK ) & (registersToLock << _CFGCON_PGLOCK_POSITION));
00000020  00000000   NOP
79:                  }
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  DEVCON_ExistsDeviceRegsLockUnlock_PIC32MZ
84:                  
85:                    Summary:
86:                      Implements PIC32MZ variant of PLIB_DEVCON_ExistsDeviceRegsLockUnlock
87:                  
88:                    Description:
89:                      This template implements the PIC32MZ variant of the PLIB_DEVCON_ExistsDeviceRegsLockUnlock function.
90:                  */
91:                  
92:                  #define PLIB_DEVCON_ExistsDeviceRegsLockUnlock PLIB_DEVCON_ExistsDeviceRegsLockUnlock
93:                  PLIB_TEMPLATE bool DEVCON_ExistsDeviceRegsLockUnlock_PIC32MZ( DEVCON_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  #endif /*_DEVCON_DEVICEREGSLOCKUNLOCK_PIC32MZ_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_vrefcontrol_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_VREFControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VREFControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_VREFIsReady
16:                          PLIB_ADCHS_VREFFaultHasOccurred
17:                          PLIB_ADCHS_VREFReadyInterruptEnable
18:                          PLIB_ADCHS_VREFReadyInterruptDisable
19:                          PLIB_ADCHS_VREFFaultInterruptEnable
20:                          PLIB_ADCHS_VREFFaultInterruptDisable
21:                          PLIB_ADCHS_ExistsVREFControl
22:                  
23:                  *******************************************************************************/
24:                  
25:                  //DOM-IGNORE-BEGIN
26:                  /*******************************************************************************
27:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
28:                  
29:                  Microchip licenses to you the right to use, modify, copy and distribute
30:                  Software only when embedded on a Microchip microcontroller or digital signal
31:                  controller that is integrated into your product or third party product
32:                  (pursuant to the sublicense terms in the accompanying license agreement).
33:                  
34:                  You should refer to the license agreement accompanying this Software for
35:                  additional information regarding your rights and obligations.
36:                  
37:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
38:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
39:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
40:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
41:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
42:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
43:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
44:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
46:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                  *******************************************************************************/
48:                  
49:                  //DOM-IGNORE-END
50:                  
51:                  #ifndef _ADCHS_VREFCONTROL_DEFAULT_H
52:                  #define _ADCHS_VREFCONTROL_DEFAULT_H
53:                  
54:                  
55:                  
56:                  //******************************************************************************
57:                  /* Function :  ADCHS_VREFIsReady_Default
58:                  
59:                    Summary:
60:                      Implements Default variant of PLIB_ADCHS_VREFIsReady 
61:                  
62:                    Description:
63:                      This template implements the Default variant of the PLIB_ADCHS_VREFIsReady function.
64:                      This operation is atomic.
65:                  */
66:                  
67:                  PLIB_TEMPLATE bool ADCHS_VREFIsReady_Default( ADCHS_MODULE_ID index )
68:                  {
69:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
70:                  
71:                      return (bool)regs->ADCCON2.BGVRRDY;
00000328  00000000   NOP
72:                  }
73:                  
74:                  
75:                  //******************************************************************************
76:                  /* Function :  ADCHS_VREFFaultHasOccurred_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_ADCHS_VREFFaultHasOccurred 
80:                  
81:                    Description:
82:                      This template implements the Default variant of the PLIB_ADCHS_VREFFaultHasOccurred function.
83:                      This operation is atomic.
84:                  */
85:                  
86:                  PLIB_TEMPLATE bool ADCHS_VREFFaultHasOccurred_Default( ADCHS_MODULE_ID index )
87:                  {
88:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
89:                  
90:                      return (bool)regs->ADCCON2.REFFLT;
00000338  00000000   NOP
91:                  }
92:                  
93:                  
94:                  //******************************************************************************
95:                  /* Function :  ADCHS_VREFReadyInterruptEnable_Default
96:                  
97:                    Summary:
98:                      Implements Default variant of PLIB_ADCHS_VREFReadyInterruptEnable 
99:                  
100:                   Description:
101:                     This template implements the Default variant of the PLIB_ADCHS_VREFReadyInterruptEnable function.
102:                     This operation is not atomic.
103:                 */
104:                 
105:                 PLIB_TEMPLATE void ADCHS_VREFReadyInterruptEnable_Default( ADCHS_MODULE_ID index )
106:                 {
107:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
108:                 
109:                     regs->ADCCON2.BGVRIEN = 1;
110:                 }
111:                 
112:                 
113:                 //******************************************************************************
114:                 /* Function :  ADCHS_VREFReadyInterruptDisable_Default
115:                 
116:                   Summary:
117:                     Implements Default variant of PLIB_ADCHS_VREFReadyInterruptDisable 
118:                 
119:                   Description:
120:                     This template implements the Default variant of the PLIB_ADCHS_VREFReadyInterruptDisable function.
121:                     This operation is not atomic.
122:                 */
123:                 
124:                 PLIB_TEMPLATE void ADCHS_VREFReadyInterruptDisable_Default( ADCHS_MODULE_ID index )
125:                 {
126:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
127:                 
128:                     regs->ADCCON2.BGVRIEN = 0;
129:                 }
130:                 
131:                 
132:                 //******************************************************************************
133:                 /* Function :  ADCHS_VREFFaultInterruptEnable_Default
134:                 
135:                   Summary:
136:                     Implements Default variant of PLIB_ADCHS_VREFFaultInterruptEnable 
137:                 
138:                   Description:
139:                     This template implements the Default variant of the PLIB_ADCHS_VREFFaultInterruptEnable function.
140:                     This operation is not atomic.
141:                 */
142:                 
143:                 PLIB_TEMPLATE void ADCHS_VREFFaultInterruptEnable_Default( ADCHS_MODULE_ID index )
144:                 {
145:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
146:                 
147:                     regs->ADCCON2.REFFLTIEN = 1;
148:                 }
149:                 
150:                 
151:                 //******************************************************************************
152:                 /* Function :  ADCHS_VREFFaultInterruptDisable_Default
153:                 
154:                   Summary:
155:                     Implements Default variant of PLIB_ADCHS_VREFFaultInterruptDisable 
156:                 
157:                   Description:
158:                     This template implements the Default variant of the PLIB_ADCHS_VREFFaultInterruptDisable function.
159:                     This operation is not atomic.
160:                 */
161:                 
162:                 PLIB_TEMPLATE void ADCHS_VREFFaultInterruptDisable_Default( ADCHS_MODULE_ID index )
163:                 {
164:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
165:                 
166:                     regs->ADCCON2.REFFLTIEN = 0;
167:                 }
168:                 
169:                 
170:                 //******************************************************************************
171:                 /* Function :  ADCHS_ExistsVREFControl_Default
172:                 
173:                   Summary:
174:                     Implements Default variant of PLIB_ADCHS_ExistsVREFControl
175:                 
176:                   Description:
177:                     This template implements the Default variant of the PLIB_ADCHS_ExistsVREFControl function.
178:                 */
179:                 
180:                 #define PLIB_ADCHS_ExistsVREFControl PLIB_ADCHS_ExistsVREFControl
181:                 PLIB_TEMPLATE bool ADCHS_ExistsVREFControl_Default( ADCHS_MODULE_ID index )
182:                 {
183:                     return true;
184:                 }
185:                 
186:                 
187:                 #endif /*_ADCHS_VREFCONTROL_DEFAULT_H*/
188:                 
189:                 /******************************************************************************
190:                  End of File
191:                 */
192:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_triggercontrol_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_TriggerControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TriggerControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_AnalogInputLevelTriggerSet
16:                          PLIB_ADCHS_AnalogInputEdgeTriggerSet
17:                          PLIB_ADCHS_AnalogInputTriggerSourceSelect
18:                          PLIB_ADCHS_GlobalSoftwareTriggerEnable
19:                          PLIB_ADCHS_GlobalLevelSoftwareTriggerEnable
20:                          PLIB_ADCHS_GlobalLevelSoftwareTriggerDisable
21:                          PLIB_ADCHS_TriggerSuspendEnable
22:                          PLIB_ADCHS_TriggerSuspendDisable
23:                          PLIB_ADCHS_ExistsTriggerControl
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _ADCHS_TRIGGERCONTROL_DEFAULT_H
54:                  #define _ADCHS_TRIGGERCONTROL_DEFAULT_H
55:                  
56:                  
57:                  
58:                  //******************************************************************************
59:                  /* Function :  ADCHS_AnalogInputLevelTriggerSet_Default
60:                  
61:                    Summary:
62:                      Implements Default variant of PLIB_ADCHS_AnalogInputLevelTriggerSet 
63:                  
64:                    Description:
65:                      This template implements the Default variant of the PLIB_ADCHS_AnalogInputLevelTriggerSet function.
66:                      This operation is not atomic.
67:                  */
68:                  
69:                  PLIB_TEMPLATE void ADCHS_AnalogInputLevelTriggerSet_Default( ADCHS_MODULE_ID index , ADCHS_CLASS12_AN_INPUT_ID analogInput )
70:                  {
71:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
72:                  #ifndef CHECON /* PIC32MZ */
73:                      regs->ADCTRGSNS |= BIT(analogInput);
74:                  #else /*PIC32MK */
75:                          regs->ADCTRGSNS.set = BIT(analogInput);
76:                  #endif
77:                  }
78:                  
79:                  
80:                  //******************************************************************************
81:                  /* Function :  ADCHS_AnalogInputEdgeTriggerSet_Default
82:                  
83:                    Summary:
84:                      Implements Default variant of PLIB_ADCHS_AnalogInputEdgeTriggerSet 
85:                  
86:                    Description:
87:                      This template implements the Default variant of the PLIB_ADCHS_AnalogInputEdgeTriggerSet function.
88:                      This operation is not atomic.
89:                  */
90:                  
91:                  PLIB_TEMPLATE void ADCHS_AnalogInputEdgeTriggerSet_Default( ADCHS_MODULE_ID index , ADCHS_CLASS12_AN_INPUT_ID analogInput )
92:                  {
93:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
94:                  
95:                  #ifndef CHECON /* PIC32MZ */
96:                      regs->ADCTRGSNS &= ~BIT(analogInput);
00000104  00000000   NOP
97:                  #else /*PIC32MK */
98:                      regs->ADCTRGSNS.clr = BIT(analogInput);
99:                  #endif
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  ADCHS_AnalogInputTriggerSourceSelect_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_ADCHS_AnalogInputTriggerSourceSelect 
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_ADCHS_AnalogInputTriggerSourceSelect function.
111:                     This operation is not atomic.
112:                 */
113:                 
114:                 PLIB_TEMPLATE void ADCHS_AnalogInputTriggerSourceSelect_Default( ADCHS_MODULE_ID index , ADCHS_CLASS12_AN_INPUT_ID inputId , ADCHS_TRIGGER_SOURCE triggerSource )
115:                 {
116:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
117:                 
118:                 #ifndef CHECON /* PIC32MZ */
119:                     regs->ADCTRGx[inputId >> 2] &= ~(0x1f << ((inputId & 0x03) * 8));
00000114  00000000   NOP
120:                     regs->ADCTRGx[inputId >> 2] |= triggerSource << ((inputId & 0x03) * 8);
00000124  00000000   NOP
121:                 #else /*PIC32MK */
122:                     regs->ADCTRGx[inputId >> 2].bits &= ~(0x1f << ((inputId & 0x03) * 8));
123:                     regs->ADCTRGx[inputId >> 2].bits |= triggerSource << ((inputId & 0x03) * 8);
124:                 #endif
125:                 }
126:                 
127:                 
128:                 //******************************************************************************
129:                 /* Function :  ADCHS_GlobalSoftwareTriggerEnable_Default
130:                 
131:                   Summary:
132:                     Implements Default variant of PLIB_ADCHS_GlobalSoftwareTriggerEnable 
133:                 
134:                   Description:
135:                     This template implements the Default variant of the PLIB_ADCHS_GlobalSoftwareTriggerEnable function.
136:                     This operation is not atomic.
137:                 */
138:                 
139:                 PLIB_TEMPLATE void ADCHS_GlobalSoftwareTriggerEnable_Default( ADCHS_MODULE_ID index )
140:                 {
141:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
142:                 
143:                     regs->ADCCON3.GSWTRG = 1;
00000000  00000000   NOP
144:                 }
145:                 
146:                 
147:                 //******************************************************************************
148:                 /* Function :  ADCHS_GlobalLevelSoftwareTriggerEnable_Default
149:                 
150:                   Summary:
151:                     Implements Default variant of PLIB_ADCHS_GlobalLevelSoftwareTriggerEnable 
152:                 
153:                   Description:
154:                     This template implements the Default variant of the PLIB_ADCHS_GlobalLevelSoftwareTriggerEnable function.
155:                     This operation is not atomic.
156:                 */
157:                 
158:                 PLIB_TEMPLATE void ADCHS_GlobalLevelSoftwareTriggerEnable_Default( ADCHS_MODULE_ID index )
159:                 {
160:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
161:                 
162:                     regs->ADCCON3.GLSWTRG = 1;
163:                 }
164:                 
165:                 
166:                 //******************************************************************************
167:                 /* Function :  ADCHS_GlobalLevelSoftwareTriggerDisable_Default
168:                 
169:                   Summary:
170:                     Implements Default variant of PLIB_ADCHS_GlobalLevelSoftwareTriggerDisable 
171:                 
172:                   Description:
173:                     This template implements the Default variant of the PLIB_ADCHS_GlobalLevelSoftwareTriggerDisable function.
174:                     This operation is not atomic.
175:                 */
176:                 
177:                 PLIB_TEMPLATE void ADCHS_GlobalLevelSoftwareTriggerDisable_Default( ADCHS_MODULE_ID index )
178:                 {
179:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
180:                 
181:                     regs->ADCCON3.GLSWTRG = 0;
182:                 }
183:                 
184:                 
185:                 //******************************************************************************
186:                 /* Function :  ADCHS_TriggerSuspendEnable_Default
187:                 
188:                   Summary:
189:                     Implements Default variant of PLIB_ADCHS_TriggerSuspendEnable 
190:                 
191:                   Description:
192:                     This template implements the Default variant of the PLIB_ADCHS_TriggerSuspendEnable function.
193:                     This operation is not atomic.
194:                 */
195:                 
196:                 PLIB_TEMPLATE void ADCHS_TriggerSuspendEnable_Default( ADCHS_MODULE_ID index )
197:                 {
198:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
199:                 
200:                     regs->ADCCON3.TRGSUSP = 1;
201:                 }
202:                 
203:                 
204:                 //******************************************************************************
205:                 /* Function :  ADCHS_TriggerSuspendDisable_Default
206:                 
207:                   Summary:
208:                     Implements Default variant of PLIB_ADCHS_TriggerSuspendDisable 
209:                 
210:                   Description:
211:                     This template implements the Default variant of the PLIB_ADCHS_TriggerSuspendDisable function.
212:                     This operation is not atomic.
213:                 */
214:                 
215:                 PLIB_TEMPLATE void ADCHS_TriggerSuspendDisable_Default( ADCHS_MODULE_ID index )
216:                 {
217:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
218:                 
219:                     regs->ADCCON3.TRGSUSP = 0;
220:                 }
221:                 
222:                 
223:                 //******************************************************************************
224:                 /* Function :  ADCHS_ExistsTriggerControl_Default
225:                 
226:                   Summary:
227:                     Implements Default variant of PLIB_ADCHS_ExistsTriggerControl
228:                 
229:                   Description:
230:                     This template implements the Default variant of the PLIB_ADCHS_ExistsTriggerControl function.
231:                 */
232:                 
233:                 #define PLIB_ADCHS_ExistsTriggerControl PLIB_ADCHS_ExistsTriggerControl
234:                 PLIB_TEMPLATE bool ADCHS_ExistsTriggerControl_Default( ADCHS_MODULE_ID index )
235:                 {
236:                     return true;
237:                 }
238:                 
239:                 
240:                 #endif /*_ADCHS_TRIGGERCONTROL_DEFAULT_H*/
241:                 
242:                 /******************************************************************************
243:                  End of File
244:                 */
245:                 
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_Setup_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Setup
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_Setup
16:                          PLIB_ADCHS_ChannelSetup
17:                          PLIB_ADCHS_ExistsConfiguration
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _ADCHS_SETUP_DEFAULT_H
48:                  #define _ADCHS_SETUP_DEFAULT_H
49:                  
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADCHS_Setup_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADCHS_Setup 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADCHS_Setup function.
60:                      Operation is not atomic.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void ADCHS_Setup_Default( ADCHS_MODULE_ID index , ADCHS_VREF_SOURCE voltageRefSelect , ADCHS_CHARGEPUMP_MODE chargePump , ADCHS_OUTPUT_DATA_FORMAT outputFormat , bool stopInIdle , ADCHS_FAST_SYNC_SYSTEM_CLOCK sysClk , ADCHS_FAST_SYNC_PERIPHERAL_CLOCK periClk , ADCHS_INTERRUPT_BIT_SHIFT_LEFT intVectorShift , uint16_t intVectorBase , ADCHS_CLOCK_SOURCE adcClockSource , int8_t adcClockDivider , ADCHS_WARMUP_CLOCK warmUpClock )
64:                  {
65:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
66:                      volatile __ADCANCONbits_t *ADCANCON = (__ADCANCONbits_t *)&regs->ADCANCON;
67:                  
68:                      regs->ADCCON1.AICPMPEN = chargePump;
00000000  00000000   NOP
69:                      regs->ADCCON1.IRQVS = intVectorShift;
00000014  00000000   NOP
70:                      regs->ADCCON1.FRACT = outputFormat;
00000020  00000000   NOP
71:                      regs->ADCCON1.SIDL = stopInIdle;
0000002C  00000000   NOP
72:                      regs->ADCCON1.FSSCLKEN = sysClk;
00000038  00000000   NOP
73:                      regs->ADCCON1.FSPBCLKEN = periClk;
00000044  00000000   NOP
74:                  
75:                      regs->ADCCON3.VREFSEL = voltageRefSelect;
00000050  00000000   NOP
76:                      regs->ADCCON3.ADCSEL = adcClockSource;
0000005C  00000000   NOP
77:                      regs->ADCCON3.CONCLKDIV = adcClockDivider;
00000068  00000000   NOP
78:                  
79:                      regs->ADCBASE = intVectorBase;
00000074  00000000   NOP
80:                      ADCANCON->WKUPCLKCNT = warmUpClock;
00000078  00000000   NOP
81:                  }
82:                  
83:                  //******************************************************************************
84:                  /* Function :  ADCHS_ChannelSetup_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_ADCHS_ChannelSetup 
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_ADCHS_ChannelSetup function.
91:                      Operation is not atomic.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void ADCHS_ChannelSetup_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID , ADCHS_DATA_RESOLUTION res , uint8_t	channelClockDivider , uint16_t sampleTimeCount , ADCHS_EARLY_INTERRUPT_PRIOR_CLOCK earlyInterruptClk )
95:                  {
96:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
97:                      volatile uint32_t *ADCCON2 = (volatile uint32_t *)&regs->ADCCON2;
98:                      uint32_t tempVal = 0;
99:                  
100:                     if (channelID == ADCHS_CHANNEL_7) {
101:                 	tempVal = *ADCCON2;
102:                 	tempVal &= ~(0x0000007F | 0x03FF0000 | 0x00000700);
103:                 	tempVal |= (uint32_t)(channelClockDivider);
104:                 	tempVal |= (uint32_t)(sampleTimeCount << 16);
105:                 	tempVal |= (uint32_t)(earlyInterruptClk << 8);
106:                 	*ADCCON2 = tempVal;
107:                 
108:                 	regs->ADCCON1.SELRES = res;
109:                     } else {
110:                 	tempVal = regs->ADCxTIME[channelID];
00000088  00000000   NOP
111:                 	tempVal &= ~(0x000003FF | 0x007F0000 | 0x1C0000000 | 0x03000000);
0000008C  00000000   NOP
112:                 	tempVal |= (uint32_t)(sampleTimeCount);
113:                 	tempVal |= (uint32_t)(channelClockDivider << 16);
114:                 	tempVal |= (uint32_t)(earlyInterruptClk << 26);
115:                 	tempVal |= (uint32_t)(res << 24);
00000098  00000000   NOP
116:                 	regs->ADCxTIME[channelID] = tempVal;
000000A4  00000000   NOP
117:                     }
118:                 }
119:                 
120:                 
121:                 //******************************************************************************
122:                 /* Function :  ADCHS_ExistsConfiguration_Default
123:                 
124:                   Summary:
125:                     Implements Default variant of PLIB_ADCHS_ExistsConfiguration
126:                 
127:                   Description:
128:                     This template implements the Default variant of the PLIB_ADCHS_ExistsConfiguration function.
129:                 */
130:                 
131:                 #define PLIB_ADCHS_ExistsConfiguration PLIB_ADCHS_ExistsConfiguration
132:                 PLIB_TEMPLATE bool ADCHS_ExistsConfiguration_Default( ADCHS_MODULE_ID index )
133:                 {
134:                     return true;
135:                 }
136:                 
137:                 
138:                 #endif /*_ADCHS_SETUP_DEFAULT_H*/
139:                 
140:                 /******************************************************************************
141:                  End of File
142:                 */
143:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_manualcontrol_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_ManualControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ManualControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_SoftwareSamplingStart
16:                          PLIB_ADCHS_SoftwareSamplingStop
17:                          PLIB_ADCHS_SoftwareConversionStart
18:                          PLIB_ADCHS_SoftwareConversionInputSelect
19:                          PLIB_ADCHS_ExistsManualControl
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _ADCHS_MANUALCONTROL_DEFAULT_H
50:                  #define _ADCHS_MANUALCONTROL_DEFAULT_H
51:                  
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  ADCHS_SoftwareSamplingStart_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_ADCHS_SoftwareSamplingStart 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_ADCHS_SoftwareSamplingStart function.
62:                      This operation is not atomic.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void ADCHS_SoftwareSamplingStart_Default( ADCHS_MODULE_ID index )
66:                  {
67:                      volatile adchs_register_t *regs = (volatile adchs_register_t *)index;
68:                  
69:                      regs->ADCCON3.SAMP = 1;
70:                  }
71:                  
72:                  
73:                  //******************************************************************************
74:                  /* Function :  ADCHS_SoftwareSamplingStop_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_ADCHS_SoftwareSamplingStop 
78:                  
79:                    Description:
80:                      This template implements the Default variant of the PLIB_ADCHS_SoftwareSamplingStop function.
81:                      This operation is not atomic.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void ADCHS_SoftwareSamplingStop_Default( ADCHS_MODULE_ID index )
85:                  {
86:                      volatile adchs_register_t *regs = (volatile adchs_register_t *)index;
87:                  
88:                      regs->ADCCON3.SAMP = 0;
00000000  00000000   NOP
89:                  }
90:                  
91:                  
92:                  //******************************************************************************
93:                  /* Function :  ADCHS_SoftwareConversionStart_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_ADCHS_SoftwareConversionStart 
97:                  
98:                    Description:
99:                      This template implements the Default variant of the PLIB_ADCHS_SoftwareConversionStart function.
100:                     This operation is not atomic.
101:                 */
102:                 
103:                 PLIB_TEMPLATE void ADCHS_SoftwareConversionStart_Default( ADCHS_MODULE_ID index )
104:                 {
105:                     volatile adchs_register_t *regs = (volatile adchs_register_t *)index;
106:                 
107:                     regs->ADCCON3.RQCNVRT = 1;
108:                 }
109:                 
110:                 
111:                 //******************************************************************************
112:                 /* Function :  ADCHS_SoftwareConversionInputSelect_Default
113:                 
114:                   Summary:
115:                     Implements Default variant of PLIB_ADCHS_SoftwareConversionInputSelect 
116:                 
117:                   Description:
118:                     This template implements the Default variant of the PLIB_ADCHS_SoftwareConversionInputSelect function.
119:                     This operation is not atomic.
120:                 */
121:                 
122:                 PLIB_TEMPLATE void ADCHS_SoftwareConversionInputSelect_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID anInput )
123:                 {
124:                     volatile adchs_register_t *regs = (volatile adchs_register_t *)index;
125:                 
126:                     regs->ADCCON3.ADINSEL = anInput;
127:                 }
128:                 
129:                 
130:                 //******************************************************************************
131:                 /* Function :  ADCHS_ExistsManualControl_Default
132:                 
133:                   Summary:
134:                     Implements Default variant of PLIB_ADCHS_ExistsManualControl
135:                 
136:                   Description:
137:                     This template implements the Default variant of the PLIB_ADCHS_ExistsManualControl function.
138:                 */
139:                 
140:                 #define PLIB_ADCHS_ExistsManualControl PLIB_ADCHS_ExistsManualControl
141:                 PLIB_TEMPLATE bool ADCHS_ExistsManualControl_Default( ADCHS_MODULE_ID index )
142:                 {
143:                     return true;
144:                 }
145:                 
146:                 
147:                 #endif /*_ADCHS_MANUALCONTROL_DEFAULT_H*/
148:                 
149:                 /******************************************************************************
150:                  End of File
151:                 */
152:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_inputcontrol_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_InputControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : InputControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_ChannelInputSelect
16:                          PLIB_ADCHS_ExistsChannelInputSelectControl
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _ADCHS_INPUTCONTROL_DEFAULT_H
47:                  #define _ADCHS_INPUTCONTROL_DEFAULT_H
48:                  
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  ADCHS_ChannelInputSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_ADCHS_ChannelInputSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_ADCHS_ChannelInputSelect function.
59:                      Operation is not atomic.
60:                  */               
61:                  PLIB_TEMPLATE bool ADCHS_ChannelInputSelect_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID , ADCHS_CHANNEL_INP_SEL sel )
62:                  {
63:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
64:                  
65:                  #ifndef CHECON /* PIC32MZ */
66:                      regs->ADCTRGMODE &= ~(3 << (2 * channelID)  <<16); 
000000B8  00000000   NOP
67:                      regs->ADCTRGMODE |= (sel - 4 * channelID) << (2 * channelID)  << 16; 
000000CC  00000000   NOP
68:                  #else /*PIC32MK */
69:                      regs->ADCTRGMODE.bits &= ~(3 << (2 * channelID)  <<16); 
70:                      regs->ADCTRGMODE.bits |= (sel - 4 * channelID) << (2 * channelID)  << 16; 
71:                  #endif
72:                  
73:                      return true;
74:                  }
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  ADCHS_ExistsChannelInputSelectControl_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_ADCHS_ExistsChannelInputSelectControl
82:                  
83:                    Description:
84:                      This template implements the Default variant of the PLIB_ADCHS_ExistsChannelInputSelectControl function.
85:                  */
86:                  
87:                  #define PLIB_ADCHS_ExistsChannelInputSelectControl PLIB_ADCHS_ExistsChannelInputSelectControl
88:                  PLIB_TEMPLATE bool ADCHS_ExistsChannelInputSelectControl_Default( ADCHS_MODULE_ID index )
89:                  {
90:                      return true;
91:                  }
92:                  
93:                  
94:                  #endif /*_ADCHS_INPUTCONTROL_DEFAULT_H*/
95:                  
96:                  /******************************************************************************
97:                   End of File
98:                  */
99:                  
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_enablecontrol_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_Enable
16:                          PLIB_ADCHS_Disable
17:                          PLIB_ADCHS_ExistsEnableControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _ADCHS_ENABLECONTROL_DEFAULT_H
48:                  #define _ADCHS_ENABLECONTROL_DEFAULT_H
49:                  
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADCHS_Enable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADCHS_Enable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADCHS_Enable function.
60:                      Operation is not atomic.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void ADCHS_Enable_Default( ADCHS_MODULE_ID index )
64:                  {
65:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
66:                  
67:                      regs->ADCCON1.ON = 1;
0000031C  00000000   NOP
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  ADCHS_Disable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_ADCHS_Disable 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_ADCHS_Disable function.
79:                      Operation is not atomic.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void ADCHS_Disable_Default( ADCHS_MODULE_ID index )
83:                  {
84:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
85:                  
86:                      regs->ADCCON1.ON = 0;
00000000  00000000   NOP
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  ADCHS_ExistsEnableControl_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_ADCHS_ExistsEnableControl
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_ADCHS_ExistsEnableControl function.
98:                  */
99:                  
100:                 #define PLIB_ADCHS_ExistsEnableControl PLIB_ADCHS_ExistsEnableControl
101:                 PLIB_TEMPLATE bool ADCHS_ExistsEnableControl_Default( ADCHS_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_ADCHS_ENABLECONTROL_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_earlyinterruptcontrol_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_EarlyInterruptControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EarlyInterruptControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_EarlyInterruptEnable
16:                          PLIB_ADCHS_EarlyInterruptDisable
17:                          PLIB_ADCHS_AnalogInputEarlyInterruptEnable
18:                          PLIB_ADCHS_AnalogInputEarlyInterruptDisable
19:                          PLIB_ADCHS_AnalogInputEarlyInterruptIsReady
20:                          PLIB_ADCHS_ExistsEarlyInterruptControl
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _ADCHS_EARLYINTERRUPTCONTROL_DEFAULT_H
51:                  #define _ADCHS_EARLYINTERRUPTCONTROL_DEFAULT_H
52:                  
53:                  
54:                  
55:                  //******************************************************************************
56:                  /* Function :  ADCHS_EarlyInterruptEnable_Default
57:                  
58:                    Summary:
59:                      Implements Default variant of PLIB_ADCHS_EarlyInterruptEnable 
60:                  
61:                    Description:
62:                      This template implements the Default variant of the PLIB_ADCHS_EarlyInterruptEnable function.
63:                      This operation is not atomic.
64:                  */
65:                  
66:                  PLIB_TEMPLATE void ADCHS_EarlyInterruptEnable_Default( ADCHS_MODULE_ID index )
67:                  {
68:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
69:                  
70:                      regs->ADCCON2.ADCEIOVR = 0;
000000D4  00000000   NOP
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  ADCHS_EarlyInterruptDisable_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_ADCHS_EarlyInterruptDisable 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the PLIB_ADCHS_EarlyInterruptDisable function.
82:                      This operation is not atomic.
83:                  */
84:                  
85:                  PLIB_TEMPLATE void ADCHS_EarlyInterruptDisable_Default( ADCHS_MODULE_ID index )
86:                  {
87:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
88:                  
89:                      regs->ADCCON2.ADCEIOVR = 1;
90:                  }
91:                  
92:                  
93:                  //******************************************************************************
94:                  /* Function :  ADCHS_AnalogInputEarlyInterruptEnable_Default
95:                  
96:                    Summary:
97:                      Implements Default variant of PLIB_ADCHS_AnalogInputEarlyInterruptEnable 
98:                  
99:                    Description:
100:                     This template implements the Default variant of the PLIB_ADCHS_AnalogInputEarlyInterruptEnable function.
101:                     This operation is not atomic.
102:                 */
103:                 
104:                 PLIB_TEMPLATE void ADCHS_AnalogInputEarlyInterruptEnable_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID analogInput )
105:                 {
106:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
107:                 
108:                 #ifndef CHECON /* PIC32MZ */
109:                     regs->ADCEIENx[analogInput >> 5] |= BIT(analogInput & 0x1f);
110:                 #else /*PIC32MK */
111:                     regs->ADCEIENx[analogInput >> 5].bits |= BIT(analogInput & 0x1f);
112:                 #endif
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  ADCHS_AnalogInputEarlyInterruptDisable_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_ADCHS_AnalogInputEarlyInterruptDisable 
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_ADCHS_AnalogInputEarlyInterruptDisable function.
124:                     This operation is not atomic.
125:                 */
126:                 
127:                 PLIB_TEMPLATE void ADCHS_AnalogInputEarlyInterruptDisable_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID analogInput )
128:                 {
129:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
130:                 
131:                 #ifndef CHECON /* PIC32MZ */
132:                     regs->ADCEIENx[analogInput >> 5] &= ~BIT(analogInput & 0x1f);
133:                 #else /*PIC32MK */
134:                     regs->ADCEIENx[analogInput >> 5].clr = BIT(analogInput & 0x1f);
135:                 #endif
136:                 }
137:                 
138:                 
139:                 //******************************************************************************
140:                 /* Function :  ADCHS_AnalogInputEarlyInterruptIsReady_Default
141:                 
142:                   Summary:
143:                     Implements Default variant of PLIB_ADCHS_AnalogInputEarlyInterruptIsReady 
144:                 
145:                   Description:
146:                     This template implements the Default variant of the PLIB_ADCHS_AnalogInputEarlyInterruptIsReady function.
147:                     This operation is atomic.
148:                 */
149:                 
150:                 PLIB_TEMPLATE bool ADCHS_AnalogInputEarlyInterruptIsReady_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID analogInput )
151:                 {
152:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
153:                 
154:                 #ifndef CHECON /* PIC32MZ */
155:                     return (bool)(regs->ADCEISTATx[analogInput >> 5] & BIT(analogInput & 0x1f));
156:                 #else /*PIC32MK */
157:                     return (bool)(regs->ADCEISTATx[analogInput >> 5].bits & BIT(analogInput & 0x1f));
158:                 #endif
159:                 }
160:                 
161:                 
162:                 //******************************************************************************
163:                 /* Function :  ADCHS_ExistsEarlyInterruptControl_Default
164:                 
165:                   Summary:
166:                     Implements Default variant of PLIB_ADCHS_ExistsEarlyInterruptControl
167:                 
168:                   Description:
169:                     This template implements the Default variant of the PLIB_ADCHS_ExistsEarlyInterruptControl function.
170:                 */
171:                 
172:                 #define PLIB_ADCHS_ExistsEarlyInterruptControl PLIB_ADCHS_ExistsEarlyInterruptControl
173:                 PLIB_TEMPLATE bool ADCHS_ExistsEarlyInterruptControl_Default( ADCHS_MODULE_ID index )
174:                 {
175:                     return true;
176:                 }
177:                 
178:                 
179:                 #endif /*_ADCHS_EARLYINTERRUPTCONTROL_DEFAULT_H*/
180:                 
181:                 /******************************************************************************
182:                  End of File
183:                 */
184:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_digitalfilter_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_DigitalFilter_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DigitalFilter
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_DigitalFilterEnable
16:                          PLIB_ADCHS_DigitalFilterDisable
17:                          PLIB_ADCHS_DigitalFilterOversamplingModeSetup
18:                          PLIB_ADCHS_DigitalFilterAveragingModeSetup
19:                          PLIB_ADCHS_DigitalFilterOversamplingModeRatioSelect
20:                          PLIB_ADCHS_DigitalFilterAveragingModeSampleCountSelect
21:                          PLIB_ADCHS_DigitalFilterDataIsReady
22:                          PLIB_ADCHS_DigitalFilterDataGet
23:                          PLIB_ADCHS_DigitalFilterDataReadyInterruptEnable
24:                          PLIB_ADCHS_DigitalFilterDataReadyInterruptDisable
25:                          PLIB_ADCHS_ExistsDigitalFilter
26:                  
27:                  *******************************************************************************/
28:                  
29:                  //DOM-IGNORE-BEGIN
30:                  /*******************************************************************************
31:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
32:                  
33:                  Microchip licenses to you the right to use, modify, copy and distribute
34:                  Software only when embedded on a Microchip microcontroller or digital signal
35:                  controller that is integrated into your product or third party product
36:                  (pursuant to the sublicense terms in the accompanying license agreement).
37:                  
38:                  You should refer to the license agreement accompanying this Software for
39:                  additional information regarding your rights and obligations.
40:                  
41:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
42:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
43:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
44:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
45:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
46:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
47:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
48:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
49:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
50:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
51:                  *******************************************************************************/
52:                  
53:                  //DOM-IGNORE-END
54:                  
55:                  #ifndef _ADCHS_DIGITALFILTER_DEFAULT_H
56:                  #define _ADCHS_DIGITALFILTER_DEFAULT_H
57:                  
58:                  
59:                  
60:                  //******************************************************************************
61:                  /* Function :  ADCHS_DigitalFilterEnable_Default
62:                  
63:                    Summary:
64:                      Implements Default variant of PLIB_ADCHS_DigitalFilterEnable 
65:                  
66:                    Description:
67:                      This template implements the Default variant of the PLIB_ADCHS_DigitalFilterEnable function.
68:                      Operation is not atomic.
69:                  */
70:                  
71:                  PLIB_TEMPLATE void ADCHS_DigitalFilterEnable_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID id )
72:                  {
73:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
74:                  
75:                      regs->ADCFLTRx[id].AFEN = 1;
76:                  }
77:                  
78:                  
79:                  //******************************************************************************
80:                  /* Function :  ADCHS_DigitalFilterDisable_Default
81:                  
82:                    Summary:
83:                      Implements Default variant of PLIB_ADCHS_DigitalFilterDisable 
84:                  
85:                    Description:
86:                      This template implements the Default variant of the PLIB_ADCHS_DigitalFilterDisable function.
87:                      Operation is not atomic.
88:                  */
89:                  
90:                  PLIB_TEMPLATE void ADCHS_DigitalFilterDisable_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID id )
91:                  {
92:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
93:                  
94:                      regs->ADCFLTRx[id].AFEN = 0;
00000000  00000000   NOP
95:                  }
96:                  
97:                  
98:                  //******************************************************************************
99:                  /* Function :  ADCHS_DigitalFilterOversamplingModeSetup_Default
100:                 
101:                   Summary:
102:                     Implements Default variant of PLIB_ADCHS_DigitalFilterOversamplingModeSetup 
103:                 
104:                   Description:
105:                     This template implements the Default variant of the PLIB_ADCHS_DigitalFilterOversamplingModeSetup function.
106:                     Operation is not atomic.
107:                 */
108:                 
109:                 PLIB_TEMPLATE void ADCHS_DigitalFilterOversamplingModeSetup_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID id , ADCHS_AN_INPUT_ID analogInput , ADCHS_DIGITAL_FILTER_SIGNIFICANT_BITS length , ADCHS_DIGITAL_FILTER_OVERSAMPLE_RATIO ratio , bool intEnable )
110:                 {
111:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
112:                 
113:                     regs->ADCFLTRx[id].CHNLID = analogInput;
114:                     regs->ADCFLTRx[id].DATA16EN = length;
115:                     regs->ADCFLTRx[id].OVRSAM = ratio;
116:                     regs->ADCFLTRx[id].DFMODE = 0;
117:                 
118:                     regs->ADCFLTRx[id].AFGIEN = intEnable;
119:                 }
120:                 
121:                 
122:                 //******************************************************************************
123:                 /* Function :  ADCHS_DigitalFilterAveragingModeSetup_Default
124:                 
125:                   Summary:
126:                     Implements Default variant of PLIB_ADCHS_DigitalFilterAveragingModeSetup 
127:                 
128:                   Description:
129:                     This template implements the Default variant of the PLIB_ADCHS_DigitalFilterAveragingModeSetup function.
130:                     Operation is not atomic.
131:                 */
132:                 
133:                 PLIB_TEMPLATE void ADCHS_DigitalFilterAveragingModeSetup_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID id , ADCHS_AN_INPUT_ID analogInput , ADCHS_DIGITAL_FILTER_SIGNIFICANT_BITS length , ADCHS_DIGITAL_FILTER_AVERAGE_SAMPLE_COUNT count , bool intEnable )
134:                 {
135:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
136:                 
137:                     regs->ADCFLTRx[id].CHNLID = analogInput;
000002DC  00000000   NOP
138:                     regs->ADCFLTRx[id].DATA16EN = length;
000002E8  00000000   NOP
139:                     regs->ADCFLTRx[id].OVRSAM = count;
000002F4  00000000   NOP
140:                     regs->ADCFLTRx[id].DFMODE = 1;
00000304  00000000   NOP
141:                 
142:                     regs->ADCFLTRx[id].AFGIEN = intEnable;
00000310  00000000   NOP
143:                 }
144:                 
145:                 
146:                 //******************************************************************************
147:                 /* Function :  ADCHS_DigitalFilterOversamplingModeRatioSelect_Default
148:                 
149:                   Summary:
150:                     Implements Default variant of PLIB_ADCHS_DigitalFilterOversamplingModeRatioSelect 
151:                 
152:                   Description:
153:                     This template implements the Default variant of the PLIB_ADCHS_DigitalFilterOversamplingModeRatioSelect function.
154:                     Operation is not atomic.
155:                 */
156:                 
157:                 PLIB_TEMPLATE void ADCHS_DigitalFilterOversamplingModeRatioSelect_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID id , ADCHS_DIGITAL_FILTER_OVERSAMPLE_RATIO ratio )
158:                 {
159:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
160:                 
161:                     regs->ADCFLTRx[id].OVRSAM = ratio;
162:                     regs->ADCFLTRx[id].DFMODE = 0;
163:                 }
164:                 
165:                 
166:                 //******************************************************************************
167:                 /* Function :  ADCHS_DigitalFilterAveragingModeSampleCountSelect_Default
168:                 
169:                   Summary:
170:                     Implements Default variant of PLIB_ADCHS_DigitalFilterAveragingModeSampleCountSelect 
171:                 
172:                   Description:
173:                     This template implements the Default variant of the PLIB_ADCHS_DigitalFilterAveragingModeSampleCountSelect function.
174:                     Operation is not atomic.
175:                 */
176:                 
177:                 PLIB_TEMPLATE void ADCHS_DigitalFilterAveragingModeSampleCountSelect_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID id , ADCHS_DIGITAL_FILTER_AVERAGE_SAMPLE_COUNT count )
178:                 {
179:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
180:                 
181:                     regs->ADCFLTRx[id].OVRSAM = count;
182:                     regs->ADCFLTRx[id].DFMODE = 1;
183:                 }
184:                 
185:                 
186:                 //******************************************************************************
187:                 /* Function :  ADCHS_DigitalFilterDataIsReady_Default
188:                 
189:                   Summary:
190:                     Implements Default variant of PLIB_ADCHS_DigitalFilterDataIsReady 
191:                 
192:                   Description:
193:                     This template implements the Default variant of the PLIB_ADCHS_DigitalFilterDataIsReady function.
194:                     Operation is atomic.
195:                 */
196:                 
197:                 PLIB_TEMPLATE bool ADCHS_DigitalFilterDataIsReady_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID id )
198:                 {
199:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
200:                 
201:                     return (bool)regs->ADCFLTRx[id].AFRDY;
202:                 }
203:                 
204:                 
205:                 //******************************************************************************
206:                 /* Function :  ADCHS_DigitalFilterDataGet_Default
207:                 
208:                   Summary:
209:                     Implements Default variant of PLIB_ADCHS_DigitalFilterDataGet 
210:                 
211:                   Description:
212:                     This template implements the Default variant of the PLIB_ADCHS_DigitalFilterDataGet function.
213:                     Operation is atomic.
214:                 */
215:                 
216:                 PLIB_TEMPLATE int16_t ADCHS_DigitalFilterDataGet_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID dfltrID )
217:                 {
218:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
219:                 
220:                     return (int16_t)regs->ADCFLTRx[dfltrID].FLTRDATA;
00000000  00000000   NOP
221:                 }
222:                 
223:                 
224:                 //******************************************************************************
225:                 /* Function :  ADCHS_DigitalFilterDataReadyInterruptEnable_Default
226:                 
227:                   Summary:
228:                     Implements Default variant of PLIB_ADCHS_DigitalFilterDataReadyInterruptEnable 
229:                 
230:                   Description:
231:                     This template implements the Default variant of the PLIB_ADCHS_DigitalFilterDataReadyInterruptEnable function.
232:                     Operation is not atomic.
233:                 */
234:                 
235:                 PLIB_TEMPLATE void ADCHS_DigitalFilterDataReadyInterruptEnable_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID digFilter )
236:                 {
237:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
238:                 
239:                     regs->ADCFLTRx[digFilter].AFGIEN = 1;
240:                 }
241:                 
242:                 
243:                 //******************************************************************************
244:                 /* Function :  ADCHS_DigitalFilterDataReadyInterruptDisable_Default
245:                 
246:                   Summary:
247:                     Implements Default variant of PLIB_ADCHS_DigitalFilterDataReadyInterruptDisable 
248:                 
249:                   Description:
250:                     This template implements the Default variant of the PLIB_ADCHS_DigitalFilterDataReadyInterruptDisable function.
251:                     Operation is not atomic.
252:                 */
253:                 
254:                 PLIB_TEMPLATE void ADCHS_DigitalFilterDataReadyInterruptDisable_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_FILTER_ID digFilter )
255:                 {
256:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
257:                 
258:                     regs->ADCFLTRx[digFilter].AFGIEN = 0;
259:                 }
260:                 
261:                 
262:                 //******************************************************************************
263:                 /* Function :  ADCHS_ExistsDigitalFilter_Default
264:                 
265:                   Summary:
266:                     Implements Default variant of PLIB_ADCHS_ExistsDigitalFilter
267:                 
268:                   Description:
269:                     This template implements the Default variant of the PLIB_ADCHS_ExistsDigitalFilter function.
270:                 */
271:                 
272:                 #define PLIB_ADCHS_ExistsDigitalFilter PLIB_ADCHS_ExistsDigitalFilter
273:                 PLIB_TEMPLATE bool ADCHS_ExistsDigitalFilter_Default( ADCHS_MODULE_ID index )
274:                 {
275:                     return true;
276:                 }
277:                 
278:                 
279:                 #endif /*_ADCHS_DIGITALFILTER_DEFAULT_H*/
280:                 
281:                 /******************************************************************************
282:                  End of File
283:                 */
284:                 
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_DigitalFeatureControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DigitalFeatureControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_ChannelDigitalFeatureEnable
16:                          PLIB_ADCHS_ChannelDigitalFeatureDisable
17:                          PLIB_ADCHS_ExistsChannelDigitalControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _ADCHS_DIGITALFEATURECONTROL_DEFAULT_H
48:                  #define _ADCHS_DIGITALFEATURECONTROL_DEFAULT_H
49:                  
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADCHS_ChannelDigitalFeatureEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADCHS_ChannelDigitalFeatureEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADCHS_ChannelDigitalFeatureEnable function.
60:                      Operation is not atomic.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void ADCHS_ChannelDigitalFeatureEnable_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID )
64:                  {
65:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
66:                      volatile uint32_t *ADCCON3 = (volatile uint32_t *)&regs->ADCCON3;
67:                  
68:                      *ADCCON3 |= BIT(channelID + 16);
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  ADCHS_ChannelDigitalFeatureDisable_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_ADCHS_ChannelDigitalFeatureDisable 
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_ADCHS_ChannelDigitalFeatureDisable function.
80:                      Operation is not atomic.
81:                  */
82:                  
83:                  PLIB_TEMPLATE void ADCHS_ChannelDigitalFeatureDisable_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID )
84:                  {
85:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
86:                      volatile uint32_t *ADCCON3 = (volatile uint32_t *)&regs->ADCCON3;
87:                  
88:                      *ADCCON3 &= ~BIT(channelID + 16);
00000000  00000000   NOP
89:                  }
90:                  
91:                  
92:                  //******************************************************************************
93:                  /* Function :  ADCHS_ExistsChannelDigitalControl_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_ADCHS_ExistsChannelDigitalControl
97:                  
98:                    Description:
99:                      This template implements the Default variant of the PLIB_ADCHS_ExistsChannelDigitalControl function.
100:                 */
101:                 
102:                 #define PLIB_ADCHS_ExistsChannelDigitalControl PLIB_ADCHS_ExistsChannelDigitalControl
103:                 PLIB_TEMPLATE bool ADCHS_ExistsChannelDigitalControl_Default( ADCHS_MODULE_ID index )
104:                 {
105:                     return true;
106:                 }
107:                 
108:                 
109:                 #endif /*_ADCHS_DIGITALFEATURECONTROL_DEFAULT_H*/
110:                 
111:                 /******************************************************************************
112:                  End of File
113:                 */
114:                 
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_DigitalComparator_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DigitalComparator
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_DigitalComparatorAnalogInputSelect
16:                          PLIB_ADCHS_DigitalComparatorAnalogInputGet
17:                          PLIB_ADCHS_DigitalComparatorEnable
18:                          PLIB_ADCHS_DigitalComparatorDisable
19:                          PLIB_ADCHS_DigitalComparatorInterruptEnable
20:                          PLIB_ADCHS_DigitalComparatorInterruptDisable
21:                          PLIB_ADCHS_DigitalComparatorSetup
22:                          PLIB_ADCHS_DigitalComparatorEventHasOccurred
23:                          PLIB_ADCHS_DigitalComparatorLimitSet
24:                          PLIB_ADCHS_ExistsDigitalComparator
25:                  
26:                  *******************************************************************************/
27:                  
28:                  //DOM-IGNORE-BEGIN
29:                  /*******************************************************************************
30:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
31:                  
32:                  Microchip licenses to you the right to use, modify, copy and distribute
33:                  Software only when embedded on a Microchip microcontroller or digital signal
34:                  controller that is integrated into your product or third party product
35:                  (pursuant to the sublicense terms in the accompanying license agreement).
36:                  
37:                  You should refer to the license agreement accompanying this Software for
38:                  additional information regarding your rights and obligations.
39:                  
40:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
41:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
42:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
43:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
44:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
45:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
46:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
47:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
48:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
49:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
50:                  *******************************************************************************/
51:                  
52:                  //DOM-IGNORE-END
53:                  
54:                  #ifndef _ADCHS_DIGITALCOMPARATOR_DEFAULT_H
55:                  #define _ADCHS_DIGITALCOMPARATOR_DEFAULT_H
56:                  
57:                  
58:                  
59:                  //******************************************************************************
60:                  /* Function :  ADCHS_DigitalComparatorAnalogInputSelect_Default
61:                  
62:                    Summary:
63:                      Implements Default variant of PLIB_ADCHS_DigitalComparatorAnalogInputSelect 
64:                  
65:                    Description:
66:                      This template implements the Default variant of the PLIB_ADCHS_DigitalComparatorAnalogInputSelect function.
67:                      Operation is not atomic.
68:                  */
69:                  
70:                  PLIB_TEMPLATE void ADCHS_DigitalComparatorAnalogInputSelect_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_COMPARATOR_ID digComparator , ADCHS_AN_INPUT_ID analogInput )
71:                  {
72:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
73:                  
74:                      regs->adccmpx[digComparator].ADCCMPEN |= BIT(analogInput);
75:                  }
76:                  
77:                  
78:                  //******************************************************************************
79:                  /* Function :  ADCHS_DigitalComparatorAnalogInputGet_Default
80:                  
81:                    Summary:
82:                      Implements Default variant of PLIB_ADCHS_DigitalComparatorAnalogInputGet 
83:                  
84:                    Description:
85:                      This template implements the Default variant of the PLIB_ADCHS_DigitalComparatorAnalogInputGet function.
86:                      Operation is atomic.
87:                  */
88:                  
89:                  PLIB_TEMPLATE ADCHS_AN_INPUT_ID ADCHS_DigitalComparatorAnalogInputGet_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_COMPARATOR_ID digComparator )
90:                  {
91:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
92:                  
93:                      return regs->ADCCMPCONx[digComparator].AINID;
94:                  }
95:                  
96:                  
97:                  //******************************************************************************
98:                  /* Function :  ADCHS_DigitalComparatorEnable_Default
99:                  
100:                   Summary:
101:                     Implements Default variant of PLIB_ADCHS_DigitalComparatorEnable 
102:                 
103:                   Description:
104:                     This template implements the Default variant of the PLIB_ADCHS_DigitalComparatorEnable function.
105:                     Operation is not atomic.
106:                 */
107:                 
108:                 PLIB_TEMPLATE void ADCHS_DigitalComparatorEnable_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_COMPARATOR_ID digComparator )
109:                 {
110:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
111:                 
112:                     regs->ADCCMPCONx[digComparator].ENDCMP = 1;
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  ADCHS_DigitalComparatorDisable_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_ADCHS_DigitalComparatorDisable 
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_ADCHS_DigitalComparatorDisable function.
124:                     Operation is not atomic.
125:                 */
126:                 
127:                 PLIB_TEMPLATE void ADCHS_DigitalComparatorDisable_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_COMPARATOR_ID digComparator )
128:                 {
129:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
130:                 
131:                     regs->ADCCMPCONx[digComparator].ENDCMP = 0;
00000000  00000000   NOP
132:                 }
133:                 
134:                 
135:                 //******************************************************************************
136:                 /* Function :  ADCHS_DigitalComparatorInterruptEnable_Default
137:                 
138:                   Summary:
139:                     Implements Default variant of PLIB_ADCHS_DigitalComparatorInterruptEnable 
140:                 
141:                   Description:
142:                     This template implements the Default variant of the PLIB_ADCHS_DigitalComparatorInterruptEnable function.
143:                     Operation is not atomic.
144:                 */
145:                 
146:                 PLIB_TEMPLATE void ADCHS_DigitalComparatorInterruptEnable_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_COMPARATOR_ID digComparator )
147:                 {
148:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
149:                 
150:                     regs->ADCCMPCONx[digComparator].DCMPGIEN = 1;
151:                 }
152:                 
153:                 
154:                 //******************************************************************************
155:                 /* Function :  ADCHS_DigitalComparatorInterruptDisable_Default
156:                 
157:                   Summary:
158:                     Implements Default variant of PLIB_ADCHS_DigitalComparatorInterruptDisable 
159:                 
160:                   Description:
161:                     This template implements the Default variant of the PLIB_ADCHS_DigitalComparatorInterruptDisable function.
162:                     Operation is not atomic.
163:                 */
164:                 
165:                 PLIB_TEMPLATE void ADCHS_DigitalComparatorInterruptDisable_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_COMPARATOR_ID digComparator )
166:                 {
167:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
168:                 
169:                     regs->ADCCMPCONx[digComparator].DCMPGIEN = 0;
170:                 }
171:                 
172:                 
173:                 //******************************************************************************
174:                 /* Function :  ADCHS_DigitalComparatorSetup_Default
175:                 
176:                   Summary:
177:                     Implements Default variant of PLIB_ADCHS_DigitalComparatorSetup 
178:                 
179:                   Description:
180:                     This template implements the Default variant of the PLIB_ADCHS_DigitalComparatorSetup function.
181:                     Operation is not atomic.
182:                 */
183:                 
184:                 PLIB_TEMPLATE void ADCHS_DigitalComparatorSetup_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_COMPARATOR_ID id , bool intEnable , bool inBetweenOrEqual , bool greaterEqualHi , bool lessThanHi , bool greaterEqualLo , bool lessThanLo , ADCHS_AN_INPUT_ID analogInput , int16_t  hiLimit , int16_t  loLimit )
185:                 {
186:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
187:                 
188:                     regs->ADCCMPCONx[id].IELOLO = lessThanLo;
00000154  00000000   NOP
000001BC  00000000   NOP
0000021C  00000000   NOP
0000027C  00000000   NOP
189:                     regs->ADCCMPCONx[id].IELOHI = greaterEqualLo;
00000168  00000000   NOP
000001C8  00000000   NOP
00000228  00000000   NOP
00000288  00000000   NOP
190:                     regs->ADCCMPCONx[id].IEHILO = lessThanHi;
00000174  00000000   NOP
000001D4  00000000   NOP
00000234  00000000   NOP
00000294  00000000   NOP
191:                     regs->ADCCMPCONx[id].IEHIHI = greaterEqualHi;
00000180  00000000   NOP
000001E0  00000000   NOP
00000240  00000000   NOP
000002A0  00000000   NOP
192:                     regs->ADCCMPCONx[id].IEBTWN = inBetweenOrEqual;
0000018C  00000000   NOP
000001EC  00000000   NOP
0000024C  00000000   NOP
000002AC  00000000   NOP
193:                     regs->ADCCMPCONx[id].DCMPGIEN = intEnable;
0000019C  00000000   NOP
000001F8  00000000   NOP
00000258  00000000   NOP
000002B8  00000000   NOP
194:                 
195:                     regs->adccmpx[id].ADCCMPEN |= BIT(analogInput);
000001A8  00000000   NOP
00000204  00000000   NOP
00000264  00000000   NOP
000002C4  00000000   NOP
196:                     regs->adccmpx[id].ADCCMP = ((uint32_t)(hiLimit << 16) | loLimit);
000001B4  00000000   NOP
00000210  00000000   NOP
00000270  00000000   NOP
000002D0  00000000   NOP
197:                 }
198:                 
199:                 
200:                 //******************************************************************************
201:                 /* Function :  ADCHS_DigitalComparatorEventHasOccurred_Default
202:                 
203:                   Summary:
204:                     Implements Default variant of PLIB_ADCHS_DigitalComparatorEventHasOccurred 
205:                 
206:                   Description:
207:                     This template implements the Default variant of the PLIB_ADCHS_DigitalComparatorEventHasOccurred function.
208:                     Operation is not atomic.
209:                 */
210:                 
211:                 PLIB_TEMPLATE bool ADCHS_DigitalComparatorEventHasOccurred_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_COMPARATOR_ID id )
212:                 {
213:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
214:                 
215:                     return (bool)regs->ADCCMPCONx[id].DCMPED;
00000000  00000000   NOP
216:                 }
217:                 
218:                 
219:                 //******************************************************************************
220:                 /* Function :  ADCHS_DigitalComparatorLimitSet_Default
221:                 
222:                   Summary:
223:                     Implements Default variant of PLIB_ADCHS_DigitalComparatorLimitSet 
224:                 
225:                   Description:
226:                     This template implements the Default variant of the PLIB_ADCHS_DigitalComparatorLimitSet function.
227:                     Operation is not atomic.
228:                 */
229:                 
230:                 PLIB_TEMPLATE void ADCHS_DigitalComparatorLimitSet_Default( ADCHS_MODULE_ID index , ADCHS_DIGITAL_COMPARATOR_ID id , int16_t  hiLimit , int16_t  loLimit )
231:                 {
232:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
233:                 
234:                     regs->adccmpx[id].ADCCMP = ((uint32_t)(hiLimit << 16) | loLimit);
235:                 }
236:                 
237:                 
238:                 //******************************************************************************
239:                 /* Function :  ADCHS_ExistsDigitalComparator_Default
240:                 
241:                   Summary:
242:                     Implements Default variant of PLIB_ADCHS_ExistsDigitalComparator
243:                 
244:                   Description:
245:                     This template implements the Default variant of the PLIB_ADCHS_ExistsDigitalComparator function.
246:                 */
247:                 
248:                 #define PLIB_ADCHS_ExistsDigitalComparator PLIB_ADCHS_ExistsDigitalComparator
249:                 PLIB_TEMPLATE bool ADCHS_ExistsDigitalComparator_Default( ADCHS_MODULE_ID index )
250:                 {
251:                     return true;
252:                 }
253:                 
254:                 
255:                 #endif /*_ADCHS_DIGITALCOMPARATOR_DEFAULT_H*/
256:                 
257:                 /******************************************************************************
258:                  End of File
259:                 */
260:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_conversionresult_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_ConversionResult_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ConversionResult
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_AnalogInputDataReadyInterruptEnable
16:                          PLIB_ADCHS_AnalogInputDataReadyInterruptDisable
17:                          PLIB_ADCHS_AnalogInputDataIsReady
18:                          PLIB_ADCHS_AnalogInputResultGet
19:                          PLIB_ADCHS_ExistsConversionResults
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _ADCHS_CONVERSIONRESULT_DEFAULT_H
50:                  #define _ADCHS_CONVERSIONRESULT_DEFAULT_H
51:                  
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  ADCHS_AnalogInputDataReadyInterruptEnable_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_ADCHS_AnalogInputDataReadyInterruptEnable 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_ADCHS_AnalogInputDataReadyInterruptEnable function.
62:                      Operation is not atomic.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void ADCHS_AnalogInputDataReadyInterruptEnable_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID analogInput )
66:                  {
67:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
68:                  
69:                  #ifndef CHECON /* PIC32MZ */
70:                      regs->ADCGIRQENx[analogInput / 32] |= BIT(analogInput % 32);
000000E0  00000000   NOP
71:                  #else /*PIC32MK */
72:                      regs->ADCGIRQENx[analogInput / 32].set = BIT(analogInput % 32);
73:                  #endif
74:                  }
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  ADCHS_AnalogInputDataReadyInterruptDisable_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_ADCHS_AnalogInputDataReadyInterruptDisable 
82:                  
83:                    Description:
84:                      This template implements the Default variant of the PLIB_ADCHS_AnalogInputDataReadyInterruptDisable function.
85:                      Operation is not atomic.
86:                  */
87:                  
88:                  PLIB_TEMPLATE void ADCHS_AnalogInputDataReadyInterruptDisable_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID analogInput )
89:                  {
90:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
91:                  
92:                  #ifndef CHECON /* PIC32MZ */
93:                      regs->ADCGIRQENx[analogInput / 32] &= ~BIT(analogInput % 32);
94:                  #else /*PIC32MK */
95:                      regs->ADCGIRQENx[analogInput / 32].clr = BIT(analogInput % 32);
96:                  #endif
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  ADCHS_AnalogInputDataIsReady_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_ADCHS_AnalogInputDataIsReady 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_ADCHS_AnalogInputDataIsReady function.
108:                     Operation is atomic.
109:                 */
110:                 
111:                 PLIB_TEMPLATE bool ADCHS_AnalogInputDataIsReady_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID analogInput )
112:                 {
113:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
114:                 
115:                 #ifndef CHECON /* PIC32MZ */
116:                     return (bool)(regs->ADCSTATx[analogInput / 32] & BIT(analogInput % 32));
117:                 #else /*PIC32MK */
118:                      return (bool)(regs->ADCSTATx[analogInput / 32].bits & BIT(analogInput % 32));
119:                 #endif
120:                 }
121:                 
122:                 //******************************************************************************
123:                 /* Function :  ADCHS_AnalogInputResultGet_Default
124:                 
125:                   Summary:
126:                     Implements Default variant of PLIB_ADCHS_AnalogInputResultGet 
127:                 
128:                   Description:
129:                     This template implements the Default variant of the PLIB_ADCHS_AnalogInputResultGet function.
130:                     Operation is atomic.
131:                 */
132:                 
133:                 PLIB_TEMPLATE uint32_t ADCHS_AnalogInputResultGet_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID analogInput )
134:                 {
135:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
136:                 
137:                 #ifndef CHECON /* PIC32MZ */
138:                     return regs->ADCDATAx[analogInput];
00000004  00000000   NOP
139:                 #else /*PIC32MK */
140:                     return regs->ADCDATAx[analogInput].bits;
141:                 #endif
142:                 }
143:                 
144:                 //******************************************************************************
145:                 /* Function :  ADCHS_ExistsConversionResults_Default
146:                 
147:                   Summary:
148:                     Implements Default variant of PLIB_ADCHS_ExistsConversionResults
149:                 
150:                   Description:
151:                     This template implements the Default variant of the PLIB_ADCHS_ExistsConversionResults function.
152:                 */
153:                 
154:                 #define PLIB_ADCHS_ExistsConversionResults PLIB_ADCHS_ExistsConversionResults
155:                 PLIB_TEMPLATE bool ADCHS_ExistsConversionResults_Default( ADCHS_MODULE_ID index )
156:                 {
157:                     return true;
158:                 }
159:                 
160:                 
161:                 #endif /*_ADCHS_CONVERSIONRESULT_DEFAULT_H*/
162:                 
163:                 /******************************************************************************
164:                  End of File
165:                 */
166:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_channeltriggersamplecontrol_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_ChannelTriggerSampleControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelTriggerSampleControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_ChannelTriggerSampleSelect
16:                          PLIB_ADCHS_ExistsTriggerSampleControl
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _ADCHS_CHANNELTRIGGERSAMPLECONTROL_DEFAULT_H
47:                  #define _ADCHS_CHANNELTRIGGERSAMPLECONTROL_DEFAULT_H
48:                  
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  ADCHS_ChannelTriggerSampleSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_ADCHS_ChannelTriggerSampleSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_ADCHS_ChannelTriggerSampleSelect function.
59:                      Operation is not atomic.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool ADCHS_ChannelTriggerSampleSelect_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID , ADCHS_CHANNEL_TRIGGER_SAMPLING_SEL sampSel )
63:                  {
64:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
65:                  
66:                      if (channelID == ADCHS_CHANNEL_7)
67:                  	return false;
68:                  #ifndef CHECON 
69:                      regs->ADCTRGMODE &= ~(0x0101 << channelID);
000000A8  00000000   NOP
70:                  
71:                      switch (sampSel) {
72:                      case ADCHS_CHANNEL_UNSYNC_TRIGGER_UNSYNC_SAMPLING:
73:                  	break;
74:                  
75:                      case ADCHS_CHANNEL_SYNC_SAMPLING:
76:                  	regs->ADCTRGMODE |= (0x0001 << channelID);
77:                  	break;
78:                  
79:                      case ADCHS_CHANNEL_SYNC_TRIGGER_UNSYNC_SAMPLING:
80:                  	regs->ADCTRGMODE |= (0x0100 << channelID);
81:                  	break;
82:                  
83:                  #else
84:                      regs->ADCTRGMODE.bits &= ~(0x0101 << channelID);
85:                  
86:                      switch (sampSel) {
87:                      case ADCHS_CHANNEL_UNSYNC_TRIGGER_UNSYNC_SAMPLING:
88:                  	break;
89:                  
90:                      case ADCHS_CHANNEL_SYNC_SAMPLING:
91:                  	regs->ADCTRGMODE.bits |= (0x0001 << channelID);
92:                  	break;
93:                  
94:                      case ADCHS_CHANNEL_SYNC_TRIGGER_UNSYNC_SAMPLING:
95:                  	regs->ADCTRGMODE.bits |= (0x0100 << channelID);
96:                  	break;
97:                  
98:                  #endif
99:                  
100:                     default:
101:                 	break;
102:                     }
103:                 
104:                     return true;
105:                 }
106:                 
107:                 //******************************************************************************
108:                 /* Function :  ADCHS_ExistsTriggerSampleControl_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_ADCHS_ExistsTriggerSampleControl
112:                 
113:                   Description:
114:                     This template implements the Default variant of the PLIB_ADCHS_ExistsTriggerSampleControl function.
115:                 */
116:                 
117:                 #define PLIB_ADCHS_ExistsTriggerSampleControl PLIB_ADCHS_ExistsTriggerSampleControl
118:                 PLIB_TEMPLATE bool ADCHS_ExistsTriggerSampleControl_Default( ADCHS_MODULE_ID index )
119:                 {
120:                     return true;
121:                 }
122:                 
123:                 
124:                 #endif /*_ADCHS_CHANNELTRIGGERSAMPLECONTROL_DEFAULT_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_channelconfiguration_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_ChannelConfiguration_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelConfiguration
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_ChannelConfigurationGet
16:                          PLIB_ADCHS_ChannelConfigurationSet
17:                          PLIB_ADCHS_ExistsChannelConfiguration
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _ADCHS_CHANNELCONFIGURATION_DEFAULT_H
48:                  #define _ADCHS_CHANNELCONFIGURATION_DEFAULT_H
49:                  
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADCHS_ChannelConfigurationGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADCHS_ChannelConfigurationGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADCHS_ChannelConfigurationGet function.
60:                      Operation is atomic.
61:                  */
62:                  
63:                  PLIB_TEMPLATE uint32_t ADCHS_ChannelConfigurationGet_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID )
64:                  {
65:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
66:                  
67:                  #ifndef CHECON /* PIC32MZ */
68:                      return regs->ADCxCFG[channelID];
69:                  #else /*PIC32MK */
70:                      return regs->ADCxCFG[channelID].bits;
71:                  #endif
72:                  }
73:                  
74:                  
75:                  //******************************************************************************
76:                  /* Function :  ADCHS_ChannelConfigurationSet_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_ADCHS_ChannelConfigurationSet 
80:                  
81:                    Description:
82:                      This template implements the Default variant of the PLIB_ADCHS_ChannelConfigurationSet function.
83:                      Operation is atomic.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void ADCHS_ChannelConfigurationSet_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID , uint32_t config )
87:                  {
88:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
89:                  
90:                  #ifndef CHECON /* PIC32MZ */
91:                      regs->ADCxCFG[channelID] = config;
00000148  00000000   NOP
92:                  #else /*PIC32MK */
93:                      regs->ADCxCFG[channelID].bits = config;
94:                  #endif
95:                  }
96:                  
97:                  
98:                  //******************************************************************************
99:                  /* Function :  ADCHS_ExistsChannelConfiguration_Default
100:                 
101:                   Summary:
102:                     Implements Default variant of PLIB_ADCHS_ExistsChannelConfiguration
103:                 
104:                   Description:
105:                     This template implements the Default variant of the PLIB_ADCHS_ExistsChannelConfiguration function.
106:                 */
107:                 
108:                 #define PLIB_ADCHS_ExistsChannelConfiguration PLIB_ADCHS_ExistsChannelConfiguration
109:                 PLIB_TEMPLATE bool ADCHS_ExistsChannelConfiguration_Default( ADCHS_MODULE_ID index )
110:                 {
111:                     return true;
112:                 }
113:                 
114:                 
115:                 #endif /*_ADCHS_CHANNELCONFIGURATION_DEFAULT_H*/
116:                 
117:                 /******************************************************************************
118:                  End of File
119:                 */
120:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_analoginputmodecontrol_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_AnalogInputModeControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AnalogInputModeControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_AnalogInputModeSelect
16:                          PLIB_ADCHS_AnalogInputModeGet
17:                          PLIB_ADCHS_ExistsAnalogInputModeControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _ADCHS_ANALOGINPUTMODECONTROL_DEFAULT_H
48:                  #define _ADCHS_ANALOGINPUTMODECONTROL_DEFAULT_H
49:                  
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADCHS_AnalogInputModeSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADCHS_AnalogInputModeSelect 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADCHS_AnalogInputModeSelect function.
60:                      Operation is not atomic.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void ADCHS_AnalogInputModeSelect_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID analogInput , ADCHS_INPUT_MODE mode )
64:                  {
65:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
66:                  
67:                  #ifndef CHECON 
68:                      regs->ADCIMCONx[analogInput / 16] &= ~(3 << ((analogInput % 16) * 2));
000000EC  00000000   NOP
69:                      regs->ADCIMCONx[analogInput / 16] |= (mode << ((analogInput % 16) * 2));
000000FC  00000000   NOP
70:                  #else
71:                      regs->ADCIMCONx[analogInput / 16].bits &= ~(3 << ((analogInput % 16) * 2));
72:                      regs->ADCIMCONx[analogInput / 16].bits |= (mode << ((analogInput % 16) * 2));
73:                  #endif
74:                  }
75:                  
76:                  //******************************************************************************
77:                  /* Function :  ADCHS_AnalogInputModeGet_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_ADCHS_AnalogInputModeGet 
81:                  
82:                    Description:
83:                      This template implements the Default variant of the PLIB_ADCHS_AnalogInputModeGet function.
84:                      Operation is atomic.
85:                  */
86:                  
87:                  PLIB_TEMPLATE ADCHS_INPUT_MODE ADCHS_AnalogInputModeGet_Default( ADCHS_MODULE_ID index , ADCHS_AN_INPUT_ID analogInput )
88:                  {
89:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
90:                  
91:                  #ifndef CHECON 
92:                      return (ADCHS_INPUT_MODE)(regs->ADCIMCONx[analogInput / 16] >> ((analogInput % 16) * 2)) & 0x3;
93:                  #else
94:                      return (ADCHS_INPUT_MODE)(regs->ADCIMCONx[analogInput / 16].bits >> ((analogInput % 16) * 2)) & 0x3;
95:                  #endif
96:                  }
97:                  
98:                  
99:                  //******************************************************************************
100:                 /* Function :  ADCHS_ExistsAnalogInputModeControl_Default
101:                 
102:                   Summary:
103:                     Implements Default variant of PLIB_ADCHS_ExistsAnalogInputModeControl
104:                 
105:                   Description:
106:                     This template implements the Default variant of the PLIB_ADCHS_ExistsAnalogInputModeControl function.
107:                 */
108:                 
109:                 #define PLIB_ADCHS_ExistsAnalogInputModeControl PLIB_ADCHS_ExistsAnalogInputModeControl
110:                 PLIB_TEMPLATE bool ADCHS_ExistsAnalogInputModeControl_Default( ADCHS_MODULE_ID index )
111:                 {
112:                     return true;
113:                 }
114:                 
115:                 
116:                 #endif /*_ADCHS_ANALOGINPUTMODECONTROL_DEFAULT_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/templates/adchs_analogfeaturecontrol_default.h
1:                   /*******************************************************************************
2:                     ADCHS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adchs_AnalogFeatureControl_Default.h
6:                   
7:                     Summary:
8:                       ADCHS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AnalogFeatureControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADCHS_ChannelAnalogFeatureEnable
16:                          PLIB_ADCHS_ChannelAnalogFeatureDisable
17:                          PLIB_ADCHS_ChannelIsReady
18:                          PLIB_ADCHS_ChannelIsReadyInterruptEnable
19:                          PLIB_ADCHS_ChannelIsReadyInterruptDisable
20:                          PLIB_ADCHS_ExistsChannelAnalogControl
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _ADCHS_ANALOGFEATURECONTROL_DEFAULT_H
51:                  #define _ADCHS_ANALOGFEATURECONTROL_DEFAULT_H
52:                  
53:                  //******************************************************************************
54:                  
55:                  
56:                  //******************************************************************************
57:                  /* Function :  ADCHS_ChannelAnalogFeatureEnable_Default
58:                  
59:                    Summary:
60:                      Implements Default variant of PLIB_ADCHS_ChannelAnalogFeatureEnable 
61:                  
62:                    Description:
63:                      This template implements the Default variant of the PLIB_ADCHS_ChannelAnalogFeatureEnable function.
64:                      Operation is not atomic.
65:                  */
66:                  
67:                  PLIB_TEMPLATE void ADCHS_ChannelAnalogFeatureEnable_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID )
68:                  {
69:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
70:                  #ifndef CHECON 
71:                      regs->ADCANCON |= BIT(channelID);
00000350  00000000   NOP
72:                  #else
73:                      regs->ADCANCON.set = BIT(channelID);
74:                  #endif
75:                  }
76:                  
77:                  
78:                  //******************************************************************************
79:                  /* Function :  ADCHS_ChannelAnalogFeatureDisable_Default
80:                  
81:                    Summary:
82:                      Implements Default variant of PLIB_ADCHS_ChannelAnalogFeatureDisable 
83:                  
84:                    Description:
85:                      This template implements the Default variant of the PLIB_ADCHS_ChannelAnalogFeatureDisable function.
86:                      Operation is not atomic.
87:                  */
88:                  
89:                  PLIB_TEMPLATE void ADCHS_ChannelAnalogFeatureDisable_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID )
90:                  {
91:                      volatile adchs_register_t *regs = (adchs_register_t *)index;
92:                  
93:                  #ifndef CHECON 
94:                      regs->ADCANCON &= ~BIT(channelID);
95:                  #else
96:                      regs->ADCANCON.clr = BIT(channelID);
97:                  #endif
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  ADCHS_ChannelIsReady_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_ADCHS_ChannelIsReady 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_ADCHS_ChannelIsReady function.
109:                     Operation is not atomic.
110:                 */
111:                 
112:                 PLIB_TEMPLATE bool ADCHS_ChannelIsReady_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID )
113:                 {
114:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
115:                 
116:                 #ifndef CHECON 
117:                     return (bool)(regs->ADCANCON & BIT(channelID + 8));
00000360  00000000   NOP
118:                 #else
119:                     return (bool)(regs->ADCANCON.bits & BIT(channelID + 8));
120:                 #endif
121:                 }
122:                 
123:                 
124:                 //******************************************************************************
125:                 /* Function :  ADCHS_ChannelIsReadyInterruptEnable_Default
126:                 
127:                   Summary:
128:                     Implements Default variant of PLIB_ADCHS_ChannelIsReadyInterruptEnable 
129:                 
130:                   Description:
131:                     This template implements the Default variant of the PLIB_ADCHS_ChannelIsReadyInterruptEnable function.
132:                     Operation is not atomic.
133:                 */
134:                 
135:                 PLIB_TEMPLATE void ADCHS_ChannelIsReadyInterruptEnable_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID )
136:                 {
137:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
138:                 
139:                 #ifndef CHECON 
140:                     regs->ADCANCON |= BIT(channelID + 16);
141:                 #else
142:                     regs->ADCANCON.set = BIT(channelID + 16);
143:                 #endif
144:                 }
145:                 
146:                 
147:                 //******************************************************************************
148:                 /* Function :  ADCHS_ChannelIsReadyInterruptDisable_Default
149:                 
150:                   Summary:
151:                     Implements Default variant of PLIB_ADCHS_ChannelIsReadyInterruptDisable 
152:                 
153:                   Description:
154:                     This template implements the Default variant of the PLIB_ADCHS_ChannelIsReadyInterruptDisable function.
155:                     Operation is not atomic.
156:                 */
157:                 
158:                 PLIB_TEMPLATE void ADCHS_ChannelIsReadyInterruptDisable_Default( ADCHS_MODULE_ID index , ADCHS_CHANNEL_ID channelID )
159:                 {
160:                     volatile adchs_register_t *regs = (adchs_register_t *)index;
161:                 
162:                 #ifndef CHECON 
163:                    regs->ADCANCON &= ~BIT(channelID + 16);
164:                 #else
165:                    regs->ADCANCON.clr = BIT(channelID + 16);
166:                 #endif
167:                 }
168:                 
169:                 
170:                 //******************************************************************************
171:                 /* Function :  ADCHS_ExistsChannelAnalogControl_Default
172:                 
173:                   Summary:
174:                     Implements Default variant of PLIB_ADCHS_ExistsChannelAnalogControl
175:                 
176:                   Description:
177:                     This template implements the Default variant of the PLIB_ADCHS_ExistsChannelAnalogControl function.
178:                 */
179:                 
180:                 #define PLIB_ADCHS_ExistsChannelAnalogControl PLIB_ADCHS_ExistsChannelAnalogControl
181:                 PLIB_TEMPLATE bool ADCHS_ExistsChannelAnalogControl_Default( ADCHS_MODULE_ID index )
182:                 {
183:                     return true;
184:                 }
185:                 
186:                 
187:                 #endif /*_ADCHS_ANALOGFEATURECONTROL_DEFAULT_H*/
188:                 
189:                 /******************************************************************************
190:                  End of File
191:                 */
192:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/peripheral/adchs/drv_adc_static.c
1:                   /*******************************************************************************
2:                     ADC Driver Initialization File
3:                   
4:                     File Name:
5:                       drv_adc_static_hs.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the IC driver.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "DRV_ADC_Initialize" function, configuration bits, and allocates
13:                      any necessary global system resources, such as the systemObjects structure
14:                      that contains the object handles to all the MPLAB Harmony module objects in
15:                      the system.
16:                   *******************************************************************************/
17:                  
18:                  /*******************************************************************************
19:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
20:                  
21:                  Microchip licenses to you the right to use, modify, copy and distribute
22:                  Software only when embedded on a Microchip microcontroller or digital signal
23:                  controller that is integrated into your product or third party product
24:                  (pursuant to the sublicense terms in the accompanying license agreement).
25:                  
26:                  You should refer to the license agreement accompanying this Software for
27:                  additional information regarding your rights and obligations.
28:                  
29:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
30:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
31:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
32:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
33:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
34:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
35:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
36:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
37:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
38:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
39:                   *******************************************************************************/
40:                  
41:                  // *****************************************************************************
42:                  // *****************************************************************************
43:                  // Section: Include Files
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  #include "drv_adc_static.h"
47:                   
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: ADC Static Driver Functions
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  void DRV_ADC_Initialize(void)
54:                  {
55:                      /* Select Power Mode */
56:                  	PLIB_ADCHS_Setup(
57:                          DRV_ADC_ID_1,
58:                          ADCHS_VREF_AVDD_AVSS,
59:                          ADCHS_CHARGEPUMP_DISABLE,
60:                          ADCHS_OUTPUT_DATA_FORMAT_INTEGER,
61:                          false,
62:                          ADCHS_FAST_SYNC_SYSTEM_CLOCK_DISABLE,
63:                          ADCHS_FAST_SYNC_PERIPHERAL_CLOCK_DISABLE,
64:                          ADCHS_INTERRUPT_BIT_SHIFT_LEFT_0_BITS,
65:                          0x0000,
66:                          ADCHS_CLOCK_SOURCE_PBCLK,
67:                          0,
68:                          ADCHS_WARMUP_CLOCK_32768
69:                  	);
70:                  
71:                  	PLIB_ADCHS_ChannelSetup(
72:                          DRV_ADC_ID_1,
73:                          ADCHS_CHANNEL_0,
74:                          ADCHS_DATA_RESOLUTION_12BIT,
75:                          1,
76:                          1,
77:                          ADCHS_EARLY_INTERRUPT_PRIOR_CLOCK_4
78:                  	);
79:                  
80:                  	if(false == PLIB_ADCHS_ChannelTriggerSampleSelect(
81:                  					DRV_ADC_ID_1,
82:                  					ADCHS_CHANNEL_0,
83:                  					ADCHS_CHANNEL_UNSYNC_TRIGGER_UNSYNC_SAMPLING
84:                  					))
85:                  					{ while(1);}
86:                  /* Since configuration of analog inputs (dedicated and alternate) for dedicated ADC channel */
87:                  /* is done via selection of dedicated channel only, here, the analog input for a dedicated */
88:                  /* ADC channel number is fixed */					
89:                  
90:                  	if(false == PLIB_ADCHS_ChannelInputSelect(
91:                  					DRV_ADC_ID_1,
92:                  					ADCHS_CHANNEL_0,
93:                  					(ADCHS_CHANNEL_INP_SEL)ADCHS_DEFAULT_CLASS1_AN0
94:                  					))
95:                  					{ while(1);}
96:                  
97:                  
98:                      PLIB_ADCHS_EarlyInterruptEnable(DRV_ADC_ID_1);
99:                      PLIB_ADCHS_AnalogInputDataReadyInterruptEnable(DRV_ADC_ID_1, ADCHS_CLASS12_AN0);
100:                 
101:                 	PLIB_ADCHS_AnalogInputModeSelect(
102:                         DRV_ADC_ID_1,
103:                         ADCHS_AN0,
104:                         ADCHS_INPUT_MODE_SINGLE_ENDED_UNIPOLAR
105:                     );
106:                 
107:                 	PLIB_ADCHS_AnalogInputEdgeTriggerSet( DRV_ADC_ID_1, ADCHS_CLASS12_AN0 );
108:                 
109:                 	PLIB_ADCHS_AnalogInputTriggerSourceSelect(
110:                         DRV_ADC_ID_1,
111:                         ADCHS_CLASS12_AN0,
112:                         ADCHS_TRIGGER_SOURCE_GLOBAL_SOFTWARE_EDGE
113:                 	);
114:                     if (DEVADC0 != 0xFFFFFFFF)
00000130  00000000   NOP
115:                         PLIB_ADCHS_ChannelConfigurationSet(DRV_ADC_ID_1, ADCHS_CHANNEL_0, DEVADC0);
00000144  00000000   NOP
116:                 
117:                 
118:                 
119:                 	/* Digital comparator setup */
120:                     PLIB_ADCHS_DigitalComparatorSetup
121:                 		( 
122:                 			DRV_ADC_ID_1,
123:                 			ADCHS_DIGITAL_COMPARATOR_1,
124:                 			false,
125:                             true,
126:                 			false,
127:                 			false,
128:                 			false,
129:                 			false,
130:                             ADCHS_AN0,
131:                             1000,
132:                             0
133:                 		);
134:                 
135:                 	/* Digital comparator setup */
136:                     PLIB_ADCHS_DigitalComparatorSetup
137:                 		( 
138:                 			DRV_ADC_ID_1,
139:                 			ADCHS_DIGITAL_COMPARATOR_2,
140:                 			false,
141:                             true,
142:                 			false,
143:                 			false,
144:                 			false,
145:                 			false,
146:                             ADCHS_AN0,
147:                             2000,
148:                             1100
149:                 		);
150:                 
151:                 	/* Digital comparator setup */
152:                     PLIB_ADCHS_DigitalComparatorSetup
153:                 		( 
154:                 			DRV_ADC_ID_1,
155:                 			ADCHS_DIGITAL_COMPARATOR_3,
156:                 			false,
157:                             true,
158:                 			false,
159:                 			false,
160:                 			false,
161:                 			false,
162:                             ADCHS_AN0,
163:                             3000,
164:                             2100
165:                 		);
166:                 
167:                 	/* Digital comparator setup */
168:                     PLIB_ADCHS_DigitalComparatorSetup
169:                 		( 
170:                 			DRV_ADC_ID_1,
171:                 			ADCHS_DIGITAL_COMPARATOR_4,
172:                 			false,
173:                             true,
174:                 			false,
175:                 			false,
176:                 			false,
177:                 			false,
178:                             ADCHS_AN0,
179:                             4000,
180:                             3100
181:                 		);
182:                 
183:                 
184:                 	/* Digital filter initialization */
185:                     PLIB_ADCHS_DigitalFilterAveragingModeSetup
186:                 		( 
187:                 			DRV_ADC_ID_1,
188:                 		    ADCHS_DIGITAL_FILTER_1,
189:                 		    ADCHS_AN0,
190:                 		    ADCHS_DIGITAL_FILTER_SIGNIFICANT_ALL_16BITS,
191:                 			ADCHS_DIGITAL_FILTER_AVERAGE_SAMPLE_COUNT_16,
192:                 			false
193:                 		);
194:                 
195:                     /* Enable ADC */
196:                     PLIB_ADCHS_Enable(DRV_ADC_ID_1);
197:                 	
198:                 	/* Check Vref to be ready */
199:                 	while(!PLIB_ADCHS_VREFIsReady(DRV_ADC_ID_1));
00000330  00000000   NOP
200:                 	
201:                 	/* Check for Vref Fault */
202:                 	while(PLIB_ADCHS_VREFFaultHasOccurred(DRV_ADC_ID_1));	
00000348  00000000   NOP
203:                 
204:                 	
205:                 	
206:                 	
207:                 	/* Enable analog feature for the specified channel */
208:                 	PLIB_ADCHS_ChannelAnalogFeatureEnable
209:                 	(
210:                 		DRV_ADC_ID_1,
211:                 		ADCHS_CHANNEL_0
212:                 	);
213:                 	
214:                 	/* Wait for the modules to be ready */
215:                 	while(!PLIB_ADCHS_ChannelIsReady
0000036C  00000000   NOP
216:                 		(	
217:                 			DRV_ADC_ID_1,
218:                 			ADCHS_CHANNEL_0
219:                 		)
220:                 	);
221:                 	
222:                     /* Initialize ADC Interrupt */
223:                     PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_ADC_1);
224:                     PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_ADC_1);
225:                     PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_ADC1, INT_PRIORITY_LEVEL3);
226:                     PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_ADC1, INT_SUBPRIORITY_LEVEL0);	
227:                 }
228:                 
229:                 
230:                 inline void DRV_ADC_DeInitialize(void)
231:                 {
232:                     /* Enable ADC */
233:                     PLIB_ADCHS_Disable(DRV_ADC_ID_1);
234:                 }
235:                 
236:                 
237:                 inline void DRV_ADC0_Open(void)
238:                 {
239:                 	/* Enable digital feature for the specified channel */
240:                 	PLIB_ADCHS_ChannelDigitalFeatureEnable
241:                 	(
242:                 		DRV_ADC_ID_1,
243:                 		ADCHS_CHANNEL_0
244:                 	);
245:                 }
246:                 
247:                 inline void DRV_ADC0_Close(void)
248:                 {
249:                 	/* Disable digital feature for the specified channel */
250:                 	PLIB_ADCHS_ChannelDigitalFeatureDisable
251:                 	(
252:                 		DRV_ADC_ID_1,
253:                 		ADCHS_CHANNEL_0
254:                 	);
255:                 }
256:                 
257:                 
258:                 inline void DRV_ADC_Start(void)
259:                 {
260:                     /* Start ADC */
261:                     //PLIB_ADCHS_SoftwareSamplingStart(DRV_ADC_ID_1);
262:                 	PLIB_ADCHS_GlobalSoftwareTriggerEnable(DRV_ADC_ID_1);
263:                 }
264:                 
265:                 inline void DRV_ADC_Stop(void)
266:                 {
267:                     /* Stop ADC */
268:                     PLIB_ADCHS_SoftwareSamplingStop(DRV_ADC_ID_1);	
269:                 }
270:                 
271:                 uint32_t DRV_ADC_SamplesRead(uint8_t bufIndex)
272:                 {
00000000  00000000   NOP
273:                     /* Read Result */
274:                     return PLIB_ADCHS_AnalogInputResultGet
275:                 	( 
276:                 		DRV_ADC_ID_1, 
277:                 		(ADCHS_AN0 + bufIndex)
278:                 	);
279:                 }
0000000C  00000000   NOP
280:                 
281:                 bool DRV_ADC_SamplesAvailable(uint8_t bufIndex)
282:                 {
00000000  00000000   NOP
283:                     /* Check if data is available or not */
284:                 	return PLIB_ADCHS_AnalogInputDataIsReady
285:                 	(
286:                 		DRV_ADC_ID_1, 
287:                 		(ADCHS_AN0 + bufIndex)
288:                 	);
289:                 }
00000028  00000000   NOP
290:                 
291:                 
292:                 inline void DRV_ADC_DigitalComparator0_Open(void)
293:                 {
294:                 	/* Enable digital comparator */
295:                 	PLIB_ADCHS_DigitalComparatorEnable
296:                 	(
297:                 		DRV_ADC_ID_1,
298:                 		ADCHS_DIGITAL_COMPARATOR_1
299:                 	);
300:                 }
301:                 
302:                 inline void DRV_ADC_DigitalComparator0_Close(void)
303:                 {
304:                 	/* Disable digital comparator */
305:                 	PLIB_ADCHS_DigitalComparatorDisable
306:                 	(
307:                 		DRV_ADC_ID_1,
308:                 		ADCHS_DIGITAL_COMPARATOR_1
309:                 	);
310:                 }
311:                 
312:                 inline bool DRV_ADC_DigitalComparator0_EventHasOccurred(void)
313:                 {
314:                 
315:                 	return(PLIB_ADCHS_DigitalComparatorEventHasOccurred
316:                 	(
317:                 		DRV_ADC_ID_1,
318:                 		ADCHS_DIGITAL_COMPARATOR_1
319:                 	));
320:                 }
321:                 
322:                 
323:                 inline void DRV_ADC_DigitalComparator1_Open(void)
324:                 {
325:                 	/* Enable digital comparator */
326:                 	PLIB_ADCHS_DigitalComparatorEnable
327:                 	(
328:                 		DRV_ADC_ID_1,
329:                 		ADCHS_DIGITAL_COMPARATOR_2
330:                 	);
331:                 }
332:                 
333:                 inline void DRV_ADC_DigitalComparator1_Close(void)
334:                 {
335:                 	/* Disable digital comparator */
336:                 	PLIB_ADCHS_DigitalComparatorDisable
337:                 	(
338:                 		DRV_ADC_ID_1,
339:                 		ADCHS_DIGITAL_COMPARATOR_2
340:                 	);
341:                 }
342:                 
343:                 inline bool DRV_ADC_DigitalComparator1_EventHasOccurred(void)
344:                 {
345:                 
346:                 	return(PLIB_ADCHS_DigitalComparatorEventHasOccurred
347:                 	(
348:                 		DRV_ADC_ID_1,
349:                 		ADCHS_DIGITAL_COMPARATOR_2
350:                 	));
351:                 }
352:                 
353:                 
354:                 inline void DRV_ADC_DigitalComparator2_Open(void)
355:                 {
356:                 	/* Enable digital comparator */
357:                 	PLIB_ADCHS_DigitalComparatorEnable
358:                 	(
359:                 		DRV_ADC_ID_1,
360:                 		ADCHS_DIGITAL_COMPARATOR_3
361:                 	);
362:                 }
363:                 
364:                 inline void DRV_ADC_DigitalComparator2_Close(void)
365:                 {
366:                 	/* Disable digital comparator */
367:                 	PLIB_ADCHS_DigitalComparatorDisable
368:                 	(
369:                 		DRV_ADC_ID_1,
370:                 		ADCHS_DIGITAL_COMPARATOR_3
371:                 	);
372:                 }
373:                 
374:                 inline bool DRV_ADC_DigitalComparator2_EventHasOccurred(void)
375:                 {
376:                 
377:                 	return(PLIB_ADCHS_DigitalComparatorEventHasOccurred
378:                 	(
379:                 		DRV_ADC_ID_1,
380:                 		ADCHS_DIGITAL_COMPARATOR_3
381:                 	));
382:                 }
383:                 
384:                 
385:                 inline void DRV_ADC_DigitalComparator3_Open(void)
386:                 {
387:                 	/* Enable digital comparator */
388:                 	PLIB_ADCHS_DigitalComparatorEnable
389:                 	(
390:                 		DRV_ADC_ID_1,
391:                 		ADCHS_DIGITAL_COMPARATOR_4
392:                 	);
393:                 }
394:                 
395:                 inline void DRV_ADC_DigitalComparator3_Close(void)
396:                 {
397:                 	/* Disable digital comparator */
398:                 	PLIB_ADCHS_DigitalComparatorDisable
399:                 	(
400:                 		DRV_ADC_ID_1,
401:                 		ADCHS_DIGITAL_COMPARATOR_4
402:                 	);
403:                 }
404:                 
405:                 inline bool DRV_ADC_DigitalComparator3_EventHasOccurred(void)
406:                 {
407:                 
408:                 	return(PLIB_ADCHS_DigitalComparatorEventHasOccurred
409:                 	(
410:                 		DRV_ADC_ID_1,
411:                 		ADCHS_DIGITAL_COMPARATOR_4
412:                 	));
413:                 }
414:                 
415:                 
416:                 
417:                 
418:                 inline void DRV_ADC_DigitalFilter0_Open(void)
419:                 {
420:                 	/* Enable digital comparator */
421:                 	PLIB_ADCHS_DigitalFilterEnable
422:                 	(
423:                 		DRV_ADC_ID_1,
424:                 		ADCHS_DIGITAL_FILTER_1
425:                 	);
426:                 }
427:                 
428:                 inline void DRV_ADC_DigitalFilter0_Close(void)
429:                 {
430:                 	/* Disable digital comparator */
431:                 	PLIB_ADCHS_DigitalFilterDisable
432:                 	(
433:                 		DRV_ADC_ID_1,
434:                 		ADCHS_DIGITAL_FILTER_1
435:                 	);
436:                 }
437:                 
438:                 inline bool DRV_ADC_DigitalFilter0_DataIsReady(void)
439:                 {
440:                 
441:                 	return(PLIB_ADCHS_DigitalFilterDataIsReady
442:                 	(
443:                 		DRV_ADC_ID_1,
444:                 		ADCHS_DIGITAL_FILTER_1
445:                 	));
446:                 }
447:                 
448:                 inline int16_t DRV_ADC_DigitalFilter0_DataRead(void)
449:                 {
450:                 
451:                 	return(PLIB_ADCHS_DigitalFilterDataGet
452:                 	(
453:                 		DRV_ADC_ID_1,
454:                 		ADCHS_DIGITAL_FILTER_1
455:                 	));
456:                 }
0000000C  00000000   NOP
457:                 
458:                 
459:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/osal/src/osal_impl_basic.h
1:                   /*******************************************************************************
2:                     Operating System Abstraction Layer Basic Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       osal_impl_basic.h
9:                   
10:                    Summary:
11:                      Header file for the OSAL Basic implementation.
12:                  
13:                    Description:
14:                      This file defines the additions or variations to the OSAL base implementation.
15:                   Where it is logical or possible to implement an OSAL function in a simple form
16:                   without an RTOS being present then the function has been defined here and
17:                   implemented either here as an inline or #define. Longer functions that are part
18:                   of the basic implementation may also be found in the file osal.c
19:                   The best way to consider this file is detailing any deviations from the osal.h
20:                   definitions OR as the complete implementation of those functions when pretending
21:                   to support BASIC operations.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  #ifndef _OSAL_IMPL_BASIC_H
50:                  #define _OSAL_IMPL_BASIC_H
51:                  
52:                  #ifdef __cplusplus
53:                  extern "C" {
54:                  #endif
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  #include <stdint.h>
62:                  #include <stdbool.h>
63:                  
64:                  
65:                  typedef uint8_t                     OSAL_SEM_HANDLE_TYPE;
66:                  typedef uint8_t                     OSAL_MUTEX_HANDLE_TYPE;
67:                  typedef uint32_t                    OSAL_CRITSECT_DATA_TYPE;
68:                  #define OSAL_WAIT_FOREVER           (uint16_t) 0xFFFF
69:                  
70:                  #define OSAL_SEM_DECLARE(semID)         uint8_t    semID
71:                  #define OSAL_MUTEX_DECLARE(mutexID)     uint8_t    mutexID
72:                  
73:                  // *****************************************************************************
74:                  /* Macro: OSAL_ASSERT
75:                   */
76:                  
77:                  #define OSAL_ASSERT(test, message)      test
78:                  
79:                  // *****************************************************************************
80:                  /* OSAL Result type
81:                  
82:                    Summary:
83:                      Enumerated type representing the general return value from OSAL functions.
84:                  
85:                    Description:
86:                      This enum represents possible return types from OSAL functions.
87:                  
88:                    Remarks:
89:                      These enum values are the possible return values from OSAL functions
90:                      where a standard success/fail type response is required. The majority
91:                      of OSAL functions will return this type with a few exceptions.
92:                  */
93:                  
94:                  typedef enum OSAL_SEM_TYPE
95:                  {
96:                      OSAL_SEM_TYPE_BINARY,
97:                      OSAL_SEM_TYPE_COUNTING
98:                  } OSAL_SEM_TYPE;
99:                  
100:                 typedef enum OSAL_CRIT_TYPE
101:                 {
102:                     OSAL_CRIT_TYPE_LOW,
103:                     OSAL_CRIT_TYPE_HIGH
104:                 } OSAL_CRIT_TYPE;
105:                 
106:                 typedef enum OSAL_RESULT
107:                 {
108:                     OSAL_RESULT_NOT_IMPLEMENTED = -1,
109:                     OSAL_RESULT_FALSE = 0,
110:                     OSAL_RESULT_TRUE = 1
111:                 } OSAL_RESULT;
112:                 
113:                 // *****************************************************************************
114:                 // *****************************************************************************
115:                 // Section: Section: Interface Routines Group Declarations
116:                 // *****************************************************************************
117:                 // *****************************************************************************
118:                 static __inline__ OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount);
119:                 static __inline__ OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID);
120:                 static __inline__ OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS);
121:                 static __inline__ OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID);
122:                 static __inline__ OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID);
123:                 static __inline__ uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID);
124:                 
125:                 static __inline__ OSAL_CRITSECT_DATA_TYPE __attribute__((nomips16,nomicromips)) OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity);
126:                 static __inline__ void __attribute__((nomips16,nomicromips)) OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status);
127:                 
128:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID);
129:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID);
130:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS);
131:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID);
132:                 
133:                 void* OSAL_Malloc(size_t size);
134:                 void OSAL_Free(void* pData);
135:                 
136:                 OSAL_RESULT OSAL_Initialize();
137:                 
138:                 static __inline__ const char* OSAL_Name(void);
139:                 
140:                 // *****************************************************************************
141:                 // *****************************************************************************
142:                 // Section: Interface Routines Group Defintions
143:                 // *****************************************************************************
144:                 // *****************************************************************************
145:                 
146:                 /* Critical Section group */
147:                 // *****************************************************************************
148:                 /* Function: OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
149:                  */
150:                 static OSAL_CRITSECT_DATA_TYPE __attribute__((nomips16,nomicromips,always_inline)) OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
151:                 {
152:                    if(severity == OSAL_CRIT_TYPE_LOW)
153:                       return (0);
154:                    /*if priority is set to HIGH the user wants interrupts disabled*/
155:                    return (__builtin_disable_interrupts());
9D009D20  41636000   DI V1
9D009D24  000000C0   EHB
9D009DEC  41636000   DI V1
9D009DF0  000000C0   EHB
9D00FB40  41636000   DI V1
9D00FB44  000000C0   EHB
9D00FC24  41636000   DI V1
9D00FC28  000000C0   EHB
9D012B84  41646000   DI A0
9D012B88  000000C0   EHB
9D013840  41626000   DI V0
9D013844  000000C0   EHB
9D014598  41636000   DI V1
9D01459C  000000C0   EHB
9D0145EC  41636000   DI V1
9D0145F0  000000C0   EHB
00000018  00000000   NOP
00000024  00000000   NOP
00000068  00000000   NOP
156:                 }
157:                 
158:                 // *****************************************************************************
159:                 /* Function: void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
160:                  */
161:                 static void __attribute__((nomips16,nomicromips,always_inline)) OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
162:                 {
163:                    if(severity == OSAL_CRIT_TYPE_LOW)
164:                       return;
165:                    /*if priority is set to HIGH the user wants interrupts re-enabled to the state 
166:                    they were before disabling.*/
167:                    __builtin_mtc0(12,0,status);   
9D009D40  40836000   MTC0 V1, Status
9D009D44  000000C0   EHB
9D009D50  40836000   MTC0 V1, Status
9D009D54  000000C0   EHB
9D009E08  40836000   MTC0 V1, Status
9D009E0C  000000C0   EHB
9D00FB60  40836000   MTC0 V1, Status
9D00FB64  000000C0   EHB
9D00FB70  40836000   MTC0 V1, Status
9D00FB74  000000C0   EHB
9D00FC40  40836000   MTC0 V1, Status
9D00FC44  000000C0   EHB
9D012BA0  40846000   MTC0 A0, Status
9D012BA4  000000C0   EHB
9D013854  40826000   MTC0 V0, Status
9D013858  000000C0   EHB
9D0145B8  40836000   MTC0 V1, Status
9D0145BC  000000C0   EHB
9D0145C8  40836000   MTC0 V1, Status
9D0145CC  000000C0   EHB
9D014608  40836000   MTC0 V1, Status
9D01460C  000000C0   EHB
00000038  00000000   NOP
00000040  00000000   NOP
00000048  00000000   NOP
00000084  00000000   NOP
168:                 }
169:                 
170:                 // *****************************************************************************
171:                 /* Function: OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE semID, OSAL_SEM_TYPE type,
172:                                                 uint8_t maxCount, uint8_t initialCount)
173:                  */
174:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type,
175:                                                 uint8_t maxCount, uint8_t initialCount)
176:                 {
177:                    OSAL_CRITSECT_DATA_TYPE IntState;
178:                    
179:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
180:                  
181:                    if (type == OSAL_SEM_TYPE_COUNTING)
182:                       *semID = initialCount;
183:                    else
184:                       *semID = 1;
9D013848  24040001   ADDIU A0, ZERO, 1
9D01384C  3C038001   LUI V1, -32767
9D013850  A0644D01   SB A0, 19713(V1)
185:                  
186:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
187:                    
188:                    return OSAL_RESULT_TRUE;
189:                 }
190:                 
191:                 // *****************************************************************************
192:                 /* Function: OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE semID)
193:                  */
194:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* mutexID)
195:                 {
196:                    return (OSAL_RESULT_TRUE);
197:                 }
198:                 
199:                 // *****************************************************************************
200:                 /* Function: OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE semID, uint16_t waitMS)
201:                  */
202:                 static  OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
203:                 {
204:                    OSAL_CRITSECT_DATA_TYPE IntState;
205:                    
206:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
207:                        
208:                    if (*semID > 0)
9D009D28  3C028001   LUI V0, -32767
9D009D2C  90424D01   LBU V0, 19713(V0)
9D009D30  10400007   BEQ V0, ZERO, SYS_TMR_Tasks::_UserGblLock
9D009D34  3C048001   LUI A0, -32767
9D00FB48  3C028001   LUI V0, -32767
9D00FB4C  90424D01   LBU V0, 19713(V0)
9D00FB50  10400007   BEQ V0, ZERO, _SYS_TMR_ClientCreate::_UserGblLock
9D00FB54  3C048001   LUI A0, -32767
9D0145A0  3C028001   LUI V0, -32767
9D0145A4  90424D01   LBU V0, 19713(V0)
9D0145A8  10400007   BEQ V0, ZERO, _SYS_TMR_ClientCheckSrvLock::_UserGblLock
9D0145AC  2442FFFF   ADDIU V0, V0, -1
00000020  00000000   NOP
209:                    {
210:                       (*semID)--;
9D009D38  2442FFFF   ADDIU V0, V0, -1
9D009D3C  A0824D01   SB V0, 19713(A0)
9D00FB58  2442FFFF   ADDIU V0, V0, -1
9D00FB5C  A0824D01   SB V0, 19713(A0)
9D0145B0  3C058001   LUI A1, -32767
9D0145B4  A0A24D01   SB V0, 19713(A1)
00000030  00000000   NOP
211:                       OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
212:                       
213:                       return OSAL_RESULT_TRUE;
214:                    }
215:                    
216:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
217:                       
218:                    return OSAL_RESULT_FALSE;
219:                 }
220:                 
221:                 // *****************************************************************************
222:                 /* Function: OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE semID)
223:                  */
224:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
225:                 {
226:                    OSAL_CRITSECT_DATA_TYPE IntState;
227:                    
228:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
229:                    (*semID)++;
9D009DF4  3C028001   LUI V0, -32767
9D009DF8  24424CD8   ADDIU V0, V0, 19672
9D009DFC  90440029   LBU A0, 41(V0)
9D009E00  24840001   ADDIU A0, A0, 1
9D009E04  A0440029   SB A0, 41(V0)
9D00FC2C  3C028001   LUI V0, -32767
9D00FC30  24424CD8   ADDIU V0, V0, 19672
9D00FC34  90440029   LBU A0, 41(V0)
9D00FC38  24840001   ADDIU A0, A0, 1
9D00FC3C  A0440029   SB A0, 41(V0)
9D012B8C  3C028001   LUI V0, -32767
9D012B90  24424CD8   ADDIU V0, V0, 19672
9D012B94  90450029   LBU A1, 41(V0)
9D012B98  24A50001   ADDIU A1, A1, 1
9D012B9C  A0450029   SB A1, 41(V0)
9D0145F4  3C028001   LUI V0, -32767
9D0145F8  24424CD8   ADDIU V0, V0, 19672
9D0145FC  90440029   LBU A0, 41(V0)
9D014600  24840001   ADDIU A0, A0, 1
9D014604  A0440029   SB A0, 41(V0)
0000002C  00000000   NOP
00000070  00000000   NOP
230:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
231:                    
232:                    return OSAL_RESULT_TRUE;
233:                 }
234:                 
235:                 // *****************************************************************************
236:                 /* Function: OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE semID)
237:                  */
238:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
239:                 {
240:                     (*semID)++;
241:                     return OSAL_RESULT_TRUE;
242:                 }
243:                 
244:                 // *****************************************************************************
245:                 /* Function: uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE semID)
246:                  */
247:                 static uint8_t __attribute__((always_inline)) OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
248:                 {
249:                     return *semID;
250:                 }
251:                 
252:                 // *****************************************************************************
253:                 /* Function: OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE mutexID)
254:                  */
255:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
256:                 {
257:                    *mutexID = 1;
9D00FA50  A0430011   SB V1, 17(V0)
9D011E48  24633DC8   ADDIU V1, V1, 15816
9D011E4C  24020001   ADDIU V0, ZERO, 1
9D011E50  A0620014   SB V0, 20(V1)
9D011E54  A0620016   SB V0, 22(V1)
9D011E58  A0620015   SB V0, 21(V1)
9D012A4C  3C038000   LUI V1, -32768
9D012A50  24620448   ADDIU V0, V1, 1096
9D012A54  24040001   ADDIU A0, ZERO, 1
9D012A58  A044006C   SB A0, 108(V0)
9D014F90  24020001   ADDIU V0, ZERO, 1
9D014F94  A38280A0   SB V0, -32608(GP)
9D014F98  A38280B0   SB V0, -32592(GP)
9D0168E4  24030001   ADDIU V1, ZERO, 1
258:                    return OSAL_RESULT_TRUE;
259:                 }
260:                 
261:                 // *****************************************************************************
262:                 /* Function: OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE mutexID)
263:                  */
264:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
265:                 {
266:                    return (OSAL_RESULT_TRUE);
267:                    
268:                 }
269:                 // *****************************************************************************
270:                 /* Function: OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE mutexID, uint16_t waitMS)
271:                  */
272:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
273:                 {
274:                     if (*mutexID == 1)
9D004BE4  9223006C   LBU V1, 108(S1)
9D004BE8  24020001   ADDIU V0, ZERO, 1
9D004BEC  14620002   BNE V1, V0, 0x9D004BF8
9D004BF0  8E37005C   LW S7, 92(S1)
9D007EF4  9263006C   LBU V1, 108(S3)
9D007EF8  24020001   ADDIU V0, ZERO, 1
9D007EFC  50620001   BEQL V1, V0, 0x9D007F04
9D007F00  A260006C   SB ZERO, 108(S3)
9D00B170  3C028001   LUI V0, -32767
9D00B174  90433DDC   LBU V1, 15836(V0)
9D00B178  24020001   ADDIU V0, ZERO, 1
9D00B17C  14620019   BNE V1, V0, 0x9D00B1E4
9D00B180  8FBF001C   LW RA, 28(SP)
9D00B788  938380A0   LBU V1, -32608(GP)
9D00B78C  24020001   ADDIU V0, ZERO, 1
9D00B790  14620017   BNE V1, V0, 0x9D00B7F0
9D00B794  24020012   ADDIU V0, ZERO, 18
9D00B8A0  91050011   LBU A1, 17(T0)
9D00B8A4  24040001   ADDIU A0, ZERO, 1
9D00B8A8  14A4000B   BNE A1, A0, 0x9D00B8D8
9D00B8AC  24020003   ADDIU V0, ZERO, 3
9D00D574  3C028001   LUI V0, -32767
9D00D578  90433DDE   LBU V1, 15838(V0)
9D00D57C  24020001   ADDIU V0, ZERO, 1
9D00D580  1462003C   BNE V1, V0, 0x9D00D674
9D00D584  2410FFFF   ADDIU S0, ZERO, -1
9D00D73C  90443DDD   LBU A0, 15837(V0)
9D00D740  24020001   ADDIU V0, ZERO, 1
9D00D744  1482004A   BNE A0, V0, 0x9D00D870
9D00D748  2403FF9C   ADDIU V1, ZERO, -100
9D00DAFC  9244006C   LBU A0, 108(S2)
9D00DB00  24030001   ADDIU V1, ZERO, 1
9D00DB04  14830056   BNE A0, V1, 0x9D00DC60
9D00DB08  2402FF81   ADDIU V0, ZERO, -127
9D00EB68  910A005D   LBU T2, 93(T0)
9D00EB6C  24090001   ADDIU T1, ZERO, 1
9D00EB70  15490056   BNE T2, T1, 0x9D00ECCC
9D00EB74  24020005   ADDIU V0, ZERO, 5
9D00FFEC  90850011   LBU A1, 17(A0)
9D00FFF0  24030001   ADDIU V1, ZERO, 1
9D00FFF4  14A30032   BNE A1, V1, 0x9D0100C0
9D00FFF8  24020003   ADDIU V0, ZERO, 3
9D010AF8  3C028001   LUI V0, -32767
9D010AFC  90483DDC   LBU T0, 15836(V0)
9D010B00  24020001   ADDIU V0, ZERO, 1
9D010B04  15020030   BNE T0, V0, 0x9D010BC8
9D010B08  2405FF9C   ADDIU A1, ZERO, -100
9D010D98  3C028001   LUI V0, -32767
9D010D9C  90473DDC   LBU A3, 15836(V0)
9D010DA0  24020001   ADDIU V0, ZERO, 1
9D010DA4  14E20032   BNE A3, V0, 0x9D010E70
9D010DA8  2405FF9C   ADDIU A1, ZERO, -100
9D0117A4  9223006C   LBU V1, 108(S1)
9D0117A8  24020001   ADDIU V0, ZERO, 1
9D0117AC  50620001   BEQL V1, V0, 0x9D0117B4
9D0117B0  A220006C   SB ZERO, 108(S1)
9D013C14  24040001   ADDIU A0, ZERO, 1
9D013C18  14E4000E   BNE A3, A0, 0x9D013C54
9D013C1C  2402FFFF   ADDIU V0, ZERO, -1
9D013FB4  24040001   ADDIU A0, ZERO, 1
9D013FB8  14A4000D   BNE A1, A0, 0x9D013FF0
9D013FBC  2402FFFF   ADDIU V0, ZERO, -1
00000064  00000000   NOP
00000068  00000000   NOP
00000084  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
000000A8  00000000   NOP
000000AC  00000000   NOP
000000B0  00000000   NOP
000000BC  00000000   NOP
000000C4  00000000   NOP
000000D0  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
000000E4  00000000   NOP
00000110  00000000   NOP
275:                     {
276:                         *mutexID = 0;
9D004BF4  A220006C   SB ZERO, 108(S1)
9D00B184  3C028001   LUI V0, -32767
9D00B188  A0403DDC   SB ZERO, 15836(V0)
9D00B8B0  A1000011   SB ZERO, 17(T0)
9D00D74C  3C028001   LUI V0, -32767
9D00D750  0B403612   J 0x9D00D848
9D00D754  A0403DDD   SB ZERO, 15837(V0)
9D00DB0C  A240006C   SB ZERO, 108(S2)
9D00EB78  A100005D   SB ZERO, 93(T0)
9D013C20  A0600011   SB ZERO, 17(V1)
9D013FC0  A0600011   SB ZERO, 17(V1)
00000070  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
00000090  00000000   NOP
00000098  00000000   NOP
000000B4  00000000   NOP
000000BC  00000000   NOP
000000C8  00000000   NOP
000000D0  00000000   NOP
000000E4  00000000   NOP
000000EC  00000000   NOP
000000F0  00000000   NOP
0000011C  00000000   NOP
277:                         return OSAL_RESULT_TRUE;
278:                     }
279:                     return OSAL_RESULT_FALSE;
280:                 }
281:                 
282:                 // *****************************************************************************
283:                 /* Function: OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE mutexID)
284:                  */
285:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
286:                 {
287:                     *mutexID = 1;
9D005038  A222006C   SB V0, 108(S1)
9D00504C  24020001   ADDIU V0, ZERO, 1
9D005050  A222006C   SB V0, 108(S1)
9D00505C  A222006C   SB V0, 108(S1)
9D0081B8  24020001   ADDIU V0, ZERO, 1
9D0081BC  0B402076   J 0x9D0081D8
9D0081C0  A262006C   SB V0, 108(S3)
9D0081C4  256B0008   ADDIU T3, T3, 8
9D00B1D4  24030001   ADDIU V1, ZERO, 1
9D00B1D8  3C028001   LUI V0, -32767
9D00B1DC  A0433DDC   SB V1, 15836(V0)
9D00B7B8  A38280A0   SB V0, -32608(GP)
9D00B8C8  24040001   ADDIU A0, ZERO, 1
9D00B8CC  8FA30114   LW V1, 276(SP)
9D00B93C  0B402DFB   J 0x9D00B7EC
9D00B940  A38280A0   SB V0, -32608(GP)
9D00D5D4  3C038001   LUI V1, -32767
9D00D5D8  A0623DDE   SB V0, 15838(V1)
9D00D668  3C028001   LUI V0, -32767
9D00D66C  A0433DDE   SB V1, 15838(V0)
9D00D7C4  24030001   ADDIU V1, ZERO, 1
9D00D7C8  3C028001   LUI V0, -32767
9D00D7CC  A0433DDD   SB V1, 15837(V0)
9D00DC44  24020001   ADDIU V0, ZERO, 1
9D00DC48  A242006C   SB V0, 108(S2)
9D00DC4C  0B403718   J 0x9D00DC60
9D00DC50  00001021   ADDU V0, ZERO, ZERO
9D00EBB0  A102005D   SB V0, 93(T0)
9D00ECBC  A102005D   SB V0, 93(T0)
9D0100A8  24040001   ADDIU A0, ZERO, 1
9D010B2C  3C028001   LUI V0, -32767
9D010B30  A0483DDC   SB T0, 15836(V0)
9D010DC8  3C028001   LUI V0, -32767
9D010DCC  A0453DDC   SB A1, 15836(V0)
9D011868  24020001   ADDIU V0, ZERO, 1
9D01186C  A222006C   SB V0, 108(S1)
9D013C40  24040001   ADDIU A0, ZERO, 1
9D013FDC  24040001   ADDIU A0, ZERO, 1
00000090  00000000   NOP
00000094  00000000   NOP
00000098  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
000000B0  00000000   NOP
000000C0  00000000   NOP
000000C8  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
000000E4  00000000   NOP
000000E8  00000000   NOP
000000FC  00000000   NOP
00000100  00000000   NOP
00000104  00000000   NOP
00000108  00000000   NOP
00000134  00000000   NOP
0000013C  00000000   NOP
288:                     return OSAL_RESULT_TRUE;
289:                 }
290:                 
291:                 // Miscellaneous functions
292:                 // *****************************************************************************
293:                 /* Function: void* OSAL_Malloc(size_t size)
294:                  */
295:                 #define OSAL_Malloc(size)                               (malloc(size))
296:                 
297:                 // *****************************************************************************
298:                 /* Function: void OSAL_Free(void* pData)
299:                  */
300:                 #define OSAL_Free(pData)                                (free(pData))
301:                 
302:                 // Initialization and Diagnostics
303:                 // *****************************************************************************
304:                 /* Function: OSAL_RESULT OSAL_Initialize()
305:                  */
306:                 #define OSAL_Initialize()
307:                 
308:                 
309:                 // *****************************************************************************
310:                 /* Function: const char* OSAL_Name()
311:                  */
312:                 static const char* __attribute__((always_inline)) OSAL_Name(void)
313:                 {
314:                    return((const char*) "BASIC");
315:                 }
316:                 
317:                 
318:                 #ifdef __cplusplus
319:                 }
320:                 #endif
321:                 
322:                 #endif // _OSAL_IMPL_BASIC_H
323:                 
324:                 /*******************************************************************************
325:                  End of File
326:                  */
327:                 
328:                 
329:                 
330:                 
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/driver/usb/usbhs/src/dynamic/drv_usbhs_host.c
1:                   /*******************************************************************************
2:                     USB Host Controller Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbhs_host.c
9:                   
10:                    Summary:
11:                      USB Host Driver Implementation for PIC32MZ.
12:                  
13:                    Description:
14:                      This file implements the Host mode operation of the High Speed USB Driver.
15:                      This file should be included in the application if USB Host mode operation
16:                      is desired.
17:                  *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /******************************************************************************
21:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  #include "system_config.h"
45:                  #include "driver/usb/drv_usb.h"
46:                  #include "driver/usb/usbhs/drv_usbhs.h"
47:                  #include "driver/usb/usbhs/src/drv_usbhs_local.h"
48:                  #include "usb/usb_host.h"
49:                  #include "usb/usb_host_client_driver.h"
50:                  #include "peripheral/usbhs/plib_usbhs.h"
51:                  
52:                  /**********************************************************
53:                   * This structure is a set of pointer to the USBFS driver
54:                   * functions. It is provided to the host and device layer
55:                   * as the interface to the driver.
56:                   * *******************************************************/
57:                  
58:                  DRV_USB_HOST_INTERFACE gDrvUSBHSHostInterface =
59:                  {
60:                      .open = DRV_USBHS_Open,
61:                      .close = DRV_USBHS_Close,
62:                      .eventHandlerSet = DRV_USBHS_ClientEventCallBackSet,
63:                      .hostIRPSubmit = DRV_USBHS_HOST_IRPSubmit,
64:                      .hostIRPCancel = DRV_USBHS_HOST_IRPCancel,
65:                      .hostPipeSetup = DRV_USBHS_HOST_PipeSetup,
66:                      .hostPipeClose = DRV_USBHS_HOST_PipeClose,
67:                      .hostEventsDisable = DRV_USBHS_HOST_EventsDisable,
68:                      .hostEventsEnable = DRV_USBHS_HOST_EventsEnable,
69:                      .rootHubInterface.rootHubPortInterface.hubPortReset = DRV_USBHS_HOST_ROOT_HUB_PortReset,
70:                      .rootHubInterface.rootHubPortInterface.hubPortSpeedGet = DRV_USBHS_HOST_ROOT_HUB_PortSpeedGet,
71:                      .rootHubInterface.rootHubPortInterface.hubPortResetIsComplete = DRV_USBHS_HOST_ROOT_HUB_PortResetIsComplete,
72:                      .rootHubInterface.rootHubPortInterface.hubPortSuspend = DRV_USBHS_HOST_ROOT_HUB_PortSuspend,
73:                      .rootHubInterface.rootHubPortInterface.hubPortResume = DRV_USBHS_HOST_ROOT_HUB_PortResume,
74:                      .rootHubInterface.rootHubMaxCurrentGet = DRV_USBHS_HOST_ROOT_HUB_MaximumCurrentGet,
75:                      .rootHubInterface.rootHubPortNumbersGet = DRV_USBHS_HOST_ROOT_HUB_PortNumbersGet,
76:                      .rootHubInterface.rootHubSpeedGet = DRV_USBHS_HOST_ROOT_HUB_BusSpeedGet,
77:                      .rootHubInterface.rootHubInitialize = DRV_USBHS_HOST_ROOT_HUB_Initialize,
78:                      .rootHubInterface.rootHubOperationEnable = DRV_USBHS_HOST_ROOT_HUB_OperationEnable,
79:                      .rootHubInterface.rootHubOperationIsEnabled = DRV_USBHS_HOST_ROOT_HUB_OperationIsEnabled,
80:                  };
81:                  
82:                  /*****************************************
83:                   * Pool of pipe objects that is used by
84:                   * all driver instances.
85:                   *****************************************/
86:                  DRV_USBHS_HOST_PIPE_OBJ gDrvUSBHostPipeObj[DRV_USBHS_HOST_PIPES_NUMBER];
87:                  
88:                  /****************************************
89:                   * The driver object
90:                   ****************************************/
91:                  extern DRV_USBHS_OBJ gDrvUSBObj[];
92:                  
93:                  // ****************************************************************************
94:                  // ****************************************************************************
95:                  // Local Functions
96:                  // ****************************************************************************
97:                  // ****************************************************************************
98:                  
99:                  
100:                 void _DRV_USBHS_HOST_AttachDetachStateMachine (DRV_USBHS_OBJ * hDriver)
101:                 {
9D010FD8  27BDFFE0   ADDIU SP, SP, -32
9D010FDC  AFBF001C   SW RA, 28(SP)
9D010FE0  AFB10018   SW S1, 24(SP)
9D010FE4  AFB00014   SW S0, 20(SP)
102:                     /* In the host mode, we perform attach de-bouncing */
103:                     
104:                     bool interruptWasEnabled;
105:                 
106:                     switch(hDriver->attachState)
9D010FE8  8C820154   LW V0, 340(A0)
9D010FEC  24030001   ADDIU V1, ZERO, 1
9D010FF0  10430020   BEQ V0, V1, _DRV_USBHS_HOST_AttachDetachStateMachine::PLIB_USBHS_SessionEnable
9D010FF4  00808021   ADDU S0, A0, ZERO
9D010FF8  10400007   BEQ V0, ZERO, 0x9D011018
9D010FFC  24030002   ADDIU V1, ZERO, 2
9D011000  10430023   BEQ V0, V1, 0x9D011090
9D011004  24030003   ADDIU V1, ZERO, 3
9D011008  5043003E   BEQL V0, V1, 0x9D011104
9D01100C  90820158   LBU V0, 344(A0)
107:                     {
108:                         case DRV_USBHS_HOST_ATTACH_STATE_CHECK_FOR_DEVICE_ATTACH:
109:                             /* If no device is attached, then there is nothing to do
110:                              * If device is attached, then move to next state */
111:                             if(hDriver->deviceAttached)
9D011018  90820158   LBU V0, 344(A0)
9D01101C  50400009   BEQL V0, ZERO, _DRV_USBHS_HOST_AttachDetachStateMachine::PLIB_USBHS_IsBDevice
9D011020  8C82005C   LW V0, 92(A0)
112:                             {
113:                                 /* Start the de-bouncing timer */
114:                                 hDriver->timerHandle = SYS_TMR_DelayMS(DRV_USBHS_HOST_ATTACH_DEBOUNCE_DURATION);
9D011024  0F405BE0   JAL SYS_TMR_DelayMS
9D011028  240401F4   ADDIU A0, ZERO, 500
115:                                 if(hDriver->timerHandle != SYS_TMR_HANDLE_INVALID)
9D01102C  2403FFFF   ADDIU V1, ZERO, -1
9D011030  10430036   BEQ V0, V1, 0x9D01110C
9D011034  AE020118   SW V0, 280(S0)
116:                                 {
117:                                     /* The de-bounce timer has started */
118:                                     hDriver->attachState = DRV_USBHS_HOST_ATTACH_STATE_DEBOUNCING;
9D011038  24020002   ADDIU V0, ZERO, 2
9D01103C  0B404443   J 0x9D01110C
9D011040  AE020154   SW V0, 340(S0)
119:                                 }
120:                             }
121:                             else
122:                             {
123:                                 /* If a device is not attached. We need to check if the device
124:                                  * has slipped into OTG B device mode. The USB module does this
125:                                  * sometimes. While operating in host mode, the USB module
126:                                  * should always be a OTG A device.  */
127:                                 
128:                                 if(PLIB_USBHS_IsBDevice(hDriver->usbID) && 
9D01104C  10600030   BEQ V1, ZERO, 0x9D011110
9D011050  8FBF001C   LW RA, 28(SP)
9D011058  30630018   ANDI V1, V1, 24
9D01105C  24020018   ADDIU V0, ZERO, 24
9D011060  1462002C   BNE V1, V0, 0x9D011114
9D011064  8FB10018   LW S1, 24(SP)
129:                                         (PLIB_USBHS_VBUSLevelGet(hDriver->usbID) == USBHS_VBUS_VALID))
130:                                 {
131:                                     /* This means the module is not operating as host mode.
132:                                      * We should restart the session */
133:                                     hDriver->attachState = DRV_USBHS_HOST_ATTACH_STATE_RESTART_SESSION;
9D011068  24020001   ADDIU V0, ZERO, 1
9D01106C  0B404443   J 0x9D01110C
9D011070  AC820154   SW V0, 340(A0)
134:                                 }
135:                             }
136:                             break;
137:                             
138:                         case DRV_USBHS_HOST_ATTACH_STATE_RESTART_SESSION:
139:                             
140:                             /* We reach this state if the USB module has slipped out of host
141:                              * mode and must be placed back into host mode. Restart the session
142:                              */
143:                             
144:                             PLIB_USBHS_SessionEnable(hDriver->usbID);
145:                             hDriver->attachState = DRV_USBHS_HOST_ATTACH_STATE_CHECK_FOR_DEVICE_ATTACH;
146:                           
147:                             break;
9D011088  0B404443   J 0x9D01110C
9D01108C  AE000154   SW ZERO, 340(S0)
148:                 
149:                         case DRV_USBHS_HOST_ATTACH_STATE_DEBOUNCING:
150:                 
151:                             /* Check if the de-bounce delay has completed. If so then
152:                              * check if the device is still attached. */
153:                             if(SYS_TMR_DelayStatusGet(hDriver->timerHandle))
9D011090  0F405C13   JAL SYS_TMR_DelayStatusGet
9D011094  8C840118   LW A0, 280(A0)
9D011098  1040001D   BEQ V0, ZERO, 0x9D011110
9D01109C  8FBF001C   LW RA, 28(SP)
154:                             {
155:                                 /* The de-bounce period has ended. Is the device
156:                                  * still attached. Disable the driver interrupt as
157:                                  * we do not want this section to be interrupted. */
158:                                 interruptWasEnabled = _DRV_USBHS_InterruptSourceDisable(hDriver->interruptSource);
9D0110A0  0F40588F   JAL SYS_INT_SourceDisable
9D0110A4  8E040064   LW A0, 100(S0)
9D0110A8  00408821   ADDU S1, V0, ZERO
159:                 
160:                                 if(hDriver->deviceAttached)
9D0110AC  92020158   LBU V0, 344(S0)
9D0110B0  50400007   BEQL V0, ZERO, 0x9D0110D0
9D0110B4  AE000154   SW ZERO, 340(S0)
161:                                 {
162:                                     /* Yes the device is still attached. Enumerate
163:                                      * this device. usbHostDeviceInfo is the ID of
164:                                      * this root hub. */
165:                                     hDriver->attachedDeviceObjHandle = USB_HOST_DeviceEnumerate(hDriver->usbHostDeviceInfo, 0);
9D0110B8  8E04015C   LW A0, 348(S0)
9D0110BC  0F403627   JAL USB_HOST_DeviceEnumerate
9D0110C0  00002821   ADDU A1, ZERO, ZERO
9D0110C4  AE020160   SW V0, 352(S0)
166:                                     hDriver->attachState = DRV_USBHS_HOST_ATTACH_STATE_READY;
9D0110C8  24020003   ADDIU V0, ZERO, 3
9D0110CC  AE020154   SW V0, 340(S0)
167:                 
168:                                 }
169:                                 else
170:                                 {
171:                                     /* The device is not attached any more. This was
172:                                      * a false attach */
173:                                     hDriver->attachState = DRV_USBHS_HOST_ATTACH_STATE_CHECK_FOR_DEVICE_ATTACH;
174:                                 }
175:                 
176:                                 if(interruptWasEnabled)
9D0110D0  5220000F   BEQL S1, ZERO, 0x9D011110
9D0110D4  8FBF001C   LW RA, 28(SP)
177:                                 {
178:                                     /* Re-enable the interrupt if it was originally
179:                                      * enabled. */
180:                                     _DRV_USBHS_InterruptSourceEnable(hDriver->interruptSource);
9D0110D8  8E020064   LW V0, 100(S0)
181:                                 }
182:                 
183:                             }
184:                             break;
185:                 
186:                         case DRV_USBHS_HOST_ATTACH_STATE_READY:
187:                 
188:                             /* De-bouncing is done and device ready. We can check
189:                              * here if the device is detached */
190:                             if(!hDriver->deviceAttached)
9D011104  50400001   BEQL V0, ZERO, 0x9D01110C
9D011108  AC800154   SW ZERO, 340(A0)
191:                             {
192:                                 /* Device is not attached */
193:                                 hDriver->attachState = DRV_USBHS_HOST_ATTACH_STATE_CHECK_FOR_DEVICE_ATTACH;
194:                             }
195:                             break;
196:                 
197:                         default:
198:                             break;
199:                     }
200:                 }
9D011010  0B404444   J 0x9D011110
9D011014  8FBF001C   LW RA, 28(SP)
9D0110FC  0B404444   J 0x9D011110
9D011100  8FBF001C   LW RA, 28(SP)
9D01110C  8FBF001C   LW RA, 28(SP)
201:                 
202:                 void _DRV_USBHS_HOST_ResetStateMachine(DRV_USBHS_OBJ * hDriver)
203:                 {
9D012760  27BDFFE8   ADDIU SP, SP, -24
9D012764  AFBF0014   SW RA, 20(SP)
9D012768  AFB00010   SW S0, 16(SP)
204:                     /* Check if reset is needed */
205:                     switch(hDriver->resetState)
9D01276C  8C820168   LW V0, 360(A0)
9D012770  24030001   ADDIU V1, ZERO, 1
9D012774  10430006   BEQ V0, V1, 0x9D012790
9D012778  00808021   ADDU S0, A0, ZERO
9D01277C  24030002   ADDIU V1, ZERO, 2
9D012780  10430010   BEQ V0, V1, 0x9D0127C4
9D012784  8FBF0014   LW RA, 20(SP)
206:                     {
207:                         case DRV_USBHS_HOST_RESET_STATE_NO_RESET:
208:                 
209:                             /* No reset signaling is request */
210:                             break;
211:                 
212:                         case DRV_USBHS_HOST_RESET_STATE_START:
213:                 
214:                             /* We should start reset signaling. First try to get a
215:                              * timer */
216:                             hDriver->timerHandle = SYS_TMR_DelayMS(DRV_USBHS_HOST_RESET_DURATION);
9D012790  0F405BE0   JAL SYS_TMR_DelayMS
9D012794  24040064   ADDIU A0, ZERO, 100
217:                             if(hDriver->timerHandle != SYS_TMR_HANDLE_INVALID)
9D012798  2403FFFF   ADDIU V1, ZERO, -1
9D01279C  10430027   BEQ V0, V1, 0x9D01283C
9D0127A0  AE020118   SW V0, 280(S0)
218:                             {
219:                                 PLIB_USBHS_ResetEnable(hDriver->usbID);
220:                                 hDriver->resetState = DRV_USBHS_HOST_RESET_STATE_WAIT_FOR_COMPLETE;
9D0127B8  24020002   ADDIU V0, ZERO, 2
9D0127BC  0B404A0F   J 0x9D01283C
9D0127C0  AE020168   SW V0, 360(S0)
221:                             }
222:                             break;
223:                 
224:                         case DRV_USBHS_HOST_RESET_STATE_WAIT_FOR_COMPLETE:
225:                 
226:                             /* Check if the reset duration has completed */
227:                             if(SYS_TMR_DelayStatusGet(hDriver->timerHandle))
9D0127C4  0F405C13   JAL SYS_TMR_DelayStatusGet
9D0127C8  8C840118   LW A0, 280(A0)
9D0127CC  1040001C   BEQ V0, ZERO, 0x9D012840
9D0127D0  8FBF0014   LW RA, 20(SP)
228:                             {
229:                                 /* The reset has completed */
230:                                 PLIB_USBHS_ResetDisable(hDriver->usbID);
231:                                 hDriver->resetState = DRV_USBHS_HOST_RESET_STATE_NO_RESET;
9D0127E4  AE000168   SW ZERO, 360(S0)
232:                 
233:                                 /* Clear the flag */
234:                                 hDriver->isResetting = false;
9D0127E8  A2000164   SB ZERO, 356(S0)
235:                 
236:                                 /* Now that reset is complete, we can find out the
237:                                  * speed of the attached device. */
238:                                 if(PLIB_USBHS_HighSpeedIsConnected(hDriver->usbID))
9D0127F8  10600004   BEQ V1, ZERO, _DRV_USBHS_HOST_ResetStateMachine::PLIB_USBHS_FullOrHighSpeedIsConnected
9D0127FC  00000000   NOP
239:                                 {
240:                                     /* This means the device attached at high speed */
241:                                     hDriver->deviceSpeed = USB_SPEED_HIGH;
9D012800  24020001   ADDIU V0, ZERO, 1
9D012804  0B404A0F   J 0x9D01283C
9D012808  AE0200FC   SW V0, 252(S0)
242:                                 }
243:                                 else if(PLIB_USBHS_FullOrHighSpeedIsConnected(hDriver->usbID))
9D012824  10600003   BEQ V1, ZERO, 0x9D012834
9D012828  24020002   ADDIU V0, ZERO, 2
9D01282C  0B404A0F   J 0x9D01283C
9D012830  AE0200FC   SW V0, 252(S0)
244:                                 {
245:                                     hDriver->deviceSpeed = USB_SPEED_FULL;
246:                                 }
247:                                 else
248:                                 {
249:                                     hDriver->deviceSpeed = USB_SPEED_LOW;
9D012834  24020003   ADDIU V0, ZERO, 3
9D012838  AE0200FC   SW V0, 252(S0)
250:                                 }
251:                             }
252:                             break;
253:                 
254:                         default:
255:                             break;
256:                     }
257:                 }
9D012788  0B404A11   J 0x9D012844
9D01278C  8FB00010   LW S0, 16(SP)
9D01283C  8FBF0014   LW RA, 20(SP)
258:                 
259:                 DRV_USBHS_HOST_PIPE_HANDLE _DRV_USBHS_HOST_FifoTableAllocate
260:                 (
261:                     DRV_USBHS_OBJ * hDriver,
262:                     DRV_USBHS_HOST_PIPE_OBJ * pipe,
263:                     uint16_t wMaxPacketSize
264:                 )
265:                 {
9D00ACBC  30C6FFFF   ANDI A2, A2, -1
9D00AD60  27BDFFF8   ADDIU SP, SP, -8
9D00AD64  AFB10004   SW S1, 4(SP)
9D00AD68  AFB00000   SW S0, 0(SP)
266:                     uint8_t *pFifoTable = (uint8_t *)(hDriver->gDrvUSBFifoTable);
9D00ADD8  00E07021   ADDU T6, A3, ZERO
267:                     uint8_t *pFifoTableSecondary = (uint8_t *)(hDriver->gDrvUSBFifoTableSecondary);
9D00ADD4  00605021   ADDU T2, V1, ZERO
268:                     uint8_t indexFifoTable = 1;
269:                     uint8_t noOfSlotsReq = 0;
270:                     uint8_t noOfSlotsReqTemp = 0;
271:                     uint8_t counter = 0;
272:                     uint8_t byteLoop;
273:                     uint8_t bitLoop;
274:                     uint8_t byteStarting = 0;
9D00ADEC  0000C821   ADDU T9, ZERO, ZERO
275:                     uint8_t bitStarting = 0;
9D00ADE8  0000C021   ADDU T8, ZERO, ZERO
276:                     bool slotObtained = false;
277:                     bool firstObtained = false;
9D00ADE4  00005821   ADDU T3, ZERO, ZERO
278:                 
279:                 
280:                     if(wMaxPacketSize <= 64)
9D00ACC0  2CC20041   SLTIU V0, A2, 65
9D00ACC4  10400026   BEQ V0, ZERO, 0x9D00AD60
9D00ACC8  2487012C   ADDIU A3, A0, 300
9D00ACCC  248A013E   ADDIU T2, A0, 318
9D00ACD0  24090001   ADDIU T1, ZERO, 1
9D00AF3C  0B402B7F   J 0x9D00ADFC
9D00AF40  00003021   ADDU A2, ZERO, ZERO
281:                     {
282:                         /* For 9KB FIFO RAM we need total 144 bit slots where each bit slot
283:                          * represents 64 bytes of FIFO RAM memory. So that translates to 18
284:                          * byte slots.
285:                          */
286:                         while(indexFifoTable <= 18)
9D00AD40  10EA0087   BEQ A3, T2, 0x9D00AF60
9D00AD44  312900FF   ANDI T1, T1, 255
287:                         {
288:                             /* Search whole byte bit by bit */
289:                             while(counter <= 7)
9D00ACD4  0B402B52   J 0x9D00AD48
9D00ACD8  24020008   ADDIU V0, ZERO, 8
9D00AD30  1462FFEA   BNE V1, V0, 0x9D00ACDC
9D00AD34  00662007   SRAV A0, A2, V1
290:                             {
291:                                 if((*pFifoTable & (0x01 << counter)) == 0)
9D00ACDC  30840001   ANDI A0, A0, 1
9D00ACE0  14800012   BNE A0, ZERO, 0x9D00AD2C
9D00ACE4  00604021   ADDU T0, V1, ZERO
9D00ACF0  00004021   ADDU T0, ZERO, ZERO
9D00AD48  90E60000   LBU A2, 0(A3)
9D00AD4C  30C30001   ANDI V1, A2, 1
9D00AD50  1060FFE7   BEQ V1, ZERO, 0x9D00ACF0
9D00AD54  24030001   ADDIU V1, ZERO, 1
9D00AD58  0B402B37   J 0x9D00ACDC
9D00AD5C  00662007   SRAV A0, A2, V1
292:                                 {
293:                                     /* Free slot obtained. Now grab as per the max packet size */
294:                                     /* 1 slot will represent 64 bytes in the fifo.
295:                                      * So for endpoints having maxpacket size less than
296:                                      * 64 also we will allocate 64 bytes memory EP FIFO
297:                                      */
298:                                     pipe->startingOffset = (((indexFifoTable - 1) * 8) + 1 + counter) * 8;
9D00ACE8  0B402B3E   J 0x9D00ACF8
9D00ACEC  000910C0   SLL V0, T1, 3
9D00ACF4  000910C0   SLL V0, T1, 3
9D00ACF8  2442FFF9   ADDIU V0, V0, -7
9D00ACFC  01021021   ADDU V0, T0, V0
9D00AD00  000210C0   SLL V0, V0, 3
9D00AD04  ACA20004   SW V0, 4(A1)
299:                 
300:                                     pipe->noOfSlots = 1;
9D00AD08  24020001   ADDIU V0, ZERO, 1
9D00AD0C  A0A20003   SB V0, 3(A1)
301:                                     *pFifoTable = (*pFifoTable | (0x01 << counter));
9D00AD10  24020001   ADDIU V0, ZERO, 1
9D00AD14  01024004   SLLV T0, V0, T0
9D00AD18  90E20000   LBU V0, 0(A3)
9D00AD1C  01024025   OR T0, T0, V0
9D00AD20  A0E80000   SB T0, 0(A3)
302:                                     slotObtained = true;
303:                                     break;
304:                                 }
305:                             
306:                                 counter++;
307:                 
308:                             }/* end of (counter != 7) */
309:                 
310:                             if(slotObtained == true)
311:                             {
312:                                 /* Exit from the main while() loop if FIFOTable obtained */
313:                                 break;
314:                             }
315:                 
316:                             indexFifoTable++;
9D00AD38  25290001   ADDIU T1, T1, 1
317:                             pFifoTable++;
9D00AD3C  24E70001   ADDIU A3, A3, 1
318:                             
319:                             /* Reset the counter to 0 for the next FIFOTable byte scan */
320:                             counter = 0;
321:                 
322:                         }/* end of (indexFifoTable <= 18) */
323:                     }
324:                     else
325:                     {
326:                         /* Here noOfSlotsReq is number of continous bits required in the FIFO
327:                            table */
328:                         noOfSlotsReq = (wMaxPacketSize / 64);
9D00AD6C  7CD03980   EXT S0, A2, 6, 8
329:                 
330:                         if((wMaxPacketSize % 64) != 0)
9D00AD70  30C6003F   ANDI A2, A2, 63
9D00AD74  10C00003   BEQ A2, ZERO, 0x9D00AD84
9D00AD78  24830140   ADDIU V1, A0, 320
331:                         {
332:                             noOfSlotsReq++;
9D00AD7C  26100001   ADDIU S0, S0, 1
9D00AD80  321000FF   ANDI S0, S0, 255
333:                         }
334:                 
335:                         /* Keeping a backup of the number of slots required */
336:                         noOfSlotsReqTemp = noOfSlotsReq;
9D00ADDC  02004021   ADDU T0, S0, ZERO
337:                 
338:                         /* 
339:                          * Copy the latest content of the FIFOTable. The design idea is to
340:                          * set the  gDrvUSBFifoTableSecondary data structure and then copy the
341:                          * whole gDrvUSBFifoTableSecondary data to gDrvUSBFifoTable at the end.
342:                          *
343:                          * There is no chance that gDrvUSBFifoTable can get changed in the middle
344:                          * as all are protected by Mutex lock on a per USBHCD driver instance level.
345:                          */
346:                 
347:                         memcpy(hDriver->gDrvUSBFifoTableSecondary, hDriver->gDrvUSBFifoTable, sizeof(hDriver->gDrvUSBFifoTableSecondary));
9D00AD84  88EA0003   LWL T2, 3(A3)
9D00AD88  98EA0000   LWR T2, 0(A3)
9D00AD8C  88E90007   LWL T1, 7(A3)
9D00AD90  98E90004   LWR T1, 4(A3)
9D00AD94  88E8000B   LWL T0, 11(A3)
9D00AD98  98E80008   LWR T0, 8(A3)
9D00AD9C  88E6000F   LWL A2, 15(A3)
9D00ADA0  98E6000C   LWR A2, 12(A3)
9D00ADA4  88E20013   LWL V0, 19(A3)
9D00ADA8  98E20010   LWR V0, 16(A3)
9D00ADAC  A86A0003   SWL T2, 3(V1)
9D00ADB0  B86A0000   SWR T2, 0(V1)
9D00ADB4  A8690007   SWL T1, 7(V1)
9D00ADB8  B8690004   SWR T1, 4(V1)
9D00ADBC  A868000B   SWL T0, 11(V1)
9D00ADC0  B8680008   SWR T0, 8(V1)
9D00ADC4  A866000F   SWL A2, 15(V1)
9D00ADC8  B866000C   SWR A2, 12(V1)
9D00ADCC  A8620013   SWL V0, 19(V1)
9D00ADD0  B8620010   SWR V0, 16(V1)
348:                 
349:                         for(byteLoop = 1; byteLoop <=18; byteLoop++)
9D00ADE0  24020001   ADDIU V0, ZERO, 1
9D00ADF4  0B402BCF   J 0x9D00AF3C
9D00ADF8  24110013   ADDIU S1, ZERO, 19
9D00AF2C  24420001   ADDIU V0, V0, 1
9D00AF30  304200FF   ANDI V0, V0, 255
9D00AF34  10510005   BEQ V0, S1, 0x9D00AF4C
9D00AF38  254A0001   ADDIU T2, T2, 1
350:                         {
351:                             for(bitLoop = 0; bitLoop <=7; bitLoop++)
9D00ADF0  240F0008   ADDIU T7, ZERO, 8
9D00AF20  54CFFFB7   BNEL A2, T7, 0x9D00AE00
9D00AF24  91C90000   LBU T1, 0(T6)
352:                             {
353:                                 if((*pFifoTable & (0x01 << bitLoop)) == 0)
9D00ADFC  91C90000   LBU T1, 0(T6)
9D00AE00  00C94807   SRAV T1, T1, A2
9D00AE04  31290001   ANDI T1, T1, 1
9D00AE08  15200012   BNE T1, ZERO, 0x9D00AE54
9D00AE0C  30CD00FF   ANDI T5, A2, 255
354:                                 {
355:                                     if(firstObtained == false)
9D00AE10  15600008   BNE T3, ZERO, 0x9D00AE34
9D00AE14  24090001   ADDIU T1, ZERO, 1
356:                                     {
357:                                         firstObtained = true;
358:                                         byteStarting = byteLoop;
359:                                         bitStarting = bitLoop;
360:                                         *pFifoTableSecondary = (*pFifoTableSecondary | (0x01 << bitLoop));
9D00AE18  00C96004   SLLV T4, T1, A2
9D00AE1C  91490000   LBU T1, 0(T2)
9D00AE20  01896025   OR T4, T4, T1
9D00AE24  A14C0000   SB T4, 0(T2)
9D00AE28  01A0C021   ADDU T8, T5, ZERO
9D00AE2C  0B402B91   J 0x9D00AE44
9D00AE30  0040C821   ADDU T9, V0, ZERO
361:                                     }
362:                                     else
363:                                     {
364:                                         *pFifoTableSecondary = (*pFifoTableSecondary | (0x01 << bitLoop));
9D00AE34  00C96004   SLLV T4, T1, A2
9D00AE38  91490000   LBU T1, 0(T2)
9D00AE3C  01896025   OR T4, T4, T1
9D00AE40  A14C0000   SB T4, 0(T2)
365:                                     }
366:                 
367:                                     noOfSlotsReqTemp--;
9D00AE44  2508FFFF   ADDIU T0, T0, -1
9D00AE48  310800FF   ANDI T0, T0, 255
9D00AE4C  0B402BAB   J 0x9D00AEAC
9D00AE50  240B0001   ADDIU T3, ZERO, 1
368:                                 }
369:                                 else
370:                                 {
371:                                     firstObtained = false;
9D00AEA8  00005821   ADDU T3, ZERO, ZERO
372:                                     noOfSlotsReqTemp = noOfSlotsReq;
9D00AEA4  02004021   ADDU T0, S0, ZERO
373:                                     /*
374:                                      * Reset the secondary array  to original array. This is
375:                                      * required because it may happen that at initial we got some
376:                                      * free slots but not enough slots as required. In this case
377:                                      * we need to recopy again the original FifoTable data.
378:                                      */
379:                                     memcpy(hDriver->gDrvUSBFifoTableSecondary, hDriver->gDrvUSBFifoTable, sizeof(hDriver->gDrvUSBFifoTable));
9D00AE54  88ED0003   LWL T5, 3(A3)
9D00AE58  98ED0000   LWR T5, 0(A3)
9D00AE5C  88EC0007   LWL T4, 7(A3)
9D00AE60  98EC0004   LWR T4, 4(A3)
9D00AE64  88EB000B   LWL T3, 11(A3)
9D00AE68  98EB0008   LWR T3, 8(A3)
9D00AE6C  88E9000F   LWL T1, 15(A3)
9D00AE70  98E9000C   LWR T1, 12(A3)
9D00AE74  88E80013   LWL T0, 19(A3)
9D00AE78  98E80010   LWR T0, 16(A3)
9D00AE7C  A86D0003   SWL T5, 3(V1)
9D00AE80  B86D0000   SWR T5, 0(V1)
9D00AE84  A86C0007   SWL T4, 7(V1)
9D00AE88  B86C0004   SWR T4, 4(V1)
9D00AE8C  A86B000B   SWL T3, 11(V1)
9D00AE90  B86B0008   SWR T3, 8(V1)
9D00AE94  A869000F   SWL T1, 15(V1)
9D00AE98  B869000C   SWR T1, 12(V1)
9D00AE9C  A8680013   SWL T0, 19(V1)
9D00AEA0  B8680010   SWR T0, 16(V1)
380:                                 }
381:                 
382:                                 if(noOfSlotsReqTemp == 0)
9D00AEAC  1500001C   BNE T0, ZERO, 0x9D00AF20
9D00AEB0  24C60001   ADDIU A2, A2, 1
383:                                 {
384:                                     /* Obtained all continuous slots */
385:                                     pipe->startingOffset = (((byteStarting - 1) * 8) + 1 + bitStarting) * 8;
9D00AEB4  0019C8C0   SLL T9, T9, 3
9D00AEB8  2739FFF9   ADDIU T9, T9, -7
9D00AEBC  0338C021   ADDU T8, T9, T8
9D00AEC0  0018C0C0   SLL T8, T8, 3
9D00AEC4  ACB80004   SW T8, 4(A1)
386:                                     pipe->noOfSlots = noOfSlotsReq;
9D00AEC8  A0B00003   SB S0, 3(A1)
387:                                     slotObtained = true;
388:                                     break;
389:                                 }
390:                 
391:                             }/* end of for(bitLoop) */
392:                 
393:                             if(slotObtained == true)
394:                             {
395:                                 memcpy(hDriver->gDrvUSBFifoTable, hDriver->gDrvUSBFifoTableSecondary, sizeof(hDriver->gDrvUSBFifoTable));
9D00AECC  886A0003   LWL T2, 3(V1)
9D00AED0  986A0000   LWR T2, 0(V1)
9D00AED4  88690007   LWL T1, 7(V1)
9D00AED8  98690004   LWR T1, 4(V1)
9D00AEDC  8868000B   LWL T0, 11(V1)
9D00AEE0  98680008   LWR T0, 8(V1)
9D00AEE4  8866000F   LWL A2, 15(V1)
9D00AEE8  9866000C   LWR A2, 12(V1)
9D00AEEC  88620013   LWL V0, 19(V1)
9D00AEF0  98620010   LWR V0, 16(V1)
9D00AEF4  A8EA0003   SWL T2, 3(A3)
9D00AEF8  B8EA0000   SWR T2, 0(A3)
9D00AEFC  A8E90007   SWL T1, 7(A3)
9D00AF00  B8E90004   SWR T1, 4(A3)
9D00AF04  A8E8000B   SWL T0, 11(A3)
9D00AF08  B8E80008   SWR T0, 8(A3)
9D00AF0C  A8E6000F   SWL A2, 15(A3)
9D00AF10  B8E6000C   SWR A2, 12(A3)
9D00AF14  A8E20013   SWL V0, 19(A3)
396:                                 /* Exit from the main for() loop if FIFOTable obtained */
397:                                 break;
9D00AF18  0B402BD1   J 0x9D00AF44
9D00AF1C  B8E20010   SWR V0, 16(A3)
398:                             }
399:                 
400:                             pFifoTable++;
9D00AF28  25CE0001   ADDIU T6, T6, 1
401:                             pFifoTableSecondary++;
402:                 
403:                         }/* end of for(byteLoop) */
404:                     }/*end of else(wmaxpacket > 64)*/
405:                 
406:                     if(slotObtained ==  false)
407:                     {
408:                         /* Slot NOT obtained */
409:                         return DRV_USBHS_HOST_PIPE_HANDLE_INVALID;
9D00AF4C  2402FFFF   ADDIU V0, ZERO, -1
410:                     }
411:                     else
412:                     {
413:                         return ((DRV_USBHS_HOST_PIPE_HANDLE)pipe);
9D00AF44  0B402BD4   J 0x9D00AF50
9D00AF48  00A01021   ADDU V0, A1, ZERO
414:                     }
415:                 
416:                 }/* end of _DRV_USBHS_HOST_FifoTableAllocate() */
9D00AD24  03E00008   JR RA
9D00AD28  00A01021   ADDU V0, A1, ZERO
9D00AD2C  24630001   ADDIU V1, V1, 1
9D00AF50  8FB10004   LW S1, 4(SP)
417:                 
418:                 void _DRV_USBHS_HOST_IRPTransmitFIFOLoad
419:                 (
420:                     USBHS_MODULE_ID usbID, 
421:                     USB_HOST_IRP_LOCAL * irp,
422:                     uint8_t endpoint
423:                 )
424:                 {
9D00E7B0  27BDFFD0   ADDIU SP, SP, -48
9D00E7B4  AFBF002C   SW RA, 44(SP)
9D00E7B8  AFB50028   SW S5, 40(SP)
9D00E7BC  AFB40024   SW S4, 36(SP)
9D00E7C0  AFB30020   SW S3, 32(SP)
9D00E7C4  AFB2001C   SW S2, 28(SP)
9D00E7C8  AFB10018   SW S1, 24(SP)
9D00E7CC  AFB00014   SW S0, 20(SP)
9D00E7D0  00809021   ADDU S2, A0, ZERO
9D00E7D4  00A08021   ADDU S0, A1, ZERO
9D00E7D8  30D300FF   ANDI S3, A2, 255
425:                     /* This function will copy data from the irp to the fifo
426:                      * base on the number of bytes that were completed and
427:                      * then trigger the transmit */
428:                 
429:                     uint8_t * data;
430:                     unsigned int count, pendingBytes;
431:                     DRV_USBHS_HOST_PIPE_OBJ * pipe = (DRV_USBHS_HOST_PIPE_OBJ *)(irp->pipe);
9D00E7DC  8CB5002C   LW S5, 44(A1)
432:                     uint8_t dmaChannelGrabbed = 0;
433:                 
434:                     /* Load the fifo */
435:                     pendingBytes = irp->size - irp->completedBytes;
9D00E7E0  8CA20020   LW V0, 32(A1)
9D00E7E4  8CB10008   LW S1, 8(A1)
9D00E7E8  02228823   SUBU S1, S1, V0
436:                     count = (pendingBytes > pipe->endpointSize) ? pipe->endpointSize : pendingBytes;
9D00E7EC  8EA3001C   LW V1, 28(S5)
9D00E7F0  0071302B   SLTU A2, V1, S1
9D00E7F4  0066880B   MOVN S1, V1, A2
437:                     data = (uint8_t *)((uint8_t *)irp->data + irp->completedBytes);
9D00E7F8  8CB40004   LW S4, 4(A1)
438:                 
439:                     if(endpoint == 0)
9D00E7FC  1660000E   BNE S3, ZERO, 0x9D00E838
9D00E800  0282A021   ADDU S4, S4, V0
440:                     {
441:                         irp->completedBytes += count;
9D00E804  02221021   ADDU V0, S1, V0
9D00E808  ACA20020   SW V0, 32(A1)
442:                         PLIB_USBHS_EndpointFIFOLoad(usbID, endpoint, data, count);
443:                     }
444:                     else
445:                     {
446:                         /* NON CONTROL transfer */
447:                         dmaChannelGrabbed = _DRV_USBHS_HOST_GetFreeDMAChannel((DRV_USBHS_OBJ *)(pipe->hClient), USB_DATA_DIRECTION_HOST_TO_DEVICE, endpoint);
9D00E838  8EA40008   LW A0, 8(S5)
9D00E83C  00002821   ADDU A1, ZERO, ZERO
9D00E840  0F40574B   JAL _DRV_USBHS_HOST_GetFreeDMAChannel
9D00E844  02603021   ADDU A2, S3, ZERO
448:                         if((dmaChannelGrabbed == 0))
9D00E848  54400011   BNEL V0, ZERO, 0x9D00E890
9D00E84C  8EA40008   LW A0, 8(S5)
449:                         {
450:                             /* NO DMA channel available. So do normal FIFO load */
451:                             irp->completedBytes += count;
9D00E850  8E020020   LW V0, 32(S0)
9D00E854  00511021   ADDU V0, V0, S1
9D00E858  AE020020   SW V0, 32(S0)
452:                             PLIB_USBHS_EndpointFIFOLoad(usbID, endpoint, data, count);
453:                         }
454:                         else
455:                         {
456:                             /* DMA CHANNEL has been grabbed and DMA buffer address is OK
457:                                (divisible by 4). So program the DMA registers now to start
458:                                DMA operation
459:                                */
460:                             ((DRV_USBHS_OBJ *)(pipe->hClient))->gDrvUSBDMAPool[dmaChannelGrabbed] .count = count;
9D00E890  000218C0   SLL V1, V0, 3
9D00E894  00831821   ADDU V1, A0, V1
9D00E898  AC710008   SW S1, 8(V1)
461:                 
462:                             PLIB_USBHS_DMAOperationEnable(usbID, endpoint, dmaChannelGrabbed, (void *)data, count, 0);
463:                         }
464:                     }
465:                 }/* end of _DRV_USBHS_HOST_IRPTransmitFIFOLoad() */
9D00E90C  0B403A53   J 0x9D00E94C
9D00E910  8FBF002C   LW RA, 44(SP)
9D00E924  0B403A53   J 0x9D00E94C
9D00E928  8FBF002C   LW RA, 44(SP)
9D00E948  8FBF002C   LW RA, 44(SP)
466:                 
467:                 void _DRV_USBHS_HOST_IRPTransmitSetupPacket
468:                 (
469:                     USBHS_MODULE_ID usbID,
470:                     USB_HOST_IRP_LOCAL * irp
471:                 )
472:                 {
473:                     /* This function will load the irp setup packet into endpoint 
474:                      * 0 fifo and will then transmit the setup packet. */
475:                 
476:                     DRV_USBHS_HOST_PIPE_OBJ * pipe = (DRV_USBHS_HOST_PIPE_OBJ *)(irp->pipe);
9D015470  8CA2002C   LW V0, 44(A1)
477:                     uint8_t * data = (uint8_t *)irp->setup;
9D015474  8CA70000   LW A3, 0(A1)
478:                 
479:                     PLIB_USBHS_Endpoint0SetupPacketLoad(usbID, data, pipe->deviceAddress, pipe->hubAddress, pipe->hubPort, pipe->speed);
9D015478  904B0001   LBU T3, 1(V0)
9D01547C  904A0030   LBU T2, 48(V0)
9D015480  90490031   LBU T1, 49(V0)
9D015484  8C48002C   LW T0, 44(V0)
480:                 
481:                 }/* end of _DRV_USBHS_HOST_IRPTransmitSetupPacket() */
482:                 
483:                 unsigned int _DRV_USBHS_HOST_IRPReceiveFIFOUnload 
484:                 (
485:                     USBHS_MODULE_ID usbID,
486:                     USB_HOST_IRP_LOCAL * irp,
487:                     uint8_t endpoint,
488:                     bool * pisDMAUsed
489:                 )
490:                 {
9D00D280  27BDFFC8   ADDIU SP, SP, -56
9D00D284  AFBF0034   SW RA, 52(SP)
9D00D288  AFB50030   SW S5, 48(SP)
9D00D28C  AFB4002C   SW S4, 44(SP)
9D00D290  AFB30028   SW S3, 40(SP)
9D00D294  AFB20024   SW S2, 36(SP)
9D00D298  AFB10020   SW S1, 32(SP)
9D00D29C  AFB0001C   SW S0, 28(SP)
9D00D2A0  00809021   ADDU S2, A0, ZERO
9D00D2A4  00A08821   ADDU S1, A1, ZERO
9D00D2A8  00E09821   ADDU S3, A3, ZERO
9D00D2AC  30D400FF   ANDI S4, A2, 255
491:                     /* This function will recover the count of the received data/
492:                      * and will then unload the endpoint fifo. Finally the rx packet
493:                      * ready bit will be cleared */
494:                 
495:                     uint32_t  count;
496:                     uint8_t * data;
497:                     DRV_USBHS_HOST_PIPE_OBJ * pipe = (DRV_USBHS_HOST_PIPE_OBJ *)(irp->pipe);
9D00D2B0  8CB5002C   LW S5, 44(A1)
498:                     uint8_t dmaChannelGrabbed = 0;
499:                 
500:                     /* Copy the data from the FIFO0 to the application
501:                      * buffer and then update the complete byte count
502:                      * and clear the RX packet ready bit */
503:                 
504:                     data = (uint8_t *)((uint8_t *)irp->data + irp->completedBytes);
9D00D2B4  8CB00004   LW S0, 4(A1)
9D00D2B8  8CA20020   LW V0, 32(A1)
505:                     if(endpoint == 0)
9D00D2BC  16800014   BNE S4, ZERO, 0x9D00D310
9D00D2C0  02028021   ADDU S0, S0, V0
506:                     {
507:                         count = PLIB_USBHS_EndpointFIFOUnload(usbID, endpoint, data);
508:                         irp->completedBytes += count;
9D00D428  8E230020   LW V1, 32(S1)
9D00D42C  00621821   ADDU V1, V1, V0
9D00D430  AE230020   SW V1, 32(S1)
9D00D434  0B40351A   J 0x9D00D468
9D00D438  A2600000   SB ZERO, 0(S3)
509:                         *pisDMAUsed = false;
510:                     }
511:                     else
512:                     {
513:                         dmaChannelGrabbed = _DRV_USBHS_HOST_GetFreeDMAChannel((DRV_USBHS_OBJ *)(pipe->hClient), USB_DATA_DIRECTION_DEVICE_TO_HOST, endpoint);
9D00D310  8EA40008   LW A0, 8(S5)
9D00D314  24050001   ADDIU A1, ZERO, 1
9D00D318  0F40574B   JAL _DRV_USBHS_HOST_GetFreeDMAChannel
9D00D31C  02803021   ADDU A2, S4, ZERO
514:                         if((dmaChannelGrabbed == 0))
9D00D320  14400017   BNE V0, ZERO, _DRV_USBHS_HOST_IRPReceiveFIFOUnload::PLIB_USBHS_GetReceiveDataCount
9D00D324  00401821   ADDU V1, V0, ZERO
515:                         {
516:                             /* NO DMA channel available. So do normal FIFO unload */
517:                             count = PLIB_USBHS_EndpointFIFOUnload(usbID, endpoint, data);
518:                             irp->completedBytes += count;
9D00D458  8E230020   LW V1, 32(S1)
9D00D45C  00621821   ADDU V1, V1, V0
9D00D460  AE230020   SW V1, 32(S1)
519:                             *pisDMAUsed = false;
9D00D464  A2600000   SB ZERO, 0(S3)
520:                         }
521:                         else
522:                         {
523:                             /* DMA CHANNEL has been grabbed and DMA buffer address is OK
524:                              * (divisible by 4). So program the DMA registers now to start
525:                              * DMA operation
526:                              */
527:                 
528:                             /* Obtain the Recieved data count in bytes */
529:                             count = (uint32_t) PLIB_USBHS_GetReceiveDataCount(usbID, endpoint);
530:                 
531:                             ((DRV_USBHS_OBJ *)(pipe->hClient))->gDrvUSBDMAPool[dmaChannelGrabbed] .count = count;
9D00D390  8EA50008   LW A1, 8(S5)
9D00D394  000320C0   SLL A0, V1, 3
9D00D398  00A42021   ADDU A0, A1, A0
9D00D39C  AC820008   SW V0, 8(A0)
532:                 
533:                             PLIB_USBHS_DMAOperationEnable(usbID, endpoint,dmaChannelGrabbed, (void *)(data), count, 1);
534:                             *pisDMAUsed = true;
9D00D410  0B40351A   J 0x9D00D468
9D00D414  A2630000   SB V1, 0(S3)
535:                         }
536:                     }
537:                 
538:                     return (count);
539:                 }/* end of _DRV_USBHS_HOST_IRPReceiveFIFOUnload() */
9D00D468  8FBF0034   LW RA, 52(SP)
540:                 
541:                 void _DRV_USBHS_HOST_Initialize
542:                 (
543:                     DRV_USBHS_OBJ * drvObj, 
544:                     SYS_MODULE_INDEX index
545:                   
546:                 )
547:                 {
548:                     USBHS_MODULE_ID usbID = drvObj->usbID;
9D015DF0  8C82005C   LW V0, 92(A0)
549:                    
550:                     /* No device attached */
551:                     drvObj->deviceAttached = false;
9D015DF4  A0800158   SB ZERO, 344(A0)
552:                 
553:                     /* Initialize the device handle */
554:                     drvObj->attachedDeviceObjHandle = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
9D015DF8  2403FFFF   ADDIU V1, ZERO, -1
9D015DFC  AC830160   SW V1, 352(A0)
555:                 
556:                     /* Disable all interrupts. Interrupts will be enabled when the root hub is
557:                      * enabled */
558:                     PLIB_USBHS_InterruptEnableSet(usbID, 0x0, 0x0, 0x0);
559:                 
560:                     /* Based on the speed that we are initializing
561:                      * set up the HS Enable bit in the Power register */
562:                 
563:                     if(drvObj->operationSpeed == USB_SPEED_HIGH)
9D015E0C  8C850054   LW A1, 84(A0)
9D015E10  24030001   ADDIU V1, ZERO, 1
9D015E14  14A30007   BNE A1, V1, _DRV_USBHS_HOST_Initialize::PLIB_USBHS_HighSpeedDisable
9D015E18  00000000   NOP
564:                     {
565:                         /* Enable high speed */
566:                         PLIB_USBHS_HighSpeedEnable(usbID);
567:                     }
568:                     else
569:                     {
570:                         /* Enable full speed */
571:                         PLIB_USBHS_HighSpeedDisable(usbID);
572:                     }
573:                 
574:                     /* Initialize the host specific members in the driver object */
575:                     drvObj->isResetting     = false;
9D015E2C  0B405791   J 0x9D015E44
9D015E30  A0800164   SB ZERO, 356(A0)
9D015E40  A0800164   SB ZERO, 356(A0)
576:                     drvObj->usbHostDeviceInfo = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
9D015E44  2402FFFF   ADDIU V0, ZERO, -1
577:                    
578:                 }/* end of _DRV_USBHS_HOST_Initialize() */
579:                 
580:                 USB_ERROR DRV_USBHS_HOST_IRPSubmit
581:                 (
582:                     DRV_USBHS_HOST_PIPE_HANDLE  hPipe, 
583:                     USB_HOST_IRP * inputIRP
584:                 )
585:                 {
9D00DA98  27BDFFD0   ADDIU SP, SP, -48
9D00DA9C  AFBF002C   SW RA, 44(SP)
9D00DAA0  AFB60028   SW S6, 40(SP)
9D00DAA4  AFB50024   SW S5, 36(SP)
9D00DAA8  AFB40020   SW S4, 32(SP)
9D00DAAC  AFB3001C   SW S3, 28(SP)
9D00DAB0  AFB20018   SW S2, 24(SP)
9D00DAB4  AFB10014   SW S1, 20(SP)
9D00DAB8  AFB00010   SW S0, 16(SP)
586:                     USB_HOST_IRP_LOCAL * irpIterator;
587:                     DRV_USBHS_HOST_TRANSFER_GROUP * controlTransferGroup;
588:                     bool interruptWasEnabled = false;
9D00DB20  00009821   ADDU S3, ZERO, ZERO
589:                     unsigned int direction;
590:                     uint8_t endpoint;
591:                 
592:                     USB_HOST_IRP_LOCAL * irp        = (USB_HOST_IRP_LOCAL *)inputIRP;
593:                     DRV_USBHS_HOST_PIPE_OBJ * pipe = (DRV_USBHS_HOST_PIPE_OBJ *)(hPipe);
594:                     DRV_USBHS_OBJ * hDriver;
595:                     USBHS_MODULE_ID usbID;
596:                 
597:                     if((pipe == NULL) || (hPipe == (DRV_USBHS_HOST_PIPE_HANDLE_INVALID)))
9D00DABC  10800065   BEQ A0, ZERO, 0x9D00DC54
9D00DAC0  00808821   ADDU S1, A0, ZERO
9D00DAC4  2402FFFF   ADDIU V0, ZERO, -1
9D00DAC8  10820064   BEQ A0, V0, 0x9D00DC5C
9D00DACC  00A08021   ADDU S0, A1, ZERO
598:                     {
599:                         /* This means an invalid pipe was specified. 
600:                          * Return with an error */
601:                 
602:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Pipe handle is not valid");
603:                         return USB_ERROR_PARAMETER_INVALID;
9D00DC54  0B403718   J 0x9D00DC60
9D00DC58  2402FF83   ADDIU V0, ZERO, -125
9D00DC5C  2402FF83   ADDIU V0, ZERO, -125
604:                     }
605:                 
606:                     hDriver = (DRV_USBHS_OBJ *)(pipe->hClient);
9D00DAD0  8C920008   LW S2, 8(A0)
607:                     usbID = hDriver->usbID;
9D00DAD4  8E54005C   LW S4, 92(S2)
608:                     controlTransferGroup = &hDriver->controlTransferGroup;
609:                 
610:                     /* Assign owner pipe */
611:                     irp->pipe = hPipe;
9D00DAD8  AE04002C   SW A0, 44(S0)
612:                     irp->status = USB_HOST_IRP_STATUS_PENDING;
9D00DADC  24020002   ADDIU V0, ZERO, 2
9D00DAE0  ACA2000C   SW V0, 12(A1)
613:                     irp->tempState = DRV_USBHS_HOST_IRP_STATE_PROCESSING;
9D00DAE4  24020008   ADDIU V0, ZERO, 8
9D00DAE8  ACA2001C   SW V0, 28(A1)
614:                     endpoint = pipe->hostEndpoint;
9D00DAEC  90950032   LBU S5, 50(A0)
615:                     direction = (pipe->endpointAndDirection & 0x80) >> 7;
616:                 
617:                     /* We need to disable interrupts was the queue state
618:                      * does not change asynchronously */
619:                 
620:                     if(!hDriver->isInInterruptContext)
9D00DAF0  924200F4   LBU V0, 244(S2)
9D00DAF4  1440000A   BNE V0, ZERO, 0x9D00DB20
9D00DAF8  9096000C   LBU S6, 12(A0)
621:                     {
622:                         // OSAL: Get Mutex
623:                         if(OSAL_MUTEX_Lock(&(hDriver->mutexID), OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
624:                         {
625:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex lock failed");
626:                             return USB_ERROR_OSAL_FUNCTION;
627:                         }
628:                         interruptWasEnabled = _DRV_USBHS_InterruptSourceDisable(hDriver->interruptSource);;
9D00DB10  0F40588F   JAL SYS_INT_SourceDisable
9D00DB14  8E440064   LW A0, 100(S2)
9D00DB18  0B4036C9   J 0x9D00DB24
9D00DB1C  00409821   ADDU S3, V0, ZERO
629:                 
630:                     }
631:                 
632:                     /* This needs to be done for all irp irrespective
633:                      * of type or if there IRP is immediately processed */
634:                 
635:                     irp->next = NULL;
9D00DB24  AE000024   SW ZERO, 36(S0)
636:                     irp->completedBytes = 0;
9D00DB28  AE000020   SW ZERO, 32(S0)
637:                     irp->status = USB_HOST_IRP_STATUS_PENDING;
9D00DB2C  24020002   ADDIU V0, ZERO, 2
9D00DB30  AE02000C   SW V0, 12(S0)
638:                 
639:                     if(pipe->irpQueueHead == NULL)
9D00DB34  8E270014   LW A3, 20(S1)
9D00DB38  54E0002F   BNEL A3, ZERO, 0x9D00DBF8
9D00DB3C  8CE30024   LW V1, 36(A3)
640:                     {
641:                         /* This means that there are no
642:                          * IRPs on this pipe. We can add
643:                          * this IRP directly */
644:                 
645:                         irp->previous = NULL;
9D00DB40  AE000028   SW ZERO, 40(S0)
646:                         pipe->irpQueueHead = irp;
9D00DB44  AE300014   SW S0, 20(S1)
647:                 
648:                         if(pipe->pipeType == USB_TRANSFER_TYPE_CONTROL)
9D00DB48  8E220010   LW V0, 16(S1)
9D00DB4C  14400017   BNE V0, ZERO, 0x9D00DBAC
9D00DB50  24020003   ADDIU V0, ZERO, 3
649:                         {
650:                             /* Set the initial stage of the IRP */
651:                             irp->tempState = DRV_USBHS_HOST_IRP_STATE_SETUP_STAGE;
9D00DB54  AE00001C   SW ZERO, 28(S0)
652:                 
653:                             /* We need to update the flags parameter of the IRP
654:                              * to indicate the direction of the control transfer. */
655:                 
656:                             if(*((uint8_t*)(irp->setup)) & 0x80)
9D00DB58  8E020000   LW V0, 0(S0)
9D00DB5C  80420000   LB V0, 0(V0)
9D00DB60  04410004   BGEZ V0, 0x9D00DB74
9D00DB64  8E020010   LW V0, 16(S0)
657:                             {
658:                                 /* This means the data stage moves from device to 
659:                                  * host. Set bit 15 of the flags parameter */
660:                 
661:                                 irp->flags |= 0x8000;
9D00DB68  34428000   ORI V0, V0, -32768
9D00DB6C  0B4036DF   J 0x9D00DB7C
9D00DB70  AE020010   SW V0, 16(S0)
662:                             }
663:                             else
664:                             {
665:                                 /* This means the data stage moves from host to
666:                                  * device. Clear bit 15 of the flags parameter. */
667:                 
668:                                 irp->flags &= 0x7FFF;
9D00DB74  30427FFF   ANDI V0, V0, 32767
9D00DB78  AE020010   SW V0, 16(S0)
669:                             }
670:                 
671:                             /* We need to check if the endpoint 0 is free and if so
672:                              * then start processing the IRP */
673:                 
674:                             if(controlTransferGroup->currentIRP == NULL)
9D00DB7C  8E420108   LW V0, 264(S2)
9D00DB80  54400023   BNEL V0, ZERO, 0x9D00DC10
9D00DB84  924300F4   LBU V1, 244(S2)
675:                             {
676:                                 /* This means that no IRPs are being processed
677:                                  * So we should start the IRP processing. Else
678:                                  * the IRP processing will start in interrupt.
679:                                  * We start by copying the setup command */
680:                 
681:                                 controlTransferGroup->currentIRP = irp;
9D00DB88  AE500108   SW S0, 264(S2)
682:                                 controlTransferGroup->currentPipe = pipe;
9D00DB8C  AE510104   SW S1, 260(S2)
683:                                 irp->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D00DB90  24020003   ADDIU V0, ZERO, 3
9D00DB94  AE02000C   SW V0, 12(S0)
684:                 
685:                                 /* Send the setup packet to device */
686:                                 _DRV_USBHS_HOST_IRPTransmitSetupPacket(usbID, irp);
9D00DB98  02802021   ADDU A0, S4, ZERO
9D00DB9C  0F40551C   JAL _DRV_USBHS_HOST_IRPTransmitSetupPacket
9D00DBA0  02002821   ADDU A1, S0, ZERO
687:                             }
688:                         }
689:                         else
690:                         {
691:                             /* For non control transfers, if this is the first
692:                              * irp in the queue, then we can start the irp */
693:                 
694:                             irp->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
695:                 
696:                             if(USB_DATA_DIRECTION_HOST_TO_DEVICE == direction)
9D00DBAC  0016B1C2   SRL S6, S6, 7
9D00DBB0  16C00007   BNE S6, ZERO, DRV_USBHS_HOST_IRPSubmit::PLIB_USBHS_EndpointRxRequestEnable
9D00DBB4  AE02000C   SW V0, 12(S0)
697:                             {
698:                                 /* Data is moving from host to device. We
699:                                  * need to copy data into the FIFO and
700:                                  * then and set the TX request bit. If the
701:                                  * IRP size is greater than endpoint size then
702:                                  * we must packetize. */
703:                 
704:                                 _DRV_USBHS_HOST_IRPTransmitFIFOLoad(usbID, irp, endpoint);
9D00DBB8  02802021   ADDU A0, S4, ZERO
9D00DBBC  02002821   ADDU A1, S0, ZERO
9D00DBC0  0F4039EC   JAL _DRV_USBHS_HOST_IRPTransmitFIFOLoad
9D00DBC4  02A03021   ADDU A2, S5, ZERO
9D00DBC8  0B403704   J 0x9D00DC10
9D00DBCC  924300F4   LBU V1, 244(S2)
705:                             }
706:                             else
707:                             {
708:                                 /* Data is moving from device to host
709:                                  * We need to set the Rx Packet Request
710:                                  * bit */
711:                 
712:                                 PLIB_USBHS_EndpointRxRequestEnable(usbID, endpoint);
713:                             }
714:                         }
715:                     }
716:                     else
717:                     {
718:                         /* We need to add the irp to the last irp
719:                          * in the pipe queue (which is a linked list) */
720:                         irpIterator = pipe->irpQueueHead;
721:                 
722:                         /* Find the last IRP in the linked list*/
723:                         while(irpIterator->next != 0)
9D00DBF4  8CE30024   LW V1, 36(A3)
9D00DBF8  50600003   BEQL V1, ZERO, 0x9D00DC08
9D00DBFC  ACF00024   SW S0, 36(A3)
724:                         {
725:                             irpIterator = irpIterator->next;
9D00DC00  0B4036FD   J 0x9D00DBF4
9D00DC04  00603821   ADDU A3, V1, ZERO
726:                         }
727:                 
728:                         /* Add the item to the last irp in the linked list */
729:                         irpIterator->next = irp;
730:                         irp->previous = irpIterator;
9D00DC08  AE070028   SW A3, 40(S0)
731:                     }
732:                 
733:                     if(!hDriver->isInInterruptContext)
9D00DBA4  0B403704   J 0x9D00DC10
9D00DBA8  924300F4   LBU V1, 244(S2)
9D00DBEC  0B403704   J 0x9D00DC10
9D00DBF0  924300F4   LBU V1, 244(S2)
9D00DC0C  924300F4   LBU V1, 244(S2)
9D00DC10  14600013   BNE V1, ZERO, 0x9D00DC60
9D00DC14  00001021   ADDU V0, ZERO, ZERO
734:                     {
735:                         if(interruptWasEnabled)
9D00DC18  5260000B   BEQL S3, ZERO, 0x9D00DC48
9D00DC1C  24020001   ADDIU V0, ZERO, 1
736:                         {
737:                             _DRV_USBHS_InterruptSourceEnable(hDriver->interruptSource);
9D00DC20  8E420064   LW V0, 100(S2)
738:                         }
739:                         //OSAL: Return Mutex
740:                         if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
741:                         {
742:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
743:                         }
744:                     }
745:                 
746:                     return USB_ERROR_NONE;
747:                 }/* end of DRV_USBHS_HOST_IRPSubmit() */
9D00DC60  8FBF002C   LW RA, 44(SP)
748:                 
749:                 void DRV_USBHS_HOST_IRPCancel(USB_HOST_IRP * inputIRP)
750:                 {
9D01175C  27BDFFD8   ADDIU SP, SP, -40
9D011760  AFBF0024   SW RA, 36(SP)
9D011764  AFB30020   SW S3, 32(SP)
9D011768  AFB2001C   SW S2, 28(SP)
9D01176C  AFB10018   SW S1, 24(SP)
9D011770  AFB00014   SW S0, 20(SP)
751:                     /* This function cancels an IRP */
752:                 
753:                     USB_HOST_IRP_LOCAL * irp = (USB_HOST_IRP_LOCAL *) inputIRP;
754:                     DRV_USBHS_OBJ * hDriver;
755:                     DRV_USBHS_HOST_PIPE_OBJ * pipe;
756:                     bool interruptWasEnabled = false;
757:                 
758:                     if(irp->pipe == DRV_USBHS_HOST_PIPE_HANDLE_INVALID)
9D011774  8C92002C   LW S2, 44(A0)
9D011778  2402FFFF   ADDIU V0, ZERO, -1
9D01177C  1242003C   BEQ S2, V0, 0x9D011870
9D011780  00808021   ADDU S0, A0, ZERO
759:                     {
760:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Invalid pipe");
761:                         return;
762:                     }
763:                 
764:                     if(irp->status <= USB_HOST_IRP_STATUS_COMPLETED_SHORT)
9D011784  8C82000C   LW V0, 12(A0)
9D011788  28420002   SLTI V0, V0, 2
9D01178C  54400039   BNEL V0, ZERO, 0x9D011874
9D011790  8FBF0024   LW RA, 36(SP)
765:                     {
766:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "IRP is not pending or in progress");
767:                         return;
768:                     }
769:                 
770:                     pipe = (DRV_USBHS_HOST_PIPE_OBJ *)irp->pipe;
771:                     hDriver = (DRV_USBHS_OBJ *) pipe->hClient;
9D011794  8E510008   LW S1, 8(S2)
772:                 
773:                     if(!hDriver->isInInterruptContext)
9D011798  922200F4   LBU V0, 244(S1)
9D01179C  14400008   BNE V0, ZERO, 0x9D0117C0
9D0117A0  00009821   ADDU S3, ZERO, ZERO
774:                     {
775:                         //OSAL: Get Mutex
776:                         if(OSAL_MUTEX_Lock(&(hDriver->mutexID), OSAL_WAIT_FOREVER) != OSAL_RESULT_TRUE)
777:                         {
778:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex lock failed");
779:                         }
780:                         interruptWasEnabled = _DRV_USBHS_InterruptSourceDisable(hDriver->interruptSource);
9D0117B4  0F40588F   JAL SYS_INT_SourceDisable
9D0117B8  8E240064   LW A0, 100(S1)
9D0117BC  00409821   ADDU S3, V0, ZERO
781:                     }
782:                 
783:                     if(irp->previous == NULL)
9D0117C0  8E030028   LW V1, 40(S0)
9D0117C4  14600007   BNE V1, ZERO, 0x9D0117E4
9D0117C8  8E020024   LW V0, 36(S0)
784:                     {
785:                         /* This means this was the first
786:                          * irp in the queue. Update the pipe
787:                          * queue head directly */
788:                 
789:                         pipe->irpQueueHead = irp->next;
9D0117CC  AE420014   SW V0, 20(S2)
790:                         if(irp->next != NULL)
9D0117D0  8E020024   LW V0, 36(S0)
9D0117D4  54400009   BNEL V0, ZERO, 0x9D0117FC
9D0117D8  AC400028   SW ZERO, 40(V0)
791:                         {
792:                             irp->next->previous = NULL;
793:                         }
794:                     }
795:                     else
796:                     {
797:                         /* Remove the IRP from the linked
798:                          * list */
799:                         irp->previous->next = irp->next;
9D0117E4  AC620024   SW V0, 36(V1)
800:                 
801:                         if(irp->next != NULL)
9D0117E8  8E030024   LW V1, 36(S0)
9D0117EC  50600004   BEQL V1, ZERO, 0x9D011800
9D0117F0  8E03000C   LW V1, 12(S0)
802:                         {
803:                             /* This applies if this is not the last
804:                              * irp in the linked list */
805:                             irp->next->previous = irp->previous;
9D0117F4  8E020028   LW V0, 40(S0)
9D0117F8  AC620028   SW V0, 40(V1)
806:                         }
807:                     }
808:                 
809:                     if(irp->status == USB_HOST_IRP_STATUS_IN_PROGRESS)
9D0117DC  0B404600   J 0x9D011800
9D0117E0  8E03000C   LW V1, 12(S0)
9D0117FC  8E03000C   LW V1, 12(S0)
9D011800  24020003   ADDIU V0, ZERO, 3
9D011804  14620004   BNE V1, V0, 0x9D011818
9D011808  2402FFFB   ADDIU V0, ZERO, -5
810:                     {
811:                         /* If the irp is already in progress then
812:                          * we set the temporary state. This will get
813:                          * caught in _DRV_USBHS_HOST_ControlXferProcess()
814:                          * and _DRV_USBHS_HOST_NonControlIRPProcess()
815:                          * functions. */
816:                 
817:                         irp->tempState = DRV_USBHS_HOST_IRP_STATE_ABORTED;
9D01180C  24020007   ADDIU V0, ZERO, 7
9D011810  0B40460C   J 0x9D011830
9D011814  AE02001C   SW V0, 28(S0)
818:                     }
819:                     else
820:                     {
821:                         irp->status = USB_HOST_IRP_STATUS_ABORTED;
9D011818  AE02000C   SW V0, 12(S0)
822:                         if(irp->callback != NULL)
9D01181C  8E020018   LW V0, 24(S0)
9D011820  50400004   BEQL V0, ZERO, 0x9D011834
9D011824  922200F4   LBU V0, 244(S1)
823:                         {
824:                             irp->callback((USB_HOST_IRP *)irp);
9D011828  0040F809   JALR V0
9D01182C  02002021   ADDU A0, S0, ZERO
825:                         }
826:                     }
827:                 
828:                     if(!hDriver->isInInterruptContext)
9D011830  922200F4   LBU V0, 244(S1)
9D011834  1440000F   BNE V0, ZERO, 0x9D011874
9D011838  8FBF0024   LW RA, 36(SP)
829:                     {
830:                         if(interruptWasEnabled)
9D01183C  1260000B   BEQ S3, ZERO, 0x9D01186C
9D011840  24020001   ADDIU V0, ZERO, 1
831:                         {
832:                             _DRV_USBHS_InterruptSourceEnable(hDriver->interruptSource);
9D011844  8E220064   LW V0, 100(S1)
833:                         }
834:                         //OSAL: Release Mutex
835:                         if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
836:                         {
837:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
838:                         }
839:                     }
840:                 }/* end of DRV_USBHS_HOST_IRPCancel() */
9D011870  8FBF0024   LW RA, 36(SP)
841:                 
842:                 void DRV_USBHS_HOST_PipeClose
843:                 (
844:                     DRV_USBHS_HOST_PIPE_HANDLE pipeHandle
845:                 )
846:                 {
9D007E94  27BDFFC8   ADDIU SP, SP, -56
9D007E98  AFBF0034   SW RA, 52(SP)
9D007E9C  AFBE0030   SW S8, 48(SP)
9D007EA0  AFB7002C   SW S7, 44(SP)
9D007EA4  AFB60028   SW S6, 40(SP)
9D007EA8  AFB50024   SW S5, 36(SP)
9D007EAC  AFB40020   SW S4, 32(SP)
9D007EB0  AFB3001C   SW S3, 28(SP)
9D007EB4  AFB20018   SW S2, 24(SP)
9D007EB8  AFB10014   SW S1, 20(SP)
9D007EBC  AFB00010   SW S0, 16(SP)
847:                     /* This function closes an open pipe */
848:                 
849:                     bool                        interruptWasEnabled = false;
9D008170  00001821   ADDU V1, ZERO, ZERO
9D008174  0B40203F   J 0x9D0080FC
9D008178  25690001   ADDIU T1, T3, 1
850:                     DRV_USBHS_OBJ                 * hDriver;
851:                     USB_HOST_IRP_LOCAL          * irp;
852:                     DRV_USBHS_HOST_PIPE_OBJ       * pipe;
853:                     DRV_USBHS_HOST_TRANSFER_GROUP * transferGroup;
854:                     DRV_USBHS_HOST_ENDPOINT_OBJ   * endpointObj;
855:                     USBHS_MODULE_ID               usbID;
856:                     unsigned int direction;
857:                 
858:                     uint8_t *pFifoTable;
859:                     uint8_t startingSlot;
860:                     uint8_t byteLoop;
861:                     uint8_t bitLoop;
862:                     bool slotObtained = false;
9D0080E4  00003821   ADDU A3, ZERO, ZERO
863:                 
864:                     /* Make sure we have a valid pipe */
865:                     if( ( pipeHandle == 0 )  || pipeHandle == DRV_USBHS_HOST_PIPE_HANDLE_INVALID)
9D007EC0  2482FFFF   ADDIU V0, A0, -1
9D007EC4  2C42FFFE   SLTIU V0, V0, -2
9D007EC8  104000C3   BEQ V0, ZERO, 0x9D0081D8
9D007ECC  00809021   ADDU S2, A0, ZERO
866:                     {
867:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Invalid pipe handle");
868:                         return;
869:                     }
870:                 
871:                     pipe = (DRV_USBHS_HOST_PIPE_OBJ*) pipeHandle;
9D007ED0  00808821   ADDU S1, A0, ZERO
872:                     direction = (pipe->endpointAndDirection & 0x80) >> 7;
873:                 
874:                     /* Make sure tha we are working with a pipe in use */
875:                     if(pipe->inUse != true)
9D007ED4  90820000   LBU V0, 0(A0)
9D007ED8  104000BF   BEQ V0, ZERO, 0x9D0081D8
9D007EDC  9095000C   LBU S5, 12(A0)
876:                     {
877:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Pipe is not in use");
878:                         return;
879:                     }
880:                 
881:                     hDriver = (DRV_USBHS_OBJ *)pipe->hClient;
9D007EE0  8C930008   LW S3, 8(A0)
882:                     usbID = hDriver->usbID;
9D007EE4  8E70005C   LW S0, 92(S3)
883:                 
884:                     /* Disable the interrupt */
885:                 
886:                     if(!hDriver->isInInterruptContext)
9D007EE8  926200F4   LBU V0, 244(S3)
9D007EEC  14400008   BNE V0, ZERO, 0x9D007F10
9D007EF0  0000A021   ADDU S4, ZERO, ZERO
887:                     {
888:                         //OSAL: Get Mutex
889:                         if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) !=
890:                                 OSAL_RESULT_TRUE)
891:                         {
892:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex lock failed");
893:                         }
894:                         interruptWasEnabled = _DRV_USBHS_InterruptSourceDisable(hDriver->interruptSource);
9D007F04  0F40588F   JAL SYS_INT_SourceDisable
9D007F08  8E640064   LW A0, 100(S3)
9D007F0C  0040A021   ADDU S4, V0, ZERO
895:                     }
896:                 
897:                     if(USB_TRANSFER_TYPE_CONTROL == pipe->pipeType)
9D007F10  8E420010   LW V0, 16(S2)
9D007F14  54400017   BNEL V0, ZERO, 0x9D007F74
9D007F18  0015A9C2   SRL S5, S5, 7
898:                     {
899:                         transferGroup = &hDriver->controlTransferGroup;
900:                 
901:                         if(pipe->previous == NULL)
9D007F1C  8E420024   LW V0, 36(S2)
9D007F20  54400008   BNEL V0, ZERO, 0x9D007F44
9D007F24  8E430020   LW V1, 32(S2)
902:                         {
903:                             /* The previous pipe could be null if this was the first pipe in the
904:                              * transfer group */
905:                 
906:                             transferGroup->pipe = pipe->next;
9D007F28  8E420020   LW V0, 32(S2)
9D007F2C  AE620100   SW V0, 256(S3)
907:                             if(pipe->next != NULL)
9D007F30  8E420020   LW V0, 32(S2)
9D007F34  54400009   BNEL V0, ZERO, 0x9D007F5C
9D007F38  AC400024   SW ZERO, 36(V0)
908:                             {
909:                                 pipe->next->previous = NULL;
910:                             }
911:                         }
912:                         else
913:                         {
914:                             /* Remove this pipe from the linked
915:                              * list */
916:                 
917:                             pipe->previous->next = pipe->next;
9D007F44  AC430020   SW V1, 32(V0)
918:                             if(pipe->next != NULL)
9D007F48  8E420020   LW V0, 32(S2)
9D007F4C  50400004   BEQL V0, ZERO, 0x9D007F60
9D007F50  8E62010C   LW V0, 268(S3)
919:                             {
920:                                 pipe->next->previous = pipe->previous;
9D007F54  8E430024   LW V1, 36(S2)
9D007F58  AC430024   SW V1, 36(V0)
921:                             }
922:                         }
923:                 
924:                         if(transferGroup->nPipes != 0)
9D007F3C  0B401FD8   J 0x9D007F60
9D007F40  8E62010C   LW V0, 268(S3)
9D007F5C  8E62010C   LW V0, 268(S3)
9D007F60  50400041   BEQL V0, ZERO, 0x9D008068
9D007F64  8E500014   LW S0, 20(S2)
925:                         {
926:                             /* Reduce the count only if its
927:                              * not zero already */
928:                 
929:                             transferGroup->nPipes --;
9D007F68  2442FFFF   ADDIU V0, V0, -1
9D007F6C  0B402019   J 0x9D008064
9D007F70  AE62010C   SW V0, 268(S3)
930:                         }
931:                     }
932:                     else
933:                     {
934:                         /* Non control tranfer pipes are not stored as groups.  We deallocate
935:                          * the endpoint object that this pipe used */
936:                 
937:                         endpointObj = &hDriver->hostEndpointTable[pipe->hostEndpoint];
9D007F74  92430032   LBU V1, 50(S2)
9D007F78  24630007   ADDIU V1, V1, 7
9D007F7C  00031900   SLL V1, V1, 4
9D007F80  02631821   ADDU V1, S3, V1
9D007F84  24630004   ADDIU V1, V1, 4
9D007F88  001510C0   SLL V0, S5, 3
9D007F8C  00621021   ADDU V0, V1, V0
938:                         endpointObj->endpoints[direction].inUse = false;
9D007F90  A0400000   SB ZERO, 0(V0)
939:                         endpointObj->endpoints[direction].pipe = NULL;
940:                 
941:                 
942:                         if(direction == USB_DATA_DIRECTION_DEVICE_TO_HOST)
9D007F94  12A0001F   BEQ S5, ZERO, DRV_USBHS_HOST_PipeClose::PLIB_USBHS_EndpointTxFIFOFlush
9D007F98  AC400004   SW ZERO, 4(V0)
943:                         {
944:                             /* Clear the error status on and flush the fifo
945:                              * on receive endpoint */
946:                 
947:                 
948:                             PLIB_USBHS_EndpointRxFIFOFlush(usbID, pipe->hostEndpoint);
949:                             PLIB_USBHS_RxEPStatusClear(usbID, pipe->hostEndpoint, USBHS_RXEP_ERROR_ALL);
950:                             PLIB_USBHS_EndpointRxRequestClear(usbID, pipe->hostEndpoint);
951:                         }
952:                         else
953:                         {
954:                             /* Clear the error status on and flush the fifo
955:                              * on transmit endpoint */
956:                             PLIB_USBHS_EndpointTxFIFOFlush(usbID, pipe->hostEndpoint);
957:                             PLIB_USBHS_TxEPStatusClear(usbID, pipe->hostEndpoint, USBHS_TXEP_ERROR_ALL);
958:                 
959:                         }
960:                     }
961:                 
962:                     /* Now we invoke the call back for each IRP in this pipe and say that it is
963:                      * aborted.  If the IRP is in progress, then that IRP will be actually
964:                      * aborted on the next SOF This will allow the USB module to complete any
965:                      * transaction that was in progress. */
966:                 
967:                     irp = (USB_HOST_IRP_LOCAL *)pipe->irpQueueHead;
9D00800C  0B40201A   J 0x9D008068
9D008010  8E500014   LW S0, 20(S2)
9D008064  8E500014   LW S0, 20(S2)
968:                     while(irp != NULL)
9D008068  52000019   BEQL S0, ZERO, 0x9D0080D0
9D00806C  8E420010   LW V0, 16(S2)
9D0080C4  5600FFEF   BNEL S0, ZERO, 0x9D008084
9D0080C8  AE17002C   SW S7, 44(S0)
969:                     {
970:                         irp->pipe = DRV_USBHS_HOST_PIPE_HANDLE_INVALID;
9D008070  2417FFFF   ADDIU S7, ZERO, -1
9D008080  AE17002C   SW S7, 44(S0)
971:                 
972:                         if(irp->status == USB_HOST_IRP_STATUS_IN_PROGRESS)
9D008074  24160003   ADDIU S6, ZERO, 3
9D008084  8E02000C   LW V0, 12(S0)
9D008088  14560008   BNE V0, S6, 0x9D0080AC
9D00808C  AE15000C   SW S5, 12(S0)
973:                         {
974:                             /* If the IRP is in progress, then we set the temp IRP state. This
975:                              * will be caught in the _DRV_USBHS_HOST_NonControlIRPProcess() and
976:                              * _DRV_USBHS_HOST_ControlXferProcess() functions */
977:                             irp->status = USB_HOST_IRP_STATUS_ABORTED;
978:                             if(irp->callback != NULL)
9D008090  8E020018   LW V0, 24(S0)
9D008094  5040000A   BEQL V0, ZERO, 0x9D0080C0
9D008098  AE1E001C   SW S8, 28(S0)
979:                             {
980:                                 irp->callback((USB_HOST_IRP*)irp);
9D00809C  0040F809   JALR V0
9D0080A0  02002021   ADDU A0, S0, ZERO
9D0080A4  0B402030   J 0x9D0080C0
9D0080A8  AE1E001C   SW S8, 28(S0)
981:                             }
982:                             irp->tempState = DRV_USBHS_HOST_IRP_STATE_ABORTED;
9D00807C  241E0007   ADDIU S8, ZERO, 7
983:                         }
984:                         else
985:                         {
986:                             /* IRP is pending */
987:                             irp->status = USB_HOST_IRP_STATUS_ABORTED;
9D008078  2415FFFB   ADDIU S5, ZERO, -5
988:                             if(irp->callback != NULL)
9D0080AC  8E020018   LW V0, 24(S0)
9D0080B0  50400004   BEQL V0, ZERO, 0x9D0080C4
9D0080B4  8E100024   LW S0, 36(S0)
989:                             {
990:                                 irp->callback((USB_HOST_IRP*)irp);
9D0080B8  0040F809   JALR V0
9D0080BC  02002021   ADDU A0, S0, ZERO
991:                             }
992:                         }
993:                         irp = irp->next;
9D0080C0  8E100024   LW S0, 36(S0)
994:                     }
995:                 
996:                     /* Update the consumed FIFO size for non control transfers. Control
997:                      * transfers have a dedicated FIFO that is the first 64 bytes */
998:                 
999:                     if(USB_TRANSFER_TYPE_CONTROL != pipe->pipeType)
9D0080CC  8E420010   LW V0, 16(S2)
9D0080D0  5040002B   BEQL V0, ZERO, 0x9D008180
9D0080D4  A2400000   SB ZERO, 0(S2)
1000:                    {
1001:                        pFifoTable = (uint8_t *)(hDriver->gDrvUSBFifoTable);
9D0080D8  2666012C   ADDIU A2, S3, 300
1002:                        startingSlot = pipe->startingOffset/8;
9D0080DC  8E4A0004   LW T2, 4(S2)
9D0080E0  00005821   ADDU T3, ZERO, ZERO
1003:                
1004:                        for(byteLoop = 1; byteLoop <=18; byteLoop++)
9D0080F4  0B40205C   J 0x9D008170
9D0080F8  240C0090   ADDIU T4, ZERO, 144
9D0081C8  156CFFEA   BNE T3, T4, 0x9D008174
9D0081CC  00001821   ADDU V1, ZERO, ZERO
9D0081D0  0B402060   J 0x9D008180
9D0081D4  A2400000   SB ZERO, 0(S2)
1005:                        {
1006:                            for(bitLoop=0; bitLoop <=7; bitLoop++)
9D0080F0  24040008   ADDIU A0, ZERO, 8
9D008160  1464FFE6   BNE V1, A0, 0x9D0080FC
9D008164  00000000   NOP
9D008168  0B402071   J 0x9D0081C4
9D00816C  24C60001   ADDIU A2, A2, 1
1007:                            {
1008:                                /*
1009:                                 * The design here is to find the starting slot in the
1010:                                 * FiFoTable.  Once found, we will start reseting all the slots
1011:                                 * allocated.  We need not check for the slot value as slots
1012:                                 * during allocation needs to be continous. No segmented slots
1013:                                 * for a particluar pipe is possible.
1014:                                 */
1015:                                if( (slotObtained == false) && (( ((byteLoop - 1) * 8) + 1 + bitLoop) == startingSlot) )
9D0080FC  14E0000E   BNE A3, ZERO, 0x9D008138
9D008100  00681004   SLLV V0, T0, V1
9D008104  01231021   ADDU V0, T1, V1
9D008108  55420013   BNEL T2, V0, 0x9D008158
9D00810C  92250003   LBU A1, 3(S1)
1016:                                {
1017:                                    /* Starting Slot found. Reset the slot. Make sure it never
1018:                                     * enters this if() loop again for this pipe close operation
1019:                                     */
1020:                                    *pFifoTable = ( *pFifoTable & ~(0x01 << bitLoop) );
9D008110  00681004   SLLV V0, T0, V1
9D008114  00021027   NOR V0, ZERO, V0
9D008118  90C50000   LBU A1, 0(A2)
9D00811C  00451024   AND V0, V0, A1
9D008120  A0C20000   SB V0, 0(A2)
1021:                                    slotObtained = true;
1022:                                    pipe->noOfSlots--;
9D008124  92220003   LBU V0, 3(S1)
9D008128  2442FFFF   ADDIU V0, V0, -1
9D00812C  A2220003   SB V0, 3(S1)
9D008130  0B402055   J 0x9D008154
9D008134  01003821   ADDU A3, T0, ZERO
1023:                                }
1024:                                else if(slotObtained == true)
1025:                                {
1026:                                    /* Slot already found before.  We can just continuing
1027:                                     * resetting all the slots allocated for the pipe.*/
1028:                                    *pFifoTable = ( *pFifoTable & ~(0x01 << bitLoop) );
9D0080E8  24080001   ADDIU T0, ZERO, 1
9D0080EC  7D4A38C0   EXT T2, T2, 3, 8
9D008138  00021027   NOR V0, ZERO, V0
9D00813C  90C50000   LBU A1, 0(A2)
9D008140  00451024   AND V0, V0, A1
9D008144  A0C20000   SB V0, 0(A2)
1029:                                    pipe->noOfSlots--;
9D008148  92220003   LBU V0, 3(S1)
9D00814C  2442FFFF   ADDIU V0, V0, -1
9D008150  A2220003   SB V0, 3(S1)
1030:                                }
1031:                                if(pipe->noOfSlots == 0)
9D008154  92250003   LBU A1, 3(S1)
9D008158  10A00008   BEQ A1, ZERO, 0x9D00817C
9D00815C  24630001   ADDIU V1, V1, 1
1032:                                {
1033:                                    /* Done releasing slots. Exit the inner loop */
1034:                                    break;
1035:                                }
1036:                            }/* end of bitLoop */
1037:                            if((pipe->noOfSlots == 0))
1038:                            {
1039:                                /* Done releasing slots. Exit the outer loop */
1040:                                break;
1041:                            }
1042:                            pFifoTable++;
1043:                        }/* end of byteloop */
1044:                        if((pipe->noOfSlots != 0))
1045:                        {
1046:                            /* This is error scenaario */
1047:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Error in releasing Fifo Table");
1048:                        }
1049:                    }
1050:                
1051:                    /* Now we return the pipe back to the driver */
1052:                    pipe->inUse = false ;
9D00817C  A2400000   SB ZERO, 0(S2)
1053:                
1054:                    /* Enable the interrupts */
1055:                    if(!hDriver->isInInterruptContext)
9D008180  926200F4   LBU V0, 244(S3)
9D008184  14400015   BNE V0, ZERO, 0x9D0081DC
9D008188  8FBF0034   LW RA, 52(SP)
1056:                    {
1057:                        if(interruptWasEnabled)
9D00818C  1280000B   BEQ S4, ZERO, 0x9D0081BC
9D008190  24020001   ADDIU V0, ZERO, 1
1058:                        {
1059:                            _DRV_USBHS_InterruptSourceEnable(hDriver->interruptSource);
9D008194  8E620064   LW V0, 100(S3)
1060:                        }
1061:                        //OSAL: Return Mutex
1062:                        if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
1063:                        {
1064:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
1065:                        }
1066:                    }
1067:                }/* end of DRV_USBHS_HOST_PipeClose() */
9D0081D8  8FBF0034   LW RA, 52(SP)
1068:                
1069:                DRV_USBHS_HOST_PIPE_HANDLE DRV_USBHS_HOST_PipeSetup
1070:                (
1071:                    DRV_HANDLE client,
1072:                    uint8_t deviceAddress,
1073:                    USB_ENDPOINT endpointAndDirection,
1074:                    uint8_t hubAddress,
1075:                    uint8_t hubPort,
1076:                    USB_TRANSFER_TYPE pipeType,
1077:                    uint8_t bInterval,
1078:                    uint16_t wMaxPacketSize,
1079:                    USB_SPEED speed
1080:                )
1081:                {
9D004AE8  27BDFFB8   ADDIU SP, SP, -72
9D004AEC  AFBF0044   SW RA, 68(SP)
9D004AF0  AFBE0040   SW S8, 64(SP)
9D004AF4  AFB7003C   SW S7, 60(SP)
9D004AF8  AFB60038   SW S6, 56(SP)
9D004AFC  AFB50034   SW S5, 52(SP)
9D004B00  AFB40030   SW S4, 48(SP)
9D004B04  AFB3002C   SW S3, 44(SP)
9D004B08  AFB20028   SW S2, 40(SP)
9D004B0C  AFB10024   SW S1, 36(SP)
9D004B10  AFB00020   SW S0, 32(SP)
9D004B14  00808821   ADDU S1, A0, ZERO
9D004B18  30B600FF   ANDI S6, A1, 255
9D004B1C  30D300FF   ANDI S3, A2, 255
9D004B20  30F500FF   ANDI S5, A3, 255
9D004B24  93B40058   LBU S4, 88(SP)
9D004B28  93B20060   LBU S2, 96(SP)
9D004B2C  97B00064   LHU S0, 100(SP)
1082:                    int pipeIter;
1083:                    int fifoSize;
1084:                    bool epFound;
1085:                    uint8_t epIter;
1086:                    uint8_t endpoint;
1087:                    USBHS_MODULE_ID usbID;
1088:                    unsigned int epDirection;
1089:                    unsigned int shiftWord;
1090:                    unsigned int i, j, accumulate;
1091:                
1092:                    DRV_USBHS_OBJ * hDriver;
1093:                    DRV_USBHS_HOST_PIPE_OBJ * pipe, * iteratorPipe;
1094:                    DRV_USBHS_HOST_TRANSFER_GROUP * transferGroup;
1095:                  
1096:                    if(client == DRV_HANDLE_INVALID)
9D004B30  2402FFFF   ADDIU V0, ZERO, -1
9D004B34  1082014B   BEQ A0, V0, 0x9D005064
9D004B38  2403FFFF   ADDIU V1, ZERO, -1
1097:                    {
1098:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Invalid client handle");
1099:                        return DRV_USBHS_HOST_PIPE_HANDLE_INVALID;
1100:                    }
1101:                
1102:                    if((speed == USB_SPEED_LOW) || (speed == USB_SPEED_FULL) || (speed == USB_SPEED_HIGH))
9D004B3C  8FA30068   LW V1, 104(SP)
9D004B40  2462FFFF   ADDIU V0, V1, -1
9D004B44  2C420003   SLTIU V0, V0, 3
9D004B48  10400008   BEQ V0, ZERO, 0x9D004B6C
9D004B4C  2602FFF8   ADDIU V0, S0, -8
1103:                    {
1104:                        if(pipeType != USB_TRANSFER_TYPE_CONTROL)
9D004B50  8FA4005C   LW A0, 92(SP)
9D004B54  10800006   BEQ A0, ZERO, 0x9D004B70
9D004B58  3042FFFF   ANDI V0, V0, -1
1105:                        {
1106:                            if(wMaxPacketSize < 8)
9D004B5C  2E020008   SLTIU V0, S0, 8
9D004B60  54400008   BNEL V0, ZERO, 0x9D004B84
9D004B64  24100008   ADDIU S0, ZERO, 8
1107:                            {
1108:                                wMaxPacketSize = 8;
1109:                            }
1110:                        }
1111:                    }
1112:                
1113:                    if((wMaxPacketSize < 8) ||(wMaxPacketSize > 4096))
9D004B68  2602FFF8   ADDIU V0, S0, -8
9D004B6C  3042FFFF   ANDI V0, V0, -1
9D004B70  2C420FF9   SLTIU V0, V0, 4089
9D004B74  1040013B   BEQ V0, ZERO, 0x9D005064
9D004B78  2403FFFF   ADDIU V1, ZERO, -1
1114:                    {
1115:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Invalid pipe endpoint size");
1116:                        return DRV_USBHS_HOST_PIPE_HANDLE_INVALID;
1117:                    }
1118:                
1119:                    /* Need to make sure that wMaxPacketSize is equal to 2 to the power n where
1120:                     * n is 3 >= n <= 12*/
1121:                
1122:                    for(i = 3; i <= 12; i ++)
9D004B8C  0B4012F5   J 0x9D004BD4
9D004B90  2405000D   ADDIU A1, ZERO, 13
9D004BCC  50850006   BEQL A0, A1, 0x9D004BE8
9D004BD0  9223006C   LBU V1, 108(S1)
1123:                    {
1124:                        accumulate = 1;
1125:                
1126:                        for (j = 0; j < i; j ++)
9D004B7C  0B4012E2   J 0x9D004B88
9D004B80  24040003   ADDIU A0, ZERO, 3
9D004B84  24040003   ADDIU A0, ZERO, 3
9D004B94  24420001   ADDIU V0, V0, 1
9D004B98  1444FFFE   BNE V0, A0, 0x9D004B94
9D004B9C  00031840   SLL V1, V1, 1
9D004BD4  1080FFF2   BEQ A0, ZERO, 0x9D004BA0
9D004BD8  24030001   ADDIU V1, ZERO, 1
9D004BDC  0B4012E5   J 0x9D004B94
9D004BE0  00001021   ADDU V0, ZERO, ZERO
1127:                        {
1128:                            accumulate *= 2;
1129:                        }
1130:                
1131:                        /* At this point accumulate will be either 8 or 16 or 32...4096. Check
1132:                         * specified wMaxPacketSize against this. */
1133:                
1134:                        if(wMaxPacketSize == accumulate)
9D004B88  02003021   ADDU A2, S0, ZERO
9D004BA0  12030010   BEQ S0, V1, DRV_USBHS_HOST_PipeSetup::OSAL_MUTEX_Lock
9D004BA4  0070102B   SLTU V0, V1, S0
1135:                        {
1136:                            /* This means the we dont have to do any adjustment*/
1137:                
1138:                            break;
1139:                        }
1140:                
1141:                        if((wMaxPacketSize > accumulate) &&
9D004BA8  50400008   BEQL V0, ZERO, 0x9D004BCC
9D004BAC  24840001   ADDIU A0, A0, 1
9D004BB4  00C2102B   SLTU V0, A2, V0
9D004BB8  50400004   BEQL V0, ZERO, 0x9D004BCC
9D004BBC  24840001   ADDIU A0, A0, 1
1142:                                (wMaxPacketSize < (accumulate * 2)))
9D004BB0  00031040   SLL V0, V1, 1
1143:                        {
1144:                            /* This means the wMaxPacketSize is between two valid ranges. Set
1145:                             * wMaxPacketSize to the higher range. */
1146:                
1147:                            wMaxPacketSize = accumulate * 2;
9D004BC0  00031840   SLL V1, V1, 1
1148:                            break;
9D004BC4  0B4012F9   J DRV_USBHS_HOST_PipeSetup::OSAL_MUTEX_Lock
9D004BC8  3070FFFF   ANDI S0, V1, -1
1149:                        }
1150:                    }
1151:                
1152:                    hDriver = (DRV_USBHS_OBJ *)client;
1153:                    endpoint = (endpointAndDirection & 0x7F);
9D004D2C  3262007F   ANDI V0, S3, 127
1154:                    epDirection = (endpointAndDirection & 0x80) >> 7;
9D004C54  001339C2   SRL A3, S3, 7
9D004C58  AFA7001C   SW A3, 28(SP)
1155:                
1156:                    usbID = hDriver->usbID;
1157:                
1158:                    /* There are two things that we need to check before we allocate a pipe. We
1159:                     * check if have a free pipe object and check if we have a free endpoint
1160:                     * that we can use */
1161:                
1162:                    /* All control transfer pipe are grouped together as a linked list of pipes.
1163:                     * Non control transfer pipes are organized individually */
1164:                
1165:                    /* We start by searching for a free pipe */
1166:                
1167:                    //OSAL - mutex lock */
1168:                    if(OSAL_MUTEX_Lock(&hDriver->mutexID, OSAL_WAIT_FOREVER) !=
1169:                                OSAL_RESULT_TRUE)
1170:                    {
1171:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex lock failed");
1172:                    }
1173:                
1174:                    for(pipeIter = 0; pipeIter < DRV_USBHS_HOST_PIPES_NUMBER; pipeIter ++)
9D004C0C  24020001   ADDIU V0, ZERO, 1
9D004C10  2405000A   ADDIU A1, ZERO, 10
9D004C28  00001021   ADDU V0, ZERO, ZERO
9D005044  1445FEF3   BNE V0, A1, 0x9D004C14
9D005048  24630034   ADDIU V1, V1, 52
1175:                    {
1176:                        if(gDrvUSBHostPipeObj[pipeIter].inUse == false)
9D004BF8  3C028000   LUI V0, -32768
9D004BFC  904205C4   LBU V0, 1476(V0)
9D004C00  10400009   BEQ V0, ZERO, 0x9D004C28
9D004C04  3C038000   LUI V1, -32768
9D004C08  246305F8   ADDIU V1, V1, 1528
9D004C14  90640000   LBU A0, 0(V1)
9D004C18  5480010A   BNEL A0, ZERO, 0x9D005044
9D004C1C  24420001   ADDIU V0, V0, 1
1177:                        {
1178:                            /* This means we have found a free pipe object */
1179:                
1180:                            pipe = &gDrvUSBHostPipeObj[pipeIter];
9D004C20  0B40130C   J 0x9D004C30
9D004C24  00021880   SLL V1, V0, 2
9D004C2C  00021880   SLL V1, V0, 2
9D004C30  00022100   SLL A0, V0, 4
9D004C34  00831823   SUBU V1, A0, V1
9D004C38  00621021   ADDU V0, V1, V0
9D004C3C  00021080   SLL V0, V0, 2
9D004C40  3C1E8000   LUI S8, -32768
9D004C44  27DE05C4   ADDIU S8, S8, 1476
1181:                
1182:                            if(pipeType != USB_TRANSFER_TYPE_CONTROL)
9D004C48  8FA6005C   LW A2, 92(SP)
9D004C4C  10C000D7   BEQ A2, ZERO, 0x9D004FAC
9D004C50  03C2F021   ADDU S8, S8, V0
1183:                            {
1184:                                /* For non control transfer we need a free
1185:                                 * non zero endpoint object. */
1186:                
1187:                                epFound = false;
1188:                                for(epIter = 1; 
9D004C84  24050008   ADDIU A1, ZERO, 8
9D004C88  304400FF   ANDI A0, V0, 255
9D004C8C  AFA40010   SW A0, 16(SP)
9D004F64  1445FF48   BNE V0, A1, 0x9D004C88
9D004F68  24630010   ADDIU V1, V1, 16
9D004F6C  0B401417   J DRV_USBHS_HOST_PipeSetup::OSAL_MUTEX_Unlock
9D004F70  24020001   ADDIU V0, ZERO, 1
9D004F74  00031100   SLL V0, V1, 4
9D004F78  02E2B821   ADDU S7, S7, V0
1189:                                        epIter < DRV_USBHS_HOST_MAXIMUM_ENDPOINTS_NUMBER;
1190:                                        epIter ++)
1191:                                {
1192:                                    if(hDriver->hostEndpointTable[epIter]
9D004C68  90420004   LBU V0, 4(V0)
9D004C6C  1040000E   BEQ V0, ZERO, 0x9D004CA8
9D004C70  24E30012   ADDIU V1, A3, 18
9D004C74  000318C0   SLL V1, V1, 3
9D004C78  02231821   ADDU V1, S1, V1
9D004C7C  24630004   ADDIU V1, V1, 4
9D004C80  24020002   ADDIU V0, ZERO, 2
9D004C94  90640000   LBU A0, 0(V1)
9D004C98  548000B2   BNEL A0, ZERO, 0x9D004F64
9D004C9C  24420001   ADDIU V0, V0, 1
9D004CA0  0B40132F   J 0x9D004CBC
9D004CA4  8FA30014   LW V1, 20(SP)
9D004CB0  24070001   ADDIU A3, ZERO, 1
9D004CB4  AFA70010   SW A3, 16(SP)
9D004CB8  8FA30014   LW V1, 20(SP)
9D004CBC  00031040   SLL V0, V1, 1
9D004CC0  8FA4001C   LW A0, 28(SP)
9D004CC4  00821021   ADDU V0, A0, V0
9D004CC8  000210C0   SLL V0, V0, 3
9D004CCC  02221021   ADDU V0, S1, V0
1193:                                            .endpoints[epDirection].inUse == false)
9D004C5C  24E20010   ADDIU V0, A3, 16
9D004C60  000210C0   SLL V0, V0, 3
9D004C64  02221021   ADDU V0, S1, V0
9D004C90  AFA20014   SW V0, 20(SP)
9D004CA8  24060001   ADDIU A2, ZERO, 1
9D004CAC  AFA60014   SW A2, 20(SP)
1194:                                    {
1195:                                        /* This means we have found an endpoint. Capture this
1196:                                         * endpoint and indicate that we have found an endpoint
1197:                                         * */
1198:                
1199:                                        epFound = true;
1200:                                        hDriver->hostEndpointTable[epIter].endpoints[epDirection].inUse = true;
9D004CD0  24030001   ADDIU V1, ZERO, 1
9D004CD4  A0430074   SB V1, 116(V0)
1201:                                        hDriver->hostEndpointTable[epIter].endpoints[epDirection].pipe = pipe;
9D004CD8  AC5E0078   SW S8, 120(V0)
1202:                
1203:                                        /* The following code maps the endpoint size to the
1204:                                         * value that should be loaded in the FIFOSZ register */
1205:                
1206:                                        fifoSize = 0;
9D004CE8  AFA00018   SW ZERO, 24(SP)
9D004D0C  AFA00018   SW ZERO, 24(SP)
1207:                                        shiftWord = wMaxPacketSize;
1208:                
1209:                                        while((shiftWord & 0x1) != 1)
9D004CDC  32030001   ANDI V1, S0, 1
9D004CE0  1460000A   BNE V1, ZERO, 0x9D004D0C
9D004CE4  02001021   ADDU V0, S0, ZERO
9D004CF8  30430001   ANDI V1, V0, 1
9D004CFC  1060FFFB   BEQ V1, ZERO, 0x9D004CEC
9D004D00  AFA60018   SW A2, 24(SP)
9D004D04  0B401345   J 0x9D004D14
9D004D08  02202021   ADDU A0, S1, ZERO
1210:                                        {
1211:                                            shiftWord = (shiftWord >> 1);
9D004CEC  00021042   SRL V0, V0, 1
1212:                                            fifoSize ++;
9D004CF0  8FA60018   LW A2, 24(SP)
9D004CF4  24C60001   ADDIU A2, A2, 1
1213:                                        }
1214:                                        fifoSize -= 3;
9D004D30  8FA70018   LW A3, 24(SP)
1215:                
1216:                                        if(_DRV_USBHS_HOST_FifoTableAllocate(hDriver,pipe,wMaxPacketSize)
9D004D10  02202021   ADDU A0, S1, ZERO
9D004D14  03C02821   ADDU A1, S8, ZERO
9D004D18  0F402B2F   JAL _DRV_USBHS_HOST_FifoTableAllocate
9D004D1C  02003021   ADDU A2, S0, ZERO
9D004D20  2404FFFF   ADDIU A0, ZERO, -1
9D004D24  104400CF   BEQ V0, A0, 0x9D005064
9D004D28  2403FFFF   ADDIU V1, ZERO, -1
1217:                                                    == DRV_USBHS_HOST_PIPE_HANDLE_INVALID)
1218:                                        {
1219:                                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Could not obtain FIFO");
1220:                                            return DRV_USBHS_HOST_PIPE_HANDLE_INVALID;
1221:                                        }
1222:                                        if(USB_DATA_DIRECTION_DEVICE_TO_HOST == epDirection)
9D004D34  8FA3001C   LW V1, 28(SP)
9D004D38  10600044   BEQ V1, ZERO, 0x9D004E4C
9D004D3C  24E4FFFD   ADDIU A0, A3, -3
9D004D40  97C60004   LHU A2, 4(S8)
1223:                                        {
1224:                                            /* This means host is receiving data. We need to
1225:                                             * setup all receive related registers. Setup the
1226:                                             * maximum packet size, fifo size, fifo start
1227:                                             * address,  target function address, rx type
1228:                                             * register, hub address and hub port  */
1229:                
1230:                                            PLIB_USBHS_HostRxEndpointConfigure
1231:                                            (
1232:                                                usbID,          /* USB Module ID */
1233:                                                epIter,         /* Host Endpoint */
1234:                                                speed,          /* Endpoint speed */
1235:                                                pipeType,       /* Pipe Type */
1236:                                                wMaxPacketSize, /* Endpoint Size */
1237:                                                pipe->startingOffset,/* FIFO Address */
1238:                                                fifoSize,       /* FIFO size */
1239:                                                endpoint,       /* Target Endpoint */
1240:                                                deviceAddress,  /* Target Address */
1241:                                                hubAddress,     /* Target Hub Address */
1242:                                                hubPort,        /* Target Hub Port */
1243:                                                bInterval       /* NAK or period interval */
1244:                                            );
1245:                                            /* Clear the Data toggle */
1246:                                            PLIB_USBHS_HostRxEndpointDataToggleClear(usbID, epIter);
1247:                                        }
1248:                                        else
1249:                                        {
1250:                                            /* This means data flows host to device. We must
1251:                                             * setup TX registers */
1252:                
1253:                                            PLIB_USBHS_HostTxEndpointConfigure
1254:                                            (
1255:                                                usbID,              /* USB Module ID */
1256:                                                epIter,             /* Host Endpoint */
1257:                                                speed,              /* Endpoint speed */
1258:                                                pipeType,           /* Pipe Type */
1259:                                                wMaxPacketSize,     /* Endpoint Size */
1260:                                                pipe->startingOffset,/* FIFO Address */
1261:                                                fifoSize,       /* FIFO size */
1262:                                                endpoint,       /* Target Endpoint */
1263:                                                deviceAddress,  /* Target Address */
1264:                                                hubAddress,     /* Target Hub Address */
1265:                                                hubPort,        /* Target Hub Port */
1266:                                                bInterval       /* NAK or period interval */
1267:                                            );
1268:                                            /* Clear the Data toggle */
1269:                                            PLIB_USBHS_HostTxEndpointDataToggleClear(usbID, epIter);
1270:                                        }
1271:                                        break;
1272:                                    }
1273:                                } /* End of search for host endpoint */
1274:                
1275:                                if(!epFound)
1276:                                {
1277:                                    /* This means we could not find a spare endpoint for this
1278:                                     * non control transfer. */
1279:                
1280:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Could not allocate endpoint");
1281:                                    //OSAL mutex unlock
1282:                                    if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
1283:                                    {
1284:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
1285:                                    }
1286:                                    return DRV_USBHS_HOST_PIPE_HANDLE_INVALID;
9D005060  2403FFFF   ADDIU V1, ZERO, -1
1287:                                }
1288:                                else
1289:                                {
1290:                                    /* Clear all the previous error condition that may be there
1291:                                     from the last device connect */
1292:                                    if(USB_DATA_DIRECTION_HOST_TO_DEVICE == epDirection)
9D004F50  8FA7001C   LW A3, 28(SP)
9D004F54  50E00007   BEQL A3, ZERO, 0x9D004F74
9D004F58  8FA30010   LW V1, 16(SP)
9D004F5C  0B4013E4   J 0x9D004F90
9D004F60  8FA40010   LW A0, 16(SP)
1293:                                    {
1294:                                        PLIB_USBHS_TxEPStatusClear(usbID, epIter,
1295:                                                USBHS_TXEP_ERROR_ALL);
1296:                                    }
1297:                                    else
1298:                                    {
1299:                                        PLIB_USBHS_RxEPStatusClear(usbID, epIter, 
1300:                                                USBHS_RXEP_ERROR_ALL);
1301:                                    }
1302:                                }
1303:                                
1304:                            } /* End of non zero endpoint handling */
1305:                            else
1306:                            {
1307:                                /* Set epIter to zero to indicate that we must use endpoint 0
1308:                                 * for control transfers. We also add the control transfer pipe
1309:                                 * to the control transfer group. */
1310:                
1311:                                epIter = 0;
9D004FF0  AFA00010   SW ZERO, 16(SP)
1312:                
1313:                                transferGroup = &hDriver->controlTransferGroup;
1314:                
1315:                                if(transferGroup->pipe == NULL)
9D004FAC  8E230100   LW V1, 256(S1)
9D004FB0  54600006   BNEL V1, ZERO, 0x9D004FCC
9D004FB4  8C620020   LW V0, 32(V1)
1316:                                {
1317:                                    /* This if the first pipe to be setup */
1318:                
1319:                                    transferGroup->pipe = pipe;
9D004FB8  AE3E0100   SW S8, 256(S1)
1320:                                    transferGroup->currentPipe = pipe;
9D004FBC  AE3E0104   SW S8, 260(S1)
9D004FC0  0B4013F8   J 0x9D004FE0
9D004FC4  AFC00024   SW ZERO, 36(S8)
1321:                                    pipe->previous = NULL;
1322:                                }
1323:                                else
1324:                                {
1325:                                    /* This is not the first pipe. Find the last pipe in the
1326:                                     * linked list */
1327:                
1328:                                    iteratorPipe = transferGroup->pipe;
1329:                                    while(iteratorPipe->next != NULL)
9D004FC8  8C620020   LW V0, 32(V1)
9D004FCC  50400003   BEQL V0, ZERO, 0x9D004FDC
9D004FD0  AC7E0020   SW S8, 32(V1)
1330:                                    {
1331:                                        /* This is not the last pipe in this transfer group */
1332:                                        iteratorPipe = iteratorPipe->next;
9D004FD4  0B4013F2   J 0x9D004FC8
9D004FD8  00401821   ADDU V1, V0, ZERO
1333:                                    }
1334:                                    iteratorPipe->next = pipe;
1335:                                    pipe->previous = iteratorPipe;
9D004FDC  AFC30024   SW V1, 36(S8)
1336:                                }
1337:                                pipe->next = NULL;
9D004FE0  AFC00020   SW ZERO, 32(S8)
1338:                
1339:                                /* Update the pipe count in the transfer group */
1340:                
1341:                                transferGroup->nPipes ++;
9D004FE4  8E22010C   LW V0, 268(S1)
9D004FE8  24420001   ADDIU V0, V0, 1
9D004FEC  AE22010C   SW V0, 268(S1)
1342:                
1343:                            }
1344:                
1345:                            /* Setup the pipe object */
1346:                            pipe->inUse         = true;
9D004F88  0B4013FE   J 0x9D004FF8
9D004F8C  24020001   ADDIU V0, ZERO, 1
9D004F90  00041100   SLL V0, A0, 4
9D004F94  02E2B821   ADDU S7, S7, V0
9D004FA4  0B4013FE   J 0x9D004FF8
9D004FA8  24020001   ADDIU V0, ZERO, 1
9D004FF4  24020001   ADDIU V0, ZERO, 1
9D004FF8  A3C20000   SB V0, 0(S8)
1347:                            pipe->deviceAddress = deviceAddress;
9D004FFC  A3D60001   SB S6, 1(S8)
1348:                            pipe->irpQueueHead  = NULL;
9D005000  AFC00014   SW ZERO, 20(S8)
1349:                            pipe->bInterval     = bInterval;
9D005004  A3D20002   SB S2, 2(S8)
1350:                            pipe->speed         = speed;
9D005008  8FA60068   LW A2, 104(SP)
9D00500C  AFC6002C   SW A2, 44(S8)
1351:                            pipe->hubAddress    = hubAddress;
9D005010  A3D50030   SB S5, 48(S8)
1352:                            pipe->hubPort       = hubPort;
9D005014  A3D40031   SB S4, 49(S8)
1353:                            pipe->pipeType      = pipeType;
9D005018  8FA7005C   LW A3, 92(SP)
9D00501C  AFC70010   SW A3, 16(S8)
1354:                            pipe->hClient       = client;
9D005020  AFD10008   SW S1, 8(S8)
1355:                            pipe->endpointSize  = wMaxPacketSize;
9D005024  AFD0001C   SW S0, 28(S8)
1356:                            pipe->intervalCounter = bInterval;
9D005028  A3D20028   SB S2, 40(S8)
1357:                            pipe->hostEndpoint  = epIter;
9D00502C  8FA30010   LW V1, 16(SP)
9D005030  A3C30032   SB V1, 50(S8)
1358:                            pipe->endpointAndDirection   = endpointAndDirection;
9D005034  A3D3000C   SB S3, 12(S8)
1359:                
1360:                            // OSAL release mutex
1361:                            if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
1362:                            {
1363:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
1364:                            }
1365:                            return((DRV_USBHS_HOST_PIPE_HANDLE)pipe);
9D00503C  0B401419   J 0x9D005064
9D005040  03C01821   ADDU V1, S8, ZERO
1366:                        }
1367:                    }
1368:                
1369:                    /* This means that we could not find a free pipe object */
1370:                    //OSAL mutex release
1371:                    if(OSAL_MUTEX_Unlock(&hDriver->mutexID) != OSAL_RESULT_TRUE)
1372:                    {
1373:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Mutex unlock failed");
1374:                    }
1375:                    return(DRV_USBHS_HOST_PIPE_HANDLE_INVALID);
9D005054  0B401419   J 0x9D005064
9D005058  2403FFFF   ADDIU V1, ZERO, -1
1376:                }/* end of DRV_USBHS_HOST_PipeSetup() */
9D005064  00601021   ADDU V0, V1, ZERO
1377:                
1378:                void _DRV_USBHS_HOST_ControlTransferProcess(DRV_USBHS_OBJ * hDriver)
1379:                {
9D008208  27BDFFD0   ADDIU SP, SP, -48
9D00820C  AFBF002C   SW RA, 44(SP)
9D008210  AFB30028   SW S3, 40(SP)
9D008214  AFB20024   SW S2, 36(SP)
9D008218  AFB10020   SW S1, 32(SP)
9D00821C  AFB0001C   SW S0, 28(SP)
9D008220  00808021   ADDU S0, A0, ZERO
1380:                    /* This function is called every time there is an endpoint 0
1381:                     interrupt. This means that a stage of the current control IRP has been
1382:                     completed. This function is called from an interrupt context */
1383:                
1384:                    uint8_t status;
1385:                    USB_HOST_IRP_LOCAL * irp;
1386:                    DRV_USBHS_HOST_PIPE_OBJ * pipe, * iterPipe;
1387:                    DRV_USBHS_HOST_TRANSFER_GROUP * transferGroup;
1388:                    bool endIRP = false;
1389:                    unsigned int count, i;
1390:                    bool foundIRP = false;
1391:                    bool isDmaUsed = false;
9D008224  A3A00010   SB ZERO, 16(SP)
1392:                    USBHS_MODULE_ID usbID;
1393:                
1394:                    transferGroup = &hDriver->controlTransferGroup;
1395:                    usbID = hDriver->usbID;
9D008228  8C92005C   LW S2, 92(A0)
1396:                
1397:                    /* First check if the IRP was aborted */
1398:                    irp = transferGroup->currentIRP;
9D00822C  8C910108   LW S1, 264(A0)
1399:                    pipe = transferGroup->currentPipe;
1400:                
1401:                    /* If current IRP is null, or current pipe is null then we have unknow
1402:                     * failure. We just quit.  Nothing we can do.*/
1403:                
1404:                    if((irp == NULL) || (pipe == NULL) ||
9D008230  122000C8   BEQ S1, ZERO, 0x9D008554
9D008234  8C930104   LW S3, 260(A0)
9D008238  126000C6   BEQ S3, ZERO, 0x9D008554
9D00823C  2402FFFF   ADDIU V0, ZERO, -1
9D008240  526200C5   BEQL S3, V0, 0x9D008558
9D008244  8FBF002C   LW RA, 44(SP)
1405:                            (pipe == (DRV_USBHS_HOST_PIPE_OBJ *)DRV_USBHS_HOST_PIPE_HANDLE_INVALID))
1406:                    {
1407:                        /* Unknown error */
1408:                        return;
1409:                    }
1410:                
1411:                    /* If here means, we have a valid IRP and pipe.  Check the status register.
1412:                     * The IRP could have been aborted. This would be known in the temp state.
1413:                     * */
1414:                
1415:                    status = PLIB_USBHS_EP0StatusGet(usbID);
1416:                    if(irp->tempState == DRV_USBHS_HOST_IRP_STATE_ABORTED)
9D00824C  8E23001C   LW V1, 28(S1)
9D008250  24040007   ADDIU A0, ZERO, 7
9D008254  14640014   BNE V1, A0, 0x9D0082A8
9D008258  304200FF   ANDI V0, V0, 255
1417:                    {
1418:                        /* This means the application has aborted this
1419:                         IRP.*/
1420:                
1421:                        endIRP = true;
1422:                        irp->status = USB_HOST_IRP_STATUS_ABORTED;
9D00825C  2402FFFB   ADDIU V0, ZERO, -5
9D008260  AE22000C   SW V0, 12(S1)
1423:                
1424:                        /* Clear up the error status and we must also flush the fifo */
1425:                
1426:                        PLIB_USBHS_EP0StatusClear(usbID, USBHS_EP0_ERROR_ALL);
1427:                        PLIB_USBHS_Endpoint0FIFOFlush(usbID);
1428:                    }
1429:                    else if(status & USBHS_EP0_ERROR_RXSTALL)
9D0082A8  30440004   ANDI A0, V0, 4
9D0082AC  308400FF   ANDI A0, A0, 255
9D0082B0  10800008   BEQ A0, ZERO, 0x9D0082D4
9D0082B4  7C022420   SEB A0, V0
1430:                    {
1431:                        /* This means the packet was stalled. Set the error status and then
1432:                         * clear the stall bit */
1433:                
1434:                        endIRP = true;
1435:                        irp->status = USB_HOST_IRP_STATUS_ERROR_STALL;
9D0082B8  2402FFFF   ADDIU V0, ZERO, -1
9D0082BC  AE22000C   SW V0, 12(S1)
1436:                        PLIB_USBHS_EP0StatusClear(usbID, USBHS_EP0_ERROR_RXSTALL);
1437:                    }
1438:                    else if(status & USBHS_EP0_ERROR_NAK_TIMEOUT)
9D0082D4  04830008   BGEZL A0, 0x9D0082F8
9D0082D8  30420010   ANDI V0, V0, 16
1439:                    {
1440:                        /* This means a NAK Time Out has occurred. Clear the error status.  */
1441:                
1442:                        endIRP = true;
1443:                        irp->status = USB_HOST_IRP_STATUS_ERROR_NAK_TIMEOUT;
9D0082DC  2402FFFE   ADDIU V0, ZERO, -2
9D0082E0  AE22000C   SW V0, 12(S1)
1444:                        PLIB_USBHS_EP0StatusClear(usbID, USBHS_EP0_ERROR_NAK_TIMEOUT);
1445:                    }
1446:                    else if(status & USBHS_EP0_ERROR_BUS)
9D0082F8  304200FF   ANDI V0, V0, 255
9D0082FC  50400008   BEQL V0, ZERO, 0x9D008320
9D008300  24020003   ADDIU V0, ZERO, 3
1447:                    {
1448:                        /* This means there was an bus error. The packet was tried three times
1449:                         * and was not successfully processed */
1450:                
1451:                        endIRP = true;
1452:                        irp->status = USB_HOST_IRP_STATUS_ERROR_DATA;
9D008304  2402FFFD   ADDIU V0, ZERO, -3
9D008308  AE22000C   SW V0, 12(S1)
1453:                        PLIB_USBHS_EP0StatusClear(usbID, USBHS_EP0_ERROR_BUS);
1454:                    }
1455:                    else
1456:                    {
1457:                        /* This means there was no error. We should check the current state of
1458:                         * the IRP and then proceed accordingly */
1459:                
1460:                       switch(irp->tempState)
9D008320  10620021   BEQ V1, V0, 0x9D0083A8
9D008324  24020005   ADDIU V0, ZERO, 5
9D008328  5062004B   BEQL V1, V0, 0x9D008458
9D00832C  AE20000C   SW ZERO, 12(S1)
9D008330  14600089   BNE V1, ZERO, 0x9D008558
9D008334  8FBF002C   LW RA, 44(SP)
1461:                       {
1462:                           case DRV_USBHS_HOST_IRP_STATE_SETUP_STAGE:
1463:                
1464:                               /* We got an interrupt after this stage. This means that the
1465:                                * setup stage has completed.  We need to check if a data stage
1466:                                * is required and then start the data stage. */
1467:                
1468:                               if((irp->data == NULL) || (irp->size == 0))
9D008338  8E220004   LW V0, 4(S1)
9D00833C  10400005   BEQ V0, ZERO, 0x9D008354
9D008340  24020005   ADDIU V0, ZERO, 5
9D008344  8E220008   LW V0, 8(S1)
9D008348  14400007   BNE V0, ZERO, 0x9D008368
9D00834C  24020003   ADDIU V0, ZERO, 3
1469:                               {
1470:                                   /* This means there is no data stage. We can proceed to the
1471:                                    * handshake stage. In a case where there isnt a data stage,
1472:                                    * we need to send an IN token to the device to the device */
1473:                
1474:                                   irp->tempState = DRV_USBHS_HOST_IRP_STATE_HANDSHAKE_SENT;
9D008350  24020005   ADDIU V0, ZERO, 5
9D008354  AE22001C   SW V0, 28(S1)
1475:                                   PLIB_USBHS_EP0INHandshakeSend(usbID);
1476:                               }
1477:                               else
1478:                               {
1479:                                   /* This means that a data stage is required. We can find out
1480:                                    * the direction of the data stage by investigating the flags
1481:                                    * parameter of the  IRP. */
1482:                
1483:                                   irp->tempState = DRV_USBHS_HOST_IRP_STATE_DATA_STAGE_SENT;
9D008368  AE22001C   SW V0, 28(S1)
1484:                                   if(irp->flags & 0x8000)
9D00836C  8E220010   LW V0, 16(S1)
9D008370  30428000   ANDI V0, V0, -32768
9D008374  10400007   BEQ V0, ZERO, 0x9D008394
9D008378  02402021   ADDU A0, S2, ZERO
1485:                
1486:                                   {
1487:                                       /* This means the data stage moves from device to host.
1488:                                        * So the host would have to send an IN token.  */
1489:                
1490:                                       PLIB_USBHS_EP0INTokenSend(usbID);
1491:                                   }
1492:                                   else
1493:                                   {
1494:                                       /* This function loads the fifo and sends the packet. The
1495:                                        * completed bytes field in the IRP will be updated. */
1496:                
1497:                                       _DRV_USBHS_HOST_IRPTransmitFIFOLoad(usbID, irp, 0);
9D008394  02202821   ADDU A1, S1, ZERO
9D008398  0F4039EC   JAL _DRV_USBHS_HOST_IRPTransmitFIFOLoad
9D00839C  00003021   ADDU A2, ZERO, ZERO
1498:                                   }
1499:                               }
1500:                               break;
1501:                
1502:                           case DRV_USBHS_HOST_IRP_STATE_DATA_STAGE_SENT:
1503:                
1504:                               /* We reach here after an interrupt which means that a data stage
1505:                                * interaction was completed. Find out what was the direction the
1506:                                * data stage */
1507:                
1508:                               if(irp->flags & 0x8000)
9D0083A8  8E220010   LW V0, 16(S1)
9D0083AC  30428000   ANDI V0, V0, -32768
9D0083B0  5040001A   BEQL V0, ZERO, 0x9D00841C
9D0083B4  8E230020   LW V1, 32(S1)
1509:                               {
1510:                                   /* This means the data was moving from device to host. We got
1511:                                    * an interrupt, which means we have received data. Start by
1512:                                    * checking how much data we received from the device */
1513:                
1514:                                   count = _DRV_USBHS_HOST_IRPReceiveFIFOUnload(usbID, irp, 0,
9D0083B8  02402021   ADDU A0, S2, ZERO
9D0083BC  02202821   ADDU A1, S1, ZERO
9D0083C0  00003021   ADDU A2, ZERO, ZERO
9D0083C4  0F4034A0   JAL _DRV_USBHS_HOST_IRPReceiveFIFOUnload
9D0083C8  27A70010   ADDIU A3, SP, 16
1515:                                           &isDmaUsed);
1516:                
1517:                                   if((count < pipe->endpointSize) ||
9D0083CC  8E63001C   LW V1, 28(S3)
9D0083D0  0043102B   SLTU V0, V0, V1
9D0083D4  14400006   BNE V0, ZERO, 0x9D0083F0
9D0083D8  24020005   ADDIU V0, ZERO, 5
9D0083DC  8E230020   LW V1, 32(S1)
9D0083E0  8E220008   LW V0, 8(S1)
9D0083E4  0062102B   SLTU V0, V1, V0
9D0083E8  14400006   BNE V0, ZERO, _DRV_USBHS_HOST_ControlTransferProcess::PLIB_USBHS_EP0INTokenSend
9D0083EC  24020005   ADDIU V0, ZERO, 5
1518:                                           (irp->completedBytes >= irp->size))
1519:                                   {
1520:                                       /* This means that we either received a short packet or
1521:                                        * we received the amount of data that we needed. We
1522:                                        * should move to the handshake stage. Send the  */
1523:                
1524:                                       irp->tempState = DRV_USBHS_HOST_IRP_STATE_HANDSHAKE_SENT;
9D0083F0  AE22001C   SW V0, 28(S1)
1525:                                       PLIB_USBHS_EP0OUTHandshakeSend(usbID);
1526:                
1527:                                   }
1528:                                   else
1529:                                   {
1530:                                       /* This means this is a multi stage control read
1531:                                        * transfer. Issue another IN token */
1532:                
1533:                                       PLIB_USBHS_EP0INTokenSend(usbID);
1534:                                       break;
1535:                                   }
1536:                               }
1537:                               else
1538:                               {
1539:                                   /* Data stage was moving from host to device.  Check if we
1540:                                    * need to send more data */
1541:                
1542:                                   if(irp->completedBytes < irp->size)
9D00841C  8E220008   LW V0, 8(S1)
9D008420  0062102B   SLTU V0, V1, V0
9D008424  10400007   BEQ V0, ZERO, 0x9D008444
9D008428  24020005   ADDIU V0, ZERO, 5
1543:                                   {
1544:                                       _DRV_USBHS_HOST_IRPTransmitFIFOLoad(usbID, irp, 0);
9D00842C  02402021   ADDU A0, S2, ZERO
9D008430  02202821   ADDU A1, S1, ZERO
9D008434  0F4039EC   JAL _DRV_USBHS_HOST_IRPTransmitFIFOLoad
9D008438  00003021   ADDU A2, ZERO, ZERO
9D00843C  0B402156   J 0x9D008558
9D008440  8FBF002C   LW RA, 44(SP)
1545:                                   }
1546:                                   else
1547:                                   {
1548:                                       /* We can move to the status stage */
1549:                                       irp->tempState = DRV_USBHS_HOST_IRP_STATE_HANDSHAKE_SENT;
9D008444  AE22001C   SW V0, 28(S1)
1550:                                       PLIB_USBHS_EP0INHandshakeSend(usbID);
1551:                                   }
1552:                               }
1553:                               break;
1554:                
1555:                           case DRV_USBHS_HOST_IRP_STATE_HANDSHAKE_SENT:
1556:                
1557:                               /* If we have reached here, it means that status stage has
1558:                                * completed. Check the direction of the data stage, update the
1559:                                * irp status flag and then end the irp. */
1560:                
1561:                               irp->status = USB_HOST_IRP_STATUS_COMPLETED;
1562:                               
1563:                               if(irp->flags & 0x8000)
9D008458  8E220010   LW V0, 16(S1)
9D00845C  30428000   ANDI V0, V0, -32768
9D008460  1040000A   BEQ V0, ZERO, _DRV_USBHS_HOST_ControlTransferProcess::PLIB_USBHS_EP0INHandshakeClear
9D008464  00000000   NOP
1564:                               {
1565:                                   /* This means the data stage moved from device to host. We
1566:                                    * need to check the number of bytes the host sent. If it was
1567:                                    * less than expected, then irp status should say so */
1568:                
1569:                                   if(irp->completedBytes < irp->size)
9D008468  8E220020   LW V0, 32(S1)
9D00846C  8E230008   LW V1, 8(S1)
9D008470  0043182B   SLTU V1, V0, V1
9D008474  50600031   BEQL V1, ZERO, 0x9D00853C
9D008478  8E220018   LW V0, 24(S1)
1570:                                   {
1571:                                       irp->size = irp->completedBytes;
9D00847C  AE220008   SW V0, 8(S1)
1572:                                       irp->status = USB_HOST_IRP_STATUS_COMPLETED_SHORT;
9D008480  24020001   ADDIU V0, ZERO, 1
9D008484  0B40214E   J 0x9D008538
9D008488  AE22000C   SW V0, 12(S1)
1573:                                   }
1574:                               }
1575:                               else
1576:                               {
1577:                                   /* We need to clear the Status Pakcet bit and
1578:                                    the Rx packet ready bit */
1579:                                   PLIB_USBHS_EP0INHandshakeClear(usbID);
1580:                               }
1581:                               endIRP = true;
1582:                               break;
1583:                
1584:                           default:
1585:                               break;
1586:                       }
1587:                    }
1588:                
1589:                    if(endIRP)
1590:                    {
1591:                        /* This means this IRP needs to be terminated and new one started. */
1592:                
1593:                        if(irp->callback != NULL)
9D0082A0  0B40214F   J 0x9D00853C
9D0082A4  8E220018   LW V0, 24(S1)
9D0082CC  0B40214F   J 0x9D00853C
9D0082D0  8E220018   LW V0, 24(S1)
9D0082F0  0B40214F   J 0x9D00853C
9D0082F4  8E220018   LW V0, 24(S1)
9D008318  0B40214F   J 0x9D00853C
9D00831C  8E220018   LW V0, 24(S1)
9D008498  0B40214F   J 0x9D00853C
9D00849C  8E220018   LW V0, 24(S1)
9D008538  8E220018   LW V0, 24(S1)
9D00853C  1440FFD8   BNE V0, ZERO, 0x9D0084A0
9D008540  00000000   NOP
9D008544  0B40212B   J 0x9D0084AC
9D008548  8E220024   LW V0, 36(S1)
1594:                        {
1595:                            irp->callback((USB_HOST_IRP *)irp);
9D0084A0  0040F809   JALR V0
9D0084A4  02202021   ADDU A0, S1, ZERO
1596:                        }
1597:                
1598:                        /* Expire the IRP */
1599:                
1600:                        pipe->irpQueueHead = irp->next;
9D0084A8  8E220024   LW V0, 36(S1)
9D0084AC  AE620014   SW V0, 20(S3)
1601:                
1602:                        /* Now we need to check if any more IRPs are in this group are pending.
1603:                         * We start searching from the current pipe onwards. If we dont find
1604:                         * another pipe with an IRP, we should land back on the current pipe and
1605:                         * check if we have a IRP to process */
1606:                
1607:                        iterPipe = transferGroup->currentPipe->next;
9D0084B0  8E020104   LW V0, 260(S0)
1608:                        for(i = 0; i < transferGroup->nPipes; i ++)
9D0084B4  8E06010C   LW A2, 268(S0)
9D0084B8  10C00024   BEQ A2, ZERO, 0x9D00854C
9D0084BC  8C420020   LW V0, 32(V0)
9D0084C0  00001821   ADDU V1, ZERO, ZERO
9D008508  1466FFEE   BNE V1, A2, 0x9D0084C4
9D00850C  8C420020   LW V0, 32(V0)
9D008510  0B402154   J 0x9D008550
9D008514  AE000104   SW ZERO, 260(S0)
9D008518  0B40214A   J 0x9D008528
9D00851C  ACA20010   SW V0, 16(A1)
1609:                        {
1610:                            if(iterPipe == NULL)
9D0084C4  50400001   BEQL V0, ZERO, 0x9D0084CC
9D0084C8  8E020100   LW V0, 256(S0)
1611:                            {
1612:                                /* We have reached the end of the pipe group. Rewind the pipe
1613:                                 * iterator to the start of the pipe group. */
1614:                
1615:                                iterPipe = transferGroup->pipe;
1616:                            }
1617:                
1618:                            /* This means that we have a valid pipe.  Now check if there is irp
1619:                             * to be processed. */
1620:                
1621:                            if(iterPipe->irpQueueHead != NULL)
9D0084CC  8C450014   LW A1, 20(V0)
9D0084D0  10A0000D   BEQ A1, ZERO, 0x9D008508
9D0084D4  24630001   ADDIU V1, V1, 1
1622:                            {
1623:                                foundIRP = true;
1624:                                transferGroup->currentPipe = iterPipe;
9D0084D8  AE020104   SW V0, 260(S0)
1625:                                transferGroup->currentIRP = iterPipe->irpQueueHead;
9D0084DC  8C450014   LW A1, 20(V0)
9D0084E0  AE050108   SW A1, 264(S0)
1626:                                break;
1627:                            }
1628:                
1629:                            iterPipe = iterPipe->next;
1630:                        }
1631:                
1632:                        if(foundIRP)
1633:                        {
1634:                            /* This means we have found another IRP to process. We must load the
1635:                             * endpoint. */
1636:                            
1637:                            irp = transferGroup->currentIRP;
1638:                            pipe = transferGroup->currentPipe;
1639:                            irp->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D0084E4  24020003   ADDIU V0, ZERO, 3
9D0084E8  ACA2000C   SW V0, 12(A1)
1640:                            irp->tempState = DRV_USBHS_HOST_IRP_STATE_SETUP_STAGE;
9D0084EC  ACA0001C   SW ZERO, 28(A1)
1641:                
1642:                            /* We need to update the flags parameter of the IRP to indicate the
1643:                             * direction of the control transfer. */
1644:                
1645:                            if(*((uint8_t*)(irp->setup)) & 0x80)
9D0084F0  8CA20000   LW V0, 0(A1)
9D0084F4  80420000   LB V0, 0(V0)
9D0084F8  04410009   BGEZ V0, 0x9D008520
9D0084FC  8CA20010   LW V0, 16(A1)
9D008500  0B402146   J 0x9D008518
9D008504  34428000   ORI V0, V0, -32768
1646:                            {
1647:                                /* This means the data stage moves from device to host. Set bit
1648:                                 * 15 of the flags parameter */
1649:                               irp->flags |= 0x8000;
1650:                            }
1651:                            else
1652:                            {
1653:                                /* This means the data stage moves from host to device. Clear
1654:                                 * bit 15 of the flags parameter. */
1655:                                irp->flags &= 0x7FFF;
9D008520  30427FFF   ANDI V0, V0, 32767
9D008524  ACA20010   SW V0, 16(A1)
1656:                            }
1657:                
1658:                            /* Send the setup packet to the device */
1659:                            _DRV_USBHS_HOST_IRPTransmitSetupPacket(usbID, irp);
9D008528  0F40551C   JAL _DRV_USBHS_HOST_IRPTransmitSetupPacket
9D00852C  02402021   ADDU A0, S2, ZERO
9D008530  0B402156   J 0x9D008558
9D008534  8FBF002C   LW RA, 44(SP)
1660:                        }
1661:                        else
1662:                        {
1663:                            /* This means we dont have an IRP. Set the current IRP and current
1664:                             * pipe to NULL to indicate that we dont have any active IRP */
1665:                
1666:                            transferGroup->currentPipe = NULL;
9D00854C  AE000104   SW ZERO, 260(S0)
1667:                            transferGroup->currentIRP = NULL;
9D008550  AE000108   SW ZERO, 264(S0)
1668:                        }
1669:                    }
1670:                
1671:                    return;
1672:                }/* end of _DRV_USBHS_HOST_ControlTransferProcess() */
9D008360  0B402156   J 0x9D008558
9D008364  8FBF002C   LW RA, 44(SP)
9D00838C  0B402156   J 0x9D008558
9D008390  8FBF002C   LW RA, 44(SP)
9D0083A0  0B402156   J 0x9D008558
9D0083A4  8FBF002C   LW RA, 44(SP)
9D0083FC  0B402156   J 0x9D008558
9D008400  8FBF002C   LW RA, 44(SP)
9D008414  0B402156   J 0x9D008558
9D008418  8FBF002C   LW RA, 44(SP)
9D008450  0B402156   J 0x9D008558
9D008454  8FBF002C   LW RA, 44(SP)
9D008554  8FBF002C   LW RA, 44(SP)
1673:                
1674:                void _DRV_USBHS_HOST_NonControlTransferProcess
1675:                (
1676:                    DRV_USBHS_OBJ * hDriver,
1677:                    uint8_t endpoint, 
1678:                    unsigned int direction
1679:                )
1680:                {
9D0069F0  27BDFFD0   ADDIU SP, SP, -48
9D0069F4  AFBF002C   SW RA, 44(SP)
9D0069F8  AFB30028   SW S3, 40(SP)
9D0069FC  AFB20024   SW S2, 36(SP)
9D006A00  AFB10020   SW S1, 32(SP)
9D006A04  AFB0001C   SW S0, 28(SP)
9D006A08  30B000FF   ANDI S0, A1, 255
1681:                    /* This function processes non zero endpoint transfers which
1682:                     would bulk, interrupt and isochronous transfers */
1683:                
1684:                    DRV_USBHS_HOST_ENDPOINT_OBJ * endpointTable = &(hDriver->hostEndpointTable[0]);
9D006A0C  24830074   ADDIU V1, A0, 116
1685:                    DRV_USBHS_HOST_PIPE_OBJ * pipe;
1686:                    USB_HOST_IRP_LOCAL * irp;
1687:                    uint8_t status;
1688:                    bool endIRP = false;
1689:                    bool isDmaUsed = false;
9D006A10  A3A00010   SB ZERO, 16(SP)
1690:                    unsigned int count;
1691:                    USBHS_MODULE_ID usbID;
1692:                
1693:                    endpointTable += endpoint;
9D006A14  00101100   SLL V0, S0, 4
9D006A18  00621021   ADDU V0, V1, V0
9D006A1C  000618C0   SLL V1, A2, 3
9D006A20  00431021   ADDU V0, V0, V1
1694:                    usbID = hDriver->usbID;
1695:                
1696:                    pipe = endpointTable->endpoints[direction].pipe;
9D006A24  8C510004   LW S1, 4(V0)
1697:                
1698:                    if((!endpointTable->endpoints[direction].inUse) ||
9D006A28  90420000   LBU V0, 0(V0)
9D006A2C  10400109   BEQ V0, ZERO, 0x9D006E54
9D006A30  8C92005C   LW S2, 92(A0)
9D006A34  12200107   BEQ S1, ZERO, 0x9D006E54
9D006A38  2402FFFF   ADDIU V0, ZERO, -1
1699:                       (pipe == NULL) ||
9D006A3C  52220106   BEQL S1, V0, 0x9D006E58
9D006A40  8FBF002C   LW RA, 44(SP)
1700:                       (pipe == (DRV_USBHS_HOST_PIPE_OBJ *)(DRV_USBHS_HOST_PIPE_HANDLE_INVALID)))
1701:                    {
1702:                        /* This means the pipe was closed. We dont do anything */
1703:                        return;
1704:                    }
1705:                
1706:                    irp = pipe->irpQueueHead;
1707:                
1708:                    if(USB_DATA_DIRECTION_HOST_TO_DEVICE == direction)
9D006A44  14C00059   BNE A2, ZERO, 0x9D006BAC
9D006A48  8E330014   LW S3, 20(S1)
9D006A4C  00101100   SLL V0, S0, 4
9D006A50  02421021   ADDU V0, S2, V0
1709:                    {
1710:                        /* We got an interrupt for data moving from host to to device. Check if
1711:                         * there were any transmission errors. Then check if there is any more
1712:                         * data to be sent in the IRP. If we are done, then end the IRP and
1713:                         * start a new one. */
1714:                
1715:                        status = PLIB_USBHS_TxEPStatusGet(usbID, endpoint);
1716:                        /* Check if the IRP was aborted */
1717:                        if(irp->tempState == DRV_USBHS_HOST_IRP_STATE_ABORTED)
9D006A58  8E65001C   LW A1, 28(S3)
9D006A5C  24040007   ADDIU A0, ZERO, 7
9D006A60  14A40015   BNE A1, A0, 0x9D006AB8
9D006A64  306300FF   ANDI V1, V1, 255
1718:                        {
1719:                            endIRP = true;
1720:                            irp->status = USB_HOST_IRP_STATUS_ABORTED;
9D006A68  2403FFFB   ADDIU V1, ZERO, -5
9D006A6C  AE63000C   SW V1, 12(S3)
1721:                
1722:                            /* Clear the error bits and the FIFO */
1723:                            PLIB_USBHS_TxEPStatusClear(usbID, endpoint, USBHS_TXEP_ERROR_ALL);
1724:                            PLIB_USBHS_EndpointTxFIFOFlush(usbID, endpoint);
1725:                        }
1726:                        else if(status & USBHS_TXEP_ERROR_RXSTALL)
9D006AB8  30640020   ANDI A0, V1, 32
9D006ABC  308400FF   ANDI A0, A0, 255
9D006AC0  1080000F   BEQ A0, ZERO, 0x9D006B00
9D006AC4  7C032420   SEB A0, V1
1727:                        {
1728:                            /* This means the packet was stalled. Set the error status and then
1729:                             * clear the stall bit */
1730:                
1731:                            endIRP = true;
1732:                            irp->status = USB_HOST_IRP_STATUS_ERROR_STALL;
9D006AC8  2403FFFF   ADDIU V1, ZERO, -1
9D006ACC  AE63000C   SW V1, 12(S3)
1733:                            PLIB_USBHS_TxEPStatusClear(usbID, endpoint, USBHS_TXEP_ERROR_RXSTALL);
1734:                
1735:                            /* Clear the Data toggle */
1736:                            PLIB_USBHS_HostTxEndpointDataToggleClear(usbID, endpoint);
1737:                
1738:                        }
1739:                        else if(status & USBHS_TXEP_ERROR_NAK_TIMEOUT)
9D006B00  04810008   BGEZ A0, 0x9D006B24
9D006B04  30630004   ANDI V1, V1, 4
1740:                        {
1741:                            /* This means a NAK Time Out has occurred. Clear the error status.
1742:                             * */
1743:                
1744:                            endIRP = true;
1745:                            irp->status = USB_HOST_IRP_STATUS_ERROR_NAK_TIMEOUT;
9D006B08  2403FFFE   ADDIU V1, ZERO, -2
9D006B0C  AE63000C   SW V1, 12(S3)
1746:                            PLIB_USBHS_TxEPStatusClear(usbID, endpoint, USBHS_TXEP_ERROR_NAK_TIMEOUT);
1747:                        }
1748:                        else if(status & USBHS_TXEP_ERROR_BUS)
9D006B24  306300FF   ANDI V1, V1, 255
9D006B28  50600008   BEQL V1, ZERO, 0x9D006B4C
9D006B2C  8E630020   LW V1, 32(S3)
1749:                        {
1750:                            /* This means there was an bus error. The packet was tried three
1751:                             * times and was not successfully processed */
1752:                
1753:                            endIRP = true;
1754:                            irp->status = USB_HOST_IRP_STATUS_ERROR_DATA;
9D006B30  2403FFFD   ADDIU V1, ZERO, -3
9D006B34  AE63000C   SW V1, 12(S3)
1755:                            PLIB_USBHS_TxEPStatusClear(usbID, endpoint, USBHS_TXEP_ERROR_BUS);
1756:                        }
1757:                        else
1758:                        {
1759:                            /* This means this transaction completed successfully.  We should
1760:                             * check if there are any spare bytes remaining to be sent and then
1761:                             * send it */
1762:                
1763:                            if(irp->completedBytes >= irp->size)
9D006B4C  8E620008   LW V0, 8(S3)
9D006B50  0062102B   SLTU V0, V1, V0
9D006B54  14400003   BNE V0, ZERO, 0x9D006B64
9D006B58  02402021   ADDU A0, S2, ZERO
9D006B5C  0B401B87   J 0x9D006E1C
9D006B60  AE60000C   SW ZERO, 12(S3)
1764:                            {
1765:                                endIRP = true;
1766:                                irp->status = USB_HOST_IRP_STATUS_COMPLETED;
1767:                            }
1768:                            else
1769:                            {
1770:                                /* This means we have more data to send */
1771:                                endIRP = false;
1772:                
1773:                                /* This function will load the next packet for this IRP into the
1774:                                 * endpoint FIFO and then transmit it. */
1775:                                _DRV_USBHS_HOST_IRPTransmitFIFOLoad(usbID, irp, endpoint);
9D006B64  02602821   ADDU A1, S3, ZERO
9D006B68  0F4039EC   JAL _DRV_USBHS_HOST_IRPTransmitFIFOLoad
9D006B6C  02003021   ADDU A2, S0, ZERO
1776:                            }
1777:                        }
1778:                
1779:                        if(endIRP)
1780:                        {
1781:                            /* This means we need to end the IRP */
1782:                
1783:                            pipe->irpQueueHead = irp->next;
9D006AB0  0B401B88   J 0x9D006E20
9D006AB4  8E620024   LW V0, 36(S3)
9D006AF8  0B401B88   J 0x9D006E20
9D006AFC  8E620024   LW V0, 36(S3)
9D006B1C  0B401B88   J 0x9D006E20
9D006B20  8E620024   LW V0, 36(S3)
9D006B44  0B401B88   J 0x9D006E20
9D006B48  8E620024   LW V0, 36(S3)
9D006E1C  8E620024   LW V0, 36(S3)
9D006E20  AE220014   SW V0, 20(S1)
1784:                
1785:                            if(irp->callback)
9D006E24  8E620018   LW V0, 24(S3)
9D006E28  1440FF53   BNE V0, ZERO, 0x9D006B78
9D006E2C  00000000   NOP
9D006E30  0B401AE1   J 0x9D006B84
9D006E34  8E250014   LW A1, 20(S1)
1786:                            {
1787:                                /* Invoke the call back*/
1788:                                irp->callback((USB_HOST_IRP *)irp);
9D006B78  0040F809   JALR V0
9D006B7C  02602021   ADDU A0, S3, ZERO
1789:                            }
1790:                
1791:                            irp = pipe->irpQueueHead;
9D006B80  8E250014   LW A1, 20(S1)
1792:                
1793:                            if((irp != NULL) && (!(irp->status == USB_HOST_IRP_STATUS_IN_PROGRESS)))
9D006B84  10A000B3   BEQ A1, ZERO, 0x9D006E54
9D006B88  24020003   ADDIU V0, ZERO, 3
9D006B8C  8CA3000C   LW V1, 12(A1)
9D006B90  106200B0   BEQ V1, V0, 0x9D006E54
9D006B94  02402021   ADDU A0, S2, ZERO
1794:                            {
1795:                                /* We do have another IRP to process. */
1796:                                irp->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D006B98  ACA2000C   SW V0, 12(A1)
1797:                                _DRV_USBHS_HOST_IRPTransmitFIFOLoad(usbID, irp, endpoint);
9D006B9C  0F4039EC   JAL _DRV_USBHS_HOST_IRPTransmitFIFOLoad
9D006BA0  02003021   ADDU A2, S0, ZERO
1798:                            }
1799:                        }
1800:                    }
1801:                    else
1802:                    {
1803:                         /* We got an interrupt for data moving from device to to host. Check if
1804:                          * there were any receptions errors. Then check if there is any more
1805:                          * data to be received in the IRP. If we are done, then end the IRP and
1806:                          * start a new one. */
1807:                
1808:                        status = PLIB_USBHS_RxEPStatusGet(usbID, endpoint);
1809:                
1810:                        /* Check if the IRP was aborted */
1811:                        if(irp->tempState == DRV_USBHS_HOST_IRP_STATE_ABORTED)
9D006BB8  8E65001C   LW A1, 28(S3)
9D006BBC  24040007   ADDIU A0, ZERO, 7
9D006BC0  14A40016   BNE A1, A0, 0x9D006C1C
9D006BC4  306300FF   ANDI V1, V1, 255
1812:                        {
1813:                            endIRP = true;
1814:                            irp->status = USB_HOST_IRP_STATUS_ABORTED;
9D006BC8  2403FFFB   ADDIU V1, ZERO, -5
9D006BCC  AE63000C   SW V1, 12(S3)
1815:                
1816:                            /* Clear the error flags and then flush the fifo if a data is
1817:                             * available */
1818:                            PLIB_USBHS_RxEPStatusClear(usbID, endpoint, USBHS_RXEP_ERROR_ALL);
1819:                            PLIB_USBHS_EndpointRxFIFOFlush(usbID, endpoint);
1820:                        }
1821:                        else if(status & USBHS_RXEP_ERROR_RXSTALL)
9D006C1C  30640040   ANDI A0, V1, 64
9D006C20  308400FF   ANDI A0, A0, 255
9D006C24  1080001A   BEQ A0, ZERO, 0x9D006C90
9D006C28  30640008   ANDI A0, V1, 8
1822:                        {
1823:                            /* This means the packet was stalled. Set the error status and then
1824:                             * clear the stall bit */
1825:                
1826:                            endIRP = true;
1827:                            irp->status = USB_HOST_IRP_STATUS_ERROR_STALL;
9D006C2C  2403FFFF   ADDIU V1, ZERO, -1
9D006C30  AE63000C   SW V1, 12(S3)
1828:                            PLIB_USBHS_RxEPStatusClear(usbID, endpoint, USBHS_RXEP_ERROR_RXSTALL);
1829:                
1830:                            /* Clear the Data toggle */
1831:                            PLIB_USBHS_HostRxEndpointDataToggleClear(usbID, endpoint);
1832:                            
1833:                            PLIB_USBHS_EndpointRxFIFOFlush(usbID, endpoint);
1834:                        }
1835:                        else if(status & USBHS_RXEP_ERROR_NAK_TIMEOUT)
9D006C90  308400FF   ANDI A0, A0, 255
9D006C94  10800016   BEQ A0, ZERO, 0x9D006CF0
9D006C98  30630004   ANDI V1, V1, 4
1836:                        {
1837:                            /* This means a NAK Time Out has occurred. Clear the error status.
1838:                             * */
1839:                
1840:                            endIRP = true;
1841:                            irp->status = USB_HOST_IRP_STATUS_ERROR_NAK_TIMEOUT;
9D006C9C  2403FFFE   ADDIU V1, ZERO, -2
9D006CA0  AE63000C   SW V1, 12(S3)
1842:                            PLIB_USBHS_RxEPStatusClear(usbID, endpoint, USBHS_RXEP_ERROR_NAK_TIMEOUT);
1843:                            PLIB_USBHS_EndpointRxFIFOFlush(usbID, endpoint);
1844:                        }
1845:                        else if(status & USBHS_RXEP_ERROR_BUS)
9D006CF0  306300FF   ANDI V1, V1, 255
9D006CF4  10600015   BEQ V1, ZERO, 0x9D006D4C
9D006CF8  2403FFFD   ADDIU V1, ZERO, -3
1846:                        {
1847:                            /* This means there was an bus error. The packet was tried three
1848:                             * times and was not successfully processed */
1849:                
1850:                            endIRP = true;
1851:                            irp->status = USB_HOST_IRP_STATUS_ERROR_DATA;
9D006CFC  AE63000C   SW V1, 12(S3)
1852:                            PLIB_USBHS_RxEPStatusClear(usbID, endpoint, USBHS_RXEP_ERROR_BUS);
1853:                            PLIB_USBHS_EndpointRxFIFOFlush(usbID, endpoint);
1854:                        }
1855:                        else
1856:                        {
1857:                            /* This means that data was received without errors. */
1858:                
1859:                            count = _DRV_USBHS_HOST_IRPReceiveFIFOUnload(usbID, irp, endpoint, &isDmaUsed);
9D006D4C  02402021   ADDU A0, S2, ZERO
9D006D50  02602821   ADDU A1, S3, ZERO
9D006D54  02003021   ADDU A2, S0, ZERO
9D006D58  0F4034A0   JAL _DRV_USBHS_HOST_IRPReceiveFIFOUnload
9D006D5C  27A70010   ADDIU A3, SP, 16
1860:                            if(isDmaUsed == false)
9D006D60  93A30010   LBU V1, 16(SP)
9D006D64  1460003C   BNE V1, ZERO, 0x9D006E58
9D006D68  8FBF002C   LW RA, 44(SP)
1861:                            {
1862:                                if((count < pipe->endpointSize) ||
9D006D6C  8E23001C   LW V1, 28(S1)
9D006D70  0043102B   SLTU V0, V0, V1
9D006D74  54400007   BNEL V0, ZERO, 0x9D006D94
9D006D78  AE60000C   SW ZERO, 12(S3)
9D006D7C  8E630020   LW V1, 32(S3)
9D006D80  8E620008   LW V0, 8(S3)
9D006D84  0062102B   SLTU V0, V1, V0
9D006D88  1440000B   BNE V0, ZERO, _DRV_USBHS_HOST_NonControlTransferProcess::PLIB_USBHS_RxEPINTokenSend
9D006D8C  26020010   ADDIU V0, S0, 16
1863:                                        (irp->completedBytes >= irp->size))
1864:                                {
1865:                                    endIRP = true;
1866:                                    irp->status = USB_HOST_IRP_STATUS_COMPLETED;
9D006D90  AE60000C   SW ZERO, 12(S3)
1867:                
1868:                                    if(irp->completedBytes < irp->size)
9D006D94  8E620020   LW V0, 32(S3)
9D006D98  8E630008   LW V1, 8(S3)
9D006D9C  0043182B   SLTU V1, V0, V1
9D006DA0  50600025   BEQL V1, ZERO, 0x9D006E38
9D006DA4  AE620008   SW V0, 8(S3)
1869:                                    {
1870:                                        /* This means the device ended the transfer and and we
1871:                                         * have a short transfer */
1872:                                        irp->status = USB_HOST_IRP_STATUS_COMPLETED_SHORT;
9D006DA8  24030001   ADDIU V1, ZERO, 1
9D006DAC  AE63000C   SW V1, 12(S3)
1873:                                    }
1874:                
1875:                                    /* Update the actual amount of data received */
1876:                                    irp->size = irp->completedBytes;
9D006DB0  0B401B8E   J 0x9D006E38
9D006DB4  AE620008   SW V0, 8(S3)
1877:                                }
1878:                                else
1879:                                {
1880:                                    /* This means we have more data to send We request another
1881:                                     * packet */
1882:                
1883:                                    endIRP = false;
1884:                                    PLIB_USBHS_RxEPINTokenSend(usbID, endpoint);
1885:                                }
1886:                            }
1887:                            else
1888:                            {
1889:                                /* DMA has been used. Do not end the IRP here.
1890:                                 It will be done in DMA ISR handler */
1891:                                endIRP = false;
1892:                            }
1893:                        }
1894:                
1895:                        if(endIRP)
1896:                        {
1897:                            /* This means we need to end the IRP */
1898:                
1899:                            pipe->irpQueueHead = irp->next;
9D006C14  0B401B8F   J 0x9D006E3C
9D006C18  8E620024   LW V0, 36(S3)
9D006C88  0B401B8F   J 0x9D006E3C
9D006C8C  8E620024   LW V0, 36(S3)
9D006CE8  0B401B8F   J 0x9D006E3C
9D006CEC  8E620024   LW V0, 36(S3)
9D006D44  0B401B8F   J 0x9D006E3C
9D006D48  8E620024   LW V0, 36(S3)
9D006E38  8E620024   LW V0, 36(S3)
9D006E3C  AE220014   SW V0, 20(S1)
1900:                          
1901:                            if(irp->callback)
9D006E40  8E620018   LW V0, 24(S3)
9D006E44  1440FFE4   BNE V0, ZERO, 0x9D006DD8
9D006E48  00000000   NOP
9D006E4C  0B401B79   J 0x9D006DE4
9D006E50  8E220014   LW V0, 20(S1)
1902:                            {
1903:                                /* Invoke the call back*/
1904:                                irp->callback((USB_HOST_IRP *)irp);
9D006DD8  0040F809   JALR V0
9D006DDC  02602021   ADDU A0, S3, ZERO
1905:                            }
1906:                
1907:                            irp = pipe->irpQueueHead;
9D006DE0  8E220014   LW V0, 20(S1)
1908:                
1909:                            /* A IRP could have been submitted in the callback. If that is the
1910:                             * case and the IRP status would indicate that it already in
1911:                             * progress. If the IRP in the queue head is not in progress then we
1912:                             * shold initiate the transaction */
1913:                
1914:                            if((irp != NULL) && (!(irp->status == USB_HOST_IRP_STATUS_IN_PROGRESS)))
9D006DE4  1040001B   BEQ V0, ZERO, 0x9D006E54
9D006DE8  24030003   ADDIU V1, ZERO, 3
9D006DEC  8C44000C   LW A0, 12(V0)
9D006DF0  10830018   BEQ A0, V1, 0x9D006E54
9D006DF4  26100010   ADDIU S0, S0, 16
1915:                            {
1916:                                irp->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D006DF8  AC43000C   SW V1, 12(V0)
1917:                                
1918:                                /* We do have another IRP to process. Request for
1919:                                 * an IN packet. */
1920:                
1921:                                PLIB_USBHS_RxEPINTokenSend(usbID, endpoint);
1922:                            }
1923:                        }
1924:                    }
1925:                }/* end of _DRV_USBHS_HOST_NonControlTransferProcess() */
9D006B70  0B401B96   J 0x9D006E58
9D006B74  8FBF002C   LW RA, 44(SP)
9D006BA4  0B401B96   J 0x9D006E58
9D006BA8  8FBF002C   LW RA, 44(SP)
9D006BAC  00101100   SLL V0, S0, 4
9D006BB0  02421021   ADDU V0, S2, V0
9D006DD0  0B401B96   J 0x9D006E58
9D006DD4  8FBF002C   LW RA, 44(SP)
9D006E14  0B401B96   J 0x9D006E58
9D006E18  8FBF002C   LW RA, 44(SP)
9D006E54  8FBF002C   LW RA, 44(SP)
1926:                
1927:                void _DRV_USBHS_HOST_Tasks_ISR(DRV_USBHS_OBJ * hDriver)
1928:                {
9D011120  27BDFFD0   ADDIU SP, SP, -48
9D011124  AFBF002C   SW RA, 44(SP)
9D011128  AFB60028   SW S6, 40(SP)
9D01112C  AFB50024   SW S5, 36(SP)
9D011130  AFB40020   SW S4, 32(SP)
9D011134  AFB3001C   SW S3, 28(SP)
9D011138  AFB20018   SW S2, 24(SP)
9D01113C  AFB10014   SW S1, 20(SP)
9D011140  AFB00010   SW S0, 16(SP)
9D011144  0080B021   ADDU S6, A0, ZERO
9D0111D8  0B40448D   J 0x9D011234
9D0111DC  24100001   ADDIU S0, ZERO, 1
9D011230  24100001   ADDIU S0, ZERO, 1
1929:                    unsigned int i;
1930:                    USBHS_GEN_INTERRUPT interruptStatus;
1931:                    USBHS_EPTXRX_INTERRUPT interruptRxStatus;
1932:                    USBHS_EPTXRX_INTERRUPT interruptTxStatus;
1933:                
1934:                    _DRV_USBHS_NonPersistentInterruptSourceClear(hDriver->interruptSource);
1935:                    USBHS_MODULE_ID usbID = hDriver->usbID;
1936:                    
1937:                
1938:                    interruptStatus = PLIB_USBHS_GenInterruptFlagsGet(usbID);
1939:                
1940:                    if(interruptStatus & USBHS_GENINT_DEVCONN) 
9D011154  32220010   ANDI V0, S1, 16
9D011158  304200FF   ANDI V0, V0, 255
9D01115C  10400004   BEQ V0, ZERO, 0x9D011170
9D011160  32220020   ANDI V0, S1, 32
1941:                    {
1942:                        hDriver->deviceAttached = true;
9D011164  24020001   ADDIU V0, ZERO, 1
9D011168  0B404468   J 0x9D0111A0
9D01116C  A0820158   SB V0, 344(A0)
1943:                
1944:                    }
1945:                    else if(interruptStatus & USBHS_GENINT_DEVDISCONN)
9D011170  304200FF   ANDI V0, V0, 255
9D011174  5040000B   BEQL V0, ZERO, 0x9D0111A4
9D011178  32310080   ANDI S1, S1, 128
1946:                    {
1947:                        /* We go a detach interrupt. The detach interrupt could have occurred
1948:                         * while the attach de-bouncing is in progress. We just set a flag saying
1949:                         * the device is detached; */
1950:                
1951:                        hDriver->deviceAttached = false;
9D01117C  A0800158   SB ZERO, 344(A0)
1952:                
1953:                        if(hDriver->attachedDeviceObjHandle != USB_HOST_DEVICE_OBJ_HANDLE_INVALID)
9D011180  8C840160   LW A0, 352(A0)
9D011184  2402FFFF   ADDIU V0, ZERO, -1
9D011188  50820005   BEQL A0, V0, 0x9D0111A0
9D01118C  AEC20160   SW V0, 352(S6)
1954:                        {
1955:                            /* Ask the host layer to de-enumerate this device. The denumeration
1956:                             * must be done in the interrupt context. */
1957:                            USB_HOST_DeviceDenumerate (hDriver->attachedDeviceObjHandle);
9D011190  0F404145   JAL USB_HOST_DeviceDenumerate
9D011194  00000000   NOP
1958:                        }
1959:                
1960:                        hDriver->attachedDeviceObjHandle = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
9D011198  2402FFFF   ADDIU V0, ZERO, -1
9D01119C  AEC20160   SW V0, 352(S6)
1961:                    }
1962:                    
1963:                    if(interruptStatus & USBHS_GENINT_VBUSERR)
9D0111A0  32310080   ANDI S1, S1, 128
9D0111A4  323100FF   ANDI S1, S1, 255
9D0111A8  12200003   BEQ S1, ZERO, _DRV_USBHS_HOST_Tasks_ISR::PLIB_USBHS_TxInterruptFlagsGet
9D0111AC  24030002   ADDIU V1, ZERO, 2
1964:                    {
1965:                        /* This interrupt occurs if a VBUS error has occurred. The fact that
1966:                         * that the code has reached means the flag was cleared (reading the
1967:                         * interrupt status clears the flag). */
1968:                        
1969:                        /* This line of code will be replaced with a USBHS Peripheral Library
1970:                         * call in a future release of Harmony. */
1971:                        USBEOFRSTbits.SOFRST = 2;
9D0111B0  3C02BF8E   LUI V0, -16498
9D0111B4  A043307F   SB V1, 12415(V0)
1972:                    }
1973:                
1974:                
1975:                    interruptTxStatus = PLIB_USBHS_TxInterruptFlagsGet(usbID);
1976:                    interruptRxStatus = PLIB_USBHS_RxInterruptFlagsGet(usbID);
1977:                
1978:                    /* Check if we have an endpoint interrupt */
1979:                
1980:                    if(interruptTxStatus & USBHS_TXRXINT_EP0)
9D0111C4  32620001   ANDI V0, S3, 1
9D0111C8  10400019   BEQ V0, ZERO, 0x9D011230
9D0111CC  32B5FFFF   ANDI S5, S5, -1
1981:                    {
1982:                        /* Process control transfers */
1983:                        _DRV_USBHS_HOST_ControlTransferProcess(hDriver);
9D0111D0  0F402082   JAL _DRV_USBHS_HOST_ControlTransferProcess
9D0111D4  02C02021   ADDU A0, S6, ZERO
1984:                    }
1985:                
1986:                    /* Process non control transfers */
1987:                    for(i = 1; i < DRV_USBHS_HOST_MAXIMUM_ENDPOINTS_NUMBER; i++ )
9D01121C  26100001   ADDIU S0, S0, 1
9D011220  1614FFF0   BNE S0, S4, 0x9D0111E4
9D011224  02128804   SLLV S1, S2, S0
9D011228  0B404490   J 0x9D011240
9D01122C  8FBF002C   LW RA, 44(SP)
9D011238  0B404478   J 0x9D0111E0
9D01123C  24140008   ADDIU S4, ZERO, 8
1988:                    {
1989:                        if(interruptTxStatus & (1 << i))
9D0111E0  02128804   SLLV S1, S2, S0
9D0111E4  02331024   AND V0, S1, S3
9D0111E8  50400006   BEQL V0, ZERO, 0x9D011204
9D0111EC  02358824   AND S1, S1, S5
9D011234  24120001   ADDIU S2, ZERO, 1
1990:                        {
1991:                            /* This means an interrupt occurred on a non zero endpoint. */
1992:                
1993:                            _DRV_USBHS_HOST_NonControlTransferProcess(hDriver, i,
9D0111F0  02C02021   ADDU A0, S6, ZERO
9D0111F4  320500FF   ANDI A1, S0, 255
9D0111F8  0F401A7C   JAL _DRV_USBHS_HOST_NonControlTransferProcess
9D0111FC  00003021   ADDU A2, ZERO, ZERO
1994:                                    USB_DATA_DIRECTION_HOST_TO_DEVICE);
1995:                
1996:                        }
1997:                
1998:                        if(interruptRxStatus & (1 << i))
9D011200  02358824   AND S1, S1, S5
9D011204  52200006   BEQL S1, ZERO, 0x9D011220
9D011208  26100001   ADDIU S0, S0, 1
1999:                        {
2000:                            /* This means an receive endpoint interrupt occurred on a non zero
2001:                             * endpoint. */
2002:                
2003:                            _DRV_USBHS_HOST_NonControlTransferProcess(hDriver, i,
9D01120C  02C02021   ADDU A0, S6, ZERO
9D011210  320500FF   ANDI A1, S0, 255
9D011214  0F401A7C   JAL _DRV_USBHS_HOST_NonControlTransferProcess
9D011218  02403021   ADDU A2, S2, ZERO
2004:                                    USB_DATA_DIRECTION_DEVICE_TO_HOST);
2005:                        }
2006:                    }
2007:                }/* end of _DRV_USBHS_HOST_Tasks_ISR() */
9D011240  8FB60028   LW S6, 40(SP)
2008:                
2009:                void _DRV_USBHS_HOST_Tasks_ISR_USBDMA(DRV_USBHS_OBJ * hDriver)
2010:                {
9D00C080  27BDFFC8   ADDIU SP, SP, -56
9D00C084  AFBF0034   SW RA, 52(SP)
9D00C088  AFBE0030   SW S8, 48(SP)
9D00C08C  AFB7002C   SW S7, 44(SP)
9D00C090  AFB60028   SW S6, 40(SP)
9D00C094  AFB50024   SW S5, 36(SP)
9D00C098  AFB40020   SW S4, 32(SP)
9D00C09C  AFB3001C   SW S3, 28(SP)
9D00C0A0  AFB20018   SW S2, 24(SP)
9D00C0A4  AFB10014   SW S1, 20(SP)
9D00C0A8  AFB00010   SW S0, 16(SP)
9D00C0AC  00809021   ADDU S2, A0, ZERO
2011:                    USBHS_MODULE_ID usbID = hDriver->usbID;
2012:                    uint8_t usbDMAInterrupts;
2013:                    uint8_t  iEndpoint;
2014:                    uint8_t usbDMAChannel = 0;
2015:                    bool endpointDir;
2016:                    bool usbDMAError = false;
2017:                    bool endIRP = false;
2018:                    USB_HOST_IRP_LOCAL * irp = (USB_HOST_IRP_LOCAL *)NULL;
2019:                
2020:                    if(!hDriver->isOpened)
9D00C0B0  90830001   LBU V1, 1(A0)
9D00C0B4  1060007B   BEQ V1, ZERO, 0x9D00C2A4
9D00C0B8  8C82005C   LW V0, 92(A0)
2021:                    {
2022:                        /* We need a valid client */
2023:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver does not have a client");
2024:                        return;
2025:                    }
2026:                
2027:                    if(hDriver->pEventCallBack == NULL)
9D00C0BC  8C830120   LW V1, 288(A0)
9D00C0C0  10600078   BEQ V1, ZERO, 0x9D00C2A4
9D00C0C4  0040A821   ADDU S5, V0, ZERO
2028:                    {
2029:                        /* We need a valid event handler */
2030:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Driver needs a event handler");
2031:                        return;
2032:                    }
2033:                
2034:                    /* Reading the interrupt flags will cause the
2035:                     * flags to get cleared */
2036:                    usbDMAInterrupts = PLIB_USBHS_DMAInterruptGet(usbID);
2037:                
2038:                    for(usbDMAChannel = 1; usbDMAChannel < 9; usbDMAChannel++)
9D00C0E0  24130008   ADDIU S3, ZERO, 8
9D00C284  1613FF97   BNE S0, S3, 0x9D00C0E4
9D00C288  26310008   ADDIU S1, S1, 8
9D00C28C  0B4030AA   J 0x9D00C2A8
9D00C290  8FBF0034   LW RA, 52(SP)
2039:                    {
2040:                        if((usbDMAInterrupts >> (usbDMAChannel - 1)) & 0x01)
9D00C0E4  02141007   SRAV V0, S4, S0
9D00C0E8  30420001   ANDI V0, V0, 1
9D00C0EC  50400065   BEQL V0, ZERO, 0x9D00C284
9D00C0F0  26100001   ADDIU S0, S0, 1
2041:                        {
2042:                            /* DMA interrupt set for this channel.
2043:                             * Map the EP it is assigned for
2044:                             */
2045:                            usbDMAError = PLIB_USBHS_DMAErrorGet(usbID, usbDMAChannel);
2046:                            if(usbDMAError == true)
2047:                            {
2048:                                continue;
2049:                            }
2050:                            iEndpoint = hDriver->gDrvUSBDMAPool[usbDMAChannel].iEndpoint;
2051:                            endpointDir = hDriver->gDrvUSBDMAPool[usbDMAChannel].endpointDir;
2052:                
2053:                            /* Check the EP direction */
2054:                            if(endpointDir == USB_DATA_DIRECTION_HOST_TO_DEVICE)
9D00C294  1440FFB7   BNE V0, ZERO, 0x9D00C174
9D00C298  9236000E   LBU S6, 14(S1)
9D00C29C  0B40304D   J 0x9D00C134
9D00C2A0  26C20007   ADDIU V0, S6, 7
2055:                            {
2056:                                /* This is TX Endpoint */
2057:                                irp = hDriver->hostEndpointTable[iEndpoint] .endpoints[endpointDir].pipe->irpQueueHead;
9D00C134  00021100   SLL V0, V0, 4
9D00C138  02421021   ADDU V0, S2, V0
9D00C13C  8C420008   LW V0, 8(V0)
9D00C140  8C420014   LW V0, 20(V0)
2058:                                irp->completedBytes += hDriver->gDrvUSBDMAPool[usbDMAChannel].count;
9D00C144  8C440020   LW A0, 32(V0)
9D00C148  8E230010   LW V1, 16(S1)
9D00C14C  00831821   ADDU V1, A0, V1
9D00C150  AC430020   SW V1, 32(V0)
2059:                                PLIB_USBHS_DeviceTxEndpointPacketReady(usbID, iEndpoint);
2060:                                /* Release the DMA channel */
2061:                                hDriver->gDrvUSBDMAPool[usbDMAChannel].inUse = false;
2062:                            }
2063:                            else
2064:                            {
2065:                                /* This is RX Endpoint */
2066:                
2067:                                /* Release the DMA channel */
2068:                                hDriver->gDrvUSBDMAPool[usbDMAChannel].inUse = false;
9D00C174  A220000C   SB ZERO, 12(S1)
2069:                
2070:                                irp = hDriver->hostEndpointTable[iEndpoint].endpoints[endpointDir].pipe->irpQueueHead;
9D00C178  00161900   SLL V1, S6, 4
9D00C17C  02431021   ADDU V0, S2, V1
9D00C180  8C440080   LW A0, 128(V0)
9D00C184  8C840014   LW A0, 20(A0)
2071:                                irp->completedBytes += hDriver->gDrvUSBDMAPool[usbDMAChannel].count;
9D00C188  8C860020   LW A2, 32(A0)
9D00C18C  8E250010   LW A1, 16(S1)
9D00C190  00C52821   ADDU A1, A2, A1
9D00C194  AC850020   SW A1, 32(A0)
9D00C198  02A31821   ADDU V1, S5, V1
2072:                
2073:                                /* Clear RXPktRDY bit in the corresponding register */
2074:                                PLIB_USBHS_RxEPStatusClear(usbID, iEndpoint, USBHS_RXEP_PKTRDY);
2075:                
2076:                                if(((hDriver->gDrvUSBDMAPool[usbDMAChannel].count) < 
9D00C1B0  8E230010   LW V1, 16(S1)
9D00C1B4  8C42001C   LW V0, 28(V0)
9D00C1B8  0062102B   SLTU V0, V1, V0
9D00C1BC  54400007   BNEL V0, ZERO, 0x9D00C1DC
9D00C1C0  AC80000C   SW ZERO, 12(A0)
2077:                                            (hDriver->hostEndpointTable[iEndpoint] .endpoints[endpointDir].pipe->endpointSize)) ||
9D00C1AC  8C420080   LW V0, 128(V0)
9D00C1C4  8C830020   LW V1, 32(A0)
9D00C1C8  8C820008   LW V0, 8(A0)
9D00C1CC  0062102B   SLTU V0, V1, V0
9D00C1D0  14400012   BNE V0, ZERO, _DRV_USBHS_HOST_Tasks_ISR_USBDMA::PLIB_USBHS_RxEPINTokenSend
9D00C1D4  26C20010   ADDIU V0, S6, 16
2078:                                        (irp->completedBytes >= irp->size))
2079:                                {
2080:                                    endIRP = true;
2081:                                    irp->status = USB_HOST_IRP_STATUS_COMPLETED;
9D00C1D8  AC80000C   SW ZERO, 12(A0)
2082:                
2083:                                    if(irp->completedBytes < irp->size)
9D00C1DC  8C820020   LW V0, 32(A0)
9D00C1E0  8C830008   LW V1, 8(A0)
9D00C1E4  0043182B   SLTU V1, V0, V1
9D00C1E8  54600001   BNEL V1, ZERO, 0x9D00C1F0
9D00C1EC  AC97000C   SW S7, 12(A0)
2084:                                    {
2085:                                        /* This means the device ended the transfer and
2086:                                         * and we have a short transfer */
2087:                                        irp->status = USB_HOST_IRP_STATUS_COMPLETED_SHORT;
2088:                                    }
2089:                                    irp->size = irp->completedBytes;
9D00C1F0  AC820008   SW V0, 8(A0)
2090:                                }
2091:                                else
2092:                                {
2093:                                    /* This means we have more data to send
2094:                                     * We request another packet */
2095:                
2096:                                    endIRP = false;
2097:                                    PLIB_USBHS_RxEPINTokenSend(usbID, iEndpoint);
2098:                                }
2099:                
2100:                                if(endIRP)
2101:                                {
2102:                                    /* This means we need to end the IRP */
2103:                
2104:                                    hDriver->hostEndpointTable[iEndpoint].endpoints[endpointDir].pipe->irpQueueHead = irp->next;
9D00C1F4  00161100   SLL V0, S6, 4
9D00C1F8  02421021   ADDU V0, S2, V0
9D00C1FC  8C420080   LW V0, 128(V0)
9D00C200  8C830024   LW V1, 36(A0)
9D00C204  AC430014   SW V1, 20(V0)
2105:                
2106:                                    if(irp->callback)
9D00C208  8C820018   LW V0, 24(A0)
9D00C20C  1440000A   BNE V0, ZERO, 0x9D00C238
9D00C210  00000000   NOP
9D00C214  0B403091   J 0x9D00C244
9D00C218  00161100   SLL V0, S6, 4
2107:                                    {
2108:                                        /* Invoke the call back*/
2109:                                        irp->callback((USB_HOST_IRP *)irp);
9D00C238  0040F809   JALR V0
9D00C23C  00000000   NOP
2110:                                    }
2111:                
2112:                                    irp = hDriver->hostEndpointTable[iEndpoint].endpoints[endpointDir].pipe->irpQueueHead;
9D00C240  00161100   SLL V0, S6, 4
9D00C244  02421021   ADDU V0, S2, V0
9D00C248  8C420080   LW V0, 128(V0)
9D00C24C  8C420014   LW V0, 20(V0)
2113:                
2114:                                    /* A IRP could have been submitted in the callback. If that is the case
2115:                                     * and the IRP status would indicate that it already in progress. If
2116:                                     * the IRP in the queue head is not in progress then we shold initiate
2117:                                     * the transaction */
2118:                
2119:                                    if((irp != NULL) && (!(irp->status == USB_HOST_IRP_STATUS_IN_PROGRESS)))
9D00C250  1040000B   BEQ V0, ZERO, 0x9D00C280
9D00C254  24040003   ADDIU A0, ZERO, 3
9D00C258  8C43000C   LW V1, 12(V0)
9D00C25C  50640009   BEQL V1, A0, 0x9D00C284
9D00C260  26100001   ADDIU S0, S0, 1
2120:                                    {
2121:                                        irp->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D00C264  AC44000C   SW A0, 12(V0)
2122:                
2123:                                        /* We do have another IRP to process. Request for
2124:                                         * an IN packet. */
2125:                
2126:                                        PLIB_USBHS_RxEPINTokenSend(usbID, iEndpoint);
2127:                                    }
2128:                                }
2129:                            }
2130:                        }
2131:                    }
2132:                
2133:                }/* end of _DRV_USBHS_HOST_Tasks_ISR_USBDMA() */
9D00C2A4  8FBF0034   LW RA, 52(SP)
2134:                
2135:                void DRV_USBHS_HOST_BusResetControl(DRV_HANDLE client, bool control)
2136:                {
2137:                    DRV_USBHS_OBJ * hDriver;
2138:                    USBHS_MODULE_ID usbID;
2139:                
2140:                    if((client == DRV_HANDLE_INVALID) || (((DRV_USBHS_OBJ *)client) == NULL))
00000000  00000000   NOP
2141:                    {
2142:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Invalid client");
2143:                        return;
2144:                    }
2145:                
2146:                    hDriver = (DRV_USBHS_OBJ *)client;
2147:                    usbID = hDriver->usbID;
2148:                
2149:                    /* If control is true, then enable reset */
2150:                
2151:                    if(control == true)
00000010  00000000   NOP
2152:                    {
2153:                        /* Enable the rest signaling */
2154:                        PLIB_USBHS_ResetEnable(usbID);
2155:                    }
2156:                    else
2157:                    {
2158:                        /* Clear the reset signaling. At this point we
2159:                         * can check the speed of the connected device. */
2160:                        PLIB_USBHS_ResetDisable(usbID);
2161:                
2162:                        if(PLIB_USBHS_HighSpeedIsConnected(usbID))
00000044  00000000   NOP
2163:                        {
2164:                            /* This means the device attached at high speed */
2165:                            hDriver->deviceSpeed = USB_SPEED_HIGH;
0000004C  00000000   NOP
2166:                        }
2167:                        else if(PLIB_USBHS_FullOrHighSpeedIsConnected(usbID))
00000070  00000000   NOP
2168:                        {
2169:                            hDriver->deviceSpeed = USB_SPEED_FULL;
2170:                        }
2171:                        else
2172:                        {
2173:                            hDriver->deviceSpeed = USB_SPEED_LOW;
00000080  00000000   NOP
2174:                        }
2175:                    }
2176:                }/* end of DRV_USBHS_HOST_BusResetControl() */
2177:                
2178:                void DRV_USBHS_HOST_StartOfFrameControl(DRV_HANDLE client, bool control)
2179:                {
2180:                    /* At the point this function does not do any thing.
2181:                     * The Start of frame signaling in this HCD is controlled
2182:                     * automatically by the module. */
2183:                }/* end of DRV_USBHS_HOST_StartOfFrameControl() */
2184:                
2185:                USB_SPEED DRV_USBHS_HOST_DeviceCurrentSpeedGet(DRV_HANDLE client)
2186:                {
2187:                    /* This function returns the current device speed */
2188:                
2189:                    DRV_USBHS_OBJ * hDriver;
2190:                
2191:                    if((client == DRV_HANDLE_INVALID) || (((DRV_USBHS_OBJ *)client) == NULL))
2192:                    {
2193:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Invalid client");
2194:                    }
2195:                
2196:                    hDriver = (DRV_USBHS_OBJ *)client;
2197:                    return(hDriver->deviceSpeed);
2198:                
2199:                }/* end of DRV_USBHS_HOST_DeviceCurrentSpeedGet() */
2200:                
2201:                void DRV_USBHS_HOST_OperationEnable(DRV_HANDLE hClient, bool enable)
2202:                {
00000000  00000000   NOP
2203:                    /* For this driver, this function does not do anything. The
2204:                     * PIC32MZ USB module does not have a explicit USB HOST mode
2205:                     * enable bit */
2206:                
2207:                }
2208:                
2209:                uint8_t _DRV_USBHS_HOST_GetFreeDMAChannel
2210:                (
2211:                    DRV_USBHS_OBJ * hDriver,
2212:                    bool endpointDir,
2213:                    uint8_t iEndpoint
2214:                )
2215:                {
9D015D2C  30A500FF   ANDI A1, A1, 255
2216:                    /* Start of local variables */
2217:                    uint8_t dmaChannel = 0;
2218:                    /* end of local variables */
2219:                
2220:                    for(dmaChannel = 1; dmaChannel < 9; dmaChannel++)
9D015D44  24080009   ADDIU T0, ZERO, 9
9D015D80  1448FFF1   BNE V0, T0, 0x9D015D48
9D015D84  24630008   ADDIU V1, V1, 8
2221:                    {
2222:                        if((hDriver->gDrvUSBDMAPool[dmaChannel]).inUse == false)
9D015D30  9082000C   LBU V0, 12(A0)
9D015D34  10400009   BEQ V0, ZERO, 0x9D015D5C
9D015D38  30C600FF   ANDI A2, A2, 255
9D015D3C  00801821   ADDU V1, A0, ZERO
9D015D40  24020002   ADDIU V0, ZERO, 2
9D015D48  90670014   LBU A3, 20(V1)
9D015D4C  14E0000B   BNE A3, ZERO, 0x9D015D7C
9D015D50  00404821   ADDU T1, V0, ZERO
9D015D54  0B405759   J 0x9D015D64
9D015D58  000948C0   SLL T1, T1, 3
9D015D5C  24090001   ADDIU T1, ZERO, 1
9D015D60  000948C0   SLL T1, T1, 3
9D015D64  00892021   ADDU A0, A0, T1
2223:                        {
2224:                            /* Found Not used DMA Channel */
2225:                            hDriver->gDrvUSBDMAPool[dmaChannel].inUse = true;
9D015D68  24020001   ADDIU V0, ZERO, 1
9D015D6C  A0820004   SB V0, 4(A0)
2226:                            hDriver->gDrvUSBDMAPool[dmaChannel].endpointDir = endpointDir;
9D015D70  A0850005   SB A1, 5(A0)
2227:                            hDriver->gDrvUSBDMAPool[dmaChannel].iEndpoint = iEndpoint;
2228:                            break;
9D015D74  0B405762   J 0x9D015D88
9D015D78  A0860006   SB A2, 6(A0)
9D015D7C  24420001   ADDIU V0, V0, 1
2229:                        }
2230:                    }
2231:                    /* DMA operation blocked */
2232:                    return 0;
2233:                }/* end of _DRV_USBHS_HOST_GetFreeDMAChannel() */
9D015D88  03E00008   JR RA
2234:                
2235:                // ****************************************************************************
2236:                /* Function:
2237:                    bool DRV_USBHS_HOST_EventDisable
2238:                    (
2239:                        DRV_HANDLE handle
2240:                    );
2241:                    
2242:                  Summary:
2243:                    Disables host mode events.
2244:                	
2245:                  Description:
2246:                    This function disables the host mode events. This function is called by the
2247:                    Host Layer when it wants to execute code atomically. 
2248:                	
2249:                  Remarks:
2250:                    Refer to drv_usbfs.h for usage information.
2251:                */
2252:                
2253:                bool DRV_USBHS_HOST_EventsDisable
2254:                (
2255:                    DRV_HANDLE handle
2256:                )
2257:                {
9D016A44  27BDFFE8   ADDIU SP, SP, -24
9D016A48  AFBF0014   SW RA, 20(SP)
2258:                    DRV_USBHS_OBJ * pUSBDrvObj;
2259:                    bool result = false;
2260:                
2261:                    if((DRV_HANDLE_INVALID != handle) && (0 != handle))
9D016A34  2483FFFF   ADDIU V1, A0, -1
9D016A38  2C63FFFE   SLTIU V1, V1, -2
9D016A3C  10600007   BEQ V1, ZERO, 0x9D016A5C
9D016A40  00001021   ADDU V0, ZERO, ZERO
2262:                    {
2263:                        pUSBDrvObj = (DRV_USBHS_OBJ *)(handle);
2264:                        result = _DRV_USBHS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
9D016A4C  0F40588F   JAL SYS_INT_SourceDisable
9D016A50  8C840064   LW A0, 100(A0)
2265:                    }
2266:                
2267:                    return(result);
2268:                }
9D016A54  8FBF0014   LW RA, 20(SP)
2269:                
2270:                
2271:                // ****************************************************************************
2272:                /* Function:
2273:                    void DRV_USBHS_HOST_EventsDisable
2274:                    (
2275:                        DRV_HANDLE handle
2276:                        bool eventRestoreContext
2277:                    );
2278:                    
2279:                  Summary:
2280:                    Restores the events to the specified the original value.
2281:                	
2282:                  Description:
2283:                    This function will restore the enable disable state of the events.
2284:                    eventRestoreContext should be equal to the value returned by the
2285:                    DRV_USBHS_HOST_EventsDisable() function.
2286:                	
2287:                  Remarks:
2288:                    Refer to drv_usbfs.h for usage information.
2289:                */
2290:                
2291:                void DRV_USBHS_HOST_EventsEnable
2292:                (
2293:                    DRV_HANDLE handle, 
2294:                    bool eventContext
2295:                )
2296:                {
9D015DD0  27BDFFE8   ADDIU SP, SP, -24
9D015DD4  AFBF0014   SW RA, 20(SP)
2297:                    DRV_USBHS_OBJ * pUSBDrvObj;
2298:                   
2299:                    if((DRV_HANDLE_INVALID != handle) && (0 != handle))
9D015D90  2482FFFF   ADDIU V0, A0, -1
9D015D94  2C42FFFE   SLTIU V0, V0, -2
9D015D98  10400013   BEQ V0, ZERO, 0x9D015DE8
9D015D9C  30A500FF   ANDI A1, A1, 255
2300:                    {
2301:                        pUSBDrvObj = (DRV_USBHS_OBJ *)(handle);
2302:                        if(eventContext == true)
9D015DA0  10A0000B   BEQ A1, ZERO, 0x9D015DD0
9D015DA4  3C03BF81   LUI V1, -16511
2303:                        {
2304:                            _DRV_USBHS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
9D015DA8  8C820064   LW V0, 100(A0)
2305:                        }
2306:                        else
2307:                        {
2308:                            _DRV_USBHS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
9D015DD8  0F40588F   JAL SYS_INT_SourceDisable
9D015DDC  8C840064   LW A0, 100(A0)
2309:                        }
2310:                    }
2311:                }
9D015DE0  8FBF0014   LW RA, 20(SP)
2312:                
2313:                // *****************************************************************************
2314:                // *****************************************************************************
2315:                // Root Hub Driver Routines
2316:                // *****************************************************************************
2317:                // *****************************************************************************
2318:                
2319:                void DRV_USBHS_HOST_ROOT_HUB_OperationEnable(DRV_HANDLE handle, bool enable)
2320:                {
9D013D28  27BDFFE8   ADDIU SP, SP, -24
9D013D2C  AFBF0014   SW RA, 20(SP)
9D013D30  AFB00010   SW S0, 16(SP)
9D013D34  00808021   ADDU S0, A0, ZERO
2321:                    /* Start of local variable */
2322:                    DRV_USBHS_OBJ * pUSBDrvObj = (DRV_USBHS_OBJ *)handle;
2323:                    /* End of local variable */
2324:                
2325:                    /* Check if the handle is valid or opened */
2326:                    if((handle == DRV_HANDLE_INVALID) || (!(pUSBDrvObj->isOpened)))
9D013D38  2402FFFF   ADDIU V0, ZERO, -1
9D013D3C  10820024   BEQ A0, V0, 0x9D013DD0
9D013D40  30A500FF   ANDI A1, A1, 255
9D013D44  90820001   LBU V0, 1(A0)
9D013D48  50400022   BEQL V0, ZERO, 0x9D013DD4
9D013D4C  8FBF0014   LW RA, 20(SP)
2327:                    {
2328:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2329:                    }
2330:                    else
2331:                    {
2332:                        if(true == enable)
9D013D50  50A0000E   BEQL A1, ZERO, DRV_USBHS_HOST_ROOT_HUB_OperationEnable::PLIB_INT_SourceFlagClear
9D013D54  8C820064   LW V0, 100(A0)
2333:                        {
2334:                            /* The USB Global interrupt and USB module is already enabled at
2335:                             * this point. We enable the attach interrupt to detect attach
2336:                             * First we enable port power */
2337:                
2338:                            if(pUSBDrvObj->rootHubInfo.portPowerEnable != NULL)
9D013D58  8C820174   LW V0, 372(A0)
9D013D5C  10400003   BEQ V0, ZERO, DRV_USBHS_HOST_ROOT_HUB_OperationEnable::PLIB_USBHS_InterruptEnableSet
9D013D60  00002021   ADDU A0, ZERO, ZERO
2339:                            {
2340:                                /* This USB module has only one port. So we call this function
2341:                                 * once to enable the port power on port 0*/
2342:                
2343:                                pUSBDrvObj->rootHubInfo.portPowerEnable(0 /* Port 0 */, true); 
9D013D64  0040F809   JALR V0
9D013D68  24050001   ADDIU A1, ZERO, 1
2344:                            }
2345:                
2346:                            /* Enable the attach and detach interrupt and EP0 interrupt. */
2347:                            PLIB_USBHS_InterruptEnableSet(pUSBDrvObj->usbID, (USBHS_GENINT_VBUSERR|USBHS_GENINT_DEVCONN|USBHS_GENINT_DEVDISCONN), 0x1, 0x0);
2348:                            
2349:                        }
2350:                        else
2351:                        {
2352:                            /* If the root hub operation is disable, we disable detach and
2353:                             * attached event and switch off the port power. */
2354:                
2355:                            SYS_INT_SourceStatusClear(pUSBDrvObj->interruptSource);
2356:                            PLIB_USBHS_InterruptEnableSet(pUSBDrvObj->usbID, 0x0, 0x0, 0x0);
2357:                            if(pUSBDrvObj->rootHubInfo.portPowerEnable != NULL)
9D013DBC  8E020174   LW V0, 372(S0)
9D013DC0  10400003   BEQ V0, ZERO, 0x9D013DD0
9D013DC4  00002021   ADDU A0, ZERO, ZERO
2358:                            {
2359:                                /* This USB module has only one port. So we call this function
2360:                                 * once to disable the port power on port 0*/
2361:                
2362:                                pUSBDrvObj->rootHubInfo.portPowerEnable(0 /* Port 0 */, false); 
9D013DC8  0040F809   JALR V0
9D013DCC  00002821   ADDU A1, ZERO, ZERO
2363:                            }
2364:                        }
2365:                    }
2366:                }
9D013D84  0B404F75   J 0x9D013DD4
9D013D88  8FBF0014   LW RA, 20(SP)
9D013DD0  8FBF0014   LW RA, 20(SP)
2367:                
2368:                bool DRV_USBHS_HOST_ROOT_HUB_OperationIsEnabled(DRV_HANDLE hClient)
2369:                {
2370:                    DRV_USBHS_OBJ * hDriver;
2371:                    USBHS_MODULE_ID usbID;
2372:                
2373:                    if((hClient == DRV_HANDLE_INVALID) || (((DRV_USBHS_OBJ *)hClient) == NULL))
2374:                    {
2375:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Invalid client");
2376:                    }
2377:                
2378:                    hDriver = (DRV_USBHS_OBJ *)hClient;
2379:                    usbID = hDriver->usbID;
2380:                  
2381:                    /* This function sets the session bit if the VBUS voltage
2382:                     * level is correct and then returns true. */
2383:                
2384:                    if(PLIB_USBHS_VBUSLevelGet(usbID) == USBHS_VBUS_VALID)
9D0169D4  30A50018   ANDI A1, A1, 24
9D0169D8  24040018   ADDIU A0, ZERO, 24
9D0169DC  14A40006   BNE A1, A0, 0x9D0169F8
9D0169E0  00001021   ADDU V0, ZERO, ZERO
2385:                    {
2386:                        PLIB_USBHS_SessionEnable(usbID);
2387:                        return(true);
9D0169F4  24020001   ADDIU V0, ZERO, 1
2388:                     
2389:                    }
2390:                    /* The VBUS voltage level is not yet set. */
2391:                    return(false);
2392:                    
2393:                }/* end of DRV_USBHS_HOST_OperationIsEnabled() */
9D0169F8  03E00008   JR RA
2394:                
2395:                // ****************************************************************************
2396:                /* Function:
2397:                    void DRV_USBHS_HOST_ROOT_HUB_Initialize
2398:                    (
2399:                        DRV_HANDLE handle,
2400:                        USB_HOST_DEVICE_OBJ_HANDLE usbHostDeviceInfo,
2401:                    )
2402:                
2403:                  Summary:
2404:                    This function instantiates the root hub driver.
2405:                
2406:                  Description:
2407:                    This function initializes the root hub driver. It is called by the host
2408:                    layer at the time of processing root hub devices. The host layer assigns a
2409:                    USB_HOST_DEVICE_OBJ_HANDLE reference to this root hub driver. This
2410:                    identifies the relationship between the root hub and the host layer.
2411:                
2412:                  Remarks:
2413:                    None.
2414:                */
2415:                
2416:                void DRV_USBHS_HOST_ROOT_HUB_Initialize
2417:                (
2418:                    DRV_HANDLE handle,
2419:                    USB_HOST_DEVICE_OBJ_HANDLE usbHostDeviceInfo
2420:                )
2421:                {
2422:                    DRV_USBHS_OBJ * pUSBDrvObj = (DRV_USBHS_OBJ *)handle;
2423:                
2424:                    if(DRV_HANDLE_INVALID == handle)
9D016FEC  2402FFFF   ADDIU V0, ZERO, -1
9D016FF0  10820004   BEQ A0, V0, 0x9D017004
9D016FF4  00000000   NOP
2425:                    {
2426:                        /* Driver handle is not valid */
2427:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2428:                    }
2429:                    else if(!(pUSBDrvObj->isOpened))
9D016FF8  90820001   LBU V0, 1(A0)
2430:                    {
2431:                        /* Driver has not been opened. Handle could be stale */
2432:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2433:                    }
2434:                    else
2435:                    {
2436:                        pUSBDrvObj->usbHostDeviceInfo = usbHostDeviceInfo;
2437:                    }
2438:                }
2439:                
2440:                // ****************************************************************************
2441:                /* Function:
2442:                    uint8_t DRV_USBHS_HOST_ROOT_HUB_PortNumbersGet(DRV_HANDLE handle);
2443:                
2444:                  Summary:
2445:                    Returns the number of ports this root hub contains.
2446:                
2447:                  Description:
2448:                    This function returns the number of ports that this root hub contains.
2449:                
2450:                  Remarks:
2451:                    None.
2452:                */
2453:                
2454:                uint8_t DRV_USBHS_HOST_ROOT_HUB_PortNumbersGet(DRV_HANDLE handle)
2455:                {
2456:                    DRV_USBHS_OBJ * pUSBDrvObj = (DRV_USBHS_OBJ *)handle;
2457:                    uint8_t result = 0;
2458:                
2459:                    if(DRV_HANDLE_INVALID == handle)
9D017088  2402FFFF   ADDIU V0, ZERO, -1
9D01708C  10820003   BEQ A0, V0, 0x9D01709C
9D017090  00000000   NOP
9D017094  03E00008   JR RA
9D017098  90820001   LBU V0, 1(A0)
2460:                    {
2461:                        /* Driver handle is not valid */
2462:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2463:                    }
2464:                    else if(!(pUSBDrvObj->isOpened))
2465:                    {
2466:                        /* Driver has not been opened. Handle could be stale */
2467:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2468:                    }
2469:                    else
2470:                    {
2471:                        result = 1;
2472:                    }
2473:                
2474:                    return(result);
2475:                }
9D01709C  03E00008   JR RA
2476:                
2477:                // ****************************************************************************
2478:                /* Function:
2479:                    uint32_t DRV_USBHS_HOST_ROOT_HUB_MaximumCurrentGet(DRV_HANDLE);
2480:                
2481:                  Summary:
2482:                    Returns the maximum amount of current that this root hub can provide on the
2483:                    bus.
2484:                
2485:                  Description:
2486:                    This function returns the maximum amount of current that this root hubn can
2487:                    provide on the bus.
2488:                
2489:                  Remarks:
2490:                    Refer to drv_usbfs.h for usage information.
2491:                */
2492:                
2493:                uint32_t DRV_USBHS_HOST_ROOT_HUB_MaximumCurrentGet(DRV_HANDLE handle)
2494:                {
2495:                    DRV_USBHS_OBJ * pUSBDrvObj = (DRV_USBHS_OBJ *)handle;
2496:                    uint32_t result = 0;
2497:                
2498:                    if(DRV_HANDLE_INVALID == handle)
9D016E20  2402FFFF   ADDIU V0, ZERO, -1
9D016E24  10820006   BEQ A0, V0, 0x9D016E40
9D016E28  00001021   ADDU V0, ZERO, ZERO
2499:                    {
2500:                        /* Driver handle is not valid */
2501:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2502:                    }
2503:                    else if(!(pUSBDrvObj->isOpened))
9D016E2C  90830001   LBU V1, 1(A0)
9D016E30  10600003   BEQ V1, ZERO, 0x9D016E40
9D016E34  00000000   NOP
2504:                    {
2505:                        /* Driver has not been opened. Handle could be stale */
2506:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2507:                    }
2508:                    else
2509:                    {
2510:                        result = pUSBDrvObj->rootHubInfo.rootHubAvailableCurrent;
9D016E38  03E00008   JR RA
9D016E3C  8C820178   LW V0, 376(A0)
2511:                    }
2512:                
2513:                    return(result);
2514:                }
9D016E40  03E00008   JR RA
2515:                
2516:                // ****************************************************************************
2517:                /* Function:
2518:                    USB_SPEED DRV_USBHS_HOST_ROOT_HUB_BusSpeedGet(DRV_HANDLE handle);
2519:                
2520:                  Summary:
2521:                    Returns the speed at which the bus to which this root hub is connected is
2522:                    operating.
2523:                
2524:                  Description:
2525:                    This function returns the speed at which the bus to which this root hub is
2526:                    connected is operating.
2527:                
2528:                 Remarks:
2529:                    None.
2530:                */
2531:                
2532:                USB_SPEED DRV_USBHS_HOST_ROOT_HUB_BusSpeedGet(DRV_HANDLE handle)
2533:                {
2534:                    DRV_USBHS_OBJ * pUSBDrvObj = (DRV_USBHS_OBJ *)handle;
2535:                    USB_SPEED speed = USB_SPEED_ERROR;
2536:                
2537:                    if(DRV_HANDLE_INVALID == handle)
9D016E48  2402FFFF   ADDIU V0, ZERO, -1
9D016E4C  10820006   BEQ A0, V0, 0x9D016E68
9D016E50  00001021   ADDU V0, ZERO, ZERO
2538:                    {
2539:                        /* Driver handle is not valid */
2540:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2541:                
2542:                    }
2543:                    else if(!(pUSBDrvObj->isOpened))
9D016E54  90830001   LBU V1, 1(A0)
9D016E58  10600003   BEQ V1, ZERO, 0x9D016E68
9D016E5C  00000000   NOP
2544:                    {
2545:                        /* Driver has not been opened. Handle could be stale */
2546:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2547:                    }
2548:                    else
2549:                    {
2550:                        /* Return the bus speed. This is speed at which the root hub is
2551:                         * operating. */
2552:                        speed = pUSBDrvObj->operationSpeed;
9D016E60  03E00008   JR RA
9D016E64  8C820054   LW V0, 84(A0)
2553:                    }
2554:                
2555:                    return(speed);
2556:                }
9D016E68  03E00008   JR RA
2557:                
2558:                // ****************************************************************************
2559:                /* Function:
2560:                    void DRV_USBHS_ROOT_HUB_PortResume(DRV_HANDLE handle, uint8_t port );
2561:                
2562:                  Summary:
2563:                    Resumes the specified root hub port.
2564:                
2565:                  Description:
2566:                    This function resumes the root hub. The resume duration is defined by
2567:                    DRV_USBHS_ROOT_HUB_RESUME_DURATION. The status of the resume signalling can
2568:                    be checked using the DRV_USBHS_ROOT_HUB_PortResumeIsComplete() function.
2569:                
2570:                  Remarks:
2571:                    The root hub on this particular hardware only contains one port - port 0.
2572:                */
2573:                
2574:                USB_ERROR DRV_USBHS_HOST_ROOT_HUB_PortResume(DRV_HANDLE handle, uint8_t port)
2575:                {
2576:                    /* The functionality is yet to be implemented. */
2577:                    return(USB_ERROR_NONE);
2578:                }
9D017370  03E00008   JR RA
2579:                
2580:                // ****************************************************************************
2581:                /* Function:
2582:                    void DRV_USBHS_ROOT_HUB_PortSuspend(DRV_HANDLE handle, uint8_t port );
2583:                
2584:                  Summary:
2585:                    Suspends the specified root hub port.
2586:                
2587:                  Description:
2588:                    This function suspends the root hub port.
2589:                
2590:                  Remarks:
2591:                    The root hub on this particular hardware only contains one port - port 0.
2592:                */
2593:                
2594:                USB_ERROR DRV_USBHS_HOST_ROOT_HUB_PortSuspend(DRV_HANDLE handle, uint8_t port)
2595:                {
2596:                    /* The functionality is yet to be implemented. */
2597:                    return (USB_ERROR_NONE);
2598:                }
9D017378  03E00008   JR RA
2599:                
2600:                // ****************************************************************************
2601:                /* Function:
2602:                    void DRV_USBHS_ROOT_HUB_PortResetIsComplete
2603:                    (
2604:                        DRV_HANDLE handle,
2605:                        uint8_t port
2606:                    );
2607:                
2608:                  Summary:
2609:                    Returns true if the root hub has completed the port reset operation.
2610:                
2611:                  Description:
2612:                    This function returns true if the port reset operation has completed. It
2613:                    should be called after the DRV_USB_HOST_ROOT_HUB_PortReset() function to
2614:                    check if the reset operation has completed.
2615:                
2616:                  Remarks:
2617:                    Refer to drv_usbfs.h for usage information.
2618:                 */
2619:                
2620:                bool DRV_USBHS_HOST_ROOT_HUB_PortResetIsComplete
2621:                (
2622:                    DRV_HANDLE handle,
2623:                    uint8_t port
2624:                )
2625:                {
2626:                    DRV_USBHS_OBJ * pUSBDrvObj = (DRV_USBHS_OBJ *)handle;
2627:                    bool result = true;
2628:                
2629:                    if(DRV_HANDLE_INVALID == handle)
9D016C44  2402FFFF   ADDIU V0, ZERO, -1
9D016C48  10820007   BEQ A0, V0, 0x9D016C68
9D016C4C  24020001   ADDIU V0, ZERO, 1
2630:                    {
2631:                        /* Driver handle is not valid */
2632:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2633:                
2634:                    }
2635:                    else if(!(pUSBDrvObj->isOpened))
9D016C50  90830001   LBU V1, 1(A0)
9D016C54  10600004   BEQ V1, ZERO, 0x9D016C68
9D016C58  00000000   NOP
2636:                    {
2637:                        /* Driver has not been opened. Handle could be stale */
2638:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2639:                    }
2640:                    else
2641:                    {
2642:                        /* Return false if the driver is still resetting*/
2643:                        result = (pUSBDrvObj->isResetting) ? false : true;
9D016C5C  90820164   LBU V0, 356(A0)
9D016C60  03E00008   JR RA
9D016C64  38420001   XORI V0, V0, 1
2644:                    }
2645:                
2646:                    return(result);
2647:                }
9D016C68  03E00008   JR RA
2648:                
2649:                // ****************************************************************************
2650:                /* Function:
2651:                    void DRV_USBHS_ROOT_HUB_PortReset(DRV_HANDLE handle, uint8_t port );
2652:                    
2653:                  Summary:
2654:                    Resets the specified root hub port.
2655:                	
2656:                  Description:
2657:                    This function resets the root hub port. The reset duration is defined by
2658:                    DRV_USBHS_ROOT_HUB_RESET_DURATION. The status of the reset signalling can be
2659:                    checked using the DRV_USBHS_ROOT_HUB_PortResetIsComplete() function.
2660:                	
2661:                  Remarks:
2662:                    Refer to drv_usbfs.h for usage information.
2663:                */
2664:                
2665:                USB_ERROR DRV_USBHS_HOST_ROOT_HUB_PortReset(DRV_HANDLE handle, uint8_t port)
2666:                {
2667:                    DRV_USBHS_OBJ * pUSBDrvObj = (DRV_USBHS_OBJ *)handle;
2668:                    USB_ERROR result = USB_ERROR_NONE;
9D016010  03E00008   JR RA
9D016014  00001021   ADDU V0, ZERO, ZERO
2669:                
2670:                    if(DRV_HANDLE_INVALID == handle)
9D015FCC  2402FFFF   ADDIU V0, ZERO, -1
9D015FD0  10820011   BEQ A0, V0, 0x9D016018
9D015FD4  00000000   NOP
2671:                    {
2672:                        /* Driver handle is not valid */
2673:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2674:                        result = USB_ERROR_PARAMETER_INVALID;
9D016018  03E00008   JR RA
9D01601C  2402FF83   ADDIU V0, ZERO, -125
2675:                
2676:                    }
2677:                    else if(!(pUSBDrvObj->isOpened))
9D015FD8  90820001   LBU V0, 1(A0)
9D015FDC  50400010   BEQL V0, ZERO, 0x9D016020
9D015FE0  2402FF83   ADDIU V0, ZERO, -125
2678:                    {
2679:                        /* Driver has not been opened. Handle could be stale */
2680:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2681:                        result = USB_ERROR_PARAMETER_INVALID;
2682:                    }
2683:                    else if(pUSBDrvObj->isResetting)
9D015FE4  90830164   LBU V1, 356(A0)
9D015FE8  1460000D   BNE V1, ZERO, 0x9D016020
9D015FEC  00001021   ADDU V0, ZERO, ZERO
2684:                    {
2685:                        /* This means a reset is alredy in progress. Lets not do anything. */
2686:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Reset already in progress");
2687:                
2688:                    }
2689:                    else
2690:                    {
2691:                        /* Start the reset signal. Set the driver flag to indicate the reset
2692:                         * signal is in progress. Enable the 1 millisecond timer interrupt to
2693:                         * count the reset duration. Clear the reset duration counter. This
2694:                         * counter will be updated in the interrupt. Start generating the reset
2695:                         * signal. */
2696:                        
2697:                        pUSBDrvObj->isResetting = true;
9D015FF0  24020001   ADDIU V0, ZERO, 1
9D015FF4  A0820164   SB V0, 356(A0)
2698:                        pUSBDrvObj->resetState = DRV_USBHS_HOST_RESET_STATE_START;
9D015FF8  24050001   ADDIU A1, ZERO, 1
9D015FFC  AC850168   SW A1, 360(A0)
2699:                        PLIB_USBHS_ResetEnable(pUSBDrvObj->usbID);
2700:                    }
2701:                
2702:                    return(result);
2703:                }
9D016020  03E00008   JR RA
2704:                
2705:                // ****************************************************************************
2706:                /* Function:
2707:                    USB_SPEED DRV_USBHS_HOST_ROOT_HUB_PortSpeedGet
2708:                    (
2709:                        DRV_HANDLE handle,
2710:                        uint8_t port
2711:                    );
2712:                
2713:                  Summary:
2714:                    Returns the speed of at which the port is operating.
2715:                
2716:                  Description:
2717:                    This function returns the speed at which the port is operating.
2718:                
2719:                  Remarks:
2720:                    Refer to drv_usbhs.h for usage information.
2721:                */
2722:                
2723:                USB_SPEED DRV_USBHS_HOST_ROOT_HUB_PortSpeedGet(DRV_HANDLE handle, uint8_t port)
2724:                {
2725:                    DRV_USBHS_OBJ * pUSBDrvObj = (DRV_USBHS_OBJ *)handle;
2726:                    USB_SPEED speed = USB_SPEED_ERROR;
2727:                
2728:                    if(DRV_HANDLE_INVALID == handle)
9D016E70  2402FFFF   ADDIU V0, ZERO, -1
9D016E74  10820006   BEQ A0, V0, 0x9D016E90
9D016E78  00001021   ADDU V0, ZERO, ZERO
2729:                    {
2730:                        /* Driver handle is not valid */
2731:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2732:                    }
2733:                    else if(!(pUSBDrvObj->isOpened))
9D016E7C  90830001   LBU V1, 1(A0)
9D016E80  10600003   BEQ V1, ZERO, 0x9D016E90
9D016E84  00000000   NOP
2734:                    {
2735:                        /* Driver has not been opened. Handle could be stale */
2736:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "Bad Client or client closed");
2737:                    }
2738:                    else
2739:                    {
2740:                        /* The driver will not check if a device is connected. It is assumed
2741:                         * that the client has issued a port reset before calling this function
2742:                         */
2743:                
2744:                        speed = pUSBDrvObj->deviceSpeed;
9D016E88  03E00008   JR RA
9D016E8C  8C8200FC   LW V0, 252(A0)
2745:                    }
2746:                
2747:                    return(speed);
2748:                }
9D016E90  03E00008   JR RA
2749:                
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/driver/usb/usbhs/src/dynamic/drv_usbhs.c
1:                   /*******************************************************************************
2:                     USB Device Driver Core Routines
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbhs.c
9:                   
10:                    Summary:
11:                      USB Device Driver Dynamic Implementation of Core routines
12:                  
13:                    Description:
14:                      The USB device driver provides a simple interface to manage the USB
15:                      modules on Microchip microcontrollers.  This file Implements the core
16:                      interface routines for the USB driver.
17:                  
18:                      While building the driver from source, ALWAYS use this file in the build.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip  Technology  Inc.   All  rights  reserved.
24:                  
25:                  Microchip licenses to  you  the  right  to  use,  modify,  copy  and  distribute
26:                  Software only when embedded on a Microchip  microcontroller  or  digital  signal
27:                  controller  that  is  integrated  into  your  product  or  third  party  product
28:                  (pursuant to the  sublicense  terms  in  the  accompanying  license  agreement).
29:                  
30:                  You should refer  to  the  license  agreement  accompanying  this  Software  for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
34:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
38:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
40:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
41:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Include Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "driver/usb/usbhs/src/drv_usbhs_local.h"
53:                  #include "peripheral/ports/plib_ports.h"
54:                  
55:                  /************************************
56:                   * Driver instance object
57:                   ***********************************/
58:                  
59:                  DRV_USBHS_OBJ gDrvUSBObj[DRV_USBHS_INSTANCES_NUMBER];
60:                  
61:                  /*********************************
62:                   * Array of endpoint objects. Two 
63:                   * objects per endpoint 
64:                   ********************************/
65:                  
66:                  DRV_USBHS_DEVICE_ENDPOINT_OBJ gDrvUSBEndpoints [DRV_USBHS_INSTANCES_NUMBER] [DRV_USBHS_ENDPOINTS_NUMBER * 2];
67:                  
68:                  // *****************************************************************************
69:                  /* Function:
70:                      SYS_MODULE_OBJ DRV_USBHS_Initialize
71:                      ( 
72:                         const SYS_MODULE_INDEX index,
73:                         const SYS_MODULE_INIT * const init 
74:                      )
75:                  
76:                    Summary:
77:                      Dynamic impementation of DRV_USBHS_Initialize system interface function.
78:                  
79:                    Description:
80:                      This is the dynamic impementation of DRV_USBHS_Initialize system interface
81:                      function. Function performs the following task:
82:                      - Initializes the neccessary USB module as per the instance init data
83:                      - Updates internal data structure for the particular USB instance
84:                      - Returns the USB instance value as a handle to the system
85:                  
86:                    Remarks:
87:                      See drv_usbhs.h for usage information.
88:                  */
89:                  
90:                  SYS_MODULE_OBJ DRV_USBHS_Initialize 
91:                  ( 
92:                      const SYS_MODULE_INDEX  drvIndex,
93:                      const SYS_MODULE_INIT * const init
94:                  )
95:                  {
9D012A1C  3084FFFF   ANDI A0, A0, -1
96:                      /* Start of local variables */
97:                      DRV_USBHS_OBJ * drvObj;
98:                      USBHS_MODULE_ID  usbID;
99:                      DRV_USBHS_INIT * usbInit;
100:                     
101:                     /* End of local variables */
102:                     if( drvIndex >= DRV_USBHS_INSTANCES_NUMBER)
9D012A20  14800035   BNE A0, ZERO, 0x9D012AF8
9D012A24  2402FFFF   ADDIU V0, ZERO, -1
103:                     {
104:                         SYS_DEBUG(SYS_ERROR_INFO,"Increase the value of DRV_USBHS_INSTANCES_NUMBER");
105:                         return SYS_MODULE_OBJ_INVALID;
106:                     }
107:                     
108:                     if(gDrvUSBObj[drvIndex].inUse == true)
9D012A28  3C028000   LUI V0, -32768
9D012A2C  90430448   LBU V1, 1096(V0)
9D012A30  14600031   BNE V1, ZERO, 0x9D012AF8
9D012A34  2402FFFF   ADDIU V0, ZERO, -1
109:                     {
110:                         /* Cannot initialize an object that is already in use. */
111:                 
112:                         SYS_DEBUG(SYS_ERROR_INFO, "Instance already in use");
113:                         return SYS_MODULE_OBJ_INVALID;
114:                     }
115:                 
116:                 
117:                     usbInit     = (DRV_USBHS_INIT *) init;
118:                 	
119:                 	/* User needs to assign the peripheral ID of the USB HS module to the usbID
120:                        member of the DRV_USBHS_INIT structure. Peripheral ID assigned should be 
121:                 	   one of the member of USBHS_MODULE_ID enumeration. The following code is 
122:                 	   to provide backward compatibility with the applications where they have 
123:                 	   specified usbID as 0. */ 
124:                 
125:                 	if (usbInit->usbID == 0)
9D012A38  8CA20004   LW V0, 4(A1)
9D012A3C  14400003   BNE V0, ZERO, DRV_USBHS_Initialize::OSAL_MUTEX_Create
9D012A40  00403021   ADDU A2, V0, ZERO
126:                 	{
127:                         /* For the optimized PLIBs, USBHS_ID_X is a pointer to the USB module
128:                          * base address. */
129:                 
130:                 		usbID = USBHS_ID_0; 
9D012A44  3C06BF8E   LUI A2, -16498
9D012A48  24C63000   ADDIU A2, A2, 12288
131:                 	}
132:                     else
133:                     {
134:                         /* No change required */
135:                         usbID = usbInit->usbID;
136:                     }
137:                 
138:                     drvObj = &gDrvUSBObj[drvIndex];
139:                 
140:                     OSAL_ASSERT(if(OSAL_MUTEX_Create(&drvObj->mutexID) == OSAL_RESULT_TRUE), "Mutex create failed");
141:                 
142:                     /* Populate the driver object with the required data */
143:                 
144:                     drvObj->inUse   = true;
9D012A5C  A0640448   SB A0, 1096(V1)
145:                     drvObj->status  = SYS_STATUS_BUSY; 
9D012A60  24030001   ADDIU V1, ZERO, 1
9D012A64  AC43004C   SW V1, 76(V0)
146:                     drvObj->usbID   = usbID;            
9D012A68  AC46005C   SW A2, 92(V0)
147:                     drvObj->operationMode  = usbInit->operationMode; 
9D012A6C  8CA30018   LW V1, 24(A1)
9D012A70  AC430060   SW V1, 96(V0)
148:                     drvObj->operationSpeed = usbInit->operationSpeed;
9D012A74  8CA40014   LW A0, 20(A1)
9D012A78  AC440054   SW A0, 84(V0)
149:                 
150:                     /* Assign the endpoint table */
151:                     drvObj->endpointTable = &gDrvUSBEndpoints[drvIndex][0];
9D012A7C  3C048000   LUI A0, -32768
9D012A80  24840428   ADDIU A0, A0, 1064
9D012A84  AC440070   SW A0, 112(V0)
152:                     drvObj->interruptSource  = usbInit->interruptSource;
9D012A88  8CA4000C   LW A0, 12(A1)
9D012A8C  AC440064   SW A0, 100(V0)
153:                     
154:                     drvObj->rootHubInfo.rootHubAvailableCurrent = usbInit->rootHubAvailableCurrent;
9D012A90  8CA40020   LW A0, 32(A1)
9D012A94  AC440178   SW A0, 376(V0)
155:                     drvObj->rootHubInfo.portIndication = usbInit->portIndication;
9D012A98  8CA40028   LW A0, 40(A1)
9D012A9C  AC440170   SW A0, 368(V0)
156:                     drvObj->rootHubInfo.portOverCurrentDetect = usbInit->portOverCurrentDetect;
9D012AA0  8CA4002C   LW A0, 44(A1)
9D012AA4  AC44016C   SW A0, 364(V0)
157:                     drvObj->rootHubInfo.portPowerEnable = usbInit->portPowerEnable;
9D012AA8  8CA40024   LW A0, 36(A1)
9D012AAC  AC440174   SW A0, 372(V0)
158:                 
159:                     drvObj->isOpened = false;
9D012AB0  A0400001   SB ZERO, 1(V0)
160:                     drvObj->pEventCallBack = NULL;
9D012AB4  AC400120   SW ZERO, 288(V0)
161:                 
162:                     drvObj->interruptSourceUSBDma = usbInit->interruptSourceUSBDma;
9D012AB8  8CA40010   LW A0, 16(A1)
9D012ABC  AC440068   SW A0, 104(V0)
163:                 
164:                     if(drvObj->operationMode == DRV_USBHS_OPMODE_HOST)
9D012AC0  24020002   ADDIU V0, ZERO, 2
9D012AC4  54620006   BNEL V1, V0, 0x9D012AE0
9D012AC8  3C028000   LUI V0, -32768
165:                     {
166:                         /* For Host the ID pin needs to be pulle down */
167:                         PLIB_PORTS_ChangeNoticePullDownPerPortEnable( PORTS_ID_0, PORT_CHANNEL_F, PORTS_BIT_POS_3 );
168:                     }
169:                     
170:                     /* Set the starting VBUS level. */
171:                     drvObj->vbusLevel = USBHS_VBUS_SESSION_END;
9D012ADC  3C028000   LUI V0, -32768
9D012AE0  24420448   ADDIU V0, V0, 1096
9D012AE4  AC400124   SW ZERO, 292(V0)
172:                     drvObj->sessionInvalidEventSent = false;
9D012AE8  A0400128   SB ZERO, 296(V0)
173:                 
174:                     /* Set the state to indicate that the delay will be started */
175:                     drvObj->state = DRV_USBHS_TASK_STATE_STARTING_DELAY;
9D012AEC  24030001   ADDIU V1, ZERO, 1
9D012AF0  AC430114   SW V1, 276(V0)
176:                     
177:                     return ((SYS_MODULE_OBJ)drvIndex); 
9D012AF4  00001021   ADDU V0, ZERO, ZERO
178:                 
179:                 } /* end of DRV_USBHS_Initialize() */
9D012AF8  03E00008   JR RA
180:                 
181:                 // *****************************************************************************
182:                 /* Function:
183:                     void DRV_USBHS_Tasks(SYS_MODULE_OBJ object)
184:                 
185:                   Summary:
186:                     Dynamic impementation of DRV_USBHS_Tasks system interface function.
187:                 
188:                   Description:
189:                     This is the dynamic impementation of DRV_USBHS_Tasks system interface
190:                     function.
191:                 
192:                   Remarks:
193:                     See drv_usbhs.h for usage information.
194:                 */
195:                 
196:                 void DRV_USBHS_Tasks(SYS_MODULE_OBJ object)
197:                 {
9D00DE78  27BDFFE0   ADDIU SP, SP, -32
9D00DE7C  AFBF001C   SW RA, 28(SP)
9D00DE80  AFB20018   SW S2, 24(SP)
9D00DE84  AFB10014   SW S1, 20(SP)
9D00DE88  AFB00010   SW S0, 16(SP)
9D00DE8C  00808821   ADDU S1, A0, ZERO
198:                     /* Start of local variables */
199:                     DRV_USBHS_OBJ * hDriver; 
200:                     hDriver = &gDrvUSBObj[object];
9D00DE90  00041140   SLL V0, A0, 5
9D00DE94  000481C0   SLL S0, A0, 7
9D00DE98  02021023   SUBU V0, S0, V0
9D00DE9C  00441023   SUBU V0, V0, A0
9D00DEA0  00021080   SLL V0, V0, 2
9D00DEA4  3C108000   LUI S0, -32768
9D00DEA8  26100448   ADDIU S0, S0, 1096
9D00DEAC  02028021   ADDU S0, S0, V0
201:                     USBHS_MODULE_ID usbID = hDriver->usbID;
202:                     /* End of local variables */
203:                 
204:                     if(hDriver->status <= SYS_STATUS_UNINITIALIZED)
9D00DEB0  8E02004C   LW V0, 76(S0)
9D00DEB4  18400064   BLEZ V0, 0x9D00E048
9D00DEB8  8E12005C   LW S2, 92(S0)
205:                     {
206:                         /* Driver is not initialized */
207:                         return;
208:                     }
209:                 
210:                     /* Check the tasks state and maintain */
211:                     switch(hDriver->state)
9D00DEBC  8E020114   LW V0, 276(S0)
9D00DEC0  24030002   ADDIU V1, ZERO, 2
9D00DEC4  10430016   BEQ V0, V1, 0x9D00DF20
9D00DEC8  24030003   ADDIU V1, ZERO, 3
9D00DECC  1043003A   BEQ V0, V1, 0x9D00DFB8
9D00DED0  24030001   ADDIU V1, ZERO, 1
9D00DED4  1443005D   BNE V0, V1, 0x9D00E04C
9D00DED8  8FBF001C   LW RA, 28(SP)
212:                     {
213:                         case DRV_USBHS_TASK_STATE_STARTING_DELAY:
214:                 
215:                             /* On PI32MZ DA and EF devices, enable the global USB interrupt in 
216:                              * the USBCRCON register. */
217:                             _DRV_USBHS_CLOCK_CONTROL_GLOBAL_USB_INT_ENABLE(usbID);
218:                 
219:                             /* Start the delay here - 3 sec */
220:                             hDriver->timerHandle = SYS_TMR_DelayMS(_DRV_USBHS_MODULE_RESET_DURATION);
9D00DEF8  0F405BE0   JAL SYS_TMR_DelayMS
9D00DEFC  24040003   ADDIU A0, ZERO, 3
221:                  
222:                             if(hDriver->timerHandle != SYS_TMR_HANDLE_INVALID)
9D00DF00  2403FFFF   ADDIU V1, ZERO, -1
9D00DF04  10430050   BEQ V0, V1, 0x9D00E048
9D00DF08  AE020118   SW V0, 280(S0)
223:                             {
224:                                 /* Reset the PHY. This is a workaround
225:                                  * for an errata */
226:                                 PLIB_USBHS_SoftResetEnable(usbID);
227:                 
228:                                 /* Delay has started. Move to the next state */
229:                                 hDriver->state = DRV_USBHS_TASK_STATE_WAITING_FOR_DELAY_COMPLETE;
9D00DF14  24020002   ADDIU V0, ZERO, 2
9D00DF18  0B403812   J 0x9D00E048
9D00DF1C  AE020114   SW V0, 276(S0)
230:                             }
231:                 
232:                             break;
233:                 
234:                         case DRV_USBHS_TASK_STATE_WAITING_FOR_DELAY_COMPLETE:
235:                 
236:                             /* Check if the delay is complete */
237:                             if(SYS_TMR_DelayStatusGet(hDriver->timerHandle)) 
9D00DF20  0F405C13   JAL SYS_TMR_DelayStatusGet
9D00DF24  8E040118   LW A0, 280(S0)
9D00DF28  10400048   BEQ V0, ZERO, 0x9D00E04C
9D00DF2C  8FBF001C   LW RA, 28(SP)
238:                             {
239:                                 /* This means the delay is complete. Clear the Soft Reset  */
240:                                 PLIB_USBHS_SoftResetDisable(usbID);
241:                 
242:                                 /* Setup the USB Module based on the selected
243:                                  * mode */
244:                 
245:                                 switch(hDriver->operationMode)
9D00DF34  8E030060   LW V1, 96(S0)
9D00DF38  24020002   ADDIU V0, ZERO, 2
9D00DF3C  54620005   BNEL V1, V0, DRV_USBHS_Tasks::PLIB_INT_SourceFlagClear
9D00DF40  8E020064   LW V0, 100(S0)
246:                                 {
247:                                     case DRV_USBHS_OPMODE_DEVICE:
248:                                         
249:                                         /* Configure the driver object for device mode operation.
250:                                          * In the PIC32MZ DA devices, the USBCRCON register needs
251:                                          * to configured */
252:                                         
253:                                         _DRV_USBHS_CLOCK_CONTROL_SETUP_DEVICE_MODE
254:                                         _DRV_USBHS_DEVICE_INIT(hDriver, object);
255:                                         break;
256:                                         
257:                                     case DRV_USBHS_OPMODE_HOST:
258:                                        
259:                                         /* Configure the driver object for host mode operation.
260:                                          * In the PICMZ DA devices, the USBCRCON register needs
261:                                          * to configured. */
262:                                         _DRV_USBHS_HOST_INIT(hDriver, object);
9D00DF44  02002021   ADDU A0, S0, ZERO
9D00DF48  0F40577C   JAL _DRV_USBHS_HOST_Initialize
9D00DF4C  3225FFFF   ANDI A1, S1, -1
263:                                         _DRV_USBHS_CLOCK_CONTROL_SETUP_HOST_MODE
264:                                                        
265:                                         break;
266:                                         
267:                                     case DRV_USBHS_OPMODE_OTG:
268:                                         break;
269:                                     default:
270:                                         SYS_DEBUG(SYS_ERROR_INFO, "What mode are you trying?");
271:                                         break;
272:                                 }
273:                 
274:                                 /* Clear and enable the interrupts */
275:                                 _DRV_USBHS_InterruptSourceClear(hDriver->interruptSource);
9D00DF50  8E020064   LW V0, 100(S0)
276:                                 _DRV_USBHS_InterruptSourceEnable(hDriver->interruptSource);
277:                                 
278:                                 _DRV_USBHS_InterruptSourceClear(hDriver->interruptSourceUSBDma);
9D00DF84  8E020068   LW V0, 104(S0)
279:                                 _DRV_USBHS_InterruptSourceEnable(hDriver->interruptSourceUSBDma);
280:                 
281:                 
282:                                 /* Indicate that the object is ready and change the state to running
283:                                  * */
284:                 
285:                                 hDriver->status = SYS_STATUS_READY;
9D00DFA4  24020002   ADDIU V0, ZERO, 2
9D00DFA8  AE02004C   SW V0, 76(S0)
286:                                 hDriver->state = DRV_USBHS_TASK_STATE_RUNNING;
9D00DFAC  24020003   ADDIU V0, ZERO, 3
9D00DFB0  0B403812   J 0x9D00E048
9D00DFB4  AE020114   SW V0, 276(S0)
287:                             }
288:                 
289:                             break;
290:                 
291:                         case DRV_USBHS_TASK_STATE_RUNNING:
292:                             /* The module is in a running state. In the polling mode the 
293:                              * driver ISR tasks and DMA ISR tasks are called here. We also
294:                              * check for the VBUS level and generate events if a client 
295:                              * event handler is registered. */
296:                 
297:                             if(hDriver->pEventCallBack != NULL && hDriver->operationMode == DRV_USBHS_OPMODE_DEVICE)
9D00DFB8  8E020120   LW V0, 288(S0)
9D00DFBC  5040001B   BEQL V0, ZERO, 0x9D00E02C
9D00DFC0  8E030060   LW V1, 96(S0)
9D00DFC4  8E040060   LW A0, 96(S0)
9D00DFC8  54830018   BNEL A0, V1, 0x9D00E02C
9D00DFCC  8E030060   LW V1, 96(S0)
298:                             {
299:                                 /* We have a valid client call back function. Check if
300:                                  VBUS level has changed */
301:                                 USBHS_VBUS_LEVEL vbusLevel = PLIB_USBHS_VBUSLevelGet(hDriver->usbID);
302:                                 if(hDriver->vbusLevel != vbusLevel)
9D00DFD8  8E030124   LW V1, 292(S0)
9D00DFDC  1071001A   BEQ V1, S1, 0x9D00E048
9D00DFE0  24030018   ADDIU V1, ZERO, 24
303:                                 {
304:                                     /* This means there was a change in the level */
305:                                     if(vbusLevel == USBHS_VBUS_VALID)
9D00DFE4  56230007   BNEL S1, V1, 0x9D00E004
9D00DFE8  92030128   LBU V1, 296(S0)
306:                                     {
307:                                         /* We have a valid VBUS level */
308:                                         hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBHS_EVENT_DEVICE_SESSION_VALID, NULL);
9D00DFEC  8E04011C   LW A0, 284(S0)
9D00DFF0  24050007   ADDIU A1, ZERO, 7
9D00DFF4  0040F809   JALR V0
9D00DFF8  00003021   ADDU A2, ZERO, ZERO
9D00DFFC  0B403809   J 0x9D00E024
9D00E000  A2000128   SB ZERO, 296(S0)
309:                                         
310:                                         /* We should be ready for send session invalid event
311:                                          * to the application when they happen.*/
312:                                         hDriver->sessionInvalidEventSent = false;
313:                 
314:                                     }
315:                                     else
316:                                     {
317:                                         /* Any thing other than valid is considered invalid.
318:                                          * This event may occur multiple times, but we send
319:                                          * it only once. */
320:                                         if(!hDriver->sessionInvalidEventSent)
9D00E004  54600010   BNEL V1, ZERO, 0x9D00E048
9D00E008  AE110124   SW S1, 292(S0)
321:                                         {
322:                                             hDriver->pEventCallBack(hDriver->hClientArg, DRV_USBHS_EVENT_DEVICE_SESSION_INVALID, NULL);
9D00E00C  8E04011C   LW A0, 284(S0)
9D00E010  24050008   ADDIU A1, ZERO, 8
9D00E014  0040F809   JALR V0
9D00E018  00003021   ADDU A2, ZERO, ZERO
323:                                             hDriver->sessionInvalidEventSent = true;
9D00E01C  24020001   ADDIU V0, ZERO, 1
9D00E020  A2020128   SB V0, 296(S0)
324:                                         }
325:                                     }
326:                 
327:                                     hDriver->vbusLevel = vbusLevel;
9D00E024  0B403812   J 0x9D00E048
9D00E028  AE110124   SW S1, 292(S0)
328:                                 }
329:                             }
330:                             else if(hDriver->operationMode == DRV_USBHS_OPMODE_HOST)
9D00E02C  24020002   ADDIU V0, ZERO, 2
9D00E030  14620006   BNE V1, V0, 0x9D00E04C
9D00E034  8FBF001C   LW RA, 28(SP)
331:                             {
332:                                 _DRV_USBHS_HOST_ATTACH_DETACH_STATE_MACHINE(hDriver);
9D00E038  0F4043F6   JAL _DRV_USBHS_HOST_AttachDetachStateMachine
9D00E03C  02002021   ADDU A0, S0, ZERO
333:                                 _DRV_USBHS_HOST_RESET_STATE_MACINE(hDriver);
9D00E040  0F4049D8   JAL _DRV_USBHS_HOST_ResetStateMachine
9D00E044  02002021   ADDU A0, S0, ZERO
334:                             }
335:                 
336:                             _DRV_USBHS_Tasks_ISR(object);
337:                             _DRV_USBHS_Tasks_ISR_USBDMA(object);
338:                             break;
339:                     }
340:                 }/* end of DRV_USBHS_Tasks() */
9D00E048  8FBF001C   LW RA, 28(SP)
341:                 
342:                 // *****************************************************************************
343:                 /* Function:
344:                     void DRV_USBHS_Deinitialize( const SYS_MODULE_OBJ object )
345:                 
346:                   Summary:
347:                     Dynamic impementation of DRV_USBHS_Deinitialize system interface function.
348:                 
349:                   Description:
350:                     This is the dynamic impementation of DRV_USBHS_Deinitialize system interface
351:                     function.
352:                 
353:                   Remarks:
354:                     See drv_usbhs.h for usage information.
355:                 */
356:                 
357:                 void DRV_USBHS_Deinitialize 
358:                 ( 
359:                     const SYS_MODULE_INDEX  object
360:                 )
361:                 {
00000000  00000000   NOP
00000018  00000000   NOP
362:                     /* Start of local variables */
363:                     DRV_USBHS_OBJ * drvObj;
364:                     bool returnValue = false;
365:                     /* End of local variables */
366:                 
367:                     if(object == SYS_MODULE_OBJ_INVALID)
368:                     {
369:                         /* Invalid object */
370:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBHS Driver: Invalid object in DRV_USBHS_Deinitialize()");
371:                     }
372:                     else
373:                     {
374:                         if( object >= DRV_USBHS_INSTANCES_NUMBER)
00000004  00000000   NOP
375:                         {
376:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBHS Driver: Invalid object in DRV_USBHS_Deinitialize()");
377:                         }
378:                         else
379:                         {
380:                             if(gDrvUSBObj[object].inUse == false)
0000000C  00000000   NOP
381:                             {
382:                                 /* Cannot de-initialize an object that is not already in use. */
383:                                 SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBHS Driver: Driver not initialized in DRV_USBHS_Deinitialize()");
384:                             }
385:                             else
386:                             {
387:                                 drvObj = &gDrvUSBObj[object];
388:                 
389:                                 /* Populate the driver object with the required data */
390:                 
391:                                 drvObj->inUse   = false;
00000024  00000000   NOP
392:                                 drvObj->status  = SYS_STATUS_UNINITIALIZED; 
0000002C  00000000   NOP
393:                 
394:                                 /* Clear and disable the interrupts. Assigning to a value has
395:                                  * been implemented to remove compiler warning in polling mode.
396:                                    */
397:                 
398:                                 returnValue = _DRV_USBHS_InterruptSourceDisable(drvObj->interruptSource);
00000034  00000000   NOP
399:                                 returnValue = returnValue;
400:                                 _DRV_USBHS_InterruptSourceClear(drvObj->interruptSource);
0000003C  00000000   NOP
401:                 
402:                                 drvObj->isOpened = false;
00000060  00000000   NOP
403:                                 drvObj->pEventCallBack = NULL;
00000064  00000000   NOP
404:                 
405:                                 /* Delete the mutex */
406:                                 if(OSAL_MUTEX_Delete(&drvObj->mutexID) != OSAL_RESULT_TRUE)
407:                                 {
408:                                     SYS_DEBUG_MESSAGE(SYS_ERROR_INFO,"\r\nUSBHS Driver: Could not delete mutex in DRV_USBHS_Deinitialize()");
409:                                 }
410:                             }
411:                         }
412:                     }
413:                 
414:                     return;
415:                 
416:                 } /* end of DRV_USBHS_Deinitialize() */
00000068  00000000   NOP
417:                 
418:                 // *****************************************************************************
419:                 /* Function:
420:                     SYS_STATUS DRV_USBHS_Status( const SYS_MODULE_OBJ object )
421:                 
422:                   Summary:
423:                     Dynamic implementation of DRV_USBHS_Status system interface function.
424:                 
425:                   Description:
426:                     This is the dynamic implementation of DRV_USBHS_Status system interface
427:                     function.
428:                 
429:                   Remarks:
430:                     See drv_usbhs.h for usage information.
431:                 */
432:                 
433:                 SYS_STATUS DRV_USBHS_Status ( SYS_MODULE_OBJ object )
434:                 {
435:                     SYS_STATUS result = SYS_STATUS_ERROR;
436:                 
437:                     if(object == SYS_MODULE_OBJ_INVALID)
00000000  00000000   NOP
438:                     {
439:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBHS Driver: System Module Object is invalid in DRV_USBHS_Status().");
440:                     }
441:                     else
442:                     {
443:                         result = gDrvUSBObj[object].status;
0000000C  00000000   NOP
444:                     }
445:                        
446:                     /* Return the status of the driver object */
447:                     return(result);
448:                 
449:                 }/* end of DRV_USBHS_Status() */
00000030  00000000   NOP
450:                 
451:                 
452:                 DRV_HANDLE DRV_USBHS_Open
453:                 (
454:                     const SYS_MODULE_INDEX iDriver,
455:                     const DRV_IO_INTENT    ioIntent 
456:                 )
457:                 {
9D0160E0  3084FFFF   ANDI A0, A0, -1
458:                     /* Start of local variables */
459:                     DRV_USBHS_OBJ * drvObj;
460:                     DRV_HANDLE handle = DRV_HANDLE_INVALID;
461:                     /* End of local variables */
462:                 
463:                     /* The iDriver value should be valid. It should be less the number of driver
464:                      * object instances.  */
465:                 
466:                     if(iDriver >= DRV_USBHS_INSTANCES_NUMBER)
9D0160E4  14800012   BNE A0, ZERO, 0x9D016130
9D0160E8  2402FFFF   ADDIU V0, ZERO, -1
467:                     {
468:                         SYS_DEBUG(SYS_ERROR_DEBUG, "\r\nUSBHS Driver: Bad Driver Index in DRV_USBHS_Open().");
469:                     }
470:                     else
471:                     {
472:                         drvObj = &gDrvUSBObj[iDriver];
473:                 
474:                         if(drvObj->status == SYS_STATUS_READY)
9D0160EC  3C028000   LUI V0, -32768
9D0160F0  8C440494   LW A0, 1172(V0)
9D0160F4  24030002   ADDIU V1, ZERO, 2
9D0160F8  1483000D   BNE A0, V1, 0x9D016130
9D0160FC  2402FFFF   ADDIU V0, ZERO, -1
475:                         {
476:                             if(ioIntent != (DRV_IO_INTENT_EXCLUSIVE|DRV_IO_INTENT_NONBLOCKING |DRV_IO_INTENT_READWRITE))
9D016100  2403000F   ADDIU V1, ZERO, 15
9D016104  14A3000A   BNE A1, V1, 0x9D016130
9D016108  00000000   NOP
477:                             {
478:                                 /* The driver only supports this mode */
479:                                 SYS_DEBUG(SYS_ERROR_DEBUG, "\r\nUSBHS Driver: Unsupported IO Intent in DRV_USBHS_Open().");
480:                             }
481:                             else
482:                             {
483:                                 if(drvObj->isOpened)
9D01610C  3C028000   LUI V0, -32768
9D016110  90430449   LBU V1, 1097(V0)
9D016114  14600006   BNE V1, ZERO, 0x9D016130
9D016118  2402FFFF   ADDIU V0, ZERO, -1
484:                                 {
485:                                     /* Driver supports exclusive open only */
486:                                     SYS_DEBUG(SYS_ERROR_DEBUG, "\r\nUSBHS Driver: Driver can be opened only once. Multiple calls to DRV_USBHS_Open().");
487:                                 }
488:                                 else
489:                                 {
490:                                     /* Clear prior value */
491:                                     drvObj->pEventCallBack = NULL;
9D01611C  3C028000   LUI V0, -32768
9D016120  24420448   ADDIU V0, V0, 1096
9D016124  AC400120   SW ZERO, 288(V0)
492:                 
493:                                     /* Store the handle in the driver object client table and update
494:                                      * the number of clients*/
495:                                     drvObj->isOpened = true;
9D016128  24030001   ADDIU V1, ZERO, 1
9D01612C  A0430001   SB V1, 1(V0)
496:                                     handle = ((DRV_HANDLE)drvObj);
497:                                     SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBHS Driver: Driver opened successfully in DRV_USBHS_Open().");
498:                                 }
499:                             }
500:                         }
501:                     }
502:                 
503:                     /* Return the client object */
504:                 
505:                     return (handle);
506:                 
507:                 }/* end of DRV_USBHS_Open() */
9D016130  03E00008   JR RA
508:                 
509:                 // *****************************************************************************
510:                 /* Function:
511:                     void DRV_USBHS_Close( DRV_HANDLE client )
512:                 
513:                   Summary:
514:                     Dynamic implementation of DRV_USBHS_Close client interface function.
515:                 
516:                   Description:
517:                     This is the dynamic implementation of DRV_USBHS_Close client interface
518:                     function.
519:                 
520:                   Remarks:
521:                     See drv_usbhs.h for usage information.
522:                 */
523:                 
524:                 void DRV_USBHS_Close( DRV_HANDLE client )
525:                 {
526:                     /* Start of local variables */
527:                     DRV_USBHS_OBJ * hDriver;
528:                     /* end of local variables */
529:                 
530:                     if(client == DRV_HANDLE_INVALID)
9D016DD0  2402FFFF   ADDIU V0, ZERO, -1
9D016DD4  10820006   BEQ A0, V0, 0x9D016DF0
9D016DD8  00000000   NOP
531:                     {
532:                         SYS_DEBUG(SYS_ERROR_INFO, "Bad Client Handle");
533:                         return;
534:                     }
535:                 
536:                     hDriver = (DRV_USBHS_OBJ *) client;
537:                     
538:                     if(!(hDriver->isOpened))
9D016DDC  90820001   LBU V0, 1(A0)
9D016DE0  10400003   BEQ V0, ZERO, 0x9D016DF0
9D016DE4  00000000   NOP
539:                     {
540:                         SYS_DEBUG(SYS_ERROR_INFO, "Invalid client handle");
541:                         return;
542:                     }
543:                     /* Give back the client */
544:                     hDriver->isOpened = false;
9D016DE8  A0800001   SB ZERO, 1(A0)
545:                     hDriver->pEventCallBack = NULL;
9D016DEC  AC800120   SW ZERO, 288(A0)
546:                 }/* end of DRV_USBHS_Close() */
547:                 
548:                 // *****************************************************************************
549:                 /* Function:
550:                     DRV_HANDLE DRV_USBHS_Tasks_ISR( SYS_MODULE_OBJ object )
551:                 
552:                   Summary:
553:                     Dynamic implementation of DRV_USBHS_Tasks_ISR system interface function.
554:                 
555:                   Description:
556:                     This is the dynamic implementation of DRV_USBHS_Tasks_ISR system interface
557:                     function.
558:                 
559:                   Remarks:
560:                     See drv_usbhs.h for usage information.
561:                 */
562:                 
563:                 void DRV_USBHS_Tasks_ISR( SYS_MODULE_OBJ object )
564:                 {
9D0152E4  27BDFFE8   ADDIU SP, SP, -24
9D0152E8  AFBF0014   SW RA, 20(SP)
9D0152EC  AFB00010   SW S0, 16(SP)
565:                     /* Start of local variables */
566:                     DRV_USBHS_OBJ * 	hDriver;
567:                     /* end of local variables */
568:                 
569:                     hDriver = &gDrvUSBObj[object];
9D0152F0  00041140   SLL V0, A0, 5
9D0152F4  000481C0   SLL S0, A0, 7
9D0152F8  02028023   SUBU S0, S0, V0
9D0152FC  02042023   SUBU A0, S0, A0
9D015300  00042080   SLL A0, A0, 2
9D015304  3C108000   LUI S0, -32768
9D015308  26100448   ADDIU S0, S0, 1096
9D01530C  02048021   ADDU S0, S0, A0
570:                     hDriver->isInInterruptContext = true;
9D015310  24020001   ADDIU V0, ZERO, 1
9D015314  A20200F4   SB V0, 244(S0)
571:                 
572:                 	switch(hDriver->operationMode)
9D015318  8E030060   LW V1, 96(S0)
9D01531C  24020002   ADDIU V0, ZERO, 2
9D015320  54620004   BNEL V1, V0, DRV_USBHS_Tasks_ISR::PLIB_INT_SourceFlagClear
9D015324  8E020064   LW V0, 100(S0)
573:                 	{
574:                         case DRV_USBHS_OPMODE_DEVICE:
575:                             _DRV_USBHS_DEVICE_TASKS_ISR(hDriver);
576:                             break;
577:                         case DRV_USBHS_OPMODE_HOST:
578:                             _DRV_USBHS_HOST_TASKS_ISR(hDriver);
9D015328  0F404448   JAL _DRV_USBHS_HOST_Tasks_ISR
9D01532C  02002021   ADDU A0, S0, ZERO
579:                             break;
580:                         case DRV_USBHS_OPMODE_OTG:
581:                             break;
582:                         default:
583:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBHS Driver: What mode are you trying?");
584:                             break;
585:                 	}	
586:                   
587:                     /* Clear the interrupt */
588:                     _DRV_USBHS_PersistentInterruptSourceClear(hDriver->interruptSource);
9D015330  8E020064   LW V0, 100(S0)
589:                     hDriver->isInInterruptContext = false;
9D015354  A20000F4   SB ZERO, 244(S0)
590:                 }/* end of DRV_USBHS_Tasks_ISR() */
9D015358  8FBF0014   LW RA, 20(SP)
591:                 
592:                 void DRV_USBHS_Tasks_ISR_USBDMA
593:                 (
594:                     SYS_MODULE_OBJ object
595:                 )
596:                 {
9D015368  27BDFFE8   ADDIU SP, SP, -24
9D01536C  AFBF0014   SW RA, 20(SP)
9D015370  AFB00010   SW S0, 16(SP)
597:                     /* Start of local variables */
598:                     DRV_USBHS_OBJ * 	hDriver;
599:                     /* end of local variables */
600:                 
601:                     hDriver = &gDrvUSBObj[object];
9D015374  00041140   SLL V0, A0, 5
9D015378  000481C0   SLL S0, A0, 7
9D01537C  02028023   SUBU S0, S0, V0
9D015380  02042023   SUBU A0, S0, A0
9D015384  00042080   SLL A0, A0, 2
9D015388  3C108000   LUI S0, -32768
9D01538C  26100448   ADDIU S0, S0, 1096
9D015390  02048021   ADDU S0, S0, A0
602:                     hDriver->isInInterruptContextUSBDMA = true;
9D015394  24020001   ADDIU V0, ZERO, 1
9D015398  A20200F5   SB V0, 245(S0)
603:                 
604:                 	switch(hDriver->operationMode)
9D01539C  8E030060   LW V1, 96(S0)
9D0153A0  24020002   ADDIU V0, ZERO, 2
9D0153A4  54620004   BNEL V1, V0, 0x9D0153B8
9D0153A8  A20000F5   SB ZERO, 245(S0)
605:                 	{
606:                         case DRV_USBHS_OPMODE_DEVICE:
607:                             _DRV_USBHS_DEVICE_TASKS_ISR_USBDMA(hDriver);
608:                             break;
609:                         case DRV_USBHS_OPMODE_HOST:
610:                             _DRV_USBHS_HOST_TASKS_ISR_USBDMA(hDriver);
9D0153AC  0F403020   JAL _DRV_USBHS_HOST_Tasks_ISR_USBDMA
9D0153B0  02002021   ADDU A0, S0, ZERO
611:                             break;
612:                         case DRV_USBHS_OPMODE_OTG:
613:                             break;
614:                         default:
615:                             SYS_DEBUG(SYS_ERROR_INFO, "What mode are you trying?");
616:                             break;
617:                 	}
618:                         
619:                     /* Clear the interrupt */
620:                     hDriver->isInInterruptContextUSBDMA = false;
9D0153B4  A20000F5   SB ZERO, 245(S0)
621:                     _DRV_USBHS_InterruptSourceClear(hDriver->interruptSourceUSBDma);
9D0153B8  8E020068   LW V0, 104(S0)
622:                 
623:                 }/* end of DRV_USBHS_Tasks_ISR()*/
9D0153DC  8FBF0014   LW RA, 20(SP)
624:                 
625:                 
626:                 void DRV_USBHS_ResumeControl(DRV_HANDLE hClient, bool control)
627:                 {
00000000  00000000   NOP
628:                     /* Start of local variables */
629:                     DRV_USBHS_OBJ * hDriver;
630:                     USBHS_MODULE_ID usbID;
631:                     /* end of local variables */
632:                 
633:                     if((hClient == DRV_HANDLE_INVALID))
634:                     {
635:                         SYS_DEBUG(SYS_ERROR_INFO, "Invalid client");
636:                     }
637:                 
638:                     hDriver = (DRV_USBHS_OBJ *)hClient;
639:                     usbID = hDriver->usbID;
640:                 
641:                     if(control)
00000004  00000000   NOP
642:                     {
643:                         PLIB_USBHS_ResumeEnable(usbID);
644:                     }
645:                     else
646:                     {
647:                         PLIB_USBHS_ResumeDisable(usbID);
648:                     }
649:                 }/* end of DRV_USBHS_ResumeControl() */
650:                 
651:                 // *****************************************************************************
652:                 /* Function:
653:                     bool DRV_USBHS_HOST_Resume(DRV_HANDLE handle)
654:                 
655:                   Summary:
656:                     Dynamic implementation of DRV_USBHS_HOST_Resume
657:                     client interface function.
658:                 
659:                   Description:
660:                     This is the dynamic implementation of DRV_USBHS_HOST_Resume client
661:                     interface function. Function resumes a suspended BUS.
662:                 
663:                   Remarks:
664:                     See drv_usbhs.h for usage information.
665:                 */
666:                 
667:                 bool DRV_USBHS_HOST_Resume
668:                 (
669:                     DRV_HANDLE handle
670:                 )
671:                 {
672:                     /* Start of local variable */
673:                     DRV_USBHS_OBJ * pusbdrvObj = (DRV_USBHS_OBJ *)NULL;
674:                     bool returnValue = false;
675:                     /* End of local variable */
676:                     
677:                     /* Check if the handle is valid */
678:                     if((handle == DRV_HANDLE_INVALID))
00000000  00000000   NOP
679:                     {
680:                         SYS_DEBUG(SYS_ERROR_INFO, "Bad Client or client closed");
681:                     }
682:                     else
683:                     {
684:                         pusbdrvObj = (DRV_USBHS_OBJ *)handle;
685:                 
686:                         PLIB_USBHS_ResumeEnable(pusbdrvObj->usbID);
687:                         returnValue = true;
00000020  00000000   NOP
688:                     }
689:                     return returnValue;
690:                 
691:                 }/* end of DRV_USBHS_HOST_Resume() */
00000028  00000000   NOP
692:                 
693:                 // *****************************************************************************
694:                 /* Function:
695:                     bool DRV_USBHS_HOST_Suspend(DRV_HANDLE handle)
696:                 
697:                   Summary:
698:                     Dynamic implementation of DRV_USBHS_HOST_Suspend
699:                     client interface function.
700:                 
701:                   Description:
702:                     This is the dynamic implementation of DRV_USBHS_HOST_Suspend client
703:                     interface function. Function suspends USB BUS.
704:                 
705:                   Remarks:
706:                     See drv_usbhs.h for usage information.
707:                 */
708:                 
709:                 bool DRV_USBHS_HOST_Suspend
710:                 (
711:                     DRV_HANDLE handle
712:                 )
713:                 {	
714:                     /* Start of local variable */
715:                     DRV_USBHS_OBJ * pusbdrvObj = (DRV_USBHS_OBJ *)NULL;
716:                     bool returnValue = false;
717:                     /* End of local variable */
718:                 
719:                     /* Check if the handle is valid */
720:                     if((handle == DRV_HANDLE_INVALID))
00000000  00000000   NOP
721:                     {
722:                         SYS_DEBUG(SYS_ERROR_INFO, "Bad Client or client closed");
723:                     }
724:                     else
725:                     {
726:                         pusbdrvObj = (DRV_USBHS_OBJ *)handle;
727:                 
728:                         /* Suspend the bus */
729:                         PLIB_USBHS_SuspendEnable(pusbdrvObj->usbID);
730:                         returnValue = true;
00000020  00000000   NOP
731:                     }
732:                     return returnValue;
733:                 
734:                 }/* end of DRV_USBHS_HOST_Suspend() */
00000028  00000000   NOP
735:                 
736:                 // *****************************************************************************
737:                 /* Function:
738:                     void DRV_USBHS_ClientEventCallBackSet
739:                     (
740:                         DRV_HANDLE   handle,
741:                         uintptr_t    hReferenceData,
742:                         DRV_USBHS_EVENT_CALLBACK eventCallBack
743:                     )
744:                 
745:                   Summary:
746:                     Dynamic implementation of DRV_USBHS_ClientEventCallBackSet client interface
747:                     function.
748:                 
749:                   Description:
750:                     This is the dynamic implementation of DRV_USBHS_ClientEventCallBackSet
751:                     client interface function.
752:                 
753:                   Remarks:
754:                     See drv_usbhs.h for usage information.
755:                 */
756:                 
757:                 void DRV_USBHS_ClientEventCallBackSet
758:                 ( 
759:                     DRV_HANDLE   client          ,
760:                     uintptr_t    hReferenceData ,
761:                     DRV_USB_EVENT_CALLBACK eventCallBack 
762:                 )
763:                 {
764:                     /* Start of local variable */
765:                     DRV_USBHS_OBJ * pusbDrvObj;
766:                     /* end of local variable */
767:                     
768:                     if(client == DRV_HANDLE_INVALID)
9D016DF8  2402FFFF   ADDIU V0, ZERO, -1
9D016DFC  10820006   BEQ A0, V0, 0x9D016E18
9D016E00  00000000   NOP
769:                     {
770:                         SYS_DEBUG(SYS_ERROR_INFO, "Bad Client Handle");
771:                         return;
772:                     }
773:                 
774:                     pusbDrvObj = (DRV_USBHS_OBJ *) client;
775:                     
776:                     if(!pusbDrvObj->isOpened)
9D016E04  90820001   LBU V0, 1(A0)
9D016E08  10400003   BEQ V0, ZERO, 0x9D016E18
9D016E0C  00000000   NOP
777:                     {
778:                         SYS_DEBUG(SYS_ERROR_INFO, "Invalid client handle");
779:                         return;
780:                     }
781:                 
782:                     /* Assign event call back and reference data */
783:                     pusbDrvObj->hClientArg = hReferenceData;
9D016E10  AC85011C   SW A1, 284(A0)
784:                     pusbDrvObj->pEventCallBack = eventCallBack;
9D016E14  AC860120   SW A2, 288(A0)
785:                    
786:                     return;
787:                     
788:                 }/* end of DRV_USBHS_ClientEventCallBackSet() */
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/framework/driver/tmr/src/dynamic/drv_tmr.c
1:                   /*******************************************************************************
2:                     Timer Device Driver dynamic implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr.c
9:                   
10:                    Summary:
11:                      Timer device driver dynamic implementation.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer 
15:                      modules on Microchip micro controllers.  This file implements the core 
16:                      interface routines for the Timer driver in dynamic mode. 
17:                      
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Include Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include <stddef.h>
53:                  #include <string.h>
54:                  #include "driver/tmr/src/drv_tmr_local.h"
55:                  #include "system/clk/sys_clk.h"
56:                  
57:                  // *****************************************************************************
58:                  // *****************************************************************************
59:                  // Section: File Scope Variables
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  
63:                  // each driver module can support multiple clients
64:                  //
65:                  typedef struct
66:                  {
67:                      DRV_TMR_MODULE_INSTANCE         tmrInstance;     // the current timer module
68:                      DRV_TMR_CLIENT_OBJ              tmrClients[1];   // Timer driver supports only Single Client. If you have multiple clients looking for timer, then use Timer System Service.
69:                  }DRV_TMR_MODULE_DESCRIPTOR;
70:                  
71:                  
72:                  static DRV_TMR_MODULE_DESCRIPTOR    gDrvTmrDcpt[DRV_TMR_INSTANCES_NUMBER];       // the supported timer modules
73:                  static unsigned int                 gDrvTmrInstances = 0;                        // current number of initialized instances 
74:                  
75:                  static const DRV_TMR_INIT defaultTmrInit = 
76:                  {
77:                      {SYS_MODULE_POWER_RUN_FULL},
78:                      TMR_ID_2,
79:                      DRV_TMR_CLKSOURCE_INTERNAL,
80:                      TMR_PRESCALE_VALUE_256,
81:                      DRV_TMR_OPERATION_MODE_16_BIT,
82:                      INT_SOURCE_TIMER_2,
83:                      false,
84:                  };
85:                  
86:                  
87:                  // *****************************************************************************
88:                  // *****************************************************************************
89:                  // Section: File Scope Functions
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  
93:                  static void DRV_TMR_ProcessEvents ( DRV_TMR_MODULE_DESCRIPTOR* pDcpt );
94:                  
95:                  
96:                  // sets a clean status
97:                  static void _DRV_TMR_ClientClear(DRV_TMR_CLIENT_OBJ* pObj)
98:                  {
99:                      pObj->alarmCallback = 0 ;
9D01392C  AE000034   SW ZERO, 52(S0)
00000034  00000000   NOP
100:                     pObj->alarmPeriodic = false;
9D013930  A2000028   SB ZERO, 40(S0)
00000038  00000000   NOP
101:                     pObj->pModInst->timerPeriod = 0;
9D013934  8E020024   LW V0, 36(S0)
0000003C  00000000   NOP
102:                     pObj->alarmCount = 0;
9D01393C  AE000030   SW ZERO, 48(S0)
00000044  00000000   NOP
103:                 
104:                     pObj->clientStatus = DRV_TMR_CLIENT_OBJ_READY;
9D013940  24020001   ADDIU V0, ZERO, 1
00000048  00000000   NOP
105:                 }
106:                 
107:                 // sets a client parameters
108:                 static void _DRV_TMR_ClientSetParams(
109:                         DRV_TMR_CLIENT_OBJ* pObj, 
110:                         uint32_t period, 
111:                         bool isPeriodic,                        
112:                         uintptr_t context, 
113:                         DRV_TMR_CALLBACK callBack
114:                 )
115:                 {
116:                     pObj->alarmCallback = callBack ;
9D01190C  8FA40038   LW A0, 56(SP)
117:                     pObj->alarmPeriodic = isPeriodic;
9D011914  A2140004   SB S4, 4(S0)
118:                     pObj->context = context;
9D011918  AE130014   SW S3, 20(S0)
119:                     pObj->pModInst->timerPeriod = period;
9D01191C  8E040000   LW A0, 0(S0)
120:                     pObj->alarmCount = 0;
121:                 }
122:                 
123:                 
124:                 static bool _DRV_TMR_Suspend(DRV_TMR_CLIENT_OBJ* pObj)
125:                 {
9D016290  27BDFFE8   ADDIU SP, SP, -24
9D016294  AFBF0014   SW RA, 20(SP)
9D016298  AFB00010   SW S0, 16(SP)
9D01629C  00808021   ADDU S0, A0, ZERO
126:                     if(pObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
9D0162A0  8C840008   LW A0, 8(A0)
9D0162A4  24030003   ADDIU V1, ZERO, 3
9D0162A8  14830009   BNE A0, V1, 0x9D0162D0
9D0162AC  00001021   ADDU V0, ZERO, ZERO
127:                     {
128:                         SYS_INT_SourceDisable( pObj->pModInst->interruptSource );
9D0162B0  8E020000   LW V0, 0(S0)
9D0162B4  0F40588F   JAL SYS_INT_SourceDisable
9D0162B8  8C440014   LW A0, 20(V0)
129:                         PLIB_TMR_Stop ( pObj->pModInst->tmrId );
9D0162BC  8E020000   LW V0, 0(S0)
130:                         return true;
9D0162CC  24020001   ADDIU V0, ZERO, 1
131:                     }
132:                 
133:                     return false;
134:                 }
9D0162D0  8FBF0014   LW RA, 20(SP)
135:                 
136:                 static void _DRV_TMR_Resume(DRV_TMR_CLIENT_OBJ* pObj, bool resume)
137:                 {
138:                     if(resume)
9D015BF8  10A00017   BEQ A1, ZERO, 0x9D015C58
9D015BFC  3C05BF81   LUI A1, -16511
139:                     {
140:                         SYS_INT_SourceStatusClear ( pObj->pModInst->interruptSource );
9D015C00  8C820000   LW V0, 0(A0)
9D015C04  8C420014   LW V0, 20(V0)
141:                         SYS_INT_SourceEnable( pObj->pModInst->interruptSource );
9D015C24  8C820000   LW V0, 0(A0)
9D015C28  8C420014   LW V0, 20(V0)
142:                 
143:                         /* Start the Timer */
144:                         PLIB_TMR_Start ( pObj->pModInst->tmrId );
9D015C48  8C820000   LW V0, 0(A0)
145:                     }
146:                 }
147:                 
148:                 // releases a client
149:                 static __inline__ void __attribute__((always_inline)) _DRV_TMR_ClientDelete(DRV_TMR_CLIENT_OBJ* pObj, bool suspend)
150:                 {
151:                     if(suspend)
152:                     {
153:                         _DRV_TMR_Suspend(pObj);
9D016524  0F4058A4   JAL _DRV_TMR_Suspend
9D016528  00000000   NOP
00000030  00000000   NOP
154:                     }
155:                     // add other delete code here
156:                     pObj->clientStatus = DRV_TMR_CLIENT_OBJ_CLOSED;
9D01652C  AE000008   SW ZERO, 8(S0)
00000038  00000000   NOP
157:                 }
158:                 
159:                 static bool _DRV_TMR_ClockSourceSet(TMR_MODULE_ID timerId, DRV_TMR_CLK_SOURCES clockSource)
160:                 {
9D01284C  27BDFFE8   ADDIU SP, SP, -24
161:                     bool clockSet = true;
9D012864  0B404A4A   J 0x9D012928
9D012868  24020001   ADDIU V0, ZERO, 1
9D0128C8  0B404A4A   J 0x9D012928
9D0128CC  24020001   ADDIU V0, ZERO, 1
9D012914  0B404A4A   J 0x9D012928
9D012918  24020001   ADDIU V0, ZERO, 1
9D012924  24020001   ADDIU V0, ZERO, 1
162:                     /* Clock Source Selection */
163:                     if(clockSource == DRV_TMR_CLKSOURCE_INTERNAL)
9D012850  14A00006   BNE A1, ZERO, 0x9D01286C
9D012854  AFBF0014   SW RA, 20(SP)
164:                     {
165:                         if ( PLIB_TMR_ExistsClockSource ( timerId ) )
166:                         {               
167:                             PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );           
168:                         }
169:                         else
170:                         {
171:                             /* If clock source feature doesn't exist for any specific timer module instance,
172:                             then by default internal peripheral clock is considered as timer source, so do nothing */ 
173:                         }
174:                     }
175:                     /* External Synchronous Clock Source Selection */
176:                     else if(!(clockSource & 0x10))
9D01286C  30A20010   ANDI V0, A1, 16
9D012870  14400017   BNE V0, ZERO, 0x9D0128D0
9D012874  3C03BF84   LUI V1, -16508
177:                     {
178:                         if ( PLIB_TMR_ExistsClockSource ( timerId ) )
179:                         {               
180:                             if ( PLIB_TMR_ExistsClockSourceSync ( timerId )  )
9D012878  3C02BF84   LUI V0, -16508
9D01287C  1482000D   BNE A0, V0, 0x9D0128B4
9D012880  24030001   ADDIU V1, ZERO, 1
181:                             {
182:                                 _DRV_TMR_CLOCK_SOURCE_SELECT ( timerId, clockSource );               
9D012894  30A5000F   ANDI A1, A1, 15
9D012898  24020002   ADDIU V0, ZERO, 2
9D01289C  54A2001B   BNEL A1, V0, _DRV_TMR_ClockSourceSet::PLIB_TMR_ClockSourceExternalSyncEnable
9D0128A0  24030004   ADDIU V1, ZERO, 4
9D0128A4  0F405950   JAL SYS_CLK_SecondaryOscillatorEnable
9D0128A8  00000000   NOP
183:                                 PLIB_TMR_ClockSourceExternalSyncEnable ( timerId );                    
184:                             }
185:                             /* If Synchronization feature doesn't exist for any specific timer module 
186:                             instance with external clock source then it is synchronous by default */
187:                             else if (clockSource == DRV_TMR_CLKSOURCE_EXTERNAL_SYNCHRONOUS)
9D0128B4  14A3001C   BNE A1, V1, 0x9D012928
9D0128B8  00001021   ADDU V0, ZERO, ZERO
188:                             {
189:                                 PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_EXTERNAL_INPUT_PIN );
190:                             }
191:                             else
192:                             {
193:                                 clockSet = false;
194:                             }  
195:                         }
196:                         else
197:                         {
198:                             clockSet = false;
199:                         }        
200:                     }
201:                     /* External Asynchronous Clock Source Selection */
202:                     else if(clockSource & 0x10)
203:                     {
204:                         if ( PLIB_TMR_ExistsClockSourceSync ( timerId ) )
9D0128D0  14830015   BNE A0, V1, 0x9D012928
9D0128D4  00001021   ADDU V0, ZERO, ZERO
205:                         {
206:                             _DRV_TMR_CLOCK_SOURCE_SELECT ( timerId, clockSource );               
9D0128EC  30A5000F   ANDI A1, A1, 15
9D0128F0  24020002   ADDIU V0, ZERO, 2
9D0128F4  54A20009   BNEL A1, V0, _DRV_TMR_ClockSourceSet::PLIB_TMR_ClockSourceExternalSyncDisable
9D0128F8  24030004   ADDIU V1, ZERO, 4
9D0128FC  0F405950   JAL SYS_CLK_SecondaryOscillatorEnable
9D012900  00000000   NOP
207:                             PLIB_TMR_ClockSourceExternalSyncDisable ( timerId );
208:                         }
209:                         else
210:                         {
211:                             clockSet = false;
212:                         }        
213:                     }
214:                     
215:                     return clockSet;
216:                 }
9D012928  8FBF0014   LW RA, 20(SP)
217:                 
218:                 // Prescaler selection
219:                 static bool _DRV_TMR_ClockPrescaleSet(TMR_MODULE_ID timerId, TMR_PRESCALE  prescale)
220:                 {
221:                     if( PLIB_TMR_ExistsPrescale( timerId ) )
222:                     {
223:                         PLIB_TMR_PrescaleSelect( timerId , prescale );
224:                         return true;
225:                     }
226:                     return false;
227:                 }
9D013B14  03E00008   JR RA
9D013B18  24020001   ADDIU V0, ZERO, 1
9D013B30  03E00008   JR RA
9D013B34  24020001   ADDIU V0, ZERO, 1
9D013B44  03E00008   JR RA
9D013B48  24020001   ADDIU V0, ZERO, 1
9D013B5C  03E00008   JR RA
9D013B60  24020001   ADDIU V0, ZERO, 1
9D013B74  03E00008   JR RA
9D013B78  24020001   ADDIU V0, ZERO, 1
9D013B8C  03E00008   JR RA
9D013B90  24020001   ADDIU V0, ZERO, 1
9D013BA0  24020001   ADDIU V0, ZERO, 1
228:                 
229:                 // Timer operation mode
230:                 static bool _DRV_TMR_OperModeSet(TMR_MODULE_ID timerId, DRV_TMR_OPERATION_MODE  operMode, bool update)
231:                 {
232:                 
233:                     if(operMode == DRV_TMR_OPERATION_MODE_16_BIT)
9D00EF50  24030001   ADDIU V1, ZERO, 1
9D00EF54  54430008   BNEL V0, V1, DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D00EF58  24030002   ADDIU V1, ZERO, 2
234:                     {
235:                 #if defined(PLIB_TMR_ExistsMode16Bit)
236:                         if ( PLIB_TMR_ExistsMode16Bit ( timerId ) )
237:                         {
238:                             if(update)
239:                             {
240:                                 PLIB_TMR_Mode16BitEnable( timerId );
241:                             }
242:                         }
243:                 #endif
244:                         // assume that 16 bit mode is always supported!
245:                         return true;
246:                     }
247:                     else if(operMode == DRV_TMR_OPERATION_MODE_32_BIT)
9D00EF78  14430017   BNE V0, V1, 0x9D00EFD8
9D00EF7C  3C028001   LUI V0, -32767
248:                     {
249:                 #if defined(PLIB_TMR_ExistsMode32Bit)
250:                         if ( PLIB_TMR_ExistsMode32Bit ( timerId ) )
9D00EF84  50400014   BEQL V0, ZERO, 0x9D00EFD8
9D00EF88  3C028001   LUI V0, -32767
251:                         {
252:                             if(update)
253:                             {
254:                                 PLIB_TMR_Mode32BitEnable ( timerId );
255:                             }
256:                             return true;
257:                         }
258:                 #endif
259:                     }
260:                 
261:                     // unsupported mode
262:                     return false;
263:                 }
264:                 
265:                 static bool _DRV_TMR_InstanceSetup ( DRV_TMR_MODULE_INSTANCE *pTmrInst)
266:                 {    
267:                     TMR_MODULE_ID timerId = pTmrInst->tmrId;
268:                 
269:                     /* 1. Clock Source Selection and prescaler */
270:                     if(!_DRV_TMR_ClockSourceSet(timerId, pTmrInst->clockSource))
9D00EF20  0F404A13   JAL _DRV_TMR_ClockSourceSet
9D00EF24  02002021   ADDU A0, S0, ZERO
9D00EF28  1040002B   BEQ V0, ZERO, 0x9D00EFD8
9D00EF2C  3C028001   LUI V0, -32767
271:                     {
272:                         return false;
273:                     }
274:                 
275:                     /* 2. Prescaler */
276:                     if(!_DRV_TMR_ClockPrescaleSet(timerId, pTmrInst->prescale))
9D00EF30  02002021   ADDU A0, S0, ZERO
9D00EF34  3C028001   LUI V0, -32767
9D00EF38  0F404EBA   JAL _DRV_TMR_ClockPrescaleSet
9D00EF3C  8C454DE4   LW A1, 19940(V0)
9D00EF40  10400025   BEQ V0, ZERO, 0x9D00EFD8
9D00EF44  3C028001   LUI V0, -32767
277:                     {
278:                         return false;
279:                     }
280:                 
281:                     /* 3. Timer operation mode */
282:                     if(!_DRV_TMR_OperModeSet(timerId, pTmrInst->operMode, true))
9D00EF48  3C028001   LUI V0, -32767
9D00EF4C  8C424DF8   LW V0, 19960(V0)
283:                     {
284:                         return false;
285:                     }
286:                 
287:                     /* 4. Asynchronous Write Control */
288:                 #if defined(PLIB_TMR_ExistsCounterAsyncWriteControl)
289:                     if( PLIB_TMR_ExistsCounterAsyncWriteControl ( timerId ) )
9D00EF70  0B403BF2   J DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D00EF74  3C02BF84   LUI V0, -16508
9D00EF94  0B403BF2   J DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D00EF98  3C02BF84   LUI V0, -16508
9D00EFC8  1202FFF4   BEQ S0, V0, DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D00EFCC  3C028001   LUI V0, -32767
290:                     {
291:                         if( pTmrInst->asyncWriteEnable)
9D00EF9C  90424DFC   LBU V0, 19964(V0)
9D00EFA0  10400005   BEQ V0, ZERO, DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D00EFA4  24031000   ADDIU V1, ZERO, 4096
292:                         {
293:                             PLIB_TMR_CounterAsyncWriteEnable ( timerId );
294:                         }
295:                         else 
296:                         {
297:                             PLIB_TMR_CounterAsyncWriteDisable ( timerId );
298:                         }
299:                     }
300:                 #endif
301:                 
302:                 
303:                     /* Successfully initialized */
304:                     return true;
305:                 
306:                 }
307:                 
308:                 static bool _DRV_TMR_RootInitialize(void)
309:                 {
310:                     memset(&gDrvTmrDcpt, 0, sizeof(gDrvTmrDcpt));
9D00EE9C  3C048001   LUI A0, -32767
311:                 
312:                     return true;
313:                 }
314:                 
315:                 static /*__inline__*/ DRV_TMR_MODULE_DESCRIPTOR* /*__attribute__((always_inline))*/ _DRV_TMR_ModuleObj(SYS_MODULE_OBJ object, bool checkReady)
316:                 {
317:                     if(gDrvTmrInstances != 0)
9D015260  8F82804C   LW V0, -32692(GP)
9D015264  10400019   BEQ V0, ZERO, 0x9D0152CC
9D015268  00000000   NOP
318:                     {   // module initialized
319:                         DRV_TMR_MODULE_DESCRIPTOR* pDcpt = (DRV_TMR_MODULE_DESCRIPTOR*)object;
320:                 
321:                         /* check the validity of the handle */
322:                         if(pDcpt - gDrvTmrDcpt  <= sizeof(gDrvTmrDcpt)/sizeof(*gDrvTmrDcpt))
9D01526C  3C028001   LUI V0, -32767
9D015270  24424DDC   ADDIU V0, V0, 19932
9D015274  00821023   SUBU V0, A0, V0
9D015278  00021083   SRA V0, V0, 2
9D01527C  00021900   SLL V1, V0, 4
9D015280  00621021   ADDU V0, V1, V0
9D015284  00021A00   SLL V1, V0, 8
9D015288  00431021   ADDU V0, V0, V1
9D01528C  00021C00   SLL V1, V0, 16
9D015290  00431021   ADDU V0, V0, V1
9D015294  00021023   SUBU V0, ZERO, V0
9D015298  2C420002   SLTIU V0, V0, 2
9D01529C  1040000D   BEQ V0, ZERO, 0x9D0152D4
9D0152A0  00000000   NOP
323:                         {
324:                             if(pDcpt->tmrInstance.inUse != false)
9D0152A4  90820018   LBU V0, 24(A0)
9D0152A8  5040000C   BEQL V0, ZERO, 0x9D0152DC
9D0152AC  00001021   ADDU V0, ZERO, ZERO
325:                             {
326:                                 if(checkReady == false || pDcpt->tmrInstance.status == SYS_STATUS_READY)
9D0152B0  10A0000A   BEQ A1, ZERO, 0x9D0152DC
9D0152B4  00801021   ADDU V0, A0, ZERO
9D0152B8  8C820000   LW V0, 0(A0)
327:                                 {   // success
328:                                     return pDcpt;
329:                                 }
330:                             }
331:                         }
332:                     }
333:                 
334:                     return 0;
9D0152BC  38420002   XORI V0, V0, 2
9D0152C0  0002200B   MOVN A0, ZERO, V0
9D0152C4  03E00008   JR RA
9D0152C8  00801021   ADDU V0, A0, ZERO
9D0152CC  03E00008   JR RA
9D0152D0  00001021   ADDU V0, ZERO, ZERO
9D0152D4  03E00008   JR RA
9D0152D8  00001021   ADDU V0, ZERO, ZERO
335:                 }
9D0152DC  03E00008   JR RA
336:                 
337:                 static void DRV_TMR_ProcessEvents ( DRV_TMR_MODULE_DESCRIPTOR* pDcpt )
338:                 {
339:                     DRV_TMR_MODULE_INSTANCE* pTmrInst = &pDcpt->tmrInstance;
340:                 
341:                     /* Check if the Timer Interrupt/Status is set */
342:                     if ( SYS_INT_SourceStatusGet ( pTmrInst->interruptSource ) != false )
9D0138AC  8C420014   LW V0, 20(V0)
9D0138D4  1080001D   BEQ A0, ZERO, 0x9D01394C
343:                     {
344:                         /* Clear Timer Interrupt/Status Flag */
345:                         SYS_INT_SourceStatusClear ( pTmrInst->interruptSource );
346:                 
347:                         // process clients
348:                         int ix;
349:                         DRV_TMR_CLIENT_OBJ* pClient = pDcpt->tmrClients;
350:                         for(ix = 0; ix < sizeof(pDcpt->tmrClients) / sizeof(*pDcpt->tmrClients); ix++, pClient++)
351:                         {
352:                             if(pClient->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
9D0138E8  8E03002C   LW V1, 44(S0)
353:                             {
354:                                 /* increment the alarm */
355:                                 pClient->alarmCount++;
9D0138F8  8E050030   LW A1, 48(S0)
356:                 
357:                                 /* callback the application routine */
358:                                 if( pClient->alarmCallback != NULL )
9D013904  8E020034   LW V0, 52(S0)
359:                                 {
360:                                     (*pClient->alarmCallback)( pClient->context, pClient->alarmCount);
9D013910  0040F809   JALR V0
361:                                 }
362:                 
363:                                 /* Alarm in one shot mode */
364:                                 if ( pClient->alarmPeriodic != true )
9D013918  92020028   LBU V0, 40(S0)
365:                                 {
366:                                     _DRV_TMR_Suspend(pClient);     // Stop Timer
9D013924  0F4058A4   JAL _DRV_TMR_Suspend
367:                                     _DRV_TMR_ClientClear(pClient); // Clear timer client
368:                                 }
369:                             }
370:                         }
371:                 
372:                     }
373:                 } 
374:                 
375:                 static __inline__ DRV_TMR_CLIENT_OBJ* __attribute__((always_inline)) _DRV_TMR_ClientObj(DRV_HANDLE handle)
376:                 {
377:                     /* check the validity of the handle */
378:                     if(handle != DRV_HANDLE_INVALID)
9D0118AC  2402FFFF   ADDIU V0, ZERO, -1
9D0118B0  10820038   BEQ A0, V0, 0x9D011994
9D0118B4  30D400FF   ANDI S4, A2, 255
9D0133AC  2402FFFF   ADDIU V0, ZERO, -1
9D0133B0  1082002B   BEQ A0, V0, 0x9D013460
9D0133B4  00808021   ADDU S0, A0, ZERO
9D015CD4  2402FFFF   ADDIU V0, ZERO, -1
9D015CD8  1082000F   BEQ A0, V0, 0x9D015D18
9D015CDC  00808021   ADDU S0, A0, ZERO
9D016504  2402FFFF   ADDIU V0, ZERO, -1
9D016508  10820009   BEQ A0, V0, 0x9D016530
9D01650C  00808021   ADDU S0, A0, ZERO
00000000  00000000   NOP
0000000C  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
379:                     {
380:                         DRV_TMR_CLIENT_OBJ* pObj = (DRV_TMR_CLIENT_OBJ*)handle;
381:                         if(pObj->clientStatus > 0)
9D0118B8  8C820008   LW V0, 8(A0)
9D0118BC  18400036   BLEZ V0, 0x9D011998
9D0118C0  00001021   ADDU V0, ZERO, ZERO
9D0133B8  8C820008   LW V0, 8(A0)
9D0133BC  18400029   BLEZ V0, 0x9D013464
9D0133C0  00001021   ADDU V0, ZERO, ZERO
9D015CE0  8E030008   LW V1, 8(S0)
9D015CE4  1860000D   BLEZ V1, 0x9D015D1C
9D015CE8  00001021   ADDU V0, ZERO, ZERO
9D016510  8C820008   LW V0, 8(A0)
9D016514  18400007   BLEZ V0, 0x9D016534
9D016518  8FBF0014   LW RA, 20(SP)
0000000C  00000000   NOP
00000018  00000000   NOP
0000001C  00000000   NOP
00000024  00000000   NOP
382:                         {
383:                             return pObj;
384:                         }
385:                     }
386:                 
387:                     return 0;
388:                 }
389:                 
390:                 // *****************************************************************************
391:                 // *****************************************************************************
392:                 // Section: Driver System Interface Function Definitions
393:                 // *****************************************************************************
394:                 // *****************************************************************************
395:                 
396:                 // *****************************************************************************
397:                 /* Function:
398:                     SYS_MODULE_OBJ DRV_TMR_Initialize 
399:                     ( 
400:                         const SYS_MODULE_INDEX drvIndex,
401:                         const SYS_MODULE_INIT * const init 
402:                     )
403:                 
404:                   Summary:
405:                     Initializes the Timer driver.
406:                 
407:                   Description:
408:                     This function initializes the Timer driver, making it ready for clients to
409:                     open and use it.
410:                 
411:                   Remarks:
412:                     Refer to drv_tmr.h for usage information.
413:                 */
414:                 
415:                 SYS_MODULE_OBJ DRV_TMR_Initialize 
416:                 ( 
417:                     const SYS_MODULE_INDEX drvIndex,
418:                     const SYS_MODULE_INIT  * const init 
419:                 )
420:                 {
9D00EE7C  27BDFFE0   ADDIU SP, SP, -32
9D00EE80  AFBF001C   SW RA, 28(SP)
9D00EE84  AFB10018   SW S1, 24(SP)
9D00EE88  AFB00014   SW S0, 20(SP)
9D00EE8C  00A08821   ADDU S1, A1, ZERO
421:                     if(gDrvTmrInstances == 0)
9D00EE90  8F82804C   LW V0, -32692(GP)
9D00EE94  14400006   BNE V0, ZERO, 0x9D00EEB0
9D00EE98  3090FFFF   ANDI S0, A0, -1
422:                     {
423:                         if(!_DRV_TMR_RootInitialize())
424:                         {   // failed to initialize
425:                             return SYS_MODULE_OBJ_INVALID;
426:                         }
427:                     }
428:                 
429:                     DRV_TMR_MODULE_DESCRIPTOR* pTmrDcpt;
430:                     DRV_TMR_MODULE_INSTANCE*   pTmrInst;
431:                     const DRV_TMR_INIT * tmrInit;
432:                     
433:                     /* Validate the driver index. Check if the specified driver
434:                     index is in valid range */
435:                     if ( drvIndex >= DRV_TMR_INSTANCES_NUMBER )
9D00EEB0  16000055   BNE S0, ZERO, 0x9D00F008
9D00EEB4  2402FFFF   ADDIU V0, ZERO, -1
436:                     {
437:                         return SYS_MODULE_OBJ_INVALID;
438:                     }
439:                 
440:                     /* Check if this hardware instance was already initialized */
441:                     pTmrDcpt = gDrvTmrDcpt + drvIndex; 
442:                     if ( pTmrDcpt->tmrInstance.inUse != false )
9D00EEB8  3C028001   LUI V0, -32767
9D00EEBC  90424DF4   LBU V0, 19956(V0)
9D00EEC0  10400003   BEQ V0, ZERO, 0x9D00EED0
9D00EEC4  3C028001   LUI V0, -32767
443:                     {
444:                         return (SYS_MODULE_OBJ)pTmrDcpt;
9D00EEC8  0B403C02   J 0x9D00F008
9D00EECC  24424DDC   ADDIU V0, V0, 19932
445:                     }
446:                 
447:                     /* Copy to local variables */
448:                     tmrInit = ( const DRV_TMR_INIT * ) init;
449:                     if(tmrInit == 0)
9D00EED0  16200005   BNE S1, ZERO, 0x9D00EEE8
9D00EED4  24424DDC   ADDIU V0, V0, 19932
450:                     {
451:                         tmrInit = &defaultTmrInit;
9D00EED8  3C119D01   LUI S1, -25343
9D00EEDC  2631706C   ADDIU S1, S1, 28780
452:                     }
453:                 
454:                     // TODO: verify the validity of the passed in tmrId!
455:                 
456:                     /* Object is valid, set it in use */
457:                     pTmrInst = &pTmrDcpt->tmrInstance;
458:                     pTmrInst->inUse = true;
9D00EEE0  3C028001   LUI V0, -32767
9D00EEE4  24424DDC   ADDIU V0, V0, 19932
9D00EEE8  24030001   ADDIU V1, ZERO, 1
9D00EEEC  A0430018   SB V1, 24(V0)
459:                 
460:                     /* Initialize the Interrupt Source */
461:                     pTmrInst->tmrId = tmrInit->tmrId;
9D00EEF0  8E300004   LW S0, 4(S1)
9D00EEF4  AC50000C   SW S0, 12(V0)
462:                     pTmrInst->clockSource = tmrInit->clockSource;
9D00EEF8  8E250008   LW A1, 8(S1)
9D00EEFC  AC450010   SW A1, 16(V0)
463:                     pTmrInst->prescale = tmrInit->prescale;
9D00EF00  8E23000C   LW V1, 12(S1)
9D00EF04  AC430008   SW V1, 8(V0)
464:                     pTmrInst->interruptSource = tmrInit->interruptSource;
9D00EF08  8E230010   LW V1, 16(S1)
9D00EF0C  AC430014   SW V1, 20(V0)
465:                     pTmrInst->operMode = tmrInit->mode;
9D00EF10  8E230014   LW V1, 20(S1)
9D00EF14  AC43001C   SW V1, 28(V0)
466:                     pTmrInst->asyncWriteEnable = tmrInit->asyncWriteEnable;
9D00EF18  92230018   LBU V1, 24(S1)
9D00EF1C  A0430020   SB V1, 32(V0)
467:                 
468:                     /* Setup the Hardware */
469:                     if ( _DRV_TMR_InstanceSetup (pTmrInst) == false )
470:                     {   /* Hardware update fail. Set the status. */
471:                         pTmrInst->inUse = false;
9D00EFD8  A0404DF4   SB ZERO, 19956(V0)
472:                         return SYS_MODULE_OBJ_INVALID;
9D00EFDC  0B403C02   J 0x9D00F008
9D00EFE0  2402FFFF   ADDIU V0, ZERO, -1
473:                     }
474:                 
475:                     SYS_INT_SourceDisable( pTmrInst->interruptSource );
9D00EFB0  0B403BF9   J 0x9D00EFE4
9D00EFB4  3C118001   LUI S1, -32767
9D00EFC0  0B403BF9   J 0x9D00EFE4
9D00EFC4  3C118001   LUI S1, -32767
9D00EFD0  0B403BF9   J 0x9D00EFE4
9D00EFD4  3C118001   LUI S1, -32767
9D00EFE4  26304DDC   ADDIU S0, S1, 19932
9D00EFE8  0F40588F   JAL SYS_INT_SourceDisable
9D00EFEC  8E040014   LW A0, 20(S0)
476:                 
477:                     /* Set the current driver state */
478:                     pTmrInst->status = SYS_STATUS_READY;
9D00EFF0  24020002   ADDIU V0, ZERO, 2
9D00EFF4  AE224DDC   SW V0, 19932(S1)
479:                 
480:                     gDrvTmrInstances++;
9D00EFF8  8F82804C   LW V0, -32692(GP)
9D00EFFC  24420001   ADDIU V0, V0, 1
9D00F000  AF82804C   SW V0, -32692(GP)
481:                 
482:                     /* Return the driver handle */
483:                     return (SYS_MODULE_OBJ)pTmrDcpt;
9D00F004  02001021   ADDU V0, S0, ZERO
484:                 
485:                 } /* DRV_TMR_Initialize */
9D00F008  8FBF001C   LW RA, 28(SP)
486:                 
487:                 // *****************************************************************************
488:                 /* Function:
489:                     void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
490:                 
491:                   Summary:
492:                     Deinitializes the specified instance of the Timer driver.
493:                 
494:                   Description:
495:                     Deinitializes the specified instance of the Timer driver, disabling
496:                     its operation (and any hardware). All internal data is invalidated.
497:                 
498:                   Remarks:
499:                     Refer to drv_tmr.h for usage information.
500:                 */
501:                 
502:                 void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
503:                 {
00000000  00000000   NOP
504:                     int ix;
505:                     DRV_TMR_MODULE_DESCRIPTOR* pDcpt = _DRV_TMR_ModuleObj(object, false);
0000000C  00000000   NOP
506:                 
507:                     if(pDcpt)
00000014  00000000   NOP
508:                     {
509:                         SYS_INT_SourceDisable(pDcpt->tmrInstance.interruptSource);
0000001C  00000000   NOP
510:                 
511:                         DRV_TMR_CLIENT_OBJ* pObj = pDcpt->tmrClients; 
512:                         for(ix = 0; ix < sizeof(pDcpt->tmrClients) / sizeof(*pDcpt->tmrClients); ix++, pObj++)
513:                         {
514:                             if(pObj->clientStatus > 0)
00000024  00000000   NOP
515:                             {
516:                                 _DRV_TMR_ClientDelete(pObj, true);
517:                             }
518:                         }
519:                 
520:                         pDcpt->tmrInstance.inUse = false;
0000003C  00000000   NOP
521:                         /* Update the Timer Driver status */
522:                         pDcpt->tmrInstance.status =  SYS_STATUS_UNINITIALIZED ;
00000040  00000000   NOP
523:                     }
524:                 } 
00000044  00000000   NOP
525:                 
526:                 // *****************************************************************************
527:                 /* Function:
528:                     SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
529:                 
530:                   Summary:
531:                     Provides the current status of the Timer driver.
532:                 
533:                   Description:
534:                     This function provides the current status of the Timer driver.
535:                 
536:                   Remarks:
537:                     Refer to drv_tmr.h for usage information.
538:                 */
539:                 
540:                 SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
541:                 {
00000000  00000000   NOP
542:                     DRV_TMR_MODULE_DESCRIPTOR* pDcpt = _DRV_TMR_ModuleObj(object, false);
00000008  00000000   NOP
543:                 
544:                     return pDcpt ? pDcpt->tmrInstance.status : SYS_STATUS_ERROR;
00000010  00000000   NOP
545:                 
546:                 }
0000001C  00000000   NOP
547:                 
548:                 // *****************************************************************************
549:                 /* Function:
550:                     void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
551:                 
552:                   Summary:
553:                     Maintains the driver's state machine.
554:                 
555:                   Description:
556:                     This function is used to maintain the driver's internal state machine and
557:                     processes the timer events.
558:                 
559:                   Remarks:
560:                     Refer to drv_tmr.h for usage information.
561:                 */
562:                 
563:                 void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
564:                 {
9D013890  27BDFFE8   ADDIU SP, SP, -24
9D013894  AFBF0014   SW RA, 20(SP)
9D013898  AFB00010   SW S0, 16(SP)
565:                     DRV_TMR_MODULE_DESCRIPTOR* pDcpt = _DRV_TMR_ModuleObj(object, true);
9D01389C  0F405498   JAL _DRV_TMR_ModuleObj
9D0138A0  24050001   ADDIU A1, ZERO, 1
566:                 
567:                     if(pDcpt)
9D0138A4  10400028   BEQ V0, ZERO, 0x9D013948
9D0138A8  00408021   ADDU S0, V0, ZERO
568:                     {
569:                         DRV_TMR_ProcessEvents(pDcpt);
570:                     }
571:                 
572:                 }
9D013948  8FBF0014   LW RA, 20(SP)
573:                 
574:                 // *****************************************************************************
575:                 // *****************************************************************************
576:                 // Section: TMR Driver Client Functions
577:                 // *****************************************************************************
578:                 // *****************************************************************************
579:                 
580:                 // *****************************************************************************
581:                 /* Function:
582:                     DRV_HANDLE DRV_TMR_Open 
583:                     ( 
584:                         const SYS_MODULE_INDEX index,
585:                         const DRV_IO_INTENT    intent
586:                     )
587:                 
588:                   Summary:
589:                     Opens the specified Timer driver instance and returns a handle to it.
590:                   
591:                   Description:
592:                     This function opens the specified Timer driver instance and provides a
593:                     handle that must be provided to all other client-level operations to
594:                     identify the caller and the instance of the driver.  Timer driver does not
595:                     support multiple clients. If two tasks want to use the timer, one should
596:                     wait until the other one gets closed. 
597:                 
598:                   Remarks:
599:                     Refer to drv_tmr.h for usage information.
600:                 */
601:                 
602:                 DRV_HANDLE DRV_TMR_Open 
603:                 ( 
604:                     const SYS_MODULE_INDEX index, 
605:                     const DRV_IO_INTENT ioIntent 
606:                 )
607:                 {
9D015F70  3084FFFF   ANDI A0, A0, -1
608:                 
609:                     if (index >= DRV_TMR_INSTANCES_NUMBER || ( ioIntent & DRV_IO_INTENT_SHARED ) != 0)
9D015F74  14800013   BNE A0, ZERO, 0x9D015FC4
9D015F78  2402FFFF   ADDIU V0, ZERO, -1
610:                     {   // only exclusive access for now.
611:                         return DRV_HANDLE_INVALID;
612:                     }
613:                 
614:                     if(gDrvTmrInstances != 0)
9D015F7C  8F83804C   LW V1, -32692(GP)
9D015F80  10600010   BEQ V1, ZERO, 0x9D015FC4
9D015F84  00000000   NOP
615:                     {   // module initialized
616:                         DRV_TMR_MODULE_DESCRIPTOR* pDcpt = gDrvTmrDcpt + index;
617:                         if(pDcpt->tmrInstance.inUse != false)
9D015F88  3C028001   LUI V0, -32767
9D015F8C  90434DF4   LBU V1, 19956(V0)
9D015F90  1060000C   BEQ V1, ZERO, 0x9D015FC4
9D015F94  2402FFFF   ADDIU V0, ZERO, -1
618:                         {   // search a free client
619:                             int ix;
620:                 
621:                             DRV_TMR_CLIENT_OBJ* dObj = pDcpt->tmrClients + 0;
622:                             for(ix = 0; ix < sizeof(pDcpt->tmrClients) / sizeof(*pDcpt->tmrClients); ix++, dObj++)
623:                             {
624:                                 if(dObj->clientStatus == DRV_TMR_CLIENT_OBJ_CLOSED)
9D015F98  3C028001   LUI V0, -32767
9D015F9C  8C434E08   LW V1, 19976(V0)
9D015FA0  14600008   BNE V1, ZERO, 0x9D015FC4
9D015FA4  2402FFFF   ADDIU V0, ZERO, -1
625:                                 {   // found free client
626:                                     dObj->pModInst = &pDcpt->tmrInstance;
9D015FA8  3C028001   LUI V0, -32767
9D015FAC  24424DDC   ADDIU V0, V0, 19932
9D015FB0  AC420024   SW V0, 36(V0)
627:                                     dObj->clientStatus = DRV_TMR_CLIENT_OBJ_READY;
9D015FB4  24030001   ADDIU V1, ZERO, 1
9D015FB8  AC43002C   SW V1, 44(V0)
628:                                     return ( ( DRV_HANDLE ) dObj );
9D015FBC  3C028001   LUI V0, -32767
9D015FC0  24424E00   ADDIU V0, V0, 19968
629:                                 }
630:                             }
631:                         }
632:                     }
633:                 
634:                     return DRV_HANDLE_INVALID;
635:                 }
9D015FC4  03E00008   JR RA
636:                 
637:                 // *****************************************************************************
638:                 /* Function:
639:                     void DRV_TMR_Close ( DRV_HANDLE handle )
640:                 
641:                   Summary:
642:                     Closes an opened instance of the Timer driver.
643:                 
644:                   Description:
645:                     This function closes an opened instance of the Timer driver, invalidating
646:                     the handle.
647:                   
648:                   Remarks:
649:                     Refer to drv_tmr.h for usage information.
650:                 */
651:                 
652:                 void DRV_TMR_Close ( DRV_HANDLE handle )
653:                 {
9D0164F8  27BDFFE8   ADDIU SP, SP, -24
9D0164FC  AFBF0014   SW RA, 20(SP)
9D016500  AFB00010   SW S0, 16(SP)
654:                     DRV_TMR_CLIENT_OBJ *pObj = _DRV_TMR_ClientObj(handle);
655:                 
656:                     if (pObj)
9D01651C  50800006   BEQL A0, ZERO, 0x9D016538
9D016520  8FB00010   LW S0, 16(SP)
657:                     {
658:                         _DRV_TMR_ClientDelete(pObj, true);
659:                     }
660:                 } 
9D016530  8FBF0014   LW RA, 20(SP)
661:                 
662:                 // *****************************************************************************
663:                 /* Function:
664:                     DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus ( DRV_HANDLE handle )
665:                 
666:                   Summary:
667:                     Gets the status of the client operation.
668:                 
669:                   Description:
670:                     This function gets the status of the recently completed client level
671:                     operation.
672:                 
673:                   Remarks:
674:                     Refer to drv_tmr.h for usage information.
675:                 */
676:                 
677:                 DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus ( DRV_HANDLE handle )
678:                 {
679:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
680:                     DRV_TMR_CLIENT_STATUS cliStat = DRV_TMR_CLIENT_STATUS_INVALID;
00000034  00000000   NOP
681:                     
682:                     if(dObj)
00000018  00000000   NOP
683:                     {
684:                         if( dObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
685:                         {
686:                             cliStat = DRV_TMR_CLIENT_STATUS_RUNNING;
00000020  00000000   NOP
687:                         }
688:                         else
689:                         {
690:                             cliStat = DRV_TMR_CLIENT_STATUS_READY;
691:                         }
692:                     }
693:                    
694:                    return cliStat;
695:                 
696:                 }
0000003C  00000000   NOP
697:                 
698:                 // *****************************************************************************
699:                 // *****************************************************************************
700:                 // Section: TMR Driver Counter functions
701:                 // *****************************************************************************
702:                 // *****************************************************************************
703:                 
704:                 // *****************************************************************************
705:                 /* Function:
706:                     void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
707:                 
708:                   Summary:
709:                     Updates the Timer's counter register.
710:                 
711:                   Description:
712:                     This function updates the Timer's value in the counter register.
713:                 
714:                   Remarks:
715:                     Refer to drv_tmr.h for usage information.
716:                 */
717:                 
718:                 void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t value )
719:                 {
720:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
721:                 
722:                     if(dObj)
00000018  00000000   NOP
723:                     {
724:                         if(dObj->pModInst->operMode == DRV_TMR_OPERATION_MODE_16_BIT)
00000020  00000000   NOP
725:                         {   
726:                             PLIB_TMR_Counter16BitSet ( dObj->pModInst->tmrId, (uint16_t)value );
727:                         }
728:                         else
729:                         {
730:                             PLIB_TMR_Counter32BitSet ( dObj->pModInst->tmrId, value );
731:                         }
732:                     }
733:                 }
734:                 
735:                 // *****************************************************************************
736:                 /* Function:
737:                     uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
738:                 
739:                   Summary:
740:                     Reads the Timer's counter register.
741:                 
742:                   Description:
743:                     This function returns the Timer's value in the counter register.
744:                 
745:                   Remarks:
746:                     Refer to drv_tmr.h for usage information.
747:                 */
748:                 
749:                 uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
750:                 {
751:                 
752:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
753:                 
754:                     if(dObj)
00000018  00000000   NOP
755:                     {
756:                         if(dObj->pModInst->operMode == DRV_TMR_OPERATION_MODE_32_BIT)
00000020  00000000   NOP
757:                         {
758:                             return PLIB_TMR_Counter32BitGet ( dObj->pModInst->tmrId );
00000030  00000000   NOP
00000054  00000000   NOP
759:                         }
760:                         else
761:                         {
762:                             return PLIB_TMR_Counter16BitGet ( dObj->pModInst->tmrId );
00000060  00000000   NOP
763:                         }
764:                     }
765:                 
766:                     return 0;
00000068  00000000   NOP
767:                 }
00000070  00000000   NOP
768:                 
769:                 // *****************************************************************************
770:                 /* Function:
771:                     void DRV_TMR_CounterClear ( DRV_HANDLE handle )
772:                 
773:                   Summary:
774:                     Clears the Timer's counter register.
775:                 
776:                   Description:
777:                     This function clears the Timer's value in the counter register.
778:                 
779:                   Remarks:
780:                     Refer to drv_tmr.h for usage information.
781:                 */
782:                 
783:                 void DRV_TMR_CounterClear ( DRV_HANDLE handle )
784:                 {
785:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
786:                 
787:                     if(dObj)
00000018  00000000   NOP
788:                     {
789:                         if(dObj && dObj->pModInst->operMode == DRV_TMR_OPERATION_MODE_16_BIT)
00000020  00000000   NOP
790:                         {   
791:                             PLIB_TMR_Counter16BitClear ( dObj->pModInst->tmrId );
792:                         }
793:                         else
794:                         {
795:                             PLIB_TMR_Counter32BitClear ( dObj->pModInst->tmrId );
796:                         }
797:                     }
798:                 }
799:                 
800:                 // *****************************************************************************
801:                 // *****************************************************************************
802:                 // Section: TMR Driver Alarm functions
803:                 // *****************************************************************************
804:                 // *****************************************************************************
805:                 
806:                 // *****************************************************************************
807:                 /* Function:
808:                     bool DRV_TMR_AlarmRegister 
809:                     ( 
810:                         DRV_HANDLE handle, 
811:                         uint32_t divider, 
812:                         bool isPeriodic, 
813:                         uintptr_t context, 
814:                         DRV_TMR_CALLBACK callBack 
815:                     )
816:                 
817:                   Summary:
818:                     Sets up an alarm.
819:                 
820:                   Description:
821:                     This function sets up an alarm, allowing the client to receive a callback
822:                     from the driver when the timer counter reaches zero.  Alarms can be one-shot
823:                     or periodic.  A periodic alarm will reload the timer and generate alarm
824:                     until stopped.  The alarm frequency is: DRV_TMR_CounterFrequencyGet() /
825:                     divider;
826:                 
827:                   Remarks:
828:                     Refer to drv_tmr.h for usage information.
829:                 */
830:                 
831:                 bool DRV_TMR_AlarmRegister 
832:                 ( 
833:                     DRV_HANDLE handle, 
834:                     uint32_t divider, 
835:                     bool isPeriodic,
836:                     uintptr_t context, 
837:                     DRV_TMR_CALLBACK callBack 
838:                 )
839:                 {
9D01188C  27BDFFD8   ADDIU SP, SP, -40
9D011890  AFBF0024   SW RA, 36(SP)
9D011894  AFB40020   SW S4, 32(SP)
9D011898  AFB3001C   SW S3, 28(SP)
9D01189C  AFB20018   SW S2, 24(SP)
9D0118A0  AFB10014   SW S1, 20(SP)
9D0118A4  AFB00010   SW S0, 16(SP)
9D0118A8  00808021   ADDU S0, A0, ZERO
840:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
841:                 
842:                     if(dObj == 0)
9D0118C4  10800034   BEQ A0, ZERO, 0x9D011998
9D0118C8  00A08821   ADDU S1, A1, ZERO
843:                     {
844:                         return false;
845:                     }
846:                 
847:                     DRV_TMR_OPERATION_MODE operMode = dObj->pModInst->operMode;
9D0118CC  8C820000   LW V0, 0(A0)
9D0118D0  8C52001C   LW S2, 28(V0)
848:                     bool success = false;
849:                 
850:                     if(operMode == DRV_TMR_OPERATION_MODE_32_BIT)
9D0118D4  24020002   ADDIU V0, ZERO, 2
9D0118D8  16420004   BNE S2, V0, 0x9D0118EC
9D0118DC  00E09821   ADDU S3, A3, ZERO
851:                     {
852:                         success = (divider >= DRV_TIMER_DIVIDER_MIN_32BIT && divider <= DRV_TIMER_DIVIDER_MAX_32BIT);
9D0118E0  2CA30002   SLTIU V1, A1, 2
9D0118E4  0B40463E   J 0x9D0118F8
9D0118E8  38630001   XORI V1, V1, 1
853:                     }
854:                     else
855:                     {
856:                         success = (divider >= DRV_TIMER_DIVIDER_MIN_16BIT && divider <= DRV_TIMER_DIVIDER_MAX_16BIT);
9D0118EC  24A3FFFE   ADDIU V1, A1, -2
9D0118F0  3402FFFF   ORI V0, ZERO, -1
9D0118F4  0062182B   SLTU V1, V1, V0
857:                     }
858:                 
859:                     if(success)
9D0118F8  10600027   BEQ V1, ZERO, 0x9D011998
9D0118FC  00601021   ADDU V0, V1, ZERO
860:                     {
861:                         bool resume = _DRV_TMR_Suspend(dObj);
9D011900  0F4058A4   JAL _DRV_TMR_Suspend
9D011904  02002021   ADDU A0, S0, ZERO
862:                         _DRV_TMR_ClientSetParams(dObj, divider - 1, isPeriodic, context, callBack);
9D011908  2623FFFF   ADDIU V1, S1, -1
863:                 
864:                         if(operMode == DRV_TMR_OPERATION_MODE_32_BIT)
9D011924  24040002   ADDIU A0, ZERO, 2
9D011928  1644000B   BNE S2, A0, 0x9D011958
9D01192C  AE00000C   SW ZERO, 12(S0)
865:                         {
866:                             PLIB_TMR_Period32BitSet ( dObj->pModInst->tmrId, divider - 1);
9D011930  8E040000   LW A0, 0(S0)
9D011934  8C84000C   LW A0, 12(A0)
867:                         }
868:                         else
869:                         {
870:                             PLIB_TMR_Period16BitSet ( dObj->pModInst->tmrId, (uint16_t)divider - 1 );
9D011958  8E030000   LW V1, 0(S0)
9D011960  2631FFFF   ADDIU S1, S1, -1
871:                         }
872:                         if(resume)
9D01196C  50400006   BEQL V0, ZERO, 0x9D011988
9D011970  24020002   ADDIU V0, ZERO, 2
873:                         {
874:                             _DRV_TMR_Resume(dObj, resume);
9D011974  02002021   ADDU A0, S0, ZERO
9D011978  0F4056FE   JAL _DRV_TMR_Resume
9D01197C  24050001   ADDIU A1, ZERO, 1
9D011980  0B404666   J 0x9D011998
9D011984  24020001   ADDIU V0, ZERO, 1
875:                         }
876:                         else
877:                         {
878:                             dObj->clientStatus = DRV_TMR_CLIENT_OBJ_ARMED;
9D011988  AE020008   SW V0, 8(S0)
879:                         }
880:                     }
881:                 
882:                 
883:                     return success;
9D01198C  0B404666   J 0x9D011998
9D011990  24020001   ADDIU V0, ZERO, 1
9D011994  00001021   ADDU V0, ZERO, ZERO
884:                 }
9D011998  8FBF0024   LW RA, 36(SP)
885:                 
886:                 // *****************************************************************************
887:                 /* Function:
888:                     bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle);
889:                 
890:                   Summary:
891:                     Disables an alarm signal.
892:                 
893:                   Description:
894:                     This function allows the client to disable an alarm generation.
895:                     Use DRV_TMR_AlarmEnable to re-enable.
896:                 
897:                   Remarks:
898:                     Refer to drv_tmr.h for usage information.
899:                 */
900:                 
901:                 
902:                 bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle)
903:                 {
0000002C  00000000   NOP
904:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
905:                 
906:                     if(dObj && dObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
00000018  00000000   NOP
907:                     {
908:                         return SYS_INT_SourceDisable ( dObj->pModInst->interruptSource ) ;
00000034  00000000   NOP
909:                     }
910:                 
911:                     return false;
00000048  00000000   NOP
912:                 }
00000058  00000000   NOP
913:                 
914:                 // *****************************************************************************
915:                 /* Function:
916:                     void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable );
917:                 
918:                   Summary:
919:                     Re-enables an alarm signal.
920:                 
921:                   Description:
922:                     This function allows the client to re-enable an alarm after it has been
923:                     disabled by a DRV_TMR_AlarmDisable call.
924:                 
925:                   Remarks:
926:                     Refer to drv_tmr.h for usage information.
927:                 */
928:                 
929:                 void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable )
930:                 {
931:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
932:                 
933:                     if(dObj && dObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING && enable)
00000018  00000000   NOP
934:                     {
935:                         SYS_INT_SourceEnable ( dObj->pModInst->interruptSource ) ;
00000030  00000000   NOP
936:                     }
937:                 }
938:                 
939:                 // *****************************************************************************
940:                 /* Function:
941:                     void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
942:                 
943:                   Summary:
944:                     Updates the Timer's period.
945:                 
946:                   Description:
947:                     This function updates the Timer's period.
948:                 
949:                   Remarks:
950:                     Refer to drv_tmr.h for usage information.
951:                 */
952:                 
953:                 void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t   period )
954:                 {
00000000  00000000   NOP
955:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
956:                 
957:                     if(dObj)
00000028  00000000   NOP
958:                     {
959:                         bool resume = _DRV_TMR_Suspend(dObj);
00000030  00000000   NOP
960:                         /* Client update with the new count value */
961:                         dObj->pModInst->timerPeriod = period;
00000038  00000000   NOP
962:                 
963:                         if(dObj->pModInst->operMode == DRV_TMR_OPERATION_MODE_32_BIT)
00000040  00000000   NOP
964:                         {
965:                             PLIB_TMR_Period32BitSet ( dObj->pModInst->tmrId, period);
00000054  00000000   NOP
966:                         }
967:                         else
968:                         {
969:                             PLIB_TMR_Period16BitSet ( dObj->pModInst->tmrId, (uint16_t)period );
970:                         }
971:                         _DRV_TMR_Resume(dObj, resume);
00000074  00000000   NOP
00000084  00000000   NOP
972:                     }
973:                 } 
00000090  00000000   NOP
974:                 
975:                 // *****************************************************************************
976:                 /* Function:
977:                     uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
978:                 
979:                   Summary:
980:                     Provides the Timer's period.
981:                 
982:                   Description:
983:                     This function gets the Timer's period.
984:                 
985:                   Remarks:
986:                     Refer to drv_tmr.h for usage information.
987:                 */
988:                 
989:                 uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
990:                 {
991:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
992:                 
993:                     if(dObj)
00000018  00000000   NOP
994:                     {
995:                         return  dObj->pModInst->timerPeriod;
00000020  00000000   NOP
996:                     }
997:                 
998:                     return 0;
0000002C  00000000   NOP
999:                 } 
00000034  00000000   NOP
1000:                
1001:                // *****************************************************************************
1002:                /* Function:
1003:                    void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
1004:                
1005:                  Summary:
1006:                    Removes a previously set alarm.
1007:                
1008:                  Description:
1009:                    This function removes a previously set alarm.
1010:                
1011:                  Remarks:
1012:                    Refer to drv_tmr.h for usage information.
1013:                */
1014:                
1015:                void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
1016:                {
00000000  00000000   NOP
1017:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1018:                
1019:                    if(dObj)
00000024  00000000   NOP
1020:                    {
1021:                        _DRV_TMR_Suspend(dObj);
0000002C  00000000   NOP
1022:                        _DRV_TMR_ClientClear(dObj);
1023:                    }
1024:                } 
00000050  00000000   NOP
1025:                
1026:                // *****************************************************************************
1027:                // *****************************************************************************
1028:                // Section: TMR Driver Operation Control functions
1029:                // *****************************************************************************
1030:                // *****************************************************************************
1031:                
1032:                // *****************************************************************************
1033:                /* Function:
1034:                    bool DRV_TMR_Start ( DRV_HANDLE handle )
1035:                
1036:                  Summary:
1037:                    Starts the Timer counting.
1038:                
1039:                  Description:
1040:                    This function starts the Timer counting.
1041:                
1042:                  Remarks:
1043:                    Refer to drv_tmr.h for usage information.
1044:                */
1045:                
1046:                bool DRV_TMR_Start ( DRV_HANDLE handle )
1047:                {
9D015CC8  27BDFFE8   ADDIU SP, SP, -24
9D015CCC  AFBF0014   SW RA, 20(SP)
9D015CD0  AFB00010   SW S0, 16(SP)
1048:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1049:                
1050:                    if(dObj && dObj->clientStatus == DRV_TMR_CLIENT_OBJ_ARMED)
9D015CEC  1080000B   BEQ A0, ZERO, 0x9D015D1C
9D015CF0  24040002   ADDIU A0, ZERO, 2
9D015CF4  1464000A   BNE V1, A0, 0x9D015D20
9D015CF8  8FBF0014   LW RA, 20(SP)
1051:                    {
1052:                        _DRV_TMR_Resume(dObj, true);
9D015CFC  02002021   ADDU A0, S0, ZERO
9D015D00  0F4056FE   JAL _DRV_TMR_Resume
9D015D04  24050001   ADDIU A1, ZERO, 1
1053:                
1054:                        /* Update the Client Status */
1055:                        dObj->clientStatus = DRV_TMR_CLIENT_OBJ_RUNNING;
9D015D08  24020003   ADDIU V0, ZERO, 3
9D015D0C  AE020008   SW V0, 8(S0)
1056:                        return true;
9D015D10  0B405747   J 0x9D015D1C
9D015D14  24020001   ADDIU V0, ZERO, 1
9D015D18  00001021   ADDU V0, ZERO, ZERO
1057:                    }
1058:                    return false;
1059:                }
9D015D1C  8FBF0014   LW RA, 20(SP)
1060:                
1061:                // *****************************************************************************
1062:                /* Function:
1063:                    void DRV_TMR_Stop ( DRV_HANDLE handle )
1064:                
1065:                  Summary:
1066:                    Stops the Timer from counting.
1067:                
1068:                  Description:
1069:                    This function stops the running Timer from counting.
1070:                
1071:                  Remarks:
1072:                    Refer to drv_tmr.h for usage information.
1073:                */
1074:                
1075:                void DRV_TMR_Stop ( DRV_HANDLE handle )
1076:                {
00000000  00000000   NOP
1077:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1078:                
1079:                    if(dObj && dObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
00000024  00000000   NOP
1080:                    {   /* Stop the Timer from running */
1081:                        _DRV_TMR_Suspend(dObj);
00000034  00000000   NOP
1082:                        SYS_INT_SourceStatusClear ( dObj->pModInst->interruptSource );
0000003C  00000000   NOP
1083:                        /* Update the Client Status */
1084:                        dObj->clientStatus = DRV_TMR_CLIENT_OBJ_ARMED;
00000064  00000000   NOP
1085:                    }
1086:                }
0000006C  00000000   NOP
1087:                
1088:                // *****************************************************************************
1089:                /* Function:
1090:                    uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
1091:                
1092:                  Summary:
1093:                    Provides the status of Timer's period elapse.
1094:                
1095:                  Description:
1096:                    This function returns the number of times Timer's period has elapsed since
1097:                    last call to this API has made. On calling this API, the internally
1098:                    maintained counter will be cleared and count will be started again from next
1099:                    elapse.
1100:                
1101:                  Remarks:
1102:                    Refer to drv_tmr.h for usage information.
1103:                */
1104:                
1105:                uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
1106:                {
1107:                    uint32_t alarmCountTemp;
1108:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1109:                
1110:                    if(dObj)
00000018  00000000   NOP
1111:                    {
1112:                        alarmCountTemp = dObj->alarmCount;
00000020  00000000   NOP
1113:                        dObj->alarmCount = 0;
1114:                        return( alarmCountTemp );
00000024  00000000   NOP
1115:                    }
1116:                
1117:                    return 0;
0000002C  00000000   NOP
1118:                }
00000034  00000000   NOP
1119:                
1120:                // *****************************************************************************
1121:                /* Function:
1122:                    DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
1123:                
1124:                  Summary:
1125:                    This function gets the currently selected operation mode.
1126:                
1127:                  Description:
1128:                    This function gets the currently selected 16/32 bit operation mode.
1129:                
1130:                  Remarks:
1131:                    Refer to drv_tmr.h for usage information.
1132:                */
1133:                
1134:                DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
1135:                {
1136:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1137:                
1138:                    if(dObj)
00000018  00000000   NOP
1139:                    {
1140:                        return dObj->pModInst->operMode;
00000020  00000000   NOP
1141:                    }
1142:                
1143:                    return DRV_TMR_OPERATION_MODE_NONE;
0000002C  00000000   NOP
1144:                }
00000034  00000000   NOP
1145:                
1146:                // *****************************************************************************
1147:                // *****************************************************************************
1148:                // Section: TMR Driver Miscellaneous information functions
1149:                // *****************************************************************************
1150:                // *****************************************************************************
1151:                
1152:                // *****************************************************************************
1153:                /* Function:
1154:                    uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
1155:                
1156:                  Summary:
1157:                    Provides the Timer input frequency.
1158:                
1159:                  Description:
1160:                    This function provides the Timer input frequency. Input frequency is the
1161:                    clock to the Timer register and it is considering the prescaler divisor. 
1162:                
1163:                  Remarks:
1164:                    Refer to drv_tmr.h for usage information.
1165:                */
1166:                
1167:                uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
1168:                {
9D0133A0  27BDFFE8   ADDIU SP, SP, -24
9D0133A4  AFBF0014   SW RA, 20(SP)
9D0133A8  AFB00010   SW S0, 16(SP)
1169:                    uint32_t prescale, tmrBaseFreq ;
1170:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1171:                
1172:                    if(dObj)
9D0133C4  10800028   BEQ A0, ZERO, 0x9D013468
9D0133C8  8FBF0014   LW RA, 20(SP)
1173:                    {
1174:                        if(dObj->pModInst->clockSource == DRV_TMR_CLKSOURCE_INTERNAL)
9D0133CC  8C820000   LW V0, 0(A0)
9D0133D0  8C430010   LW V1, 16(V0)
9D0133D4  14600023   BNE V1, ZERO, 0x9D013464
9D0133D8  00001021   ADDU V0, ZERO, ZERO
1175:                        {
1176:                            tmrBaseFreq = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_FOR_TIMER_PERIPHERAL);
9D0133DC  0F4058B8   JAL SYS_CLK_PeripheralFrequencyGet
9D0133E0  24040002   ADDIU A0, ZERO, 2
1177:                            prescale = PLIB_TMR_PrescaleGet ( dObj->pModInst->tmrId );
9D0133E4  8E030000   LW V1, 0(S0)
9D0133E8  8C64000C   LW A0, 12(V1)
1178:                            return ( tmrBaseFreq / prescale );
9D013450  0043001B   DIVU V0, V1
9D013454  006001F4   TEQ V1, ZERO
9D013458  0B404D19   J 0x9D013464
9D01345C  00001012   MFLO V0
9D013460  00001021   ADDU V0, ZERO, ZERO
1179:                        }
1180:                    }
1181:                
1182:                    return 0;
1183:                }
9D013464  8FBF0014   LW RA, 20(SP)
1184:                
1185:                // *****************************************************************************
1186:                /* Function:
1187:                    DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
1188:                    ( 
1189:                        DRV_HANDLE handle, 
1190:                        DRV_TMR_DIVIDER_RANGE* pDivRange
1191:                    )
1192:                
1193:                  Summary:
1194:                    Returns the Timer divider values.
1195:                
1196:                  Description:
1197:                    This function provides the Timer operating mode and divider range.
1198:                
1199:                  Remarks:
1200:                    Refer to drv_tmr.h for usage information.
1201:                */
1202:                
1203:                DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
1204:                ( 
1205:                    DRV_HANDLE handle,
1206:                    DRV_TMR_DIVIDER_RANGE * pDivRange
1207:                )
1208:                {
1209:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1210:                
1211:                    if(dObj)
00000018  00000000   NOP
1212:                    {
1213:                        DRV_TMR_OPERATION_MODE operMode = dObj->pModInst->operMode;
00000020  00000000   NOP
1214:                
1215:                        if(pDivRange)
00000024  00000000   NOP
1216:                        {
1217:                
1218:                            if(operMode == DRV_TMR_OPERATION_MODE_32_BIT)
0000002C  00000000   NOP
1219:                            {
1220:                                pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_32BIT;
00000038  00000000   NOP
1221:                                pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_32BIT;
00000040  00000000   NOP
1222:                            }
1223:                            else
1224:                            {
1225:                                pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_16BIT;
0000004C  00000000   NOP
1226:                                pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_16BIT;
00000050  00000000   NOP
1227:                            }
1228:                            pDivRange->dividerStep = 1;
00000058  00000000   NOP
1229:                        }
1230:                        return operMode;
1231:                    }
1232:                
1233:                    return DRV_TMR_OPERATION_MODE_NONE;
00000064  00000000   NOP
1234:                
1235:                }
0000006C  00000000   NOP
1236:                
1237:                // *****************************************************************************
1238:                /* Function:
1239:                    bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
1240:                
1241:                  Summary:
1242:                    Enables the Gate mode.
1243:                
1244:                  Description:
1245:                    This function enables the Gated mode of Timer. User can measure the duration
1246:                    of an external signal in this mode. Once the Gate mode is enabled, Timer
1247:                    will start on the raising edge of the external signal. It will keep counting
1248:                    until the next falling edge. 
1249:                
1250:                  Remarks:
1251:                    Refer to drv_tmr.h for usage information.
1252:                */
1253:                
1254:                bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
1255:                {
00000000  00000000   NOP
1256:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1257:                    if(dObj)
00000024  00000000   NOP
1258:                    {
1259:                #if defined(PLIB_TMR_ExistsGatedTimeAccumulation)
1260:                        if(PLIB_TMR_ExistsGatedTimeAccumulation( dObj->pModInst->tmrId))
1261:                        {
1262:                            bool resume = _DRV_TMR_Suspend(dObj);
0000002C  00000000   NOP
1263:                            PLIB_TMR_GateEnable( dObj->pModInst->tmrId );
00000034  00000000   NOP
1264:                            _DRV_TMR_Resume(dObj, resume);
00000044  00000000   NOP
1265:                            return true;
00000050  00000000   NOP
1266:                        }
1267:                #endif
1268:                    }
1269:                
1270:                    return false;
1271:                }
0000005C  00000000   NOP
1272:                 
1273:                // *****************************************************************************
1274:                /* Function:
1275:                    bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
1276:                
1277:                  Summary:
1278:                    Enables the Gate mode.
1279:                
1280:                  Description:
1281:                    This function enables the Gated mode of Timer. User can measure the duration
1282:                    of an external signal in this mode. Once the Gate mode is enabled, Timer
1283:                    will start on the raising edge of the external signal. It will keep counting
1284:                    until the next falling edge. 
1285:                
1286:                  Remarks:
1287:                    Refer to drv_tmr.h for usage information.
1288:                */
1289:                
1290:                bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
1291:                {
00000000  00000000   NOP
1292:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1293:                    if(dObj)
00000024  00000000   NOP
1294:                    {
1295:                #if defined(PLIB_TMR_ExistsGatedTimeAccumulation)
1296:                        if(PLIB_TMR_ExistsGatedTimeAccumulation( dObj->pModInst->tmrId))
1297:                        {
1298:                            bool resume = _DRV_TMR_Suspend(dObj);
0000002C  00000000   NOP
1299:                            PLIB_TMR_GateDisable( dObj->pModInst->tmrId );
00000034  00000000   NOP
1300:                            _DRV_TMR_Resume(dObj, resume);
00000044  00000000   NOP
1301:                            return true;
00000050  00000000   NOP
1302:                        }
1303:                #endif
1304:                    }
1305:                    return false;
1306:                }
0000005C  00000000   NOP
1307:                
1308:                // *****************************************************************************
1309:                /* Function:
1310:                    bool DRV_TMR_ClockSet 
1311:                    ( 
1312:                        DRV_HANDLE handle, 
1313:                        DRV_TMR_CLK_SOURCES clockSource, 
1314:                        TMR_PRESCALE  preScale 
1315:                    )
1316:                
1317:                  Summary:
1318:                    Sets the timers clock by selecting the source and prescaler.
1319:                
1320:                  Description:
1321:                    This function sets the timers clock by selecting the source and prescaler.
1322:                
1323:                  Remarks:
1324:                    Refer to drv_tmr.h for usage information.
1325:                */
1326:                
1327:                bool DRV_TMR_ClockSet 
1328:                ( 
1329:                    DRV_HANDLE handle, 
1330:                    DRV_TMR_CLK_SOURCES clockSource, 
1331:                    TMR_PRESCALE  prescale 
1332:                )
1333:                {
00000000  00000000   NOP
1334:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1335:                
1336:                
1337:                    if(dObj)
00000030  00000000   NOP
1338:                    {
1339:                        bool success = false;
1340:                        bool resume = _DRV_TMR_Suspend(dObj);
00000038  00000000   NOP
1341:                
1342:                        if(_DRV_TMR_ClockSourceSet(dObj->pModInst->tmrId, clockSource))
00000044  00000000   NOP
1343:                        {
1344:                            if(_DRV_TMR_ClockPrescaleSet(dObj->pModInst->tmrId, prescale))
0000005C  00000000   NOP
1345:                            {   
1346:                                success = true;
1347:                            }
1348:                        }
1349:                
1350:                        _DRV_TMR_Resume(dObj, resume);
00000070  00000000   NOP
1351:                        return success;
0000007C  00000000   NOP
1352:                    }
1353:                
1354:                    return false;
1355:                }
00000088  00000000   NOP
1356:                
1357:                // *****************************************************************************
1358:                /* Function:
1359:                    TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
1360:                
1361:                  Summary:
1362:                    This function gets the currently selected prescaler.
1363:                
1364:                  Description:
1365:                    This function gets the currently selected prescaler.
1366:                
1367:                  Remarks:
1368:                    Refer to drv_tmr.h for usage information.
1369:                */
1370:                
1371:                TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
1372:                {
1373:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1374:                
1375:                    if(dObj)
00000018  00000000   NOP
1376:                    {
1377:                        uint16_t prescale_value;
1378:                        /* Call the PLIB directly */
1379:                        prescale_value = PLIB_TMR_PrescaleGet( dObj->pModInst->tmrId );
00000020  00000000   NOP
1380:                        
1381:                
1382:                        switch(prescale_value)
00000084  00000000   NOP
000000C0  00000000   NOP
1383:                        {
1384:                            case 1: return TMR_PRESCALE_VALUE_1;
00000054  00000000   NOP
000000B8  00000000   NOP
000000E0  00000000   NOP
1385:                                                        
1386:                            case 2: return TMR_PRESCALE_VALUE_2;
1387:                                                        
1388:                            case 4: return TMR_PRESCALE_VALUE_4;
00000100  00000000   NOP
1389:                                                        
1390:                            case 8: return TMR_PRESCALE_VALUE_8;
000000F0  00000000   NOP
00000108  00000000   NOP
1391:                            
1392:                            case 16: return TMR_PRESCALE_VALUE_16;
00000110  00000000   NOP
1393:                                                        
1394:                            case 32: return TMR_PRESCALE_VALUE_32;
1395:                                                        
1396:                            case 64: return TMR_PRESCALE_VALUE_64;
000000E8  00000000   NOP
00000118  00000000   NOP
1397:                                                        
1398:                            case 256: return TMR_PRESCALE_VALUE_256;            
000000F8  00000000   NOP
1399:                
1400:                            default: return TMR_PRESCALE_VALUE_1;
1401:                        }
1402:                    }
1403:                
1404:                    return -1;
00000120  00000000   NOP
1405:                
1406:                } 
00000128  00000000   NOP
1407:                
1408:                
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/system_config/pic32mz_ef_curiosity/bsp/bsp.c
1:                   /*******************************************************************************
2:                     Board Support Package Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       bsp.c
9:                   
10:                    Summary:
11:                      Board Support Package implementation for PIC32MZ EF Curiosity Development
12:                      Board.
13:                  
14:                    Description:
15:                      This file contains routines that implement the board support package for
16:                      PIC32MZ EF Curiosity Development Board.
17:                  *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2016 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                  *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  
50:                  #include "bsp.h"
51:                  
52:                  
53:                  // *****************************************************************************
54:                  /* Data Structure: 
55:                      switch_port_channel_map[]
56:                  
57:                    Summary:
58:                      Maps each switch to its port channel
59:                    
60:                    Description:
61:                      The switch_port_channel_map array, indexed by BSP_SWITCH, maps each switch 
62:                      to its port channel.
63:                  
64:                    Remarks:
65:                      Refer to bsp.h for usage information.
66:                  */
67:                  static const PORTS_CHANNEL switch_port_channel_map[] =
68:                  {
69:                      PORT_CHANNEL_G
70:                  };
71:                  
72:                  // *****************************************************************************
73:                  /* Data Structure: 
74:                      switch_port_bit_pos_map[]
75:                  
76:                    Summary:
77:                      Maps each switch to its port bit position
78:                    
79:                    Description:
80:                      The switch_port_bit_pos_map array, indexed by BSP_SWITCH, maps each switch to its port bit position
81:                  
82:                    Remarks:
83:                      Refer to bsp.h for usage information.
84:                  */
85:                  static const PORTS_BIT_POS switch_port_bit_pos_map[] =
86:                  {
87:                      PORTS_BIT_POS_12
88:                  };
89:                  
90:                  
91:                  // *****************************************************************************
92:                  /* Function: 
93:                      void BSP_SwitchStateGet(BSP_SWITCH switch);
94:                  
95:                    Summary:
96:                      Returns the present state (pressed or not pressed) of the specified switch.
97:                    
98:                    Description:
99:                      This function returns the present state (pressed or not pressed) of the
100:                     specified switch.
101:                 
102:                   Remarks:
103:                     Refer to bsp.h for usage information.
104:                 */
105:                 
106:                 BSP_SWITCH_STATE BSP_SwitchStateGet( BSP_SWITCH bspSwitch )
107:                 {
108:                     return ( PLIB_PORTS_PinGet(PORTS_ID_0, switch_port_channel_map[bspSwitch], switch_port_bit_pos_map[bspSwitch]) );
109:                 }
0000000C  00000000   NOP
110:                 
111:                 // *****************************************************************************
112:                 /* Data Structure: 
113:                     led_port_channel_map[]
114:                 
115:                   Summary:
116:                     Maps each led to its port channel
117:                   
118:                   Description:
119:                     The led_port_channel_map array, indexed by BSP_LED, maps each led to its 
120:                     port channel.
121:                 
122:                   Remarks:
123:                     Refer to bsp.h for usage information.
124:                 */
125:                 static const PORTS_CHANNEL led_port_channel_map[] =
126:                 {
127:                     PORT_CHANNEL_E,
128:                     PORT_CHANNEL_B,
129:                     PORT_CHANNEL_B,
130:                     PORT_CHANNEL_B,
131:                     PORT_CHANNEL_E,
132:                     PORT_CHANNEL_E
133:                 };
134:                 
135:                 // *****************************************************************************
136:                 /* Data Structure: 
137:                     led_port_bit_pos_map[]
138:                 
139:                   Summary:
140:                     Maps each led to its port bit position
141:                   
142:                   Description:
143:                     The led_port_bit_pos_map array, indexed by BSP_LED, maps each led to its port 
144:                     bit position.
145:                 
146:                   Remarks:
147:                     Refer to bsp.h for usage information.
148:                 */
149:                 static const PORTS_BIT_POS led_port_bit_pos_map[] =
150:                 {
151:                     PORTS_BIT_POS_6,
152:                     PORTS_BIT_POS_5,
153:                     PORTS_BIT_POS_1,
154:                     PORTS_BIT_POS_0,
155:                     PORTS_BIT_POS_3,
156:                     PORTS_BIT_POS_4
157:                 };
158:                 
159:                 // *****************************************************************************
160:                 /* Data Structure: 
161:                     led_active_level_map[]
162:                 
163:                   Summary:
164:                     Maps each led to its active level
165:                   
166:                   Description:
167:                     The led_active_level_map array, indexed by BSP_LED, maps each led to its active 
168:                     level.
169:                 
170:                   Remarks:
171:                     Refer to bsp.h for usage information.
172:                 */
173:                 static const BSP_LED_ACTIVE_LEVEL led_active_level_map[] =
174:                 {
175:                    BSP_LED_ACTIVE_HIGH,
176:                    BSP_LED_ACTIVE_LOW,
177:                    BSP_LED_ACTIVE_LOW,
178:                    BSP_LED_ACTIVE_LOW,
179:                    BSP_LED_ACTIVE_HIGH,
180:                    BSP_LED_ACTIVE_HIGH
181:                 };
182:                 
183:                 // *****************************************************************************
184:                 /* Function: 
185:                     void BSP_LEDStateSet(BSP_LED led, BSP_LED_STATE state);
186:                 
187:                   Summary:
188:                     Controls the state of the LED.
189:                   
190:                   Description:
191:                     This function allows the application to specify the state of the LED.
192:                 
193:                   Remarks:
194:                     Refer to bsp_config.h for usage information.
195:                 */
196:                 
197:                 void BSP_LEDStateSet(BSP_LED led, BSP_LED_STATE state)
198:                 {
199:                     /* Set the state of the LED */
200:                     if(led_active_level_map[led] == BSP_LED_ACTIVE_HIGH)
00000000  00000000   NOP
201:                     {
202:                         PLIB_PORTS_PinWrite (PORTS_ID_0 , led_port_channel_map[led], led_port_bit_pos_map[led], state );
0000001C  00000000   NOP
203:                     }
204:                     else
205:                     {
206:                         PLIB_PORTS_PinWrite (PORTS_ID_0 , led_port_channel_map[led], led_port_bit_pos_map[led], ~state );
00000098  00000000   NOP
207:                     }
208:                 }
209:                 
210:                 // *****************************************************************************
211:                 /* Function: 
212:                     void BSP_LEDToggle(BSP_LED led);
213:                 
214:                   Summary:
215:                     Toggles the state of the LED between BSP_LED_STATE_ON and BSP_LED_STATE_OFF.
216:                   
217:                   Description:
218:                     This function toggles the state of the LED between BSP_LED_STATE_ON and
219:                     BSP_LED_STATE_OFF.
220:                 
221:                   Remarks:
222:                     Refer to bsp.h for usage information.
223:                 */    
224:                 
225:                 void BSP_LEDToggle(BSP_LED led)
226:                 {
227:                     PLIB_PORTS_PinToggle(PORTS_ID_0, led_port_channel_map[led], led_port_bit_pos_map[led] );
228:                 }
229:                 
230:                 // *****************************************************************************
231:                 /* Function: 
232:                     BSP_LED_STATE BSP_LEDStateGet(BSP_LED led);
233:                 
234:                   Summary:
235:                     Returns the present state of the LED.
236:                   
237:                   Description:
238:                     This function returns the present state of the LED.
239:                 
240:                   Remarks:
241:                     Refer to bsp.h for usage information.
242:                 */    
243:                 
244:                 BSP_LED_STATE BSP_LEDStateGet (BSP_LED led)
245:                 {
246:                     BSP_LED_STATE value;
247:                 
248:                     /* Get LED Status */
249:                     value = PLIB_PORTS_PinGetLatched (PORTS_ID_0, led_port_channel_map[led], led_port_bit_pos_map[led]);
00000000  00000000   NOP
250:                 
251:                     if(led_active_level_map[led] == BSP_LED_ACTIVE_LOW)
00000040  00000000   NOP
252:                     {
253:                         value = ~value;
0000004C  00000000   NOP
254:                     }
255:                 
256:                     return value;
257:                 }
00000050  00000000   NOP
258:                 
259:                 // *****************************************************************************
260:                 /* Function: 
261:                     void BSP_LEDOn(BSP_LED led);
262:                 
263:                   Summary:
264:                     Switches ON the specified LED.
265:                   
266:                   Description:
267:                     This function switches ON the specified LED.
268:                 
269:                   Remarks:
270:                     Refer to bsp.h for usage information.
271:                 */
272:                 
273:                 void BSP_LEDOn(BSP_LED led)
274:                 {
275:                     if(led_active_level_map[led] == BSP_LED_ACTIVE_HIGH)
9D014220  00041080   SLL V0, A0, 2
9D014224  3C039D01   LUI V1, -25343
9D014228  246364B0   ADDIU V1, V1, 25776
9D01422C  7C62180A   LWX V1, V0(V1)
9D014230  24020001   ADDIU V0, ZERO, 1
9D014234  14620013   BNE V1, V0, BSP_LEDOn::PLIB_PORTS_PinClear
9D014238  00042080   SLL A0, A0, 2
276:                     {
277:                         PLIB_PORTS_PinSet( PORTS_ID_0, led_port_channel_map[led], led_port_bit_pos_map[led] );
278:                     }
279:                     else
280:                     {
281:                         PLIB_PORTS_PinClear( PORTS_ID_0, led_port_channel_map[led], led_port_bit_pos_map[led] );
282:                     }
283:                 }
284:                 
285:                 // *****************************************************************************
286:                 /* Function: 
287:                     void BSP_LEDOff(BSP_LED led);
288:                 
289:                   Summary:
290:                     Switches Off the specified LED.
291:                   
292:                   Description:
293:                     This function switches Off the specified LED.
294:                 
295:                   Remarks:
296:                     Refer to bsp.h for usage information.
297:                 */
298:                 
299:                 void BSP_LEDOff(BSP_LED led)
300:                 {
301:                     if(led_active_level_map[led] == BSP_LED_ACTIVE_HIGH)
9D0142CC  00041080   SLL V0, A0, 2
9D0142D0  3C039D01   LUI V1, -25343
9D0142D4  246364B0   ADDIU V1, V1, 25776
9D0142D8  7C62180A   LWX V1, V0(V1)
9D0142DC  24020001   ADDIU V0, ZERO, 1
9D0142E0  14620013   BNE V1, V0, BSP_LEDOff::PLIB_PORTS_PinSet
9D0142E4  00042080   SLL A0, A0, 2
302:                     {
303:                         PLIB_PORTS_PinClear( PORTS_ID_0, led_port_channel_map[led], led_port_bit_pos_map[led] );
304:                     }
305:                     else
306:                     {
307:                         PLIB_PORTS_PinSet( PORTS_ID_0, led_port_channel_map[led], led_port_bit_pos_map[led] );
308:                     }
309:                 }
310:                 // *****************************************************************************
311:                 /* Function: 
312:                     void BSP_USBVBUSSwitchStateSet(BSP_USB_VBUS_SWITCH_STATE state);
313:                 
314:                   Summary:
315:                     This function enables or disables the USB VBUS switch on the board.
316:                   
317:                   Description:
318:                     This function enables or disables the VBUS switch on the board.
319:                 
320:                   Remarks:
321:                     Refer to bsp_config.h for usage information.
322:                 */
323:                 
324:                 void BSP_USBVBUSSwitchStateSet(BSP_USB_VBUS_SWITCH_STATE state)
325:                 {
326:                     /* Enable the VBUS switch */
327:                 
328:                     PLIB_PORTS_PinWrite( PORTS_ID_0, PORT_CHANNEL_G, PORTS_BIT_POS_13, state );
329:                 }
330:                 
331:                 // *****************************************************************************
332:                 /* Function: 
333:                     bool BSP_USBVBUSSwitchOverCurrentDetect(uint8_t port)
334:                 
335:                   Summary:
336:                     Returns true if the over current is detected on the VBUS supply.
337:                   
338:                   Description:
339:                     This function returns true if over current is detected on the VBUS supply.
340:                 
341:                   Remarks:
342:                     None.
343:                 */
344:                 
345:                 bool BSP_USBVBUSSwitchOverCurrentDetect(uint8_t port)
346:                 {
347:                     return(false);
348:                 }
9D017368  03E00008   JR RA
349:                 
350:                 // *****************************************************************************
351:                 /* Function: 
352:                     bool BSP_USBVBUSPowerEnable(uint8_t port, bool enable)
353:                 
354:                   Summary:
355:                     This function controls the USB VBUS supply.
356:                   
357:                   Description:
358:                     This function controls the USB VBUS supply.
359:                 
360:                   Remarks:
361:                     None.
362:                 */
363:                 
364:                 void BSP_USBVBUSPowerEnable(uint8_t port, bool enable)
365:                 {
9D016998  30A500FF   ANDI A1, A1, 255
366:                     /* Enable the VBUS switch */
367:                 
368:                     PLIB_PORTS_PinWrite( PORTS_ID_0, PORT_CHANNEL_G, PORTS_BIT_POS_13, enable );
369:                 }
370:                 
371:                 // *****************************************************************************
372:                 // *****************************************************************************
373:                 // *****************************************************************************
374:                 // Section: Interface Routines
375:                 // *****************************************************************************
376:                 // *****************************************************************************
377:                 
378:                 // *****************************************************************************
379:                 /* Function:
380:                     void BSP_Initialize(void)
381:                 
382:                   Summary:
383:                     Performs the necessary actions to initialize a board
384:                 
385:                   Description:
386:                     This function initializes the LED, Switch and other ports on the board.
387:                     This function must be called by the user before using any APIs present in
388:                     this BSP.
389:                 
390:                   Remarks:
391:                     Refer to bsp.h for usage information.
392:                 */
393:                 
394:                 void BSP_Initialize(void )
395:                 {
9D000110  27BDFFE8   ADDIU SP, SP, -24
9D000114  AFBF0014   SW RA, 20(SP)
396:                     /* Setting the SLEW rate for the SPI peripheral pins */
397:                     PLIB_PORTS_ChannelSlewRateSelect(PORTS_ID_0, PORT_CHANNEL_B, 0x4700, PORTS_PIN_SLEW_RATE_FAST);
398:                 
399:                     /* Setup the USB VBUS Switch Control Pin */
400:                     BSP_USBVBUSSwitchStateSet(BSP_USB_VBUS_SWITCH_STATE_DISABLE);
401:                 
402:                     /* Switch off LEDs */
403:                     BSP_LEDOff(BSP_LED_3);
9D000144  0F4050B3   JAL BSP_LEDOff
9D000148  00002021   ADDU A0, ZERO, ZERO
404:                     BSP_LEDOff(BSP_RGB_LED_RED);
9D00014C  0F4050B3   JAL BSP_LEDOff
9D000150  24040001   ADDIU A0, ZERO, 1
405:                     BSP_LEDOff(BSP_RGB_LED_GREEN);
9D000154  0F4050B3   JAL BSP_LEDOff
9D000158  24040002   ADDIU A0, ZERO, 2
406:                     BSP_LEDOff(BSP_RGB_LED_BLUE);
9D00015C  0F4050B3   JAL BSP_LEDOff
9D000160  24040003   ADDIU A0, ZERO, 3
407:                     BSP_LEDOff(BSP_LED_1);
9D000164  0F4050B3   JAL BSP_LEDOff
9D000168  24040004   ADDIU A0, ZERO, 4
408:                     BSP_LEDOff(BSP_LED_2);
9D00016C  0F4050B3   JAL BSP_LEDOff
9D000170  24040005   ADDIU A0, ZERO, 5
409:                 }
9D000174  8FBF0014   LW RA, 20(SP)
410:                 
411:                 /*******************************************************************************
412:                  End of File
413:                 */
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/switch.c  -
1:                   #include "switch.h"
2:                   
3:                   void initOnBoardSwitch(){
4:                       TRISGbits.TRISG12 = 1;
9D015B20  3C03BF86   LUI V1, -16506
9D015B24  94640610   LHU A0, 1552(V1)
9D015B28  24020001   ADDIU V0, ZERO, 1
9D015B2C  7C446304   INS A0, V0, 12, 1
9D015B30  A4640610   SH A0, 1552(V1)
5:                       CNPUGbits.CNPUG12 = 1; //enable pull up on switch
9D015B34  3C03BF86   LUI V1, -16506
9D015B38  94640650   LHU A0, 1616(V1)
9D015B3C  7C446304   INS A0, V0, 12, 1
9D015B40  A4640650   SH A0, 1616(V1)
6:                       
7:                       CNCONGbits.ON = 1; //enable change notifications for Port G
9D015B44  3C03BF86   LUI V1, -16506
9D015B48  94640670   LHU A0, 1648(V1)
9D015B4C  7C447BC4   INS A0, V0, 15, 1
9D015B50  A4640670   SH A0, 1648(V1)
8:                       CNENGbits.CNIEG12 = 1; //Enables CN for RG12
9D015B54  3C03BF86   LUI V1, -16506
9D015B58  94640680   LHU A0, 1664(V1)
9D015B5C  7C446304   INS A0, V0, 12, 1
9D015B60  A4640680   SH A0, 1664(V1)
9:                       IFS3bits.CNGIF = 0; //Set flag to lowered
9D015B64  3C03BF81   LUI V1, -16511
9D015B68  8C640070   LW A0, 112(V1)
9D015B6C  7C04E704   INS A0, ZERO, 28, 1
9D015B70  AC640070   SW A0, 112(V1)
10:                      IEC3bits.CNGIE = 1; //Enable Interrupts
9D015B74  3C03BF81   LUI V1, -16511
11:                      /*Interrupt Priority and Subpriority for this interrupt vector is set within system_init.c*/
12:                  }
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/main.c  ---
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for an MPLAB Harmony project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include <stddef.h>                     // Defines NULL
59:                  #include <stdbool.h>                    // Defines true
60:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
61:                  #include "system/common/sys_module.h"   // SYS function prototypes
62:                  
63:                  
64:                  
65:                  // *****************************************************************************
66:                  // *****************************************************************************
67:                  // Section: Main Entry Point
68:                  // *****************************************************************************
69:                  // *****************************************************************************
70:                  
71:                  int main ( void )
72:                  
73:                  {
9D016BE4  27BDFFE8   ADDIU SP, SP, -24
9D016BE8  AFBF0014   SW RA, 20(SP)
74:                      /* Initialize all MPLAB Harmony modules */
75:                      SYS_Initialize ( NULL );
9D016BEC  0F403309   JAL SYS_Initialize
9D016BF0  00002021   ADDU A0, ZERO, ZERO
76:                      /* Initialize the Application */
77:                      APP_Initialize();
9D016BF4  0F405986   JAL APP_Initialize
9D016BF8  00000000   NOP
78:                      
79:                      
80:                  
81:                      while ( true )
82:                      {
83:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
84:                          SYS_Tasks();
9D016BFC  0F405974   JAL SYS_Tasks
9D016C00  00000000   NOP
85:                          /* Maintain the application's state machine. */
86:                          APP_Tasks();
9D016C04  0F400D3F   JAL APP_Tasks
87:                      }
88:                  
89:                      /* Execution should not come here during normal operation */
90:                  
91:                      return ( EXIT_FAILURE );
92:                  }
93:                  
94:                  
95:                  /*******************************************************************************
96:                   End of File
97:                  */
98:                  
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/app.c  ----
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  // Section: Included Files 
53:                  // *****************************************************************************
54:                  // *****************************************************************************
55:                  
56:                  #include "app.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: Global Data Definitions
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  /* Application Data
66:                  
67:                    Summary:
68:                      Holds application data
69:                  
70:                    Description:
71:                      This structure holds the application's data.
72:                  
73:                    Remarks:
74:                      This structure should be initialized by the APP_Initialize function.
75:                      
76:                      Application strings and buffers are be defined outside this structure.
77:                  */
78:                  
79:                  USB_OBJ usbObj;
80:                  
81:                  volatile int transmits = 0;
82:                  volatile bool debounced = false;
83:                  volatile uint32_t n = 0;
84:                  volatile uint32_t radarDataBuffer1[BUFFERSIZE][1+(NUM_RX_CHANNELS*2)]; //"000000.000000\t000000000000\n"
85:                  volatile uint32_t radarDataBuffer2[BUFFERSIZE][1+(NUM_RX_CHANNELS*2)];
86:                  volatile int bufferindex = 0;
87:                  volatile int bufferindex2 = 0;
88:                  volatile int bufferindex3 = 0;
89:                  volatile int bufferindex4 = 0;
90:                  volatile int currInBuff = 1;
91:                  volatile int currOutBuff = 2;
92:                  volatile bool currentlyPressed = false;
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  // Section: Application Callback Functions
96:                  // *****************************************************************************
97:                  // *****************************************************************************
98:                  
99:                  /* TODO:  Add any necessary callback functions.
100:                 */
101:                 
102:                 // *****************************************************************************
103:                 // *****************************************************************************
104:                 // Section: Application Local Functions
105:                 // *****************************************************************************
106:                 // *****************************************************************************
107:                 
108:                 void setDebounced(){
109:                     debounced = true;
9D0172EC  24020001   ADDIU V0, ZERO, 1
110:                 }
111:                 void addSample(){
00000000  00000000   NOP
112:                     BSP_LEDOn( BSP_RGB_LED_RED );
00000008  00000000   NOP
113:                     BSP_LEDOff( BSP_RGB_LED_GREEN );
00000010  00000000   NOP
114:                     BSP_LEDOff( BSP_RGB_LED_BLUE );
00000018  00000000   NOP
115:                     n++;
00000020  00000000   NOP
116:                     if(currInBuff == 1 && currOutBuff == 2){
0000002C  00000000   NOP
117:                         radarDataBuffer1[bufferindex][0] = n;
0000004C  00000000   NOP
118:                         radarDataBuffer1[bufferindex][1] = ADCDATA2; //ADCDATA1bits.DATA; <- what is this BS??
00000070  00000000   NOP
119:                         radarDataBuffer1[bufferindex][2] = ADCDATA3;
00000090  00000000   NOP
120:                         //radarDataBuffer1[bufferindex][3] = ADCDATA4;
121:                         bufferindex++;
000000B0  00000000   NOP
122:                     }
123:                     else if(currInBuff == 2 && currOutBuff == 1){
000000C4  00000000   NOP
124:                         radarDataBuffer2[bufferindex][0] = n;
000000E4  00000000   NOP
125:                         radarDataBuffer2[bufferindex][1] = ADCDATA2;
00000108  00000000   NOP
126:                         radarDataBuffer2[bufferindex][2] = ADCDATA3;
00000128  00000000   NOP
127:                         //radarDataBuffer2[bufferindex][3] = ADCDATA4;
128:                         bufferindex++;
00000148  00000000   NOP
129:                     }
130:                     else{ usbObj.state = STATE_ERROR; }
0000015C  00000000   NOP
131:                 }
00000164  00000000   NOP
132:                 void addSampleFromFIFO(){
00000000  00000000   NOP
133:                     BSP_LEDOn( BSP_RGB_LED_RED );
00000008  00000000   NOP
134:                     BSP_LEDOff( BSP_RGB_LED_GREEN );
00000010  00000000   NOP
135:                     BSP_LEDOff( BSP_RGB_LED_BLUE );
00000018  00000000   NOP
136:                     int ID = ADCFSTATbits.ADCID;
00000020  00000000   NOP
137:                     if(currInBuff == 1 && currOutBuff == 2){
0000002C  00000000   NOP
138:                         if(ID == 4){
0000004C  00000000   NOP
139:                             radarDataBuffer1[bufferindex2][1] = ADCFIFO; //ADCDATA1bits.DATA; <- what is this BS??
00000054  00000000   NOP
140:                             bufferindex2++;
0000007C  00000000   NOP
141:                         }
142:                         else if(ID == 3){
00000090  00000000   NOP
143:                             radarDataBuffer1[bufferindex3][2] = ADCFIFO;
00000098  00000000   NOP
144:                             bufferindex3++;
000000C0  00000000   NOP
145:                         }
146:                     }
147:                     else if(currInBuff == 2 && currOutBuff == 1){
000000D4  00000000   NOP
148:                         if(ID == 4){
000000F4  00000000   NOP
149:                             radarDataBuffer2[bufferindex2][1] = ADCFIFO; //ADCDATA1bits.DATA; <- what is this BS??
00000100  00000000   NOP
150:                             bufferindex2++;
00000128  00000000   NOP
151:                         }
152:                         else if(ID == 3){
0000013C  00000000   NOP
153:                             radarDataBuffer2[bufferindex3][2] = ADCFIFO;
00000144  00000000   NOP
154:                             bufferindex3++;
0000016C  00000000   NOP
155:                         }
156:                     }
157:                     else{ usbObj.state = STATE_ERROR; }
00000180  00000000   NOP
158:                 }
000000CC  00000000   NOP
00000178  00000000   NOP
00000188  00000000   NOP
159:                 void togglePress(){
160:                     currentlyPressed = !currentlyPressed;
9D017220  9382806C   LBU V0, -32660(GP)
161:                 }
162:                 void convertValues(char usbCharBuff[],volatile uint32_t buffer2Conv[][1+(NUM_RX_CHANNELS*2)]){
9D0148B4  27BDFFB8   ADDIU SP, SP, -72
9D0148B8  AFBF0044   SW RA, 68(SP)
9D0148BC  AFB40040   SW S4, 64(SP)
9D0148C0  AFB3003C   SW S3, 60(SP)
9D0148C4  AFB20038   SW S2, 56(SP)
9D0148C8  AFB10034   SW S1, 52(SP)
9D0148CC  AFB00030   SW S0, 48(SP)
9D0148D0  0080A021   ADDU S4, A0, ZERO
9D0148D4  00A09821   ADDU S3, A1, ZERO
163:                     char temp[18] = "";
9D0148D8  AFA00018   SW ZERO, 24(SP)
9D0148DC  AFA0001C   SW ZERO, 28(SP)
9D0148E0  AFA00020   SW ZERO, 32(SP)
9D0148E4  AFA00024   SW ZERO, 36(SP)
9D0148E8  A7A00028   SH ZERO, 40(SP)
9D0148EC  00008021   ADDU S0, ZERO, ZERO
164:                     int row = 0;
165:                     for(row = 0; row < BUFFERSIZE; row++){
9D0148F8  34119000   ORI S1, ZERO, -28672
9D0148FC  02701021   ADDU V0, S3, S0
9D01492C  1611FFF4   BNE S0, S1, 0x9D014900
9D014930  02701021   ADDU V0, S3, S0
166:                         sprintf(temp, "%07d\t%04d\t%04d\n", buffer2Conv[row][0], buffer2Conv[row][1], buffer2Conv[row][2]);
9D0148F0  3C129D01   LUI S2, -25343
9D0148F4  26526960   ADDIU S2, S2, 26976
9D014900  8C460000   LW A2, 0(V0)
9D014904  8C470004   LW A3, 4(V0)
9D014908  8C420008   LW V0, 8(V0)
9D01490C  AFA20010   SW V0, 16(SP)
9D014910  27A40018   ADDIU A0, SP, 24
9D014914  0F4056E3   JAL _sprintf_cdnopuxX
9D014918  02402821   ADDU A1, S2, ZERO
167:                         strcat(usbCharBuff, temp);
9D01491C  02802021   ADDU A0, S4, ZERO
9D014920  0F40527C   JAL strcat
9D014924  27A50018   ADDIU A1, SP, 24
9D014928  2610000C   ADDIU S0, S0, 12
168:                     }
169:                 }
9D014934  8FBF0044   LW RA, 68(SP)
170:                 void error(){
171:                     usbObj.state = STATE_ERROR;
172:                 }
173:                 void doNothing(){
00000000  00000000   NOP
174:                     
175:                 }
176:                 // *****************************************************************************
177:                 // *****************************************************************************
178:                 // Section: Application Initialization and State Machine Functions
179:                 // *****************************************************************************
180:                 // *****************************************************************************
181:                 
182:                 /*******************************************************************************
183:                   Function:
184:                     void APP_Initialize ( void )
185:                 
186:                   Remarks:
187:                     See prototype in app.h.
188:                  */
189:                 
190:                 void APP_Initialize ( void )
191:                 {
9D016618  27BDFFE8   ADDIU SP, SP, -24
9D01661C  AFBF0014   SW RA, 20(SP)
192:                     /* Place the App state machine in its initial state. */
193:                     usbObj.state = STATE_BUS_ENABLE;
9D016620  3C028001   LUI V0, -32767
9D016624  24422AB0   ADDIU V0, V0, 10928
9D016628  AC400004   SW ZERO, 4(V0)
194:                     usbObj.deviceIsConnected = false;
195:                     
196:                     initTimer3();
9D01662C  0F4053A6   JAL initTimer3
9D016630  A0400410   SB ZERO, 1040(V0)
197:                     initTimer4();
9D016634  0F405821   JAL initTimer4
9D016638  00000000   NOP
198:                     initTimer5();
9D01663C  0F405864   JAL initTimer5
9D016640  00000000   NOP
199:                     configureADCs();
9D016644  0F401951   JAL configureADCs
9D016648  00000000   NOP
200:                     initOnBoardSwitch();
9D01664C  0F4056C8   JAL initOnBoardSwitch
9D016650  00000000   NOP
201:                 }
9D016654  8FBF0014   LW RA, 20(SP)
202:                 
203:                 USB_HOST_EVENT_RESPONSE APP_USBHostEventHandler (USB_HOST_EVENT event, void * eventData, uintptr_t context)
204:                 {
205:                     switch (event)
206:                     {
207:                         case USB_HOST_EVENT_DEVICE_UNSUPPORTED:
208:                             break;
209:                         default:
210:                             break;
211:                                     
212:                     }
213:                     
214:                     return(USB_HOST_EVENT_RESPONSE_NONE);
215:                 }
9D0173C0  03E00008   JR RA
216:                 
217:                 void APP_SYSFSEventHandler(SYS_FS_EVENT event, void * eventData, uintptr_t context)
218:                 {
219:                     switch(event)
9D016BB4  10800005   BEQ A0, ZERO, 0x9D016BCC
9D016BB8  24020001   ADDIU V0, ZERO, 1
9D016BBC  10820007   BEQ A0, V0, 0x9D016BDC
9D016BC0  3C028001   LUI V0, -32767
9D016BC4  03E00008   JR RA
9D016BC8  00000000   NOP
220:                     {
221:                         case SYS_FS_EVENT_MOUNT:
222:                             usbObj.deviceIsConnected = true;
9D016BCC  24030001   ADDIU V1, ZERO, 1
9D016BD0  3C028001   LUI V0, -32767
223:                             break;
9D016BD4  03E00008   JR RA
9D016BD8  A0432EC0   SB V1, 11968(V0)
224:                             
225:                         case SYS_FS_EVENT_UNMOUNT:
226:                             usbObj.deviceIsConnected = false;
9D016BDC  03E00008   JR RA
227:                             break;
228:                             
229:                         default:
230:                             break;
231:                     }
232:                 }
233:                 
234:                 /******************************************************************************
235:                   Function:
236:                     void APP_Tasks ( void )
237:                 
238:                   Remarks:
239:                     See prototype in app.h.
240:                  */
241:                 void APP_Tasks ( void )
242:                 {
9D0034FC  27BD8010   ADDIU SP, SP, -32752
9D003500  AFBF7FEC   SW RA, 32748(SP)
9D003504  AFB37FE8   SW S3, 32744(SP)
9D003508  AFB27FE4   SW S2, 32740(SP)
9D00350C  AFB17FE0   SW S1, 32736(SP)
9D003510  AFB07FDC   SW S0, 32732(SP)
9D003514  27BDA748   ADDIU SP, SP, -22712
243:                     char textBuff[USBBYTES] = "";
9D003518  AFA00010   SW ZERO, 16(SP)
9D00351C  27A40014   ADDIU A0, SP, 20
9D003520  00002821   ADDU A1, ZERO, ZERO
9D003524  0F405189   JAL memset
9D003528  3406D7FC   ORI A2, ZERO, -10244
244:                     int tempFIFOdata[16][2];
245:                     //int tempCount = 0;
246:                     int FIFOstatus = 0;
247:                     int FIFOcount = 0;
248:                     int i = 0;
249:                     switch(usbObj.state)
9D00352C  3C028001   LUI V0, -32767
9D003530  24422AB0   ADDIU V0, V0, 10928
9D003534  8C430004   LW V1, 4(V0)
9D003538  2C63000E   SLTIU V1, V1, 14
9D00353C  106001D0   BEQ V1, ZERO, 0x9D003C80
9D003540  3C039D00   LUI V1, -25344
9D003544  8C420004   LW V0, 4(V0)
9D003548  00021080   SLL V0, V0, 2
9D00354C  2463355C   ADDIU V1, V1, 13660
9D003550  7C62100A   LWX V0, V0(V1)
9D003554  00400008   JR V0
9D003558  00000000   NOP
250:                     {
251:                         case STATE_BUS_ENABLE:
252:                                       
253:                            /* Set the event handler and enable the bus */
254:                             SYS_FS_EventHandlerSet(APP_SYSFSEventHandler, (uintptr_t)NULL);
9D003594  3C049D01   LUI A0, -25343
9D003598  24846BB4   ADDIU A0, A0, 27572
9D00359C  0F405CB3   JAL SYS_FS_EventHandlerSet
9D0035A0  00002821   ADDU A1, ZERO, ZERO
255:                             USB_HOST_EventHandlerSet(APP_USBHostEventHandler, 0);
9D0035A4  3C049D01   LUI A0, -25343
9D0035A8  248473C0   ADDIU A0, A0, 29632
9D0035AC  0F405C7C   JAL USB_HOST_EventHandlerSet
9D0035B0  00002821   ADDU A1, ZERO, ZERO
256:                             USB_HOST_BusEnable(0);
9D0035B4  0F405718   JAL USB_HOST_BusEnable
9D0035B8  00002021   ADDU A0, ZERO, ZERO
257:                             usbObj.state = STATE_WAIT_FOR_BUS_ENABLE_COMPLETE;
9D0035BC  24030001   ADDIU V1, ZERO, 1
9D0035C0  3C028001   LUI V0, -32767
258:                             break;
9D0035C4  0B400F20   J 0x9D003C80
9D0035C8  AC432AB4   SW V1, 10932(V0)
259:                             
260:                         case STATE_WAIT_FOR_BUS_ENABLE_COMPLETE:
261:                             if(USB_HOST_BusIsEnabled(0))
9D0035CC  0F4059AA   JAL USB_HOST_BusIsEnabled
9D0035D0  00002021   ADDU A0, ZERO, ZERO
9D0035D4  504001AB   BEQL V0, ZERO, 0x9D003C84
9D0035D8  27BD58B8   ADDIU SP, SP, 22712
262:                             {
263:                                 usbObj.state = STATE_WAIT_FOR_DEVICE_ATTACH;
9D0035DC  24030002   ADDIU V1, ZERO, 2
9D0035E0  3C028001   LUI V0, -32767
9D0035E4  0B400F20   J 0x9D003C80
9D0035E8  AC432AB4   SW V1, 10932(V0)
264:                             }
265:                             break;
266:                        
267:                         case STATE_WAIT_FOR_DEVICE_ATTACH:
268:                             /* Wait for device attach. The state machine will move
269:                              * to the next state when the attach event
270:                              * is received.  */
271:                             if(usbObj.deviceIsConnected)
9D0035EC  3C028001   LUI V0, -32767
9D0035F0  90422EC0   LBU V0, 11968(V0)
9D0035F4  504001A3   BEQL V0, ZERO, 0x9D003C84
9D0035F8  27BD58B8   ADDIU SP, SP, 22712
272:                             {
273:                                 BSP_LEDOn( APP_USB_LED_3 );
9D0035FC  0F405088   JAL BSP_LEDOn
9D003600  00002021   ADDU A0, ZERO, ZERO
274:                                 BSP_LEDOff( APP_USB_LED_2 );
9D003604  0F4050B3   JAL BSP_LEDOff
9D003608  24040005   ADDIU A0, ZERO, 5
275:                                 usbObj.state = STATE_DEVICE_CONNECTED;
9D00360C  24030003   ADDIU V1, ZERO, 3
9D003610  3C028001   LUI V0, -32767
9D003614  0B400F20   J 0x9D003C80
9D003618  AC432AB4   SW V1, 10932(V0)
276:                             }
277:                             break;
278:                 
279:                         case STATE_DEVICE_CONNECTED:
280:                 
281:                             /* Device was connected. We can try mounting the disk */
282:                             usbObj.state = STATE_WRITE_FILE_HEADER;
9D00361C  24030007   ADDIU V1, ZERO, 7
9D003620  3C028001   LUI V0, -32767
283:                             break;
9D003624  0B400F20   J 0x9D003C80
9D003628  AC432AB4   SW V1, 10932(V0)
284:                 
285:                 //        case STATE_OPEN_FILE:
286:                 //
287:                 //            /* Try opening the file for append */
288:                 //            usbObj.fileHandle = SYS_FS_FileOpen(FILENAME, (SYS_FS_FILE_OPEN_APPEND_PLUS));
289:                 //            if(usbObj.fileHandle == SYS_FS_HANDLE_INVALID)
290:                 //            {
291:                 //                /* Could not open the file. Error out*/
292:                 //                usbObj.state = STATE_ERROR;
293:                 //                
294:                 //            }
295:                 //            else
296:                 //            {
297:                 //                /* File opened successfully. Write to file */
298:                 //                usbObj.state = STATE_WRITE_FILE_HEADER;
299:                 //            }
300:                 //            break; 
301:                 
302:                         case STATE_WRITE_FILE_HEADER:
303:                             usbObj.fileHandle = SYS_FS_FileOpen(FILENAME, (SYS_FS_FILE_OPEN_APPEND_PLUS)); //open for header write
9D00362C  3C049D01   LUI A0, -25343
9D003630  24846970   ADDIU A0, A0, 26992
9D003634  0F402DBD   JAL SYS_FS_FileOpen
9D003638  24050005   ADDIU A1, ZERO, 5
9D00363C  3C038001   LUI V1, -32767
9D003640  AC622AB0   SW V0, 10928(V1)
304:                             if(usbObj.fileHandle == SYS_FS_HANDLE_INVALID)
9D003644  2403FFFF   ADDIU V1, ZERO, -1
9D003648  14430005   BNE V0, V1, 0x9D003660
9D00364C  00402021   ADDU A0, V0, ZERO
305:                             {
306:                                 /* Could not open the file. Error out*/
307:                                 usbObj.state = STATE_ERROR;
9D003650  2403000D   ADDIU V1, ZERO, 13
9D003654  3C028001   LUI V0, -32767
9D003658  0B400F20   J 0x9D003C80
9D00365C  AC432AB4   SW V1, 10932(V0)
308:                                 
309:                             }
310:                             else{
311:                                 /* write the file header */
312:                                 if(SYS_FS_FileWrite( usbObj.fileHandle, (const void *) FILEHEADER, FILEHEADERCHARS) == -1){ usbObj.state = STATE_ERROR; }
9D003660  3C059D01   LUI A1, -25343
9D003664  24A56988   ADDIU A1, A1, 27016
9D003668  0F404EEB   JAL SYS_FS_FileWrite
9D00366C  2406000E   ADDIU A2, ZERO, 14
9D003670  2403FFFF   ADDIU V1, ZERO, -1
9D003674  14430005   BNE V0, V1, 0x9D00368C
9D003678  24030008   ADDIU V1, ZERO, 8
9D00367C  2403000D   ADDIU V1, ZERO, 13
9D003680  3C028001   LUI V0, -32767
9D003684  0B400DA5   J 0x9D003694
9D003688  AC432AB4   SW V1, 10932(V0)
313:                                 else{
314:                 //                    SYS_FS_FileClose(usbObj.fileHandle);
315:                                     usbObj.state = STATE_WAIT_FOR_TEST; 
9D00368C  3C028001   LUI V0, -32767
9D003690  AC432AB4   SW V1, 10932(V0)
316:                                 }
317:                                 BSP_LEDOn( BSP_RGB_LED_BLUE );
9D003694  0F405088   JAL BSP_LEDOn
9D003698  24040003   ADDIU A0, ZERO, 3
318:                                 BSP_LEDOn( BSP_RGB_LED_RED );
9D00369C  0F405088   JAL BSP_LEDOn
9D0036A0  24040001   ADDIU A0, ZERO, 1
319:                             }
320:                             break;
321:                             
322:                         case STATE_WAIT_FOR_TEST:
323:                             if(debounced == true && !currentlyPressed){ //for debouncing the switch
9D0036AC  93828084   LBU V0, -32636(GP)
9D0036B0  304200FF   ANDI V0, V0, 255
9D0036B4  1040000F   BEQ V0, ZERO, 0x9D0036F4
9D0036B8  00000000   NOP
9D0036BC  9382806C   LBU V0, -32660(GP)
9D0036C0  304200FF   ANDI V0, V0, 255
9D0036C4  1440000B   BNE V0, ZERO, 0x9D0036F4
9D0036C8  24030009   ADDIU V1, ZERO, 9
324:                                 usbObj.state = STATE_IDLE_TESTING;
9D0036CC  3C028001   LUI V0, -32767
9D0036D0  AC432AB4   SW V1, 10932(V0)
325:                                 debounced = false;
9D0036D4  A3808084   SB ZERO, -32636(GP)
326:                                 BSP_LEDOff( BSP_RGB_LED_RED );
9D0036D8  0F4050B3   JAL BSP_LEDOff
9D0036DC  24040001   ADDIU A0, ZERO, 1
327:                                 timer5ON();
9D0036E0  0F405C6F   JAL timer5ON
9D0036E4  00000000   NOP
328:                                 n = 0;
9D0036E8  AF808080   SW ZERO, -32640(GP)
9D0036EC  0B400F21   J 0x9D003C84
9D0036F0  27BD58B8   ADDIU SP, SP, 22712
329:                             }
330:                             else if(debounced == true && currentlyPressed){
9D0036F4  93828084   LBU V0, -32636(GP)
9D0036F8  304200FF   ANDI V0, V0, 255
9D0036FC  50400161   BEQL V0, ZERO, 0x9D003C84
9D003700  27BD58B8   ADDIU SP, SP, 22712
9D003704  9382806C   LBU V0, -32660(GP)
9D003708  304200FF   ANDI V0, V0, 255
9D00370C  5440015C   BNEL V0, ZERO, 0x9D003C80
9D003710  A3808084   SB ZERO, -32636(GP)
331:                                 debounced = false;
332:                             }
333:                             break;
334:                             
335:                         case STATE_IDLE_TESTING:
336:                             if(debounced == true && !currentlyPressed){
9D00371C  93828084   LBU V0, -32636(GP)
9D003720  304200FF   ANDI V0, V0, 255
9D003724  1040000D   BEQ V0, ZERO, 0x9D00375C
9D003728  00000000   NOP
9D00372C  9382806C   LBU V0, -32660(GP)
9D003730  304200FF   ANDI V0, V0, 255
9D003734  14400009   BNE V0, ZERO, 0x9D00375C
9D003738  00000000   NOP
337:                                 timer5OFF();
9D00373C  0F405C94   JAL timer5OFF
9D003740  00000000   NOP
338:                                 usbObj.state = STATE_CLOSE_FILE;
9D003744  2403000B   ADDIU V1, ZERO, 11
9D003748  3C028001   LUI V0, -32767
9D00374C  AC432AB4   SW V1, 10932(V0)
339:                                 debounced = false;
9D003750  A3808084   SB ZERO, -32636(GP)
9D003754  0B400F21   J 0x9D003C84
9D003758  27BD58B8   ADDIU SP, SP, 22712
340:                             }
341:                             else{
342:                                 if(debounced == true && currentlyPressed){
9D00375C  93828084   LBU V0, -32636(GP)
9D003760  304200FF   ANDI V0, V0, 255
9D003764  10400006   BEQ V0, ZERO, 0x9D003780
9D003768  3C02BF85   LUI V0, -16507
9D00376C  9382806C   LBU V0, -32660(GP)
9D003770  304200FF   ANDI V0, V0, 255
9D003774  54400001   BNEL V0, ZERO, 0x9D00377C
9D003778  A3808084   SB ZERO, -32636(GP)
343:                                     debounced = false;
344:                                 }
345:                 //                if(currInBuff == 1 && currOutBuff == 2 && bufferindex == BUFFERSIZE){
346:                 //                        currInBuff = 2; currOutBuff = 1;
347:                 //                        bufferindex = 0; bufferindex4 = 0; bufferindex3 = 0;
348:                 //                        usbObj.state = STATE_WRITE_TO_FILE;
349:                 //                }
350:                 //                if(currInBuff == 2 && currOutBuff == 1 && bufferindex == BUFFERSIZE){
351:                 //                        currInBuff = 1; currOutBuff = 2;
352:                 //                        bufferindex = 0; bufferindex4 = 0; bufferindex3 = 0;
353:                 //                        usbObj.state = STATE_WRITE_TO_FILE;
354:                 //                }
355:                                 FIFOstatus = ADCFSTATbits.FRDY;
9D00377C  3C02BF85   LUI V0, -16507
9D003780  8C43B0B8   LW V1, -20296(V0)
9D003784  7C630580   EXT V1, V1, 22, 1
356:                                 FIFOcount = ADCFSTATbits.FCNT;
9D003788  9042B0B9   LBU V0, -20295(V0)
357:                                 if(FIFOstatus == 1 && FIFOcount >= 2){
9D00378C  1060013C   BEQ V1, ZERO, 0x9D003C80
9D003790  304200FF   ANDI V0, V0, 255
9D003794  28420002   SLTI V0, V0, 2
9D003798  5440013A   BNEL V0, ZERO, 0x9D003C84
9D00379C  27BD58B8   ADDIU SP, SP, 22712
358:                                     BSP_LEDOn( APP_USB_LED_2 );
9D0037A0  0F405088   JAL BSP_LEDOn
9D0037A4  24040005   ADDIU A0, ZERO, 5
359:                                     if(ADCFSTATbits.FWROVERR){
9D0037A8  3C02BF85   LUI V0, -16507
9D0037AC  8C42B0B8   LW V0, -20296(V0)
9D0037B0  7C420540   EXT V0, V0, 21, 1
9D0037B4  10400005   BEQ V0, ZERO, 0x9D0037CC
9D0037B8  3404D810   ORI A0, ZERO, -10224
360:                                         BSP_LEDOn( APP_USB_LED_1 ); //overflow
9D0037BC  0F405088   JAL BSP_LEDOn
9D0037C0  24040004   ADDIU A0, ZERO, 4
9D0037C4  0B400F21   J 0x9D003C84
9D0037C8  27BD58B8   ADDIU SP, SP, 22712
361:                                     }
362:                                     else{
363:                                         i = 0;
364:                                         memset(tempFIFOdata, -1, sizeof(tempFIFOdata[0][0]) * 16 * 2);
9D0037CC  03A42021   ADDU A0, SP, A0
9D0037D0  2405FFFF   ADDIU A1, ZERO, -1
9D0037D4  0F405189   JAL memset
9D0037D8  24060080   ADDIU A2, ZERO, 128
365:                                         while(ADCFSTATbits.FRDY){
9D0037DC  3C02BF85   LUI V0, -16507
9D0037E0  8C42B0B8   LW V0, -20296(V0)
9D0037E4  7C420580   EXT V0, V0, 22, 1
9D0037E8  10400110   BEQ V0, ZERO, 0x9D003C2C
9D0037EC  3410D810   ORI S0, ZERO, -10224
9D0037F0  03B08021   ADDU S0, SP, S0
9D0037FC  3C120040   LUI S2, 64
9D00382C  8E22B0B8   LW V0, -20296(S1)
9D003830  00521024   AND V0, V0, S2
9D003834  1440FFF2   BNE V0, ZERO, 0x9D003800
9D003838  26100008   ADDIU S0, S0, 8
9D00383C  0B400F0C   J 0x9D003C30
9D003840  3C020001   LUI V0, 1
366:                                             BSP_LEDOn( BSP_RGB_LED_RED );
9D003800  0F405088   JAL BSP_LEDOn
9D003804  24040001   ADDIU A0, ZERO, 1
367:                                             BSP_LEDOff( BSP_RGB_LED_GREEN );
9D003808  0F4050B3   JAL BSP_LEDOff
9D00380C  24040002   ADDIU A0, ZERO, 2
368:                                             BSP_LEDOff( BSP_RGB_LED_BLUE );
9D003810  0F4050B3   JAL BSP_LEDOff
9D003814  24040003   ADDIU A0, ZERO, 3
369:                                             tempFIFOdata[i][0] = ADCFSTATbits.ADCID;
9D0037F4  3C11BF85   LUI S1, -16507
9D003818  8E22B0B8   LW V0, -20296(S1)
9D00381C  30420007   ANDI V0, V0, 7
9D003820  AE020000   SW V0, 0(S0)
370:                                             tempFIFOdata[i][1] = ADCFIFO;
9D0037F8  3C13BF85   LUI S3, -16507
9D003824  8E62B0BC   LW V0, -20292(S3)
9D003828  AE020004   SW V0, 4(S0)
371:                                             i++;
372:                                         }
373:                                         i = 0;
374:                                         while(tempFIFOdata[i][1] != -1 && i!=16){
9D003A88  8CA6000C   LW A2, 12(A1)
9D003A8C  54CD0004   BNEL A2, T5, 0x9D003AA0
9D003A90  24A50008   ADDIU A1, A1, 8
9D003A94  3C028001   LUI V0, -32767
9D003A98  0B400F20   J 0x9D003C80
9D003A9C  AC442AB4   SW A0, 10932(V0)
9D003AA0  14AEFF68   BNE A1, T6, 0x9D003844
9D003AA4  00000000   NOP
9D003AA8  3C028001   LUI V0, -32767
9D003AAC  0B400F20   J 0x9D003C80
9D003AB0  AC442AB4   SW A0, 10932(V0)
9D003C2C  3C020001   LUI V0, 1
9D003C30  03A21021   ADDU V0, SP, V0
9D003C34  8C46D814   LW A2, -10220(V0)
9D003C38  2402FFFF   ADDIU V0, ZERO, -1
9D003C3C  10C20010   BEQ A2, V0, 0x9D003C80
9D003C40  3C028001   LUI V0, -32767
9D003C44  8C442AB4   LW A0, 10932(V0)
9D003C48  3405D810   ORI A1, ZERO, -10224
9D003C4C  03A52821   ADDU A1, SP, A1
9D003C50  24AE0080   ADDIU T6, A1, 128
9D003C78  0B400E11   J 0x9D003844
9D003C7C  240DFFFF   ADDIU T5, ZERO, -1
375:                                             if(currInBuff == 1 && currOutBuff == 2){
9D003844  8F8C801C   LW T4, -32740(GP)
9D003848  15830047   BNE T4, V1, 0x9D003968
9D00384C  00000000   NOP
9D003850  8F8C8018   LW T4, -32744(GP)
9D003854  15820044   BNE T4, V0, 0x9D003968
9D003858  00000000   NOP
9D003C54  24030001   ADDIU V1, ZERO, 1
376:                                                 if(tempFIFOdata[i][0] == 3){
9D00385C  8CAC0000   LW T4, 0(A1)
9D003860  158B000C   BNE T4, T3, 0x9D003894
9D003864  00000000   NOP
377:                                                     radarDataBuffer1[bufferindex3][1] = tempFIFOdata[i][1];
9D003868  8F8C8074   LW T4, -32652(GP)
9D00386C  000C7880   SLL T7, T4, 2
9D003870  000C6100   SLL T4, T4, 4
9D003874  018F6023   SUBU T4, T4, T7
9D003878  01876021   ADDU T4, T4, A3
9D00387C  AD860004   SW A2, 4(T4)
378:                                                     bufferindex3++;
9D003880  8F868074   LW A2, -32652(GP)
9D003884  24C60001   ADDIU A2, A2, 1
9D003888  AF868074   SW A2, -32652(GP)
9D00388C  0B400EA3   J 0x9D003A8C
9D003890  8CA6000C   LW A2, 12(A1)
379:                                                 }
380:                                                 else if(tempFIFOdata[i][0] == 4){
9D003894  5589007D   BNEL T4, T1, 0x9D003A8C
9D003898  8CA6000C   LW A2, 12(A1)
381:                                                     n++;
9D00389C  8F8C8080   LW T4, -32640(GP)
9D0038A0  258C0001   ADDIU T4, T4, 1
9D0038A4  AF8C8080   SW T4, -32640(GP)
382:                                                     radarDataBuffer1[bufferindex][0] = n;
9D0038A8  8F8C807C   LW T4, -32644(GP)
9D0038AC  8F8F8080   LW T7, -32640(GP)
9D0038B0  000CC080   SLL T8, T4, 2
9D0038B4  000C6100   SLL T4, T4, 4
9D0038B8  01986023   SUBU T4, T4, T8
9D0038BC  01876021   ADDU T4, T4, A3
9D0038C0  AD8F0000   SW T7, 0(T4)
9D003C70  3C078000   LUI A3, -32768
9D003C74  24E70AB0   ADDIU A3, A3, 2736
383:                                                     radarDataBuffer1[bufferindex4][2] = tempFIFOdata[i][1];
9D0038C4  8F8C8070   LW T4, -32656(GP)
9D0038C8  000C7880   SLL T7, T4, 2
9D0038CC  000C6100   SLL T4, T4, 4
9D0038D0  018F6023   SUBU T4, T4, T7
9D0038D4  01876021   ADDU T4, T4, A3
9D0038D8  AD860008   SW A2, 8(T4)
384:                                                     bufferindex4++; bufferindex++;
9D0038DC  8F868070   LW A2, -32656(GP)
9D0038E0  24C60001   ADDIU A2, A2, 1
9D0038E4  AF868070   SW A2, -32656(GP)
9D0038E8  8F86807C   LW A2, -32644(GP)
9D0038EC  24C60001   ADDIU A2, A2, 1
9D0038F0  AF86807C   SW A2, -32644(GP)
385:                                                     if(bufferindex == BUFFERSIZE){
9D0038F4  8F86807C   LW A2, -32644(GP)
9D0038F8  54CA0064   BNEL A2, T2, 0x9D003A8C
9D0038FC  8CA6000C   LW A2, 12(A1)
386:                                                         if(currInBuff == 1 && currOutBuff == 2){
9D003900  8F86801C   LW A2, -32740(GP)
9D003904  14C3000B   BNE A2, V1, 0x9D003934
9D003908  00000000   NOP
9D00390C  8F868018   LW A2, -32744(GP)
9D003910  14C20008   BNE A2, V0, 0x9D003934
9D003914  00000000   NOP
387:                                                                 currInBuff = 2; currOutBuff = 1;
9D003918  AF82801C   SW V0, -32740(GP)
9D00391C  AF838018   SW V1, -32744(GP)
388:                                                                 bufferindex = 0; bufferindex3 = 0; bufferindex4 = 0;
9D003920  AF80807C   SW ZERO, -32644(GP)
9D003924  AF808074   SW ZERO, -32652(GP)
9D003928  AF808070   SW ZERO, -32656(GP)
389:                                                                 usbObj.state = STATE_WRITE_TO_FILE;
9D00392C  0B400EA2   J 0x9D003A88
9D003930  2404000A   ADDIU A0, ZERO, 10
390:                                                         }
391:                                                         else if(currInBuff == 2 && currOutBuff == 1){
9D003934  8F86801C   LW A2, -32740(GP)
9D003938  54C20054   BNEL A2, V0, 0x9D003A8C
9D00393C  8CA6000C   LW A2, 12(A1)
9D003940  8F868018   LW A2, -32744(GP)
9D003944  54C30051   BNEL A2, V1, 0x9D003A8C
9D003948  8CA6000C   LW A2, 12(A1)
392:                                                                 currInBuff = 1; currOutBuff = 2;
9D00394C  AF83801C   SW V1, -32740(GP)
9D003950  AF828018   SW V0, -32744(GP)
393:                                                                 bufferindex = 0; bufferindex3 = 0; bufferindex4 = 0;
9D003954  AF80807C   SW ZERO, -32644(GP)
9D003958  AF808074   SW ZERO, -32652(GP)
9D00395C  AF808070   SW ZERO, -32656(GP)
394:                                                                 usbObj.state = STATE_WRITE_TO_FILE;
9D003960  0B400EA2   J 0x9D003A88
9D003964  2404000A   ADDIU A0, ZERO, 10
395:                                                         }
396:                                                     }
397:                                                 }
398:                                             }
399:                                             else if(currInBuff == 2 && currOutBuff == 1){
9D003968  8F8C801C   LW T4, -32740(GP)
9D00396C  55820046   BNEL T4, V0, 0x9D003A88
9D003970  2404000D   ADDIU A0, ZERO, 13
9D003974  8F8C8018   LW T4, -32744(GP)
9D003978  55830043   BNEL T4, V1, 0x9D003A88
9D00397C  2404000D   ADDIU A0, ZERO, 13
9D003C58  24020002   ADDIU V0, ZERO, 2
400:                                                 if(tempFIFOdata[i][0] == 3){
9D003980  8CAC0000   LW T4, 0(A1)
9D003984  158B000C   BNE T4, T3, 0x9D0039B8
9D003988  00000000   NOP
9D003C5C  240B0003   ADDIU T3, ZERO, 3
401:                                                     radarDataBuffer2[bufferindex3][1] = tempFIFOdata[i][1];
9D00398C  8F8C8074   LW T4, -32652(GP)
9D003990  000C7880   SLL T7, T4, 2
9D003994  000C6100   SLL T4, T4, 4
9D003998  018F6023   SUBU T4, T4, T7
9D00399C  01886021   ADDU T4, T4, T0
9D0039A0  AD860004   SW A2, 4(T4)
402:                                                     bufferindex3++; 
9D0039A4  8F868074   LW A2, -32652(GP)
9D0039A8  24C60001   ADDIU A2, A2, 1
9D0039AC  AF868074   SW A2, -32652(GP)
9D0039B0  0B400E86   J 0x9D003A18
9D0039B4  00000000   NOP
403:                                                 }
404:                                                 else if(tempFIFOdata[i][0] == 4){
9D0039B8  15890017   BNE T4, T1, 0x9D003A18
9D0039BC  00000000   NOP
9D003C64  24090004   ADDIU T1, ZERO, 4
405:                                                     n++;
9D0039C0  8F8C8080   LW T4, -32640(GP)
9D0039C4  258C0001   ADDIU T4, T4, 1
9D0039C8  AF8C8080   SW T4, -32640(GP)
406:                                                     radarDataBuffer2[bufferindex][0] = n;
9D0039CC  8F8C807C   LW T4, -32644(GP)
9D0039D0  8F8F8080   LW T7, -32640(GP)
9D0039D4  000CC080   SLL T8, T4, 2
9D0039D8  000C6100   SLL T4, T4, 4
9D0039DC  01986023   SUBU T4, T4, T8
9D0039E0  01886021   ADDU T4, T4, T0
9D0039E4  AD8F0000   SW T7, 0(T4)
9D003C68  3C088001   LUI T0, -32767
9D003C6C  25089AB0   ADDIU T0, T0, -25936
407:                                                     radarDataBuffer2[bufferindex4][2] = tempFIFOdata[i][1];
9D0039E8  8F8C8070   LW T4, -32656(GP)
9D0039EC  000C7880   SLL T7, T4, 2
9D0039F0  000C6100   SLL T4, T4, 4
9D0039F4  018F6023   SUBU T4, T4, T7
9D0039F8  01886021   ADDU T4, T4, T0
9D0039FC  AD860008   SW A2, 8(T4)
408:                                                     bufferindex4++; bufferindex++;
9D003A00  8F868070   LW A2, -32656(GP)
9D003A04  24C60001   ADDIU A2, A2, 1
9D003A08  AF868070   SW A2, -32656(GP)
9D003A0C  8F86807C   LW A2, -32644(GP)
9D003A10  24C60001   ADDIU A2, A2, 1
9D003A14  AF86807C   SW A2, -32644(GP)
409:                                                 }
410:                                                 if(bufferindex == BUFFERSIZE){
9D003A18  8F86807C   LW A2, -32644(GP)
9D003A1C  54CA001B   BNEL A2, T2, 0x9D003A8C
9D003A20  8CA6000C   LW A2, 12(A1)
9D003C60  240A0C00   ADDIU T2, ZERO, 3072
411:                                                         if(currInBuff == 1 && currOutBuff == 2){
9D003A24  8F86801C   LW A2, -32740(GP)
9D003A28  14C3000B   BNE A2, V1, 0x9D003A58
9D003A2C  00000000   NOP
9D003A30  8F868018   LW A2, -32744(GP)
9D003A34  14C20008   BNE A2, V0, 0x9D003A58
9D003A38  00000000   NOP
412:                                                                 currInBuff = 2; currOutBuff = 1;
9D003A3C  AF82801C   SW V0, -32740(GP)
9D003A40  AF838018   SW V1, -32744(GP)
413:                                                                 bufferindex = 0; bufferindex3 = 0; bufferindex4 = 0;
9D003A44  AF80807C   SW ZERO, -32644(GP)
9D003A48  AF808074   SW ZERO, -32652(GP)
9D003A4C  AF808070   SW ZERO, -32656(GP)
414:                                                                 usbObj.state = STATE_WRITE_TO_FILE;
9D003A50  0B400EA2   J 0x9D003A88
9D003A54  2404000A   ADDIU A0, ZERO, 10
415:                                                         }
416:                                                         else if(currInBuff == 2 && currOutBuff == 1){
9D003A58  8F86801C   LW A2, -32740(GP)
9D003A5C  54C2000B   BNEL A2, V0, 0x9D003A8C
9D003A60  8CA6000C   LW A2, 12(A1)
9D003A64  8F868018   LW A2, -32744(GP)
9D003A68  54C30008   BNEL A2, V1, 0x9D003A8C
9D003A6C  8CA6000C   LW A2, 12(A1)
417:                                                                 currInBuff = 1; currOutBuff = 2;
9D003A70  AF83801C   SW V1, -32740(GP)
9D003A74  AF828018   SW V0, -32744(GP)
418:                                                                 bufferindex = 0; bufferindex3 = 0; bufferindex4 = 0;
9D003A78  AF80807C   SW ZERO, -32644(GP)
9D003A7C  AF808074   SW ZERO, -32652(GP)
9D003A80  AF808070   SW ZERO, -32656(GP)
9D003A84  2404000A   ADDIU A0, ZERO, 10
419:                                                                 usbObj.state = STATE_WRITE_TO_FILE;
420:                                                         }
421:                                                     }
422:                                             }
423:                                             else{ usbObj.state = STATE_ERROR; }
424:                                             i++;
425:                                         }
426:                                         //convertTempFIFOdata();
427:                 //                        for(tempCount = 0; tempCount < FIFOcount/2; tempCount++){
428:                 //                            n++;
429:                 //                            if(currInBuff == 1 && currOutBuff == 2){
430:                 //                                radarDataBuffer1[bufferindex][0] = n;
431:                 //                            }
432:                 //                            else if(currInBuff == 2 && currOutBuff == 1){
433:                 //                                radarDataBuffer2[bufferindex][0] = n;
434:                 //                            }
435:                 //                            else{ usbObj.state = STATE_ERROR; }
436:                 //                            bufferindex++;
437:                 //
438:                 //                            addSampleFromFIFO();
439:                 //                            addSampleFromFIFO();
440:                 //                        }
441:                                     }
442:                                 }
443:                             }
444:                             break;
445:                             
446:                         case STATE_WRITE_TO_FILE:
447:                 //            usbObj.fileHandle = SYS_FS_FileOpen(FILENAME, (SYS_FS_FILE_OPEN_APPEND_PLUS)); //reopen for datawrite
448:                 //            if(usbObj.fileHandle == SYS_FS_HANDLE_INVALID)
449:                 //            {
450:                 //                /* Could not open the file. Error out*/
451:                 //                usbObj.state = STATE_ERROR;
452:                 //                
453:                 //            }
454:                             if(currInBuff == 1 && currOutBuff == 2){
9D003AB4  8F83801C   LW V1, -32740(GP)
9D003AB8  24020001   ADDIU V0, ZERO, 1
9D003ABC  14620017   BNE V1, V0, 0x9D003B1C
9D003AC0  00000000   NOP
9D003AC4  8F838018   LW V1, -32744(GP)
9D003AC8  24020002   ADDIU V0, ZERO, 2
9D003ACC  14620013   BNE V1, V0, 0x9D003B1C
9D003AD0  27A40010   ADDIU A0, SP, 16
455:                                 convertValues(textBuff, radarDataBuffer2);
9D003AD4  3C058001   LUI A1, -32767
9D003AD8  0F40522D   JAL convertValues
9D003ADC  24A59AB0   ADDIU A1, A1, -25936
456:                                 if(SYS_FS_FileWrite( usbObj.fileHandle, (const void *) textBuff, USBBYTES) == -1){ usbObj.state = STATE_ERROR; }
9D003AE0  3C028001   LUI V0, -32767
9D003AE4  8C442AB0   LW A0, 10928(V0)
9D003AE8  27A50010   ADDIU A1, SP, 16
9D003AEC  0F404EEB   JAL SYS_FS_FileWrite
9D003AF0  3406D800   ORI A2, ZERO, -10240
9D003AF4  2403FFFF   ADDIU V1, ZERO, -1
9D003AF8  14430005   BNE V0, V1, 0x9D003B10
9D003AFC  24030009   ADDIU V1, ZERO, 9
9D003B00  2403000D   ADDIU V1, ZERO, 13
9D003B04  3C028001   LUI V0, -32767
9D003B08  0B400F20   J 0x9D003C80
9D003B0C  AC432AB4   SW V1, 10932(V0)
457:                                 else{ 
458:                 //                    SYS_FS_FileClose(usbObj.fileHandle);
459:                                     usbObj.state = STATE_IDLE_TESTING; 
9D003B10  3C028001   LUI V0, -32767
9D003B14  0B400F20   J 0x9D003C80
9D003B18  AC432AB4   SW V1, 10932(V0)
460:                                 }
461:                             }
462:                             else if(currInBuff == 2 && currOutBuff == 1){
9D003B1C  8F83801C   LW V1, -32740(GP)
9D003B20  24020002   ADDIU V0, ZERO, 2
9D003B24  14620018   BNE V1, V0, 0x9D003B88
9D003B28  2403000D   ADDIU V1, ZERO, 13
9D003B2C  8F838018   LW V1, -32744(GP)
9D003B30  24020001   ADDIU V0, ZERO, 1
9D003B34  14620014   BNE V1, V0, 0x9D003B88
9D003B38  2403000D   ADDIU V1, ZERO, 13
463:                                 convertValues(textBuff, radarDataBuffer1);
9D003B3C  27A40010   ADDIU A0, SP, 16
9D003B40  3C058000   LUI A1, -32768
9D003B44  0F40522D   JAL convertValues
9D003B48  24A50AB0   ADDIU A1, A1, 2736
464:                                 if(SYS_FS_FileWrite( usbObj.fileHandle, (const void *) textBuff, USBBYTES) == -1){ usbObj.state = STATE_ERROR; }
9D003B4C  3C028001   LUI V0, -32767
9D003B50  8C442AB0   LW A0, 10928(V0)
9D003B54  27A50010   ADDIU A1, SP, 16
9D003B58  0F404EEB   JAL SYS_FS_FileWrite
9D003B5C  3406D800   ORI A2, ZERO, -10240
9D003B60  2403FFFF   ADDIU V1, ZERO, -1
9D003B64  14430005   BNE V0, V1, 0x9D003B7C
9D003B68  24030009   ADDIU V1, ZERO, 9
9D003B6C  2403000D   ADDIU V1, ZERO, 13
9D003B70  3C028001   LUI V0, -32767
9D003B74  0B400F20   J 0x9D003C80
9D003B78  AC432AB4   SW V1, 10932(V0)
465:                                 else{
466:                                     //SYS_FS_FileClose(usbObj.fileHandle);
467:                                     usbObj.state = STATE_IDLE_TESTING;
9D003B7C  3C028001   LUI V0, -32767
9D003B80  0B400F20   J 0x9D003C80
9D003B84  AC432AB4   SW V1, 10932(V0)
468:                                 }
469:                             }
470:                             else{ usbObj.state = STATE_ERROR; }
9D003B88  3C028001   LUI V0, -32767
9D003B8C  0B400F20   J 0x9D003C80
9D003B90  AC432AB4   SW V1, 10932(V0)
471:                             break;
472:                 
473:                         case STATE_CLOSE_FILE:
474:                             /* Close the file */
475:                             SYS_FS_FileClose(usbObj.fileHandle);
9D003B94  3C108001   LUI S0, -32767
9D003B98  0F404FD4   JAL SYS_FS_FileClose
9D003B9C  8E042AB0   LW A0, 10928(S0)
476:                 
477:                             /* The test was successful. Lets idle. */
478:                             usbObj.state = STATE_TEST_COMPLETE;
9D003BA0  26102AB0   ADDIU S0, S0, 10928
9D003BA4  2402000C   ADDIU V0, ZERO, 12
479:                             break;
9D003BA8  0B400F20   J 0x9D003C80
9D003BAC  AE020004   SW V0, 4(S0)
480:                 
481:                         case STATE_TEST_COMPLETE:
482:                 
483:                             BSP_LEDOff( APP_USB_LED_3);
9D003BB0  0F4050B3   JAL BSP_LEDOff
9D003BB4  00002021   ADDU A0, ZERO, ZERO
484:                             BSP_LEDOn( APP_USB_LED_2 );
9D003BB8  0F405088   JAL BSP_LEDOn
9D003BBC  24040005   ADDIU A0, ZERO, 5
485:                             BSP_LEDOff(BSP_RGB_LED_BLUE);
9D003BC0  0F4050B3   JAL BSP_LEDOff
9D003BC4  24040003   ADDIU A0, ZERO, 3
486:                             BSP_LEDOff(BSP_RGB_LED_RED);
9D003BC8  0F4050B3   JAL BSP_LEDOff
9D003BCC  24040001   ADDIU A0, ZERO, 1
487:                             BSP_LEDOn(BSP_RGB_LED_GREEN);
9D003BD0  0F405088   JAL BSP_LEDOn
9D003BD4  24040002   ADDIU A0, ZERO, 2
488:                             if(usbObj.deviceIsConnected == false)
9D003BD8  3C028001   LUI V0, -32767
9D003BDC  90422EC0   LBU V0, 11968(V0)
9D003BE0  54400028   BNEL V0, ZERO, 0x9D003C84
9D003BE4  27BD58B8   ADDIU SP, SP, 22712
489:                             {
490:                                 usbObj.state = STATE_WAIT_FOR_DEVICE_ATTACH;
9D003BE8  24030002   ADDIU V1, ZERO, 2
9D003BEC  3C028001   LUI V0, -32767
9D003BF0  AC432AB4   SW V1, 10932(V0)
491:                                 BSP_LEDOff(APP_USB_LED_2);
9D003BF4  0F4050B3   JAL BSP_LEDOff
9D003BF8  24040005   ADDIU A0, ZERO, 5
492:                                 BSP_LEDOff(BSP_RGB_LED_GREEN);
9D003BFC  0F4050B3   JAL BSP_LEDOff
9D003C00  24040002   ADDIU A0, ZERO, 2
493:                                 BSP_LEDOff(BSP_RGB_LED_RED);
9D003C04  0F4050B3   JAL BSP_LEDOff
9D003C08  24040001   ADDIU A0, ZERO, 1
494:                                 BSP_LEDOff(BSP_RGB_LED_BLUE);
9D003C0C  0F4050B3   JAL BSP_LEDOff
9D003C10  24040003   ADDIU A0, ZERO, 3
495:                             }
496:                             break;
497:                 
498:                         case STATE_ERROR:
499:                 
500:                             /* The application comes here when the demo
501:                              * has failed. Provide LED indication .*/
502:                 
503:                             BSP_LEDOn( APP_USB_LED_1 );
9D003C1C  0F405088   JAL BSP_LEDOn
9D003C20  24040004   ADDIU A0, ZERO, 4
9D003C24  0B400F09   J 0x9D003C24
9D003C28  00000000   NOP
504:                             while(1){
505:                                 doNothing();
506:                             }
507:                             if(SYS_FS_Unmount("/mnt/myDrive") != 0)
508:                             {
509:                                 /* The disk could not be un mounted. Try
510:                                  * un mounting again until success. */
511:                 
512:                                 usbObj.state = STATE_ERROR;
513:                             }
514:                             else
515:                             {
516:                                 /* UnMount was successful. Wait for device attach */
517:                                 usbObj.state =  STATE_WAIT_FOR_DEVICE_ATTACH;
518:                             }
519:                             break;
520:                 
521:                         default:
522:                             break;
523:                     }
524:                 }
9D0036A4  0B400F21   J 0x9D003C84
9D0036A8  27BD58B8   ADDIU SP, SP, 22712
9D003714  0B400F21   J 0x9D003C84
9D003718  27BD58B8   ADDIU SP, SP, 22712
9D003C14  0B400F21   J 0x9D003C84
9D003C18  27BD58B8   ADDIU SP, SP, 22712
9D003C80  27BD58B8   ADDIU SP, SP, 22712
525:                 
526:                 /*******************************************************************************
527:                  End of File
528:                  */
---  c:/users/jsiek/documents/spring_2017/engr498/capture/seniordesign/msd_basic/firmware/src/adc.c  ----
1:                   #include "adc.h"
2:                   
3:                   void configureADCs(){
4:                       IFS1bits.ADCIF = 0;
9D006544  3C08BF81   LUI T0, -16511
9D006548  8D020050   LW V0, 80(T0)
9D00654C  7C026304   INS V0, ZERO, 12, 1
9D006550  AD020050   SW V0, 80(T0)
5:                       IPC11bits.ADCIP = 7;
9D006554  3C05BF81   LUI A1, -16511
9D006558  8CA201F0   LW V0, 496(A1)
9D00655C  24070007   ADDIU A3, ZERO, 7
9D006560  7CE22084   INS V0, A3, 2, 3
9D006564  ACA201F0   SW V0, 496(A1)
6:                       IPC11bits.ADCIS = 0;
9D006568  8CA201F0   LW V0, 496(A1)
9D00656C  7C020804   INS V0, ZERO, 0, 2
9D006570  ACA201F0   SW V0, 496(A1)
7:                       IEC1bits.ADCIE = 0;
9D006574  3C06BF81   LUI A2, -16511
9D006578  8CC200D0   LW V0, 208(A2)
9D00657C  7C026304   INS V0, ZERO, 12, 1
9D006580  ACC200D0   SW V0, 208(A2)
8:                       
9:                   //    jumpTable[0] = &ADC0Handler; // Set up jump table
10:                  //    jumpTable[2] = &ADC1Handler;
11:                  //    jumpTable[4] = &ADC2Handler;
12:                      
13:                      ADCANCON = 0;
9D006584  3C03BF85   LUI V1, -16507
9D006588  AC60B100   SW ZERO, -20224(V1)
14:                      TRISBbits.TRISB15 = 1;
9D00658C  3C04BF86   LUI A0, -16506
9D006590  94890110   LHU T1, 272(A0)
9D006594  24020001   ADDIU V0, ZERO, 1
9D006598  7C497BC4   INS T1, V0, 15, 1
9D00659C  A4890110   SH T1, 272(A0)
15:                      CNPUBbits.CNPUB15 = 0;
9D0065A0  3C04BF86   LUI A0, -16506
9D0065A4  94890150   LHU T1, 336(A0)
9D0065A8  7C097BC4   INS T1, ZERO, 15, 1
9D0065AC  A4890150   SH T1, 336(A0)
16:                      ANSELBbits.ANSB15 = 1;
9D0065B0  3C04BF86   LUI A0, -16506
9D0065B4  94890100   LHU T1, 256(A0)
9D0065B8  7C497BC4   INS T1, V0, 15, 1
9D0065BC  A4890100   SH T1, 256(A0)
17:                      /* Copying values per datasheet spec */
18:                      ADC0CFG = DEVADC0;
9D0065C0  3C04BFC5   LUI A0, -16443
9D0065C4  8C894000   LW T1, 16384(A0)
9D0065C8  3C04BF85   LUI A0, -16507
9D0065CC  AC89B180   SW T1, -20096(A0)
19:                      ADC1CFG = DEVADC1;
9D0065D0  3C04BFC5   LUI A0, -16443
9D0065D4  8C894004   LW T1, 16388(A0)
9D0065D8  3C04BF85   LUI A0, -16507
9D0065DC  AC89B184   SW T1, -20092(A0)
20:                      ADC2CFG = DEVADC2;
9D0065E0  3C04BFC5   LUI A0, -16443
9D0065E4  8C894008   LW T1, 16392(A0)
9D0065E8  3C04BF85   LUI A0, -16507
9D0065EC  AC89B188   SW T1, -20088(A0)
21:                      ADC3CFG = DEVADC3;
9D0065F0  3C04BFC5   LUI A0, -16443
9D0065F4  8C89400C   LW T1, 16396(A0)
9D0065F8  3C04BF85   LUI A0, -16507
9D0065FC  AC89B18C   SW T1, -20084(A0)
22:                      ADC4CFG = DEVADC4;
9D006600  3C04BFC5   LUI A0, -16443
9D006604  8C894010   LW T1, 16400(A0)
9D006608  3C04BF85   LUI A0, -16507
9D00660C  AC89B190   SW T1, -20080(A0)
23:                      ADC7CFG = DEVADC7;
9D006610  3C04BFC5   LUI A0, -16443
9D006614  8C89401C   LW T1, 16412(A0)
9D006618  3C04BF85   LUI A0, -16507
9D00661C  AC89B19C   SW T1, -20068(A0)
24:                      
25:                      /* Configure ADCCON1 */
26:                      ADCCON1 = 0;
9D006620  3C04BF85   LUI A0, -16507
9D006624  AC80B000   SW ZERO, -20480(A0)
27:                      CFGCONbits.IOANCPEN = 0;
9D006628  3C04BF80   LUI A0, -16512
9D00662C  90890000   LBU T1, 0(A0)
9D006630  7C0939C4   INS T1, ZERO, 7, 1
9D006634  A0890000   SB T1, 0(A0)
28:                      ADCCON1bits.AICPMPEN = 0;
9D006638  3C04BF85   LUI A0, -16507
9D00663C  8C89B000   LW T1, -20480(A0)
9D006640  7C096304   INS T1, ZERO, 12, 1
9D006644  AC89B000   SW T1, -20480(A0)
29:                      ADCCON1bits.SELRES = 3; //12-bit resolution
9D006648  8C8AB000   LW T2, -20480(A0)
9D00664C  24090003   ADDIU T1, ZERO, 3
9D006650  7D2AB544   INS T2, T1, 21, 2
9D006654  AC8AB000   SW T2, -20480(A0)
30:                      ADCCON1bits.STRGSRC = 0;
9D006658  8C8AB000   LW T2, -20480(A0)
9D00665C  7C0AA404   INS T2, ZERO, 16, 5
9D006660  AC8AB000   SW T2, -20480(A0)
31:                      ADCCON1bits.STRGLVL = 0;
9D006664  8C8AB000   LW T2, -20480(A0)
9D006668  7C0A18C4   INS T2, ZERO, 3, 1
9D00666C  AC8AB000   SW T2, -20480(A0)
32:                      
33:                      /* Configure ADCCON2 */
34:                      ADCCON2 = 0;
9D006670  3C0ABF85   LUI T2, -16507
9D006674  AD40B004   SW ZERO, -20476(T2)
35:                      //ADCCON2bits.EOSIEN = 1; //Interrupt when scan finished -> what does this do exactly?
36:                      //ADCCON2bits.SAMC = 5; //ADC7 sampling time = 5 * TAD7 -> 500ns
37:                      //ADCCON2bits.ADCDIV = 1; //2*T_Q = T_AD7 -> 100ns
38:                      
39:                      /* Initialize warm up time register */
40:                      ADCANCON = 0;
9D006678  AC60B100   SW ZERO, -20224(V1)
41:                      ADCANCONbits.WKUPCLKCNT = 5; // Wakeup exponent = 32 * TADx
9D00667C  3C03BF85   LUI V1, -16507
9D006680  8C6AB100   LW T2, -20224(V1)
9D006684  240B0005   ADDIU T3, ZERO, 5
9D006688  7D6ADE04   INS T2, T3, 24, 4
9D00668C  AC6AB100   SW T2, -20224(V1)
42:                      
43:                      /* Clock setting */
44:                      ADCCON3 = 0;
9D006690  3C03BF85   LUI V1, -16507
9D006694  AC60B008   SW ZERO, -20472(V1)
45:                      ADCCON3bits.ADCSEL = 1; // T_CLK = 1/PBCLK3 (1/100M) -> 10ns
9D006698  3C03BF85   LUI V1, -16507
9D00669C  8C6AB008   LW T2, -20472(V1)
9D0066A0  7C4AFF84   INS T2, V0, 30, 2
9D0066A4  AC6AB008   SW T2, -20472(V1)
46:                      ADCCON3bits.CONCLKDIV = (5-1); // T_Q = 5*T_CLK -> 50ns
9D0066A8  8C6AB008   LW T2, -20472(V1)
9D0066AC  240C0004   ADDIU T4, ZERO, 4
9D0066B0  7D8AEE04   INS T2, T4, 24, 6
9D0066B4  AC6AB008   SW T2, -20472(V1)
47:                      ADCCON3bits.VREFSEL = 0; // Select AVDD and AVSS as reference source
9D0066B8  8C6AB008   LW T2, -20472(V1)
9D0066BC  7C0A7B44   INS T2, ZERO, 13, 3
9D0066C0  AC6AB008   SW T2, -20472(V1)
48:                      
49:                      
50:                      /* Select ADC sample time and conversion clock */
51:                  //    ADC0TIMEbits.ADCDIV = 1; // ADC0 clock frequency is half of control clock = TAD0
52:                  //    ADC0TIMEbits.SAMC = 5; // ADC0 sampling time = 5 * TAD0
53:                  //    ADC0TIMEbits.SELRES = 3; // ADC0 resolution is 12 bits
54:                  //    ADC1TIMEbits.ADCDIV = 1; // ADC1 clock frequency is half of control clock = TAD1 -> 100ns
55:                  //    ADC1TIMEbits.SAMC = 555; // ADC1 sampling time = 555 * TAD1 -> 55.5us
56:                  //    ADC1TIMEbits.SELRES = 3; // ADC1 resolution is 12 bits
57:                      ADC2TIMEbits.ADCDIV = 1; // ADC2 clock frequency is half of control clock = TAD2 -> 100ns
9D0066C4  3C03BF85   LUI V1, -16507
9D0066C8  8C6AB0DC   LW T2, -20260(V1)
9D0066CC  7C4AB404   INS T2, V0, 16, 7
9D0066D0  AC6AB0DC   SW T2, -20260(V1)
58:                      ADC2TIMEbits.SAMC = 555; // ADC2 sampling time = 555 * TAD2 -> 55.5us
9D0066D4  8C6AB0DC   LW T2, -20260(V1)
9D0066D8  240C022B   ADDIU T4, ZERO, 555
9D0066DC  7D8A4804   INS T2, T4, 0, 10
9D0066E0  AC6AB0DC   SW T2, -20260(V1)
59:                      ADC2TIMEbits.SELRES = 3; // ADC2 resolution is 12 bits
9D0066E4  8C6AB0DC   LW T2, -20260(V1)
9D0066E8  7D2ACE04   INS T2, T1, 24, 2
9D0066EC  AC6AB0DC   SW T2, -20260(V1)
60:                      ADC3TIMEbits.ADCDIV = 1; // ADC3 clock frequency is 1/2 of control clock = TAD3 -> 100ns
9D0066F0  3C03BF85   LUI V1, -16507
9D0066F4  8C6AB0E0   LW T2, -20256(V1)
9D0066F8  7C4AB404   INS T2, V0, 16, 7
9D0066FC  AC6AB0E0   SW T2, -20256(V1)
61:                      ADC3TIMEbits.SAMC = 10; // ADC3 sampling time = 555 * TAD3 -> 55.5us
9D006700  8C6AB0E0   LW T2, -20256(V1)
9D006704  240C000A   ADDIU T4, ZERO, 10
9D006708  7D8A4804   INS T2, T4, 0, 10
9D00670C  AC6AB0E0   SW T2, -20256(V1)
62:                      ADC3TIMEbits.SELRES = 3; // ADC3 resolution is 12 bits
9D006710  8C6AB0E0   LW T2, -20256(V1)
9D006714  7D2ACE04   INS T2, T1, 24, 2
9D006718  AC6AB0E0   SW T2, -20256(V1)
63:                      ADC4TIMEbits.ADCDIV = 2; // ADC4 clock frequency is 1/4 of control clock = TAD4 -> 200ns
9D00671C  3C03BF85   LUI V1, -16507
9D006720  8C6AB0E4   LW T2, -20252(V1)
9D006724  240C0002   ADDIU T4, ZERO, 2
9D006728  7D8AB404   INS T2, T4, 16, 7
9D00672C  AC6AB0E4   SW T2, -20252(V1)
64:                      ADC4TIMEbits.SAMC = 5; // ADC4 sampling time = 277 * TAD4 -> 55.4us
9D006730  8C6AB0E4   LW T2, -20252(V1)
9D006734  7D6A4804   INS T2, T3, 0, 10
9D006738  AC6AB0E4   SW T2, -20252(V1)
65:                      ADC4TIMEbits.SELRES = 3; // ADC4 resolution is 12 bits
9D00673C  8C6AB0E4   LW T2, -20252(V1)
9D006740  7D2ACE04   INS T2, T1, 24, 2
9D006744  AC6AB0E4   SW T2, -20252(V1)
66:                      
67:                      /* Select analog input for ADC modules, no presync trigger, not sync sampling */
68:                      //ADCTRGMODEbits.SH0ALT = 0; // ADC0 = AN0 NOT AVAILABLE! on this dev board
69:                      //ADCTRGMODEbits.SH1ALT = 1; // ADC1 = AN46   
70:                      ADCTRGMODEbits.SH2ALT = 0; // ADC2 = AN2
9D006748  3C03BF85   LUI V1, -16507
9D00674C  8C69B00C   LW T1, -20468(V1)
9D006750  7C09AD04   INS T1, ZERO, 20, 2
9D006754  AC69B00C   SW T1, -20468(V1)
71:                      ADCTRGMODEbits.SH3ALT = 0; // ADC3 = AN3
9D006758  8C69B00C   LW T1, -20468(V1)
9D00675C  7C09BD84   INS T1, ZERO, 22, 2
9D006760  AC69B00C   SW T1, -20468(V1)
72:                      ADCTRGMODEbits.SH4ALT = 0; // ADC4 = AN4
9D006764  8C69B00C   LW T1, -20468(V1)
9D006768  7C09CE04   INS T1, ZERO, 24, 2
9D00676C  AC69B00C   SW T1, -20468(V1)
73:                      //ADCTRGMODEbits.STRGEN1 = 1; //presync triggers
74:                      //ADCTRGMODEbits.STRGEN2 = 1;
75:                      ADCTRGMODEbits.STRGEN3 = 1;
9D006770  8C69B00C   LW T1, -20468(V1)
9D006774  7C495AC4   INS T1, V0, 11, 1
9D006778  AC69B00C   SW T1, -20468(V1)
76:                      ADCTRGMODEbits.STRGEN4 = 1;
9D00677C  8C69B00C   LW T1, -20468(V1)
9D006780  7C496304   INS T1, V0, 12, 1
9D006784  AC69B00C   SW T1, -20468(V1)
77:                      
78:                      /* Select ADC input mode */
79:                      //ADCIMCON1bits.SIGN1 = 0; // unsigned data format
80:                      //ADCIMCON1bits.DIFF1 = 0; // Single ended mode
81:                      ADCIMCON1bits.SIGN2 = 0; // unsigned data format
9D006788  3C03BF85   LUI V1, -16507
9D00678C  8C69B010   LW T1, -20464(V1)
9D006790  7C092104   INS T1, ZERO, 4, 1
9D006794  AC69B010   SW T1, -20464(V1)
82:                      ADCIMCON1bits.DIFF2 = 0; // Single ended mode
9D006798  8C69B010   LW T1, -20464(V1)
9D00679C  7C092944   INS T1, ZERO, 5, 1
9D0067A0  AC69B010   SW T1, -20464(V1)
83:                      ADCIMCON1bits.SIGN3 = 0; // unsigned data format
9D0067A4  8C69B010   LW T1, -20464(V1)
9D0067A8  7C093184   INS T1, ZERO, 6, 1
9D0067AC  AC69B010   SW T1, -20464(V1)
84:                      ADCIMCON1bits.DIFF3 = 0; // Single ended mode
9D0067B0  8C69B010   LW T1, -20464(V1)
9D0067B4  7C0939C4   INS T1, ZERO, 7, 1
9D0067B8  AC69B010   SW T1, -20464(V1)
85:                      ADCIMCON1bits.SIGN4 = 0; // unsigned data format
9D0067BC  8C69B010   LW T1, -20464(V1)
9D0067C0  7C094204   INS T1, ZERO, 8, 1
9D0067C4  AC69B010   SW T1, -20464(V1)
86:                      ADCIMCON1bits.DIFF4 = 0; // Single ended mode
9D0067C8  8C69B010   LW T1, -20464(V1)
9D0067CC  7C094A44   INS T1, ZERO, 9, 1
9D0067D0  AC69B010   SW T1, -20464(V1)
87:                      //ADCIMCON1bits.SIGN10 = 0; // unsigned data format
88:                      //ADCIMCON1bits.DIFF10 = 0; // Single ended mode
89:                      
90:                      /* Configure ADCGIRQENx */
91:                      ADCGIRQEN1 = 0;
9D0067D4  3C03BF85   LUI V1, -16507
9D0067D8  AC60B020   SW ZERO, -20448(V1)
92:                      ADCGIRQEN2 = 0;
9D0067DC  3C03BF85   LUI V1, -16507
9D0067E0  AC60B024   SW ZERO, -20444(V1)
93:                  //    ADCGIRQEN1bits.AGIEN0 = 1; // Enable data ready interrupt for AN0
94:                      //ADCGIRQEN1bits.AGIEN1 = 1; // Enable data ready interrupt for AN1
95:                      //ADCGIRQEN1bits.AGIEN2 = 1; // Enable data ready interrupt for AN2
96:                      //ADCGIRQEN1bits.AGIEN3 = 1; // Enable data ready interrupt for AN3
97:                      //ADCGIRQEN1bits.AGIEN4 = 1; // Enable data ready interrupt for AN4
98:                      
99:                      /* Configure ADBASE */ //need to look into this
100:                     //ADCBASE = (int)(&jumpTable[0]); // Initialize ADCBASE with starting address of jump table
101:                     //ADCCON1bits.IRQVS = 0; // No left shift of address
102:                     
103:                     /* Configure ADCCSSx */
104:                     ADCCSS1 = 0;
9D0067E4  3C03BF85   LUI V1, -16507
9D0067E8  AC60B028   SW ZERO, -20440(V1)
105:                     ADCCSS2 = 0;
9D0067EC  3C03BF85   LUI V1, -16507
9D0067F0  AC60B02C   SW ZERO, -20436(V1)
106:                     
107:                     /* Configure ADCCMPCONx */
108:                     ADCCMPCON1 = 0; // No digital comparators are used. Setting the ADCCMPCONx
9D0067F4  3C03BF85   LUI V1, -16507
9D0067F8  AC60B0A0   SW ZERO, -20320(V1)
109:                     ADCCMPCON2 = 0; // register to '0' ensures that the comparator is disabled.
9D0067FC  3C03BF85   LUI V1, -16507
9D006800  AC60B0A4   SW ZERO, -20316(V1)
110:                     ADCCMPCON3 = 0; // Other registers are ?don't care?.
9D006804  3C03BF85   LUI V1, -16507
9D006808  AC60B0A8   SW ZERO, -20312(V1)
111:                     ADCCMPCON4 = 0;
9D00680C  3C03BF85   LUI V1, -16507
9D006810  AC60B0AC   SW ZERO, -20308(V1)
112:                     ADCCMPCON5 = 0;
9D006814  3C03BF85   LUI V1, -16507
9D006818  AC60B0B0   SW ZERO, -20304(V1)
113:                     ADCCMPCON6 = 0;
9D00681C  3C03BF85   LUI V1, -16507
9D006820  AC60B0B4   SW ZERO, -20300(V1)
114:                     
115:                     /* Configure ADCFLTRx */
116:                     ADCFLTR1 = 0; // No oversampling filters are used.
9D006824  3C03BF85   LUI V1, -16507
9D006828  AC60B068   SW ZERO, -20376(V1)
117:                     ADCFLTR2 = 0;
9D00682C  3C03BF85   LUI V1, -16507
9D006830  AC60B06C   SW ZERO, -20372(V1)
118:                     ADCFLTR3 = 0;
9D006834  3C03BF85   LUI V1, -16507
9D006838  AC60B070   SW ZERO, -20368(V1)
119:                     ADCFLTR4 = 0;
9D00683C  3C03BF85   LUI V1, -16507
9D006840  AC60B074   SW ZERO, -20364(V1)
120:                     ADCFLTR5 = 0;
9D006844  3C03BF85   LUI V1, -16507
9D006848  AC60B078   SW ZERO, -20360(V1)
121:                     ADCFLTR6 = 0;
9D00684C  3C03BF85   LUI V1, -16507
9D006850  AC60B07C   SW ZERO, -20356(V1)
122:                     
123:                     /* Set up the trigger sources */
124:                 //    ADCTRGSNSbits.LVL0 = 0; // Edge trigger
125:                 //    ADCTRGSNSbits.LVL1 = 0; // Edge trigger
126:                     ADCTRGSNSbits.LVL2 = 0; // Edge trigger
9D006854  3C03BF85   LUI V1, -16507
9D006858  9469B0D0   LHU T1, -20272(V1)
9D00685C  7C091084   INS T1, ZERO, 2, 1
9D006860  A469B0D0   SH T1, -20272(V1)
127:                     ADCTRGSNSbits.LVL3 = 0;
9D006864  9469B0D0   LHU T1, -20272(V1)
9D006868  7C0918C4   INS T1, ZERO, 3, 1
9D00686C  A469B0D0   SH T1, -20272(V1)
128:                     ADCTRGSNSbits.LVL4 = 0;
9D006870  9469B0D0   LHU T1, -20272(V1)
9D006874  7C092104   INS T1, ZERO, 4, 1
9D006878  A469B0D0   SH T1, -20272(V1)
129:                     //ADCTRGSNSbits.LVL10 = 0;
130:                     //ADCTRG1bits.TRGSRC0 = 0b00111; // Set AN0 to trigger from Timer5.
131:                 //    ADCTRG1bits.TRGSRC1 = 0b00111; // Set AN1 to trigger from Timer5.
132:                     ADCTRG1bits.TRGSRC2 = 1;//0b00111; // Set AN2 to trigger from Timer5.
9D00687C  3C03BF85   LUI V1, -16507
9D006880  8C69B080   LW T1, -20352(V1)
9D006884  7C49A404   INS T1, V0, 16, 5
9D006888  AC69B080   SW T1, -20352(V1)
133:                     ADCTRG1bits.TRGSRC3 = 0b00111; // Set AN3 to trigger from Timer5.
9D00688C  8C69B080   LW T1, -20352(V1)
9D006890  7CE9E604   INS T1, A3, 24, 5
9D006894  AC69B080   SW T1, -20352(V1)
134:                     ADCTRG2bits.TRGSRC4 = 0b00111;//1; // Set AN4 to trigger from software
9D006898  3C03BF85   LUI V1, -16507
9D00689C  8C69B084   LW T1, -20348(V1)
9D0068A0  7CE92004   INS T1, A3, 0, 5
9D0068A4  AC69B084   SW T1, -20348(V1)
135:                     //ADCTRG3bits.TRGSRC10 = 1; // Set AN10 to trigger in software.
136:                     
137:                     /* Early interrupt */
138:                     ADCEIEN1 = 0; // No early interrupt
9D0068A8  3C03BF85   LUI V1, -16507
9D0068AC  AC60B0F0   SW ZERO, -20240(V1)
139:                     ADCEIEN2 = 0;
9D0068B0  3C03BF85   LUI V1, -16507
9D0068B4  AC60B0F4   SW ZERO, -20236(V1)
140:                     //ADCCON2bits.ADCEIOVR = 1; // Override early interrupt //do we need this line? -> what is this doing exactly?
141:                     
142:                 //    /*Config ADC FIFO*/
143:                     ADCFSTAT = 0; // Clear all bits
9D0068B8  3C03BF85   LUI V1, -16507
9D0068BC  AC60B0B8   SW ZERO, -20296(V1)
144:                     //ADCFSTATbits.ADC2EN = 1; // Select ADC2
145:                     ADCFSTATbits.ADC3EN = 1;
9D0068C0  3C03BF85   LUI V1, -16507
9D0068C4  8C69B0B8   LW T1, -20296(V1)
9D0068C8  7C49DEC4   INS T1, V0, 27, 1
9D0068CC  AC69B0B8   SW T1, -20296(V1)
146:                     ADCFSTATbits.ADC4EN = 1;
9D0068D0  8C69B0B8   LW T1, -20296(V1)
9D0068D4  7C49E704   INS T1, V0, 28, 1
9D0068D8  AC69B0B8   SW T1, -20296(V1)
147:                     IFS1bits.ADCFIFOIF = 0;
9D0068DC  8D090050   LW T1, 80(T0)
9D0068E0  7C096B44   INS T1, ZERO, 13, 1
9D0068E4  AD090050   SW T1, 80(T0)
148:                     IPC11bits.ADCFIFOIP = 7;
9D0068E8  8CA801F0   LW T0, 496(A1)
9D0068EC  7CE86284   INS T0, A3, 10, 3
9D0068F0  ACA801F0   SW T0, 496(A1)
149:                     IPC11bits.ADCFIFOIS = 0;
9D0068F4  8CA701F0   LW A3, 496(A1)
9D0068F8  7C074A04   INS A3, ZERO, 8, 2
9D0068FC  ACA701F0   SW A3, 496(A1)
150:                     ADCFSTATbits.FIEN = 0;
9D006900  8C65B0B8   LW A1, -20296(V1)
9D006904  7C05BDC4   INS A1, ZERO, 23, 1
9D006908  AC65B0B8   SW A1, -20296(V1)
151:                     IEC1bits.ADCFIFOIE = 0;
9D00690C  8CC500D0   LW A1, 208(A2)
9D006910  7C056B44   INS A1, ZERO, 13, 1
9D006914  ACC500D0   SW A1, 208(A2)
152:                     ADCFSTATbits.FEN = 1; // Enable FIFO
9D006918  8C65B0B8   LW A1, -20296(V1)
9D00691C  7C45FFC4   INS A1, V0, 31, 1
9D006920  AC65B0B8   SW A1, -20296(V1)
153:                     
154:                     /* Turn the ADC on */
155:                     ADCCON1bits.ON = 1;
9D006924  8C83B000   LW V1, -20480(A0)
9D006928  7C437BC4   INS V1, V0, 15, 1
9D00692C  AC83B000   SW V1, -20480(A0)
156:                     /* Wait for voltage reference to be stable */
157:                     while(!ADCCON2bits.BGVRRDY); // Wait until the reference voltage is ready
9D006930  3C03BF85   LUI V1, -16507
9D006934  8C62B004   LW V0, -20476(V1)
9D006938  0441FFFE   BGEZ V0, 0x9D006934
9D00693C  3C04BF85   LUI A0, -16507
158:                     while(ADCCON2bits.REFFLT); // Wait if there is a fault with the reference voltage
9D006940  3C034000   LUI V1, 16384
9D006944  8C82B004   LW V0, -20476(A0)
9D006948  00431024   AND V0, V0, V1
9D00694C  1440FFFD   BNE V0, ZERO, 0x9D006944
9D006950  3C02BF85   LUI V0, -16507
159:                     /* Enable clock to analog circuit */
160:                 //    ADCANCONbits.ANEN0 = 1; // Enable the clock to analog bias and digital control
161:                 //    ADCANCONbits.ANEN1 = 1; // Enable the clock to analog bias and digital control
162:                     ADCANCONbits.ANEN2 = 1; // Enable the clock to analog bias and digital control
9D006954  8C43B100   LW V1, -20224(V0)
9D006958  24040001   ADDIU A0, ZERO, 1
9D00695C  7C831084   INS V1, A0, 2, 1
9D006960  AC43B100   SW V1, -20224(V0)
163:                     while(!ADCANCONbits.WKRDY2); // Wait until ADC2 is ready
9D006964  00401821   ADDU V1, V0, ZERO
9D006968  8C62B100   LW V0, -20224(V1)
9D00696C  30420400   ANDI V0, V0, 1024
9D006970  1040FFFD   BEQ V0, ZERO, 0x9D006968
9D006974  3C02BF85   LUI V0, -16507
164:                     ADCANCONbits.ANEN3 = 1; // Enable the clock to analog bias and digital control
9D006978  8C43B100   LW V1, -20224(V0)
9D00697C  24040001   ADDIU A0, ZERO, 1
9D006980  7C8318C4   INS V1, A0, 3, 1
9D006984  AC43B100   SW V1, -20224(V0)
165:                     while(!ADCANCONbits.WKRDY3); // Wait until ADC3 is ready
9D006988  00401821   ADDU V1, V0, ZERO
9D00698C  8C62B100   LW V0, -20224(V1)
9D006990  30420800   ANDI V0, V0, 2048
9D006994  1040FFFD   BEQ V0, ZERO, 0x9D00698C
9D006998  3C02BF85   LUI V0, -16507
166:                     ADCANCONbits.ANEN4 = 1; // Enable the clock to analog bias and digital control
9D00699C  8C43B100   LW V1, -20224(V0)
9D0069A0  24040001   ADDIU A0, ZERO, 1
9D0069A4  7C832104   INS V1, A0, 4, 1
9D0069A8  AC43B100   SW V1, -20224(V0)
167:                     //ADCANCONbits.ANEN7 = 1; // Enable the clock to analog bias and digital control
168:                     /* Wait for ADC to be ready */
169:                 //    while(!ADCANCONbits.WKRDY0); // Wait until ADC0 is ready
170:                 //    while(!ADCANCONbits.WKRDY1); // Wait until ADC1 is ready
171:                     
172:                     while(!ADCANCONbits.WKRDY4); // Wait until ADC4 is ready
9D0069AC  00401821   ADDU V1, V0, ZERO
9D0069B0  8C62B100   LW V0, -20224(V1)
9D0069B4  30421000   ANDI V0, V0, 4096
9D0069B8  1040FFFD   BEQ V0, ZERO, 0x9D0069B0
9D0069BC  3C02BF85   LUI V0, -16507
173:                     //while(!ADCANCONbits.WKRDY7); // Wait until ADC7 is ready
174:                     /* Enable the ADC module */
175:                 //    ADCCON3bits.DIGEN0 = 1; // Enable ADC0
176:                 //    ADCCON3bits.DIGEN1 = 1; // Enable ADC1
177:                     ADCCON3bits.DIGEN2 = 1; // Enable ADC2
9D0069C0  8C44B008   LW A0, -20472(V0)
9D0069C4  24030001   ADDIU V1, ZERO, 1
9D0069C8  7C649484   INS A0, V1, 18, 1
9D0069CC  AC44B008   SW A0, -20472(V0)
178:                     ADCCON3bits.DIGEN3 = 1; // Enable ADC3
9D0069D0  8C44B008   LW A0, -20472(V0)
9D0069D4  7C649CC4   INS A0, V1, 19, 1
9D0069D8  AC44B008   SW A0, -20472(V0)
179:                     ADCCON3bits.DIGEN4 = 1; // Enable ADC4
9D0069DC  8C44B008   LW A0, -20472(V0)
180:                     //ADCCON3bits.DIGEN7 = 1; // Enable ADC7
181:                 }
---  /build/bamboo/xml-data/build-dir/XC32-CYXC32-JOB1/xc32-XC32-release-1_42/src48x/gcc/libgcc/libgcc2.c
9D006E70  00C04021   ADDU T0, A2, ZERO
9D0072D4  00C04021   ADDU T0, A2, ZERO
9D006E74  00804821   ADDU T1, A0, ZERO
9D0072D8  00801021   ADDU V0, A0, ZERO
9D006E78  14E0003B   BNE A3, ZERO, 0x9D006F68
9D006E7C  00A01821   ADDU V1, A1, ZERO
9D0072DC  14E0003F   BNE A3, ZERO, 0x9D0073DC
9D0072E0  00A04821   ADDU T1, A1, ZERO
9D006E80  00A6102B   SLTU V0, A1, A2
9D006E84  10400048   BEQ V0, ZERO, 0x9D006FA8
9D006E88  70C21020   CLZ V0, A2
9D0072E4  00A6182B   SLTU V1, A1, A2
9D0072E8  10600047   BEQ V1, ZERO, 0x9D007408
9D0072EC  70C31820   CLZ V1, A2
9D006E8C  50400008   BEQL V0, ZERO, 0x9D006EB0
9D006E90  00083402   SRL A2, T0, 16
9D0072F0  50600008   BEQL V1, ZERO, 0x9D007314
9D0072F4  00081C02   SRL V1, T0, 16
9D006EA0  00464004   SLLV T0, A2, V0
9D007304  00664004   SLLV T0, A2, V1
9D006E94  00021823   SUBU V1, ZERO, V0
9D006E98  00452804   SLLV A1, A1, V0
9D006E9C  00641806   SRLV V1, A0, V1
9D006EA4  00651825   OR V1, V1, A1
9D0072F8  00034823   SUBU T1, ZERO, V1
9D0072FC  00652804   SLLV A1, A1, V1
9D007300  01244806   SRLV T1, A0, T1
9D007308  01254825   OR T1, T1, A1
9D006EA8  00444804   SLLV T1, A0, V0
9D00730C  00641004   SLLV V0, A0, V1
9D006EAC  00083402   SRL A2, T0, 16
9D006EB0  0066001B   DIVU V1, A2
9D006EB4  00C001F4   TEQ A2, ZERO
9D006EB8  00002010   MFHI A0
9D006EBC  00005812   MFLO T3
9D006EC0  310CFFFF   ANDI T4, T0, -1
9D006EC4  00095402   SRL T2, T1, 16
9D006EC8  716C5802   MUL T3, T3, T4
9D006ECC  00042400   SLL A0, A0, 16
9D006ED0  008A5025   OR T2, A0, T2
9D006ED4  014B682B   SLTU T5, T2, T3
9D006ED8  0066001B   DIVU V1, A2
9D006EDC  00C001F4   TEQ A2, ZERO
9D006EE0  51A00009   BEQL T5, ZERO, 0x9D006F08
9D006EE4  014B5023   SUBU T2, T2, T3
9D006EE8  01485021   ADDU T2, T2, T0
9D006EEC  0148182B   SLTU V1, T2, T0
9D006EF0  54600005   BNEL V1, ZERO, 0x9D006F08
9D006EF4  014B5023   SUBU T2, T2, T3
9D006EF8  014B202B   SLTU A0, T2, T3
9D006EFC  01481821   ADDU V1, T2, T0
9D006F00  0064500B   MOVN T2, V1, A0
9D006F04  014B5023   SUBU T2, T2, T3
9D006F08  3123FFFF   ANDI V1, T1, -1
9D006F0C  0146001B   DIVU T2, A2
9D006F10  00C001F4   TEQ A2, ZERO
9D006F14  00004810   MFHI T1
9D006F18  00002012   MFLO A0
9D006F1C  708C2002   MUL A0, A0, T4
9D006F20  00094C00   SLL T1, T1, 16
9D006F24  01234825   OR T1, T1, V1
9D006F28  0124182B   SLTU V1, T1, A0
9D006F2C  0146001B   DIVU T2, A2
9D006F30  00C001F4   TEQ A2, ZERO
9D006F34  50600009   BEQL V1, ZERO, 0x9D006F5C
9D006F38  01244823   SUBU T1, T1, A0
9D006F3C  01284821   ADDU T1, T1, T0
9D006F40  0128182B   SLTU V1, T1, T0
9D006F44  54600005   BNEL V1, ZERO, 0x9D006F5C
9D006F48  01244823   SUBU T1, T1, A0
9D006F4C  0124182B   SLTU V1, T1, A0
9D006F50  01284021   ADDU T0, T1, T0
9D006F54  0103480B   MOVN T1, T0, V1
9D006F58  01244823   SUBU T1, T1, A0
9D007310  00081C02   SRL V1, T0, 16
9D007314  0123001B   DIVU T1, V1
9D007318  006001F4   TEQ V1, ZERO
9D00731C  00006010   MFHI T4
9D007320  00005812   MFLO T3
9D007324  310AFFFF   ANDI T2, T0, -1
9D007328  00022402   SRL A0, V0, 16
9D00732C  00003012   MFLO A2
9D007330  716A3802   MUL A3, T3, T2
9D007334  000C6400   SLL T4, T4, 16
9D007338  01842025   OR A0, T4, A0
9D00733C  0087602B   SLTU T4, A0, A3
9D007340  0123001B   DIVU T1, V1
9D007344  006001F4   TEQ V1, ZERO
9D007348  1180000B   BEQ T4, ZERO, 0x9D007378
9D00734C  00872823   SUBU A1, A0, A3
9D007350  00882021   ADDU A0, A0, T0
9D007354  0088282B   SLTU A1, A0, T0
9D007358  14A00006   BNE A1, ZERO, 0x9D007374
9D00735C  2566FFFF   ADDIU A2, T3, -1
9D007360  0087282B   SLTU A1, A0, A3
9D007364  10A00004   BEQ A1, ZERO, 0x9D007378
9D007368  00872823   SUBU A1, A0, A3
9D00736C  2566FFFE   ADDIU A2, T3, -2
9D007370  00882021   ADDU A0, A0, T0
9D007374  00872823   SUBU A1, A0, A3
9D007378  3042FFFF   ANDI V0, V0, -1
9D00737C  00A3001B   DIVU A1, V1
9D007380  006001F4   TEQ V1, ZERO
9D007384  00004810   MFHI T1
9D007388  00003812   MFLO A3
9D00738C  00002012   MFLO A0
9D007390  70EA5002   MUL T2, A3, T2
9D007394  00094C00   SLL T1, T1, 16
9D007398  01221025   OR V0, T1, V0
9D00739C  004A482B   SLTU T1, V0, T2
9D0073A0  00A3001B   DIVU A1, V1
9D0073A4  006001F4   TEQ V1, ZERO
9D0073A8  51200009   BEQL T1, ZERO, 0x9D0073D0
9D0073AC  00061400   SLL V0, A2, 16
9D0073B0  00481021   ADDU V0, V0, T0
9D0073B4  0048402B   SLTU T0, V0, T0
9D0073B8  15000004   BNE T0, ZERO, 0x9D0073CC
9D0073BC  24E4FFFF   ADDIU A0, A3, -1
9D0073C0  004A502B   SLTU T2, V0, T2
9D0073C4  24E7FFFE   ADDIU A3, A3, -2
9D0073C8  00EA200B   MOVN A0, A3, T2
9D0073CC  00061400   SLL V0, A2, 16
9D0073D0  00821025   OR V0, A0, V0
9D0073D4  03E00008   JR RA
9D0073D8  00001821   ADDU V1, ZERO, ZERO
9D006FA8  14C00006   BNE A2, ZERO, 0x9D006FC4
9D006FAC  71021020   CLZ V0, T0
9D007408  14C00006   BNE A2, ZERO, 0x9D007424
9D00740C  71031820   CLZ V1, T0
9D006FB0  24020001   ADDIU V0, ZERO, 1
9D006FB4  0046001B   DIVU V0, A2
9D006FB8  00C001F4   TEQ A2, ZERO
9D006FBC  00004012   MFLO T0
9D007410  24030001   ADDIU V1, ZERO, 1
9D007414  0066001B   DIVU V1, A2
9D007418  00C001F4   TEQ A2, ZERO
9D00741C  00004012   MFLO T0
9D006FC0  71021020   CLZ V0, T0
9D007420  71031820   CLZ V1, T0
9D006FC4  5440007D   BNEL V0, ZERO, 0x9D0071BC
9D006FC8  00484004   SLLV T0, T0, V0
9D007424  5460007B   BNEL V1, ZERO, 0x9D007614
9D007428  00684004   SLLV T0, T0, V1
9D006FCC  00A82823   SUBU A1, A1, T0
9D006FD0  00081C02   SRL V1, T0, 16
9D006FD4  3107FFFF   ANDI A3, T0, -1
9D00742C  00A82023   SUBU A0, A1, T0
9D007430  00083C02   SRL A3, T0, 16
9D007434  310BFFFF   ANDI T3, T0, -1
9D007438  24030001   ADDIU V1, ZERO, 1
9D0071BC  24090020   ADDIU T1, ZERO, 32
9D0071C0  01224823   SUBU T1, T1, V0
9D007614  24020020   ADDIU V0, ZERO, 32
9D007618  00431023   SUBU V0, V0, V1
9D0071C4  01255006   SRLV T2, A1, T1
9D00761C  00454806   SRLV T1, A1, V0
9D0071E0  00452804   SLLV A1, A1, V0
9D0071E4  01244806   SRLV T1, A0, T1
9D0071E8  01252825   OR A1, T1, A1
9D007638  00652804   SLLV A1, A1, V1
9D00763C  00441006   SRLV V0, A0, V0
9D007640  00452825   OR A1, V0, A1
9D0071F0  00444804   SLLV T1, A0, V0
9D007648  00641004   SLLV V0, A0, V1
9D0071C8  00081C02   SRL V1, T0, 16
9D0071CC  0143001B   DIVU T2, V1
9D0071D0  006001F4   TEQ V1, ZERO
9D0071D4  00003010   MFHI A2
9D0071D8  00005812   MFLO T3
9D0071DC  3107FFFF   ANDI A3, T0, -1
9D0071EC  00056402   SRL T4, A1, 16
9D0071F4  71675802   MUL T3, T3, A3
9D0071F8  00063400   SLL A2, A2, 16
9D0071FC  01863025   OR A2, T4, A2
9D007200  00CB202B   SLTU A0, A2, T3
9D007204  0143001B   DIVU T2, V1
9D007208  006001F4   TEQ V1, ZERO
9D00720C  50800006   BEQL A0, ZERO, 0x9D007228
9D007210  00CB3023   SUBU A2, A2, T3
9D007214  00C83021   ADDU A2, A2, T0
9D007218  00C8202B   SLTU A0, A2, T0
9D00721C  10800024   BEQ A0, ZERO, 0x9D0072B0
9D007220  00CB502B   SLTU T2, A2, T3
9D007224  00CB3023   SUBU A2, A2, T3
9D007228  30AAFFFF   ANDI T2, A1, -1
9D00722C  00C3001B   DIVU A2, V1
9D007230  006001F4   TEQ V1, ZERO
9D007234  00002010   MFHI A0
9D007238  00002812   MFLO A1
9D00723C  70A72802   MUL A1, A1, A3
9D007240  00042400   SLL A0, A0, 16
9D007244  008A2025   OR A0, A0, T2
9D007248  0085502B   SLTU T2, A0, A1
9D00724C  00C3001B   DIVU A2, V1
9D007250  006001F4   TEQ V1, ZERO
9D007254  5140FF60   BEQL T2, ZERO, 0x9D006FD8
9D007258  00852823   SUBU A1, A0, A1
9D00725C  00882021   ADDU A0, A0, T0
9D007260  0088302B   SLTU A2, A0, T0
9D007264  54C0FF5C   BNEL A2, ZERO, 0x9D006FD8
9D007268  00852823   SUBU A1, A0, A1
9D00726C  0085502B   SLTU T2, A0, A1
9D007270  00883021   ADDU A2, A0, T0
9D007274  00CA200B   MOVN A0, A2, T2
9D007278  0B401BF6   J 0x9D006FD8
9D00727C  00852823   SUBU A1, A0, A1
9D0072B0  00C82021   ADDU A0, A2, T0
9D0072B4  0B401C89   J 0x9D007224
9D0072B8  008A300B   MOVN A2, A0, T2
9D007620  00083C02   SRL A3, T0, 16
9D007624  0127001B   DIVU T1, A3
9D007628  00E001F4   TEQ A3, ZERO
9D00762C  00003010   MFHI A2
9D007630  00006012   MFLO T4
9D007634  310BFFFF   ANDI T3, T0, -1
9D007644  00056C02   SRL T5, A1, 16
9D00764C  00001812   MFLO V1
9D007650  718B5002   MUL T2, T4, T3
9D007654  00063400   SLL A2, A2, 16
9D007658  01A63025   OR A2, T5, A2
9D00765C  00CA202B   SLTU A0, A2, T2
9D007660  0127001B   DIVU T1, A3
9D007664  00E001F4   TEQ A3, ZERO
9D007668  5080000B   BEQL A0, ZERO, 0x9D007698
9D00766C  00CA3023   SUBU A2, A2, T2
9D007670  00C83021   ADDU A2, A2, T0
9D007674  00C8202B   SLTU A0, A2, T0
9D007678  14800006   BNE A0, ZERO, 0x9D007694
9D00767C  2583FFFF   ADDIU V1, T4, -1
9D007680  00CA202B   SLTU A0, A2, T2
9D007684  50800004   BEQL A0, ZERO, 0x9D007698
9D007688  00CA3023   SUBU A2, A2, T2
9D00768C  2583FFFE   ADDIU V1, T4, -2
9D007690  00C83021   ADDU A2, A2, T0
9D007694  00CA3023   SUBU A2, A2, T2
9D007698  30ACFFFF   ANDI T4, A1, -1
9D00769C  00C7001B   DIVU A2, A3
9D0076A0  00E001F4   TEQ A3, ZERO
9D0076A4  00002010   MFHI A0
9D0076A8  00005012   MFLO T2
9D0076AC  00004812   MFLO T1
9D0076B0  714B2802   MUL A1, T2, T3
9D0076B4  00042400   SLL A0, A0, 16
9D0076B8  008C2025   OR A0, A0, T4
9D0076BC  0085602B   SLTU T4, A0, A1
9D0076C0  00C7001B   DIVU A2, A3
9D0076C4  00E001F4   TEQ A3, ZERO
9D0076C8  5180000B   BEQL T4, ZERO, 0x9D0076F8
9D0076CC  00031C00   SLL V1, V1, 16
9D0076D0  00882021   ADDU A0, A0, T0
9D0076D4  0088302B   SLTU A2, A0, T0
9D0076D8  14C00006   BNE A2, ZERO, 0x9D0076F4
9D0076DC  2549FFFF   ADDIU T1, T2, -1
9D0076E0  0085302B   SLTU A2, A0, A1
9D0076E4  50C00004   BEQL A2, ZERO, 0x9D0076F8
9D0076E8  00031C00   SLL V1, V1, 16
9D0076EC  2549FFFE   ADDIU T1, T2, -2
9D0076F0  00882021   ADDU A0, A0, T0
9D0076F4  00031C00   SLL V1, V1, 16
9D0076F8  00852023   SUBU A0, A0, A1
9D0076FC  0B401D0F   J 0x9D00743C
9D007700  01231825   OR V1, T1, V1
9D006FD8  00092402   SRL A0, T1, 16
9D006FDC  00A3001B   DIVU A1, V1
9D006FE0  006001F4   TEQ V1, ZERO
9D006FE4  00005010   MFHI T2
9D006FE8  00003012   MFLO A2
9D006FEC  70C73002   MUL A2, A2, A3
9D006FF0  000A5400   SLL T2, T2, 16
9D006FF4  01442025   OR A0, T2, A0
9D006FF8  0086502B   SLTU T2, A0, A2
9D006FFC  00A3001B   DIVU A1, V1
9D007000  006001F4   TEQ V1, ZERO
9D007004  51400009   BEQL T2, ZERO, 0x9D00702C
9D007008  00862023   SUBU A0, A0, A2
9D00700C  00882021   ADDU A0, A0, T0
9D007010  0088282B   SLTU A1, A0, T0
9D007014  54A00005   BNEL A1, ZERO, 0x9D00702C
9D007018  00862023   SUBU A0, A0, A2
9D00701C  0086502B   SLTU T2, A0, A2
9D007020  00882821   ADDU A1, A0, T0
9D007024  00AA200B   MOVN A0, A1, T2
9D007028  00862023   SUBU A0, A0, A2
9D00702C  3126FFFF   ANDI A2, T1, -1
9D007030  0083001B   DIVU A0, V1
9D007034  006001F4   TEQ V1, ZERO
9D007038  00004810   MFHI T1
9D00703C  00002812   MFLO A1
9D007040  70A72802   MUL A1, A1, A3
9D007044  00094C00   SLL T1, T1, 16
9D007048  01264825   OR T1, T1, A2
9D00704C  0125302B   SLTU A2, T1, A1
9D007050  0083001B   DIVU A0, V1
9D007054  006001F4   TEQ V1, ZERO
9D007058  50C00009   BEQL A2, ZERO, 0x9D007080
9D00705C  01254823   SUBU T1, T1, A1
9D007060  01284821   ADDU T1, T1, T0
9D007064  0128182B   SLTU V1, T1, T0
9D007068  54600005   BNEL V1, ZERO, 0x9D007080
9D00706C  01254823   SUBU T1, T1, A1
9D007070  0125182B   SLTU V1, T1, A1
9D007074  01284021   ADDU T0, T1, T0
9D007078  0103480B   MOVN T1, T0, V1
9D00707C  01254823   SUBU T1, T1, A1
9D00743C  00023402   SRL A2, V0, 16
9D007440  0087001B   DIVU A0, A3
9D007444  00E001F4   TEQ A3, ZERO
9D007448  00006810   MFHI T5
9D00744C  00006012   MFLO T4
9D007450  00004812   MFLO T1
9D007454  718B5002   MUL T2, T4, T3
9D007458  000D6C00   SLL T5, T5, 16
9D00745C  01A63025   OR A2, T5, A2
9D007460  00CA682B   SLTU T5, A2, T2
9D007464  0087001B   DIVU A0, A3
9D007468  00E001F4   TEQ A3, ZERO
9D00746C  11A00009   BEQ T5, ZERO, 0x9D007494
9D007470  00CA2823   SUBU A1, A2, T2
9D007474  00C83021   ADDU A2, A2, T0
9D007478  00C8202B   SLTU A0, A2, T0
9D00747C  14800004   BNE A0, ZERO, 0x9D007490
9D007480  2589FFFF   ADDIU T1, T4, -1
9D007484  00CA202B   SLTU A0, A2, T2
9D007488  548000A6   BNEL A0, ZERO, 0x9D007724
9D00748C  2589FFFE   ADDIU T1, T4, -2
9D007490  00CA2823   SUBU A1, A2, T2
9D007494  3042FFFF   ANDI V0, V0, -1
9D007498  00A7001B   DIVU A1, A3
9D00749C  00E001F4   TEQ A3, ZERO
9D0074A0  00005010   MFHI T2
9D0074A4  00003012   MFLO A2
9D0074A8  00002012   MFLO A0
9D0074AC  70CB5802   MUL T3, A2, T3
9D0074B0  000A5400   SLL T2, T2, 16
9D0074B4  01421025   OR V0, T2, V0
9D0074B8  004B502B   SLTU T2, V0, T3
9D0074BC  00A7001B   DIVU A1, A3
9D0074C0  00E001F4   TEQ A3, ZERO
9D0074C4  51400009   BEQL T2, ZERO, 0x9D0074EC
9D0074C8  00091400   SLL V0, T1, 16
9D0074CC  00481021   ADDU V0, V0, T0
9D0074D0  0048402B   SLTU T0, V0, T0
9D0074D4  15000004   BNE T0, ZERO, 0x9D0074E8
9D0074D8  24C4FFFF   ADDIU A0, A2, -1
9D0074DC  004B582B   SLTU T3, V0, T3
9D0074E0  24C6FFFE   ADDIU A2, A2, -2
9D0074E4  00CB200B   MOVN A0, A2, T3
9D0074E8  00091400   SLL V0, T1, 16
9D0074EC  03E00008   JR RA
9D0074F0  00821025   OR V0, A0, V0
9D007724  0B401D24   J 0x9D007490
9D006F5C  00491006   SRLV V0, T1, V0
9D007080  00491006   SRLV V0, T1, V0
9D006F60  03E00008   JR RA
9D006F64  00001821   ADDU V1, ZERO, ZERO
9D007084  03E00008   JR RA
9D007088  00001821   ADDU V1, ZERO, ZERO
9D006F68  00A7102B   SLTU V0, A1, A3
9D006F6C  14400047   BNE V0, ZERO, 0x9D00708C
9D006F70  70EA5020   CLZ T2, A3
9D0073DC  00A7102B   SLTU V0, A1, A3
9D0073E0  14400044   BNE V0, ZERO, 0x9D0074F4
9D0073E4  70E84020   CLZ T0, A3
9D0074F4  00001821   ADDU V1, ZERO, ZERO
9D0074F8  03E00008   JR RA
9D0074FC  00001021   ADDU V0, ZERO, ZERO
9D00708C  00801021   ADDU V0, A0, ZERO
9D007090  03E00008   JR RA
9D007094  00A01821   ADDU V1, A1, ZERO
9D006F74  15400048   BNE T2, ZERO, 0x9D007098
9D006F78  240B0020   ADDIU T3, ZERO, 32
9D0073E8  55000045   BNEL T0, ZERO, 0x9D007500
9D0073EC  24020020   ADDIU V0, ZERO, 32
9D006F7C  00E5102B   SLTU V0, A3, A1
9D006F80  14400005   BNE V0, ZERO, 0x9D006F98
9D006F84  00861023   SUBU V0, A0, A2
9D006F88  0086402B   SLTU T0, A0, A2
9D006F8C  15000089   BNE T0, ZERO, 0x9D0071B4
9D006F90  00801021   ADDU V0, A0, ZERO
9D0073F0  00E5282B   SLTU A1, A3, A1
9D0073F4  14A000C8   BNE A1, ZERO, 0x9D007718
9D0073F8  0086302B   SLTU A2, A0, A2
9D0073FC  38C20001   XORI V0, A2, 1
9D007400  03E00008   JR RA
9D007404  00001821   ADDU V1, ZERO, ZERO
9D007718  00001821   ADDU V1, ZERO, ZERO
9D006F94  00861023   SUBU V0, A0, A2
9D006F98  00A72823   SUBU A1, A1, A3
9D006F9C  0082202B   SLTU A0, A0, V0
9D006FA0  03E00008   JR RA
9D006FA4  00A41823   SUBU V1, A1, A0
9D007098  016A5823   SUBU T3, T3, T2
9D007500  00481023   SUBU V0, V0, T0
9D00709C  01473804   SLLV A3, A3, T2
9D0070A0  01661006   SRLV V0, A2, T3
9D0070A4  00473825   OR A3, V0, A3
9D007504  01073804   SLLV A3, A3, T0
9D007508  00461806   SRLV V1, A2, V0
9D00750C  00673825   OR A3, V1, A3
9D0070D4  01463004   SLLV A2, A2, T2
9D0070A8  01656806   SRLV T5, A1, T3
9D007510  00455006   SRLV T2, A1, V0
9D0070C4  01452804   SLLV A1, A1, T2
9D0070C8  01641006   SRLV V0, A0, T3
9D0070CC  00451025   OR V0, V0, A1
9D00752C  01052804   SLLV A1, A1, T0
9D007530  00441006   SRLV V0, A0, V0
9D007534  00452825   OR A1, V0, A1
9D0070AC  00074C02   SRL T1, A3, 16
9D0070B0  01A9001B   DIVU T5, T1
9D0070B4  012001F4   TEQ T1, ZERO
9D0070B8  00006010   MFHI T4
9D0070BC  00001812   MFLO V1
9D0070C0  30EEFFFF   ANDI T6, A3, -1
9D0070D0  00022C02   SRL A1, V0, 16
9D0070D8  00004012   MFLO T0
9D0070DC  706E7802   MUL T7, V1, T6
9D0070E0  000C6400   SLL T4, T4, 16
9D0070E4  01856025   OR T4, T4, A1
9D0070E8  018F282B   SLTU A1, T4, T7
9D0070EC  01A9001B   DIVU T5, T1
9D0070F0  012001F4   TEQ T1, ZERO
9D0070F4  10A0000A   BEQ A1, ZERO, 0x9D007120
9D0070F8  01442004   SLLV A0, A0, T2
9D0070FC  01876021   ADDU T4, T4, A3
9D007100  0187282B   SLTU A1, T4, A3
9D007104  14A00006   BNE A1, ZERO, 0x9D007120
9D007108  2468FFFF   ADDIU T0, V1, -1
9D00710C  018F282B   SLTU A1, T4, T7
9D007110  50A00004   BEQL A1, ZERO, 0x9D007124
9D007114  018F6023   SUBU T4, T4, T7
9D007118  2468FFFE   ADDIU T0, V1, -2
9D00711C  01876021   ADDU T4, T4, A3
9D007120  018F6023   SUBU T4, T4, T7
9D007124  3042FFFF   ANDI V0, V0, -1
9D007128  0189001B   DIVU T4, T1
9D00712C  012001F4   TEQ T1, ZERO
9D007130  00002810   MFHI A1
9D007134  00001812   MFLO V1
9D007138  00006812   MFLO T5
9D00713C  706E7002   MUL T6, V1, T6
9D007140  00052C00   SLL A1, A1, 16
9D007144  00A21025   OR V0, A1, V0
9D007148  004E282B   SLTU A1, V0, T6
9D00714C  0189001B   DIVU T4, T1
9D007150  012001F4   TEQ T1, ZERO
9D007154  50A00006   BEQL A1, ZERO, 0x9D007170
9D007158  00084400   SLL T0, T0, 16
9D00715C  00471021   ADDU V0, V0, A3
9D007160  0047282B   SLTU A1, V0, A3
9D007164  10A0004C   BEQ A1, ZERO, 0x9D007298
9D007168  246DFFFF   ADDIU T5, V1, -1
9D00716C  00084400   SLL T0, T0, 16
9D007170  01A84025   OR T0, T5, T0
9D007174  004E1023   SUBU V0, V0, T6
9D007298  004E282B   SLTU A1, V0, T6
9D00729C  50A0FFB4   BEQL A1, ZERO, 0x9D007170
9D0072A0  00084400   SLL T0, T0, 16
9D0072A4  246DFFFE   ADDIU T5, V1, -2
9D0072A8  0B401C5B   J 0x9D00716C
9D0072AC  00471021   ADDU V0, V0, A3
9D007514  00071C02   SRL V1, A3, 16
9D007518  0143001B   DIVU T2, V1
9D00751C  006001F4   TEQ V1, ZERO
9D007520  00004810   MFHI T1
9D007524  00006812   MFLO T5
9D007528  30EBFFFF   ANDI T3, A3, -1
9D007538  00057402   SRL T6, A1, 16
9D00753C  00001012   MFLO V0
9D007540  71AB6002   MUL T4, T5, T3
9D007544  00094C00   SLL T1, T1, 16
9D007548  012E4825   OR T1, T1, T6
9D00754C  012C702B   SLTU T6, T1, T4
9D007550  0143001B   DIVU T2, V1
9D007554  006001F4   TEQ V1, ZERO
9D007558  11C0000A   BEQ T6, ZERO, 0x9D007584
9D00755C  01063004   SLLV A2, A2, T0
9D007560  01274821   ADDU T1, T1, A3
9D007564  0127502B   SLTU T2, T1, A3
9D007568  15400006   BNE T2, ZERO, 0x9D007584
9D00756C  25A2FFFF   ADDIU V0, T5, -1
9D007570  012C502B   SLTU T2, T1, T4
9D007574  51400004   BEQL T2, ZERO, 0x9D007588
9D007578  012C4823   SUBU T1, T1, T4
9D00757C  25A2FFFE   ADDIU V0, T5, -2
9D007580  01274821   ADDU T1, T1, A3
9D007584  012C4823   SUBU T1, T1, T4
9D007588  30A5FFFF   ANDI A1, A1, -1
9D00758C  0123001B   DIVU T1, V1
9D007590  006001F4   TEQ V1, ZERO
9D007594  00006810   MFHI T5
9D007598  00006012   MFLO T4
9D00759C  00005012   MFLO T2
9D0075A0  718B5802   MUL T3, T4, T3
9D0075A4  000D6C00   SLL T5, T5, 16
9D0075A8  01A52825   OR A1, T5, A1
9D0075AC  00AB682B   SLTU T5, A1, T3
9D0075B0  0123001B   DIVU T1, V1
9D0075B4  006001F4   TEQ V1, ZERO
9D0075B8  51A0000B   BEQL T5, ZERO, 0x9D0075E8
9D0075BC  00021400   SLL V0, V0, 16
9D0075C0  00A72821   ADDU A1, A1, A3
9D0075C4  00A7182B   SLTU V1, A1, A3
9D0075C8  14600006   BNE V1, ZERO, 0x9D0075E4
9D0075CC  258AFFFF   ADDIU T2, T4, -1
9D0075D0  00AB182B   SLTU V1, A1, T3
9D0075D4  50600004   BEQL V1, ZERO, 0x9D0075E8
9D0075D8  00021400   SLL V0, V0, 16
9D0075DC  258AFFFE   ADDIU T2, T4, -2
9D0075E0  00A72821   ADDU A1, A1, A3
9D0075E4  00021400   SLL V0, V0, 16
9D0075E8  01421025   OR V0, T2, V0
9D0075EC  00AB2823   SUBU A1, A1, T3
9D007178  01060019   MULTU 0, T0, A2
9D00717C  00004810   MFHI T1
9D007194  00003012   MFLO A2
9D0075F0  00460019   MULTU 0, V0, A2
9D0075F4  00003810   MFHI A3
9D007180  0049182B   SLTU V1, V0, T1
9D007184  1460003E   BNE V1, ZERO, 0x9D007280
9D007188  00004012   MFLO T0
9D00718C  1049004B   BEQ V0, T1, 0x9D0072BC
9D007190  00491823   SUBU V1, V0, T1
9D0072BC  0088182B   SLTU V1, A0, T0
9D0075F8  00A7182B   SLTU V1, A1, A3
9D0075FC  14600044   BNE V1, ZERO, 0x9D007710
9D007600  00003012   MFLO A2
9D007604  10A7003F   BEQ A1, A3, 0x9D007704
9D007608  01042004   SLLV A0, A0, T0
9D007704  0086302B   SLTU A2, A0, A2
9D007708  10C0FFC0   BEQ A2, ZERO, 0x9D00760C
9D00770C  00000000   NOP
9D00760C  03E00008   JR RA
9D007610  00001821   ADDU V1, ZERO, ZERO
9D007710  0B401D83   J 0x9D00760C
9D007714  2442FFFF   ADDIU V0, V0, -1
9D007280  01063023   SUBU A2, T0, A2
9D007284  01271823   SUBU V1, T1, A3
9D007288  0106402B   SLTU T0, T0, A2
9D00728C  00681823   SUBU V1, V1, T0
9D007290  0B401C66   J 0x9D007198
9D007294  00431823   SUBU V1, V0, V1
9D007198  00863023   SUBU A2, A0, A2
9D00719C  0086202B   SLTU A0, A0, A2
9D0071A0  00641823   SUBU V1, V1, A0
9D0071A4  01631004   SLLV V0, V1, T3
9D0071A8  01463006   SRLV A2, A2, T2
9D0071AC  00461025   OR V0, V0, A2
9D0071B0  01431806   SRLV V1, V1, T2
9D0071B4  03E00008   JR RA
9D0071B8  00000000   NOP
9D00771C  03E00008   JR RA
9D007720  24020001   ADDIU V0, ZERO, 1
